# generated bindings for Gtk 3.0
# module is gir.Gtk3
{. deadCodeElim: on .}
import gobjectutils
import gir.Gdk3 as Gdk3 # 3.0 dep:Gdk-3.0
import gir.cairo1 as cairo1 # 1.0 dep:cairo-1.0
import gir.Pango1 as Pango1 # 1.0 dep:Pango-1.0
import gir.GObject2 as GObject2 # 2.0 dep:GObject-2.0
import gir.GLib2 as GLib2 # 2.0 dep:GLib-2.0
import gir.Gio2 as Gio2 # 2.0 dep:Gio-2.0
import gir.GdkPixbuf2 as GdkPixbuf2 # 2.0 dep:GdkPixbuf-2.0
import gir.GModule2 as GModule2 # 2.0 dep:GModule-2.0
import gir.Atk1 as Atk1 # 1.0 dep:Atk-1.0

# libraries: libgtk-3-0.dll,libgdk-3-0.dll
const lib = "libgtk-3-0.dll"
type
  # classes
  #------------------
  # x
  # 
  Widget* = ref GSmartPtr[TWidget]
  TWidget* = object of GObject2.TInitiallyUnowned
    # omitted field for base class:
    # parent_instance_gtkwidget: ptr GObject2.TInitiallyUnowned
    priv_gtkwidget: ptr TWidgetPrivate

  # x
  # 
  Container* = ref GSmartPtr[TContainer]
  TContainer* = object of TWidget
    # omitted field for base class:
    # widget_gtkcontainer: ptr TWidget
    priv_gtkcontainer: ptr TContainerPrivate

  # x
  # 
  Bin* = ref GSmartPtr[TBin]
  TBin* = object of TContainer
    # omitted field for base class:
    # container_gtkbin: ptr TContainer
    priv_gtkbin: ptr TBinPrivate

  # x
  # 
  Window* = ref GSmartPtr[TWindow]
  TWindow* = object of TBin
    # omitted field for base class:
    # bin_gtkwindow: ptr TBin
    priv_gtkwindow: ptr TWindowPrivate

  # x
  # 
  Dialog* = ref GSmartPtr[TDialog]
  TDialog* = object of TWindow
    # omitted field for base class:
    # window_gtkdialog: ptr TWindow
    priv_gtkdialog: ptr TDialogPrivate

  # x
  # 
  AboutDialog* = ref GSmartPtr[TAboutDialog]
  TAboutDialog* = object of TDialog
    # omitted field for base class:
    # parent_instance_gtkaboutdialog: ptr TDialog
    priv_gtkaboutdialog: ptr TAboutDialogPrivate

  # x
  # 
  AccelGroup* = ref GSmartPtr[TAccelGroup]
  TAccelGroup* = object of GObject2.TObject
    # omitted field for base class:
    # parent_gtkaccelgroup: ptr GObject2.TObject
    priv_gtkaccelgroup: ptr TAccelGroupPrivate

  # x
  # 
  Misc* = ref GSmartPtr[TMisc]
  TMisc* = object of TWidget
    # omitted field for base class:
    # widget_gtkmisc: ptr TWidget
    priv_gtkmisc: ptr TMiscPrivate

  # x
  # 
  Label* = ref GSmartPtr[TLabel]
  TLabel* = object of TMisc
    # omitted field for base class:
    # misc_gtklabel: ptr TMisc
    priv_gtklabel: ptr TLabelPrivate

  # x
  # 
  AccelLabel* = ref GSmartPtr[TAccelLabel]
  TAccelLabel* = object of TLabel
    # omitted field for base class:
    # label_gtkaccellabel: ptr TLabel
    priv_gtkaccellabel: ptr TAccelLabelPrivate

  # x
  # 
  AccelMap* = ref GSmartPtr[TAccelMap]
  TAccelMap* = object of GObject2.TObject

  # x
  # 
  Accessible* = ref GSmartPtr[TAccessible]
  TAccessible* = object of Atk1.TObject
    # omitted field for base class:
    # parent_gtkaccessible: ptr Atk1.TObject
    priv_gtkaccessible: ptr TAccessiblePrivate

  # x
  # 
  Action* = ref GSmartPtr[TAction]
  TAction* = object of GObject2.TObject
    # omitted field for base class:
    # object_x_gtkaction: ptr GObject2.TObject
    private_data_gtkaction: ptr TActionPrivate

  # x
  # 
  ActionBar* = ref GSmartPtr[TActionBar]
  TActionBar* = object of TBin
    # omitted field for base class:
    # bin_gtkactionbar: ptr TBin

  # x
  # 
  ActionGroup* = ref GSmartPtr[TActionGroup]
  TActionGroup* = object of GObject2.TObject
    # omitted field for base class:
    # parent_gtkactiongroup: ptr GObject2.TObject
    priv_gtkactiongroup: ptr TActionGroupPrivate

  # x
  # 
  Adjustment* = ref GSmartPtr[TAdjustment]
  TAdjustment* = object of GObject2.TInitiallyUnowned
    # omitted field for base class:
    # parent_instance_gtkadjustment: ptr GObject2.TInitiallyUnowned
    priv_gtkadjustment: ptr TAdjustmentPrivate

  # x
  # 
  Alignment* = ref GSmartPtr[TAlignment]
  TAlignment* = object of TBin
    # omitted field for base class:
    # bin_gtkalignment: ptr TBin
    priv_gtkalignment: ptr TAlignmentPrivate

  # x
  # 
  ComboBox* = ref GSmartPtr[TComboBox]
  TComboBox* = object of TBin
    # omitted field for base class:
    # parent_instance_gtkcombobox: ptr TBin
    priv_gtkcombobox: ptr TComboBoxPrivate

  # x
  # 
  AppChooserButton* = ref GSmartPtr[TAppChooserButton]
  TAppChooserButton* = object of TComboBox
    # omitted field for base class:
    # parent_gtkappchooserbutton: ptr TComboBox
    priv_gtkappchooserbutton: ptr TAppChooserButtonPrivate

  # x
  # 
  AppChooserDialog* = ref GSmartPtr[TAppChooserDialog]
  TAppChooserDialog* = object of TDialog
    # omitted field for base class:
    # parent_gtkappchooserdialog: ptr TDialog
    priv_gtkappchooserdialog: ptr TAppChooserDialogPrivate

  # x
  # 
  Box* = ref GSmartPtr[TBox]
  TBox* = object of TContainer
    # omitted field for base class:
    # container_gtkbox: ptr TContainer
    priv_gtkbox: ptr TBoxPrivate

  # x
  # 
  AppChooserWidget* = ref GSmartPtr[TAppChooserWidget]
  TAppChooserWidget* = object of TBox
    # omitted field for base class:
    # parent_gtkappchooserwidget: ptr TBox
    priv_gtkappchooserwidget: ptr TAppChooserWidgetPrivate

  # x
  # 
  Application* = ref GSmartPtr[TApplication]
  TApplication* = object of Gio2.TApplication
    # omitted field for base class:
    # parent_gtkapplication: ptr Gio2.TApplication
    priv_gtkapplication: ptr TApplicationPrivate

  # x
  # 
  ApplicationWindow* = ref GSmartPtr[TApplicationWindow]
  TApplicationWindow* = object of TWindow
    # omitted field for base class:
    # parent_instance_gtkapplicationwindow: ptr TWindow
    priv_gtkapplicationwindow: ptr TApplicationWindowPrivate

  # x
  # 
  Arrow* = ref GSmartPtr[TArrow]
  TArrow* = object of TMisc
    # omitted field for base class:
    # misc_gtkarrow: ptr TMisc
    priv_gtkarrow: ptr TArrowPrivate

  # x
  # 
  WidgetAccessible* = ref GSmartPtr[TWidgetAccessible]
  TWidgetAccessible* = object of TAccessible
    # omitted field for base class:
    # parent_gtkwidgetaccessible: ptr TAccessible
    priv_gtkwidgetaccessible: ptr TWidgetAccessiblePrivate

  # x
  # 
  ArrowAccessible* = ref GSmartPtr[TArrowAccessible]
  TArrowAccessible* = object of TWidgetAccessible
    # omitted field for base class:
    # parent_gtkarrowaccessible: ptr TWidgetAccessible
    priv_gtkarrowaccessible: ptr TArrowAccessiblePrivate

  # x
  # 
  Frame* = ref GSmartPtr[TFrame]
  TFrame* = object of TBin
    # omitted field for base class:
    # bin_gtkframe: ptr TBin
    priv_gtkframe: ptr TFramePrivate

  # x
  # 
  AspectFrame* = ref GSmartPtr[TAspectFrame]
  TAspectFrame* = object of TFrame
    # omitted field for base class:
    # frame_gtkaspectframe: ptr TFrame
    priv_gtkaspectframe: ptr TAspectFramePrivate

  # x
  # 
  Assistant* = ref GSmartPtr[TAssistant]
  TAssistant* = object of TWindow
    # omitted field for base class:
    # parent_gtkassistant: ptr TWindow
    priv_gtkassistant: ptr TAssistantPrivate

  # x
  # 
  CellAccessible* = ref GSmartPtr[TCellAccessible]
  TCellAccessible* = object of TAccessible
    # omitted field for base class:
    # parent_gtkcellaccessible: ptr TAccessible
    priv_gtkcellaccessible: ptr TCellAccessiblePrivate

  # x
  # 
  RendererCellAccessible* = ref GSmartPtr[TRendererCellAccessible]
  TRendererCellAccessible* = object of TCellAccessible
    # omitted field for base class:
    # parent_gtkrenderercellaccessible: ptr TCellAccessible
    priv_gtkrenderercellaccessible: ptr TRendererCellAccessiblePrivate

  # x
  # 
  BooleanCellAccessible* = ref GSmartPtr[TBooleanCellAccessible]
  TBooleanCellAccessible* = object of TRendererCellAccessible
    # omitted field for base class:
    # parent_gtkbooleancellaccessible: ptr TRendererCellAccessible
    priv_gtkbooleancellaccessible: ptr TBooleanCellAccessiblePrivate

  # x
  # 
  Builder* = ref GSmartPtr[TBuilder]
  TBuilder* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkbuilder: ptr GObject2.TObject
    priv_gtkbuilder: ptr TBuilderPrivate

  # x
  # 
  Button* = ref GSmartPtr[TButton]
  TButton* = object of TBin
    # omitted field for base class:
    # bin_gtkbutton: ptr TBin
    priv_gtkbutton: ptr TButtonPrivate

  # x
  # 
  ContainerAccessible* = ref GSmartPtr[TContainerAccessible]
  TContainerAccessible* = object of TWidgetAccessible
    # omitted field for base class:
    # parent_gtkcontaineraccessible: ptr TWidgetAccessible
    priv_gtkcontaineraccessible: ptr TContainerAccessiblePrivate

  # x
  # 
  ButtonAccessible* = ref GSmartPtr[TButtonAccessible]
  TButtonAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkbuttonaccessible: ptr TContainerAccessible
    priv_gtkbuttonaccessible: ptr TButtonAccessiblePrivate

  # x
  # 
  ButtonBox* = ref GSmartPtr[TButtonBox]
  TButtonBox* = object of TBox
    # omitted field for base class:
    # box_gtkbuttonbox: ptr TBox
    priv_gtkbuttonbox: ptr TButtonBoxPrivate

  # x
  # 
  Calendar* = ref GSmartPtr[TCalendar]
  TCalendar* = object of TWidget
    # omitted field for base class:
    # widget_gtkcalendar: ptr TWidget
    priv_gtkcalendar: ptr TCalendarPrivate

  # x
  # 
  CellArea* = ref GSmartPtr[TCellArea]
  TCellArea* = object of GObject2.TInitiallyUnowned
    # omitted field for base class:
    # parent_instance_gtkcellarea: ptr GObject2.TInitiallyUnowned
    priv_gtkcellarea: ptr TCellAreaPrivate

  # x
  # 
  CellAreaBox* = ref GSmartPtr[TCellAreaBox]
  TCellAreaBox* = object of TCellArea
    # omitted field for base class:
    # parent_instance_gtkcellareabox: ptr TCellArea
    priv_gtkcellareabox: ptr TCellAreaBoxPrivate

  # x
  # 
  CellAreaContext* = ref GSmartPtr[TCellAreaContext]
  TCellAreaContext* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkcellareacontext: ptr GObject2.TObject
    priv_gtkcellareacontext: ptr TCellAreaContextPrivate

  # x
  # 
  CellRenderer* = ref GSmartPtr[TCellRenderer]
  TCellRenderer* = object of GObject2.TInitiallyUnowned
    # omitted field for base class:
    # parent_instance_gtkcellrenderer: ptr GObject2.TInitiallyUnowned
    priv_gtkcellrenderer: ptr TCellRendererPrivate

  # x
  # 
  CellRendererText* = ref GSmartPtr[TCellRendererText]
  TCellRendererText* = object of TCellRenderer
    # omitted field for base class:
    # parent_gtkcellrenderertext: ptr TCellRenderer
    priv_gtkcellrenderertext: ptr TCellRendererTextPrivate

  # x
  # 
  CellRendererAccel* = ref GSmartPtr[TCellRendererAccel]
  TCellRendererAccel* = object of TCellRendererText
    # omitted field for base class:
    # parent_gtkcellrendereraccel: ptr TCellRendererText
    priv_gtkcellrendereraccel: ptr TCellRendererAccelPrivate

  # x
  # 
  CellRendererCombo* = ref GSmartPtr[TCellRendererCombo]
  TCellRendererCombo* = object of TCellRendererText
    # omitted field for base class:
    # parent_gtkcellrenderercombo: ptr TCellRendererText
    priv_gtkcellrenderercombo: ptr TCellRendererComboPrivate

  # x
  # 
  CellRendererPixbuf* = ref GSmartPtr[TCellRendererPixbuf]
  TCellRendererPixbuf* = object of TCellRenderer
    # omitted field for base class:
    # parent_gtkcellrendererpixbuf: ptr TCellRenderer
    priv_gtkcellrendererpixbuf: ptr TCellRendererPixbufPrivate

  # x
  # 
  CellRendererProgress* = ref GSmartPtr[TCellRendererProgress]
  TCellRendererProgress* = object of TCellRenderer
    # omitted field for base class:
    # parent_instance_gtkcellrendererprogress: ptr TCellRenderer
    priv_gtkcellrendererprogress: ptr TCellRendererProgressPrivate

  # x
  # 
  CellRendererSpin* = ref GSmartPtr[TCellRendererSpin]
  TCellRendererSpin* = object of TCellRendererText
    # omitted field for base class:
    # parent_gtkcellrendererspin: ptr TCellRendererText
    priv_gtkcellrendererspin: ptr TCellRendererSpinPrivate

  # x
  # 
  CellRendererSpinner* = ref GSmartPtr[TCellRendererSpinner]
  TCellRendererSpinner* = object of TCellRenderer
    # omitted field for base class:
    # parent_gtkcellrendererspinner: ptr TCellRenderer
    priv_gtkcellrendererspinner: ptr TCellRendererSpinnerPrivate

  # x
  # 
  CellRendererToggle* = ref GSmartPtr[TCellRendererToggle]
  TCellRendererToggle* = object of TCellRenderer
    # omitted field for base class:
    # parent_gtkcellrenderertoggle: ptr TCellRenderer
    priv_gtkcellrenderertoggle: ptr TCellRendererTogglePrivate

  # x
  # 
  CellView* = ref GSmartPtr[TCellView]
  TCellView* = object of TWidget
    # omitted field for base class:
    # parent_instance_gtkcellview: ptr TWidget
    priv_gtkcellview: ptr TCellViewPrivate

  # x
  # 
  ToggleButton* = ref GSmartPtr[TToggleButton]
  TToggleButton* = object of TButton
    # omitted field for base class:
    # button_gtktogglebutton: ptr TButton
    priv_gtktogglebutton: ptr TToggleButtonPrivate

  # x
  # 
  CheckButton* = ref GSmartPtr[TCheckButton]
  TCheckButton* = object of TToggleButton
    # omitted field for base class:
    # toggle_button_gtkcheckbutton: ptr TToggleButton

  # x
  # 
  MenuItem* = ref GSmartPtr[TMenuItem]
  TMenuItem* = object of TBin
    # omitted field for base class:
    # bin_gtkmenuitem: ptr TBin
    priv_gtkmenuitem: ptr TMenuItemPrivate

  # x
  # 
  CheckMenuItem* = ref GSmartPtr[TCheckMenuItem]
  TCheckMenuItem* = object of TMenuItem
    # omitted field for base class:
    # menu_item_gtkcheckmenuitem: ptr TMenuItem
    priv_gtkcheckmenuitem: ptr TCheckMenuItemPrivate

  # x
  # 
  MenuItemAccessible* = ref GSmartPtr[TMenuItemAccessible]
  TMenuItemAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkmenuitemaccessible: ptr TContainerAccessible
    priv_gtkmenuitemaccessible: ptr TMenuItemAccessiblePrivate

  # x
  # 
  CheckMenuItemAccessible* = ref GSmartPtr[TCheckMenuItemAccessible]
  TCheckMenuItemAccessible* = object of TMenuItemAccessible
    # omitted field for base class:
    # parent_gtkcheckmenuitemaccessible: ptr TMenuItemAccessible
    priv_gtkcheckmenuitemaccessible: ptr TCheckMenuItemAccessiblePrivate

  # x
  # 
  Clipboard* = ref GSmartPtr[TClipboard]
  TClipboard* = object of GObject2.TObject

  # x
  # 
  ColorButton* = ref GSmartPtr[TColorButton]
  TColorButton* = object of TButton
    # omitted field for base class:
    # button_gtkcolorbutton: ptr TButton
    priv_gtkcolorbutton: ptr TColorButtonPrivate

  # x
  # 
  ColorChooserDialog* = ref GSmartPtr[TColorChooserDialog]
  TColorChooserDialog* = object of TDialog
    # omitted field for base class:
    # parent_instance_gtkcolorchooserdialog: ptr TDialog
    priv_gtkcolorchooserdialog: ptr TColorChooserDialogPrivate

  # x
  # 
  ColorChooserWidget* = ref GSmartPtr[TColorChooserWidget]
  TColorChooserWidget* = object of TBox
    # omitted field for base class:
    # parent_instance_gtkcolorchooserwidget: ptr TBox
    priv_gtkcolorchooserwidget: ptr TColorChooserWidgetPrivate

  # x
  # 
  ColorSelection* = ref GSmartPtr[TColorSelection]
  TColorSelection* = object of TBox
    # omitted field for base class:
    # parent_instance_gtkcolorselection: ptr TBox
    private_data_gtkcolorselection: ptr TColorSelectionPrivate

  # x
  # 
  ColorSelectionDialog* = ref GSmartPtr[TColorSelectionDialog]
  TColorSelectionDialog* = object of TDialog
    # omitted field for base class:
    # parent_instance_gtkcolorselectiondialog: ptr TDialog
    priv_gtkcolorselectiondialog: ptr TColorSelectionDialogPrivate

  # x
  # 
  ComboBoxAccessible* = ref GSmartPtr[TComboBoxAccessible]
  TComboBoxAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkcomboboxaccessible: ptr TContainerAccessible
    priv_gtkcomboboxaccessible: ptr TComboBoxAccessiblePrivate

  # x
  # 
  ComboBoxText* = ref GSmartPtr[TComboBoxText]
  TComboBoxText* = object of TComboBox
    # omitted field for base class:
    # parent_instance_gtkcomboboxtext: ptr TComboBox
    priv_gtkcomboboxtext: ptr TComboBoxTextPrivate

  # x
  # 
  ContainerCellAccessible* = ref GSmartPtr[TContainerCellAccessible]
  TContainerCellAccessible* = object of TCellAccessible
    # omitted field for base class:
    # parent_gtkcontainercellaccessible: ptr TCellAccessible
    priv_gtkcontainercellaccessible: ptr TContainerCellAccessiblePrivate

  # x
  # 
  CssProvider* = ref GSmartPtr[TCssProvider]
  TCssProvider* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkcssprovider: ptr GObject2.TObject
    priv_gtkcssprovider: ptr TCssProviderPrivate

  # x
  # 
  DrawingArea* = ref GSmartPtr[TDrawingArea]
  TDrawingArea* = object of TWidget
    # omitted field for base class:
    # widget_gtkdrawingarea: ptr TWidget
    dummy_gtkdrawingarea: pointer

  # x
  # 
  Entry* = ref GSmartPtr[TEntry]
  TEntry* = object of TWidget
    # omitted field for base class:
    # parent_instance_gtkentry: ptr TWidget
    priv_gtkentry: ptr TEntryPrivate

  # x
  # 
  EntryAccessible* = ref GSmartPtr[TEntryAccessible]
  TEntryAccessible* = object of TWidgetAccessible
    # omitted field for base class:
    # parent_gtkentryaccessible: ptr TWidgetAccessible
    priv_gtkentryaccessible: ptr TEntryAccessiblePrivate

  # x
  # 
  EntryBuffer* = ref GSmartPtr[TEntryBuffer]
  TEntryBuffer* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkentrybuffer: ptr GObject2.TObject
    priv_gtkentrybuffer: ptr TEntryBufferPrivate

  # x
  # 
  EntryCompletion* = ref GSmartPtr[TEntryCompletion]
  TEntryCompletion* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkentrycompletion: ptr GObject2.TObject
    priv_gtkentrycompletion: ptr TEntryCompletionPrivate

  # x
  # 
  EntryIconAccessible* = ref GSmartPtr[TEntryIconAccessible]
  TEntryIconAccessible* = object of Atk1.TObject

  # x
  # 
  EventBox* = ref GSmartPtr[TEventBox]
  TEventBox* = object of TBin
    # omitted field for base class:
    # bin_gtkeventbox: ptr TBin
    priv_gtkeventbox: ptr TEventBoxPrivate

  # x
  # 
  EventController* = ref GSmartPtr[TEventController]
  TEventController* = object of GObject2.TObject

  # x
  # 
  Expander* = ref GSmartPtr[TExpander]
  TExpander* = object of TBin
    # omitted field for base class:
    # bin_gtkexpander: ptr TBin
    priv_gtkexpander: ptr TExpanderPrivate

  # x
  # 
  ExpanderAccessible* = ref GSmartPtr[TExpanderAccessible]
  TExpanderAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkexpanderaccessible: ptr TContainerAccessible
    priv_gtkexpanderaccessible: ptr TExpanderAccessiblePrivate

  # x
  # 
  FileChooserButton* = ref GSmartPtr[TFileChooserButton]
  TFileChooserButton* = object of TBox
    # omitted field for base class:
    # parent_gtkfilechooserbutton: ptr TBox
    priv_gtkfilechooserbutton: ptr TFileChooserButtonPrivate

  # x
  # 
  FileChooserDialog* = ref GSmartPtr[TFileChooserDialog]
  TFileChooserDialog* = object of TDialog
    # omitted field for base class:
    # parent_instance_gtkfilechooserdialog: ptr TDialog
    priv_gtkfilechooserdialog: ptr TFileChooserDialogPrivate

  # x
  # 
  FileChooserWidget* = ref GSmartPtr[TFileChooserWidget]
  TFileChooserWidget* = object of TBox
    # omitted field for base class:
    # parent_instance_gtkfilechooserwidget: ptr TBox
    priv_gtkfilechooserwidget: ptr TFileChooserWidgetPrivate

  # x
  # 
  FileFilter* = ref GSmartPtr[TFileFilter]
  TFileFilter* = object of GObject2.TInitiallyUnowned

  # x
  # 
  Fixed* = ref GSmartPtr[TFixed]
  TFixed* = object of TContainer
    # omitted field for base class:
    # container_gtkfixed: ptr TContainer
    priv_gtkfixed: ptr TFixedPrivate

  # x
  # 
  FlowBox* = ref GSmartPtr[TFlowBox]
  TFlowBox* = object of TContainer
    # omitted field for base class:
    # container_gtkflowbox: ptr TContainer

  # x
  # 
  FlowBoxAccessible* = ref GSmartPtr[TFlowBoxAccessible]
  TFlowBoxAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkflowboxaccessible: ptr TContainerAccessible
    priv_gtkflowboxaccessible: ptr TFlowBoxAccessiblePrivate

  # x
  # 
  FlowBoxChild* = ref GSmartPtr[TFlowBoxChild]
  TFlowBoxChild* = object of TBin
    # omitted field for base class:
    # parent_instance_gtkflowboxchild: ptr TBin

  # x
  # 
  FlowBoxChildAccessible* = ref GSmartPtr[TFlowBoxChildAccessible]
  TFlowBoxChildAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkflowboxchildaccessible: ptr TContainerAccessible

  # x
  # 
  FontButton* = ref GSmartPtr[TFontButton]
  TFontButton* = object of TButton
    # omitted field for base class:
    # button_gtkfontbutton: ptr TButton
    priv_gtkfontbutton: ptr TFontButtonPrivate

  # x
  # 
  FontChooserDialog* = ref GSmartPtr[TFontChooserDialog]
  TFontChooserDialog* = object of TDialog
    # omitted field for base class:
    # parent_instance_gtkfontchooserdialog: ptr TDialog
    priv_gtkfontchooserdialog: ptr TFontChooserDialogPrivate

  # x
  # 
  FontChooserWidget* = ref GSmartPtr[TFontChooserWidget]
  TFontChooserWidget* = object of TBox
    # omitted field for base class:
    # parent_instance_gtkfontchooserwidget: ptr TBox
    priv_gtkfontchooserwidget: ptr TFontChooserWidgetPrivate

  # x
  # 
  FontSelection* = ref GSmartPtr[TFontSelection]
  TFontSelection* = object of TBox
    # omitted field for base class:
    # parent_instance_gtkfontselection: ptr TBox
    priv_gtkfontselection: ptr TFontSelectionPrivate

  # x
  # 
  FontSelectionDialog* = ref GSmartPtr[TFontSelectionDialog]
  TFontSelectionDialog* = object of TDialog
    # omitted field for base class:
    # parent_instance_gtkfontselectiondialog: ptr TDialog
    priv_gtkfontselectiondialog: ptr TFontSelectionDialogPrivate

  # x
  # 
  FrameAccessible* = ref GSmartPtr[TFrameAccessible]
  TFrameAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkframeaccessible: ptr TContainerAccessible
    priv_gtkframeaccessible: ptr TFrameAccessiblePrivate

  # x
  # 
  Gesture* = ref GSmartPtr[TGesture]
  TGesture* = object of TEventController

  # x
  # 
  GestureSingle* = ref GSmartPtr[TGestureSingle]
  TGestureSingle* = object of TGesture

  # x
  # 
  GestureDrag* = ref GSmartPtr[TGestureDrag]
  TGestureDrag* = object of TGestureSingle

  # x
  # 
  GestureLongPress* = ref GSmartPtr[TGestureLongPress]
  TGestureLongPress* = object of TGestureSingle

  # x
  # 
  GestureMultiPress* = ref GSmartPtr[TGestureMultiPress]
  TGestureMultiPress* = object of TGestureSingle

  # x
  # 
  GesturePan* = ref GSmartPtr[TGesturePan]
  TGesturePan* = object of TGestureDrag

  # x
  # 
  GestureRotate* = ref GSmartPtr[TGestureRotate]
  TGestureRotate* = object of TGesture

  # x
  # 
  GestureSwipe* = ref GSmartPtr[TGestureSwipe]
  TGestureSwipe* = object of TGestureSingle

  # x
  # 
  GestureZoom* = ref GSmartPtr[TGestureZoom]
  TGestureZoom* = object of TGesture

  # x
  # 
  Grid* = ref GSmartPtr[TGrid]
  TGrid* = object of TContainer
    # omitted field for base class:
    # container_gtkgrid: ptr TContainer
    priv_gtkgrid: ptr TGridPrivate

  # x
  # 
  HBox* = ref GSmartPtr[THBox]
  THBox* = object of TBox
    # omitted field for base class:
    # box_gtkhbox: ptr TBox

  # x
  # 
  HButtonBox* = ref GSmartPtr[THButtonBox]
  THButtonBox* = object of TButtonBox
    # omitted field for base class:
    # button_box_gtkhbuttonbox: ptr TButtonBox

  # x
  # 
  Paned* = ref GSmartPtr[TPaned]
  TPaned* = object of TContainer
    # omitted field for base class:
    # container_gtkpaned: ptr TContainer
    priv_gtkpaned: ptr TPanedPrivate

  # x
  # 
  HPaned* = ref GSmartPtr[THPaned]
  THPaned* = object of TPaned
    # omitted field for base class:
    # paned_gtkhpaned: ptr TPaned

  # x
  # 
  HSV* = ref GSmartPtr[THSV]
  THSV* = object of TWidget
    # omitted field for base class:
    # parent_instance_gtkhsv: ptr TWidget
    priv_gtkhsv: ptr THSVPrivate

  # x
  # 
  Range* = ref GSmartPtr[TRange]
  TRange* = object of TWidget
    # omitted field for base class:
    # widget_gtkrange: ptr TWidget
    priv_gtkrange: ptr TRangePrivate

  # x
  # 
  Scale* = ref GSmartPtr[TScale]
  TScale* = object of TRange
    # omitted field for base class:
    # range_gtkscale: ptr TRange
    priv_gtkscale: ptr TScalePrivate

  # x
  # 
  HScale* = ref GSmartPtr[THScale]
  THScale* = object of TScale
    # omitted field for base class:
    # scale_gtkhscale: ptr TScale

  # x
  # 
  Scrollbar* = ref GSmartPtr[TScrollbar]
  TScrollbar* = object of TRange
    # omitted field for base class:
    # range_gtkscrollbar: ptr TRange

  # x
  # 
  HScrollbar* = ref GSmartPtr[THScrollbar]
  THScrollbar* = object of TScrollbar
    # omitted field for base class:
    # scrollbar_gtkhscrollbar: ptr TScrollbar

  # x
  # 
  Separator* = ref GSmartPtr[TSeparator]
  TSeparator* = object of TWidget
    # omitted field for base class:
    # widget_gtkseparator: ptr TWidget
    priv_gtkseparator: ptr TSeparatorPrivate

  # x
  # 
  HSeparator* = ref GSmartPtr[THSeparator]
  THSeparator* = object of TSeparator
    # omitted field for base class:
    # separator_gtkhseparator: ptr TSeparator

  # x
  # 
  HandleBox* = ref GSmartPtr[THandleBox]
  THandleBox* = object of TBin
    # omitted field for base class:
    # bin_gtkhandlebox: ptr TBin
    priv_gtkhandlebox: ptr THandleBoxPrivate

  # x
  # 
  HeaderBar* = ref GSmartPtr[THeaderBar]
  THeaderBar* = object of TContainer
    # omitted field for base class:
    # container_gtkheaderbar: ptr TContainer

  # x
  # 
  IMContext* = ref GSmartPtr[TIMContext]
  TIMContext* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkimcontext: ptr GObject2.TObject

  # x
  # 
  IMContextSimple* = ref GSmartPtr[TIMContextSimple]
  TIMContextSimple* = object of TIMContext
    # omitted field for base class:
    # object_x_gtkimcontextsimple: ptr TIMContext
    priv_gtkimcontextsimple: ptr TIMContextSimplePrivate

  # x
  # 
  IMMulticontext* = ref GSmartPtr[TIMMulticontext]
  TIMMulticontext* = object of TIMContext
    # omitted field for base class:
    # object_x_gtkimmulticontext: ptr TIMContext
    priv_gtkimmulticontext: ptr TIMMulticontextPrivate

  # x
  # 
  IconFactory* = ref GSmartPtr[TIconFactory]
  TIconFactory* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkiconfactory: ptr GObject2.TObject
    priv_gtkiconfactory: ptr TIconFactoryPrivate

  # x
  # 
  IconInfo* = ref GSmartPtr[TIconInfo]
  TIconInfo* = object of GObject2.TObject

  # x
  # 
  IconTheme* = ref GSmartPtr[TIconTheme]
  TIconTheme* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkicontheme: ptr GObject2.TObject
    priv_gtkicontheme: ptr TIconThemePrivate

  # x
  # 
  IconView* = ref GSmartPtr[TIconView]
  TIconView* = object of TContainer
    # omitted field for base class:
    # parent_gtkiconview: ptr TContainer
    priv_gtkiconview: ptr TIconViewPrivate

  # x
  # 
  IconViewAccessible* = ref GSmartPtr[TIconViewAccessible]
  TIconViewAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkiconviewaccessible: ptr TContainerAccessible
    priv_gtkiconviewaccessible: ptr TIconViewAccessiblePrivate

  # x
  # 
  Image* = ref GSmartPtr[TImage]
  TImage* = object of TMisc
    # omitted field for base class:
    # misc_gtkimage: ptr TMisc
    priv_gtkimage: ptr TImagePrivate

  # x
  # 
  ImageAccessible* = ref GSmartPtr[TImageAccessible]
  TImageAccessible* = object of TWidgetAccessible
    # omitted field for base class:
    # parent_gtkimageaccessible: ptr TWidgetAccessible
    priv_gtkimageaccessible: ptr TImageAccessiblePrivate

  # x
  # 
  ImageCellAccessible* = ref GSmartPtr[TImageCellAccessible]
  TImageCellAccessible* = object of TRendererCellAccessible
    # omitted field for base class:
    # parent_gtkimagecellaccessible: ptr TRendererCellAccessible
    priv_gtkimagecellaccessible: ptr TImageCellAccessiblePrivate

  # x
  # 
  ImageMenuItem* = ref GSmartPtr[TImageMenuItem]
  TImageMenuItem* = object of TMenuItem
    # omitted field for base class:
    # menu_item_gtkimagemenuitem: ptr TMenuItem
    priv_gtkimagemenuitem: ptr TImageMenuItemPrivate

  # x
  # 
  InfoBar* = ref GSmartPtr[TInfoBar]
  TInfoBar* = object of TBox
    # omitted field for base class:
    # parent_gtkinfobar: ptr TBox
    priv_gtkinfobar: ptr TInfoBarPrivate

  # x
  # 
  Invisible* = ref GSmartPtr[TInvisible]
  TInvisible* = object of TWidget
    # omitted field for base class:
    # widget_gtkinvisible: ptr TWidget
    priv_gtkinvisible: ptr TInvisiblePrivate

  # x
  # 
  LabelAccessible* = ref GSmartPtr[TLabelAccessible]
  TLabelAccessible* = object of TWidgetAccessible
    # omitted field for base class:
    # parent_gtklabelaccessible: ptr TWidgetAccessible
    priv_gtklabelaccessible: ptr TLabelAccessiblePrivate

  # x
  # 
  Layout* = ref GSmartPtr[TLayout]
  TLayout* = object of TContainer
    # omitted field for base class:
    # container_gtklayout: ptr TContainer
    priv_gtklayout: ptr TLayoutPrivate

  # x
  # 
  LevelBar* = ref GSmartPtr[TLevelBar]
  TLevelBar* = object of TWidget
    # omitted field for base class:
    # parent_gtklevelbar: ptr TWidget
    priv_gtklevelbar: ptr TLevelBarPrivate

  # x
  # 
  LevelBarAccessible* = ref GSmartPtr[TLevelBarAccessible]
  TLevelBarAccessible* = object of TWidgetAccessible
    # omitted field for base class:
    # parent_gtklevelbaraccessible: ptr TWidgetAccessible
    priv_gtklevelbaraccessible: ptr TLevelBarAccessiblePrivate

  # x
  # 
  LinkButton* = ref GSmartPtr[TLinkButton]
  TLinkButton* = object of TButton
    # omitted field for base class:
    # parent_instance_gtklinkbutton: ptr TButton
    priv_gtklinkbutton: ptr TLinkButtonPrivate

  # x
  # 
  LinkButtonAccessible* = ref GSmartPtr[TLinkButtonAccessible]
  TLinkButtonAccessible* = object of TButtonAccessible
    # omitted field for base class:
    # parent_gtklinkbuttonaccessible: ptr TButtonAccessible
    priv_gtklinkbuttonaccessible: ptr TLinkButtonAccessiblePrivate

  # x
  # 
  ListBox* = ref GSmartPtr[TListBox]
  TListBox* = object of TContainer
    # omitted field for base class:
    # parent_instance_gtklistbox: ptr TContainer

  # x
  # 
  ListBoxAccessible* = ref GSmartPtr[TListBoxAccessible]
  TListBoxAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtklistboxaccessible: ptr TContainerAccessible
    priv_gtklistboxaccessible: ptr TListBoxAccessiblePrivate

  # x
  # 
  ListBoxRow* = ref GSmartPtr[TListBoxRow]
  TListBoxRow* = object of TBin
    # omitted field for base class:
    # parent_instance_gtklistboxrow: ptr TBin

  # x
  # 
  ListBoxRowAccessible* = ref GSmartPtr[TListBoxRowAccessible]
  TListBoxRowAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtklistboxrowaccessible: ptr TContainerAccessible

  # x
  # 
  ListStore* = ref GSmartPtr[TListStore]
  TListStore* = object of GObject2.TObject
    # omitted field for base class:
    # parent_gtkliststore: ptr GObject2.TObject
    priv_gtkliststore: ptr TListStorePrivate

  # x
  # 
  LockButton* = ref GSmartPtr[TLockButton]
  TLockButton* = object of TButton
    # omitted field for base class:
    # parent_gtklockbutton: ptr TButton
    priv_gtklockbutton: ptr TLockButtonPrivate

  # x
  # 
  LockButtonAccessible* = ref GSmartPtr[TLockButtonAccessible]
  TLockButtonAccessible* = object of TButtonAccessible
    # omitted field for base class:
    # parent_gtklockbuttonaccessible: ptr TButtonAccessible
    priv_gtklockbuttonaccessible: ptr TLockButtonAccessiblePrivate

  # x
  # 
  MenuShell* = ref GSmartPtr[TMenuShell]
  TMenuShell* = object of TContainer
    # omitted field for base class:
    # container_gtkmenushell: ptr TContainer
    priv_gtkmenushell: ptr TMenuShellPrivate

  # x
  # 
  Menu* = ref GSmartPtr[TMenu]
  TMenu* = object of TMenuShell
    # omitted field for base class:
    # menu_shell_gtkmenu: ptr TMenuShell
    priv_gtkmenu: ptr TMenuPrivate

  # x
  # 
  MenuShellAccessible* = ref GSmartPtr[TMenuShellAccessible]
  TMenuShellAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkmenushellaccessible: ptr TContainerAccessible
    priv_gtkmenushellaccessible: ptr TMenuShellAccessiblePrivate

  # x
  # 
  MenuAccessible* = ref GSmartPtr[TMenuAccessible]
  TMenuAccessible* = object of TMenuShellAccessible
    # omitted field for base class:
    # parent_gtkmenuaccessible: ptr TMenuShellAccessible
    priv_gtkmenuaccessible: ptr TMenuAccessiblePrivate

  # x
  # 
  MenuBar* = ref GSmartPtr[TMenuBar]
  TMenuBar* = object of TMenuShell
    # omitted field for base class:
    # menu_shell_gtkmenubar: ptr TMenuShell
    priv_gtkmenubar: ptr TMenuBarPrivate

  # x
  # 
  MenuButton* = ref GSmartPtr[TMenuButton]
  TMenuButton* = object of TToggleButton
    # omitted field for base class:
    # parent_gtkmenubutton: ptr TToggleButton
    priv_gtkmenubutton: ptr TMenuButtonPrivate

  # x
  # 
  ToggleButtonAccessible* = ref GSmartPtr[TToggleButtonAccessible]
  TToggleButtonAccessible* = object of TButtonAccessible
    # omitted field for base class:
    # parent_gtktogglebuttonaccessible: ptr TButtonAccessible
    priv_gtktogglebuttonaccessible: ptr TToggleButtonAccessiblePrivate

  # x
  # 
  MenuButtonAccessible* = ref GSmartPtr[TMenuButtonAccessible]
  TMenuButtonAccessible* = object of TToggleButtonAccessible
    # omitted field for base class:
    # parent_gtkmenubuttonaccessible: ptr TToggleButtonAccessible
    priv_gtkmenubuttonaccessible: ptr TMenuButtonAccessiblePrivate

  # x
  # 
  ToolItem* = ref GSmartPtr[TToolItem]
  TToolItem* = object of TBin
    # omitted field for base class:
    # parent_gtktoolitem: ptr TBin
    priv_gtktoolitem: ptr TToolItemPrivate

  # x
  # 
  ToolButton* = ref GSmartPtr[TToolButton]
  TToolButton* = object of TToolItem
    # omitted field for base class:
    # parent_gtktoolbutton: ptr TToolItem
    priv_gtktoolbutton: ptr TToolButtonPrivate

  # x
  # 
  MenuToolButton* = ref GSmartPtr[TMenuToolButton]
  TMenuToolButton* = object of TToolButton
    # omitted field for base class:
    # parent_gtkmenutoolbutton: ptr TToolButton
    priv_gtkmenutoolbutton: ptr TMenuToolButtonPrivate

  # x
  # 
  MessageDialog* = ref GSmartPtr[TMessageDialog]
  TMessageDialog* = object of TDialog
    # omitted field for base class:
    # parent_instance_gtkmessagedialog: ptr TDialog
    priv_gtkmessagedialog: ptr TMessageDialogPrivate

  # x
  # 
  MountOperation* = ref GSmartPtr[TMountOperation]
  TMountOperation* = object of Gio2.TMountOperation
    # omitted field for base class:
    # parent_instance_gtkmountoperation: ptr Gio2.TMountOperation
    priv_gtkmountoperation: ptr TMountOperationPrivate

  # x
  # 
  Notebook* = ref GSmartPtr[TNotebook]
  TNotebook* = object of TContainer
    # omitted field for base class:
    # container_gtknotebook: ptr TContainer
    priv_gtknotebook: ptr TNotebookPrivate

  # x
  # 
  NotebookAccessible* = ref GSmartPtr[TNotebookAccessible]
  TNotebookAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtknotebookaccessible: ptr TContainerAccessible
    priv_gtknotebookaccessible: ptr TNotebookAccessiblePrivate

  # x
  # 
  NotebookPageAccessible* = ref GSmartPtr[TNotebookPageAccessible]
  TNotebookPageAccessible* = object of Atk1.TObject
    # omitted field for base class:
    # parent_gtknotebookpageaccessible: ptr Atk1.TObject
    priv_gtknotebookpageaccessible: ptr TNotebookPageAccessiblePrivate

  # x
  # 
  NumerableIcon* = ref GSmartPtr[TNumerableIcon]
  TNumerableIcon* = object of Gio2.TEmblemedIcon
    # omitted field for base class:
    # parent_gtknumerableicon: ptr Gio2.TEmblemedIcon
    priv_gtknumerableicon: ptr TNumerableIconPrivate

  # x
  # 
  OffscreenWindow* = ref GSmartPtr[TOffscreenWindow]
  TOffscreenWindow* = object of TWindow
    # omitted field for base class:
    # parent_object_gtkoffscreenwindow: ptr TWindow

  # x
  # 
  Overlay* = ref GSmartPtr[TOverlay]
  TOverlay* = object of TBin
    # omitted field for base class:
    # parent_gtkoverlay: ptr TBin
    priv_gtkoverlay: ptr TOverlayPrivate

  # x
  # 
  PageSetup* = ref GSmartPtr[TPageSetup]
  TPageSetup* = object of GObject2.TObject

  # x
  # 
  PanedAccessible* = ref GSmartPtr[TPanedAccessible]
  TPanedAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkpanedaccessible: ptr TContainerAccessible
    priv_gtkpanedaccessible: ptr TPanedAccessiblePrivate

  # x
  # 
  ScrolledWindow* = ref GSmartPtr[TScrolledWindow]
  TScrolledWindow* = object of TBin
    # omitted field for base class:
    # container_gtkscrolledwindow: ptr TBin
    priv_gtkscrolledwindow: ptr TScrolledWindowPrivate

  # x
  # 
  PlacesSidebar* = ref GSmartPtr[TPlacesSidebar]
  TPlacesSidebar* = object of TScrolledWindow

  # x
  # 
  Popover* = ref GSmartPtr[TPopover]
  TPopover* = object of TBin
    # omitted field for base class:
    # parent_instance_gtkpopover: ptr TBin
    priv_gtkpopover: ptr TPopoverPrivate

  # x
  # 
  PopoverAccessible* = ref GSmartPtr[TPopoverAccessible]
  TPopoverAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkpopoveraccessible: ptr TContainerAccessible

  # x
  # 
  PrintContext* = ref GSmartPtr[TPrintContext]
  TPrintContext* = object of GObject2.TObject

  # x
  # 
  PrintOperation* = ref GSmartPtr[TPrintOperation]
  TPrintOperation* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkprintoperation: ptr GObject2.TObject
    priv_gtkprintoperation: ptr TPrintOperationPrivate

  # x
  # 
  PrintSettings* = ref GSmartPtr[TPrintSettings]
  TPrintSettings* = object of GObject2.TObject

  # x
  # 
  ProgressBar* = ref GSmartPtr[TProgressBar]
  TProgressBar* = object of TWidget
    # omitted field for base class:
    # parent_gtkprogressbar: ptr TWidget
    priv_gtkprogressbar: ptr TProgressBarPrivate

  # x
  # 
  ProgressBarAccessible* = ref GSmartPtr[TProgressBarAccessible]
  TProgressBarAccessible* = object of TWidgetAccessible
    # omitted field for base class:
    # parent_gtkprogressbaraccessible: ptr TWidgetAccessible
    priv_gtkprogressbaraccessible: ptr TProgressBarAccessiblePrivate

  # x
  # 
  ToggleAction* = ref GSmartPtr[TToggleAction]
  TToggleAction* = object of TAction
    # omitted field for base class:
    # parent_gtktoggleaction: ptr TAction
    private_data_gtktoggleaction: ptr TToggleActionPrivate

  # x
  # 
  RadioAction* = ref GSmartPtr[TRadioAction]
  TRadioAction* = object of TToggleAction
    # omitted field for base class:
    # parent_gtkradioaction: ptr TToggleAction
    private_data_gtkradioaction: ptr TRadioActionPrivate

  # x
  # 
  RadioButton* = ref GSmartPtr[TRadioButton]
  TRadioButton* = object of TCheckButton
    # omitted field for base class:
    # check_button_gtkradiobutton: ptr TCheckButton
    priv_gtkradiobutton: ptr TRadioButtonPrivate

  # x
  # 
  RadioButtonAccessible* = ref GSmartPtr[TRadioButtonAccessible]
  TRadioButtonAccessible* = object of TToggleButtonAccessible
    # omitted field for base class:
    # parent_gtkradiobuttonaccessible: ptr TToggleButtonAccessible
    priv_gtkradiobuttonaccessible: ptr TRadioButtonAccessiblePrivate

  # x
  # 
  RadioMenuItem* = ref GSmartPtr[TRadioMenuItem]
  TRadioMenuItem* = object of TCheckMenuItem
    # omitted field for base class:
    # check_menu_item_gtkradiomenuitem: ptr TCheckMenuItem
    priv_gtkradiomenuitem: ptr TRadioMenuItemPrivate

  # x
  # 
  RadioMenuItemAccessible* = ref GSmartPtr[TRadioMenuItemAccessible]
  TRadioMenuItemAccessible* = object of TCheckMenuItemAccessible
    # omitted field for base class:
    # parent_gtkradiomenuitemaccessible: ptr TCheckMenuItemAccessible
    priv_gtkradiomenuitemaccessible: ptr TRadioMenuItemAccessiblePrivate

  # x
  # 
  ToggleToolButton* = ref GSmartPtr[TToggleToolButton]
  TToggleToolButton* = object of TToolButton
    # omitted field for base class:
    # parent_gtktoggletoolbutton: ptr TToolButton
    priv_gtktoggletoolbutton: ptr TToggleToolButtonPrivate

  # x
  # 
  RadioToolButton* = ref GSmartPtr[TRadioToolButton]
  TRadioToolButton* = object of TToggleToolButton
    # omitted field for base class:
    # parent_gtkradiotoolbutton: ptr TToggleToolButton

  # x
  # 
  RangeAccessible* = ref GSmartPtr[TRangeAccessible]
  TRangeAccessible* = object of TWidgetAccessible
    # omitted field for base class:
    # parent_gtkrangeaccessible: ptr TWidgetAccessible
    priv_gtkrangeaccessible: ptr TRangeAccessiblePrivate

  # x
  # 
  RcStyle* = ref GSmartPtr[TRcStyle]
  TRcStyle* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkrcstyle: ptr GObject2.TObject
    name_gtkrcstyle: ucstring
    bg_pixmap_name_gtkrcstyle: array[5, ucstring]
    font_desc_gtkrcstyle: ptr Pango1.TFontDescription
    color_flags_gtkrcstyle: array[5, SRcFlags]
    fg_gtkrcstyle: array[5, Gdk3.TColor]
    bg_gtkrcstyle: array[5, Gdk3.TColor]
    text_gtkrcstyle: array[5, Gdk3.TColor]
    base_gtkrcstyle: array[5, Gdk3.TColor]
    xthickness_gtkrcstyle: int32
    ythickness_gtkrcstyle: int32
    rc_properties_gtkrcstyle: ptr array[-1, pointer]
    rc_style_lists_gtkrcstyle: ptr GSLIST_TODO
    icon_factories_gtkrcstyle: ptr GSLIST_TODO
    engine_specified_gtkrcstyle: uint32

  # x
  # 
  RecentAction* = ref GSmartPtr[TRecentAction]
  TRecentAction* = object of TAction
    # omitted field for base class:
    # parent_instance_gtkrecentaction: ptr TAction
    priv_gtkrecentaction: ptr TRecentActionPrivate

  # x
  # 
  RecentChooserDialog* = ref GSmartPtr[TRecentChooserDialog]
  TRecentChooserDialog* = object of TDialog
    # omitted field for base class:
    # parent_instance_gtkrecentchooserdialog: ptr TDialog
    priv_gtkrecentchooserdialog: ptr TRecentChooserDialogPrivate

  # x
  # 
  RecentChooserMenu* = ref GSmartPtr[TRecentChooserMenu]
  TRecentChooserMenu* = object of TMenu
    # omitted field for base class:
    # parent_instance_gtkrecentchoosermenu: ptr TMenu
    priv_gtkrecentchoosermenu: ptr TRecentChooserMenuPrivate

  # x
  # 
  RecentChooserWidget* = ref GSmartPtr[TRecentChooserWidget]
  TRecentChooserWidget* = object of TBox
    # omitted field for base class:
    # parent_instance_gtkrecentchooserwidget: ptr TBox
    priv_gtkrecentchooserwidget: ptr TRecentChooserWidgetPrivate

  # x
  # 
  RecentFilter* = ref GSmartPtr[TRecentFilter]
  TRecentFilter* = object of GObject2.TInitiallyUnowned

  # x
  # 
  RecentManager* = ref GSmartPtr[TRecentManager]
  TRecentManager* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkrecentmanager: ptr GObject2.TObject
    priv_gtkrecentmanager: ptr TRecentManagerPrivate

  # x
  # 
  Revealer* = ref GSmartPtr[TRevealer]
  TRevealer* = object of TBin
    # omitted field for base class:
    # parent_instance_gtkrevealer: ptr TBin

  # x
  # 
  ScaleAccessible* = ref GSmartPtr[TScaleAccessible]
  TScaleAccessible* = object of TRangeAccessible
    # omitted field for base class:
    # parent_gtkscaleaccessible: ptr TRangeAccessible
    priv_gtkscaleaccessible: ptr TScaleAccessiblePrivate

  # x
  # 
  ScaleButton* = ref GSmartPtr[TScaleButton]
  TScaleButton* = object of TButton
    # omitted field for base class:
    # parent_gtkscalebutton: ptr TButton
    priv_gtkscalebutton: ptr TScaleButtonPrivate

  # x
  # 
  ScaleButtonAccessible* = ref GSmartPtr[TScaleButtonAccessible]
  TScaleButtonAccessible* = object of TButtonAccessible
    # omitted field for base class:
    # parent_gtkscalebuttonaccessible: ptr TButtonAccessible
    priv_gtkscalebuttonaccessible: ptr TScaleButtonAccessiblePrivate

  # x
  # 
  ScrolledWindowAccessible* = ref GSmartPtr[TScrolledWindowAccessible]
  TScrolledWindowAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkscrolledwindowaccessible: ptr TContainerAccessible
    priv_gtkscrolledwindowaccessible: ptr TScrolledWindowAccessiblePrivate

  # x
  # 
  SearchBar* = ref GSmartPtr[TSearchBar]
  TSearchBar* = object of TBin
    # omitted field for base class:
    # parent_gtksearchbar: ptr TBin

  # x
  # 
  SearchEntry* = ref GSmartPtr[TSearchEntry]
  TSearchEntry* = object of TEntry
    # omitted field for base class:
    # parent_gtksearchentry: ptr TEntry

  # x
  # 
  SeparatorMenuItem* = ref GSmartPtr[TSeparatorMenuItem]
  TSeparatorMenuItem* = object of TMenuItem
    # omitted field for base class:
    # menu_item_gtkseparatormenuitem: ptr TMenuItem

  # x
  # 
  SeparatorToolItem* = ref GSmartPtr[TSeparatorToolItem]
  TSeparatorToolItem* = object of TToolItem
    # omitted field for base class:
    # parent_gtkseparatortoolitem: ptr TToolItem
    priv_gtkseparatortoolitem: ptr TSeparatorToolItemPrivate

  # x
  # 
  Settings* = ref GSmartPtr[TSettings]
  TSettings* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtksettings: ptr GObject2.TObject
    priv_gtksettings: ptr TSettingsPrivate

  # x
  # 
  SizeGroup* = ref GSmartPtr[TSizeGroup]
  TSizeGroup* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtksizegroup: ptr GObject2.TObject
    priv_gtksizegroup: ptr TSizeGroupPrivate

  # x
  # 
  SpinButton* = ref GSmartPtr[TSpinButton]
  TSpinButton* = object of TEntry
    # omitted field for base class:
    # entry_gtkspinbutton: ptr TEntry
    priv_gtkspinbutton: ptr TSpinButtonPrivate

  # x
  # 
  SpinButtonAccessible* = ref GSmartPtr[TSpinButtonAccessible]
  TSpinButtonAccessible* = object of TEntryAccessible
    # omitted field for base class:
    # parent_gtkspinbuttonaccessible: ptr TEntryAccessible
    priv_gtkspinbuttonaccessible: ptr TSpinButtonAccessiblePrivate

  # x
  # 
  Spinner* = ref GSmartPtr[TSpinner]
  TSpinner* = object of TWidget
    # omitted field for base class:
    # parent_gtkspinner: ptr TWidget
    priv_gtkspinner: ptr TSpinnerPrivate

  # x
  # 
  SpinnerAccessible* = ref GSmartPtr[TSpinnerAccessible]
  TSpinnerAccessible* = object of TWidgetAccessible
    # omitted field for base class:
    # parent_gtkspinneraccessible: ptr TWidgetAccessible
    priv_gtkspinneraccessible: ptr TSpinnerAccessiblePrivate

  # x
  # 
  Stack* = ref GSmartPtr[TStack]
  TStack* = object of TContainer
    # omitted field for base class:
    # parent_instance_gtkstack: ptr TContainer

  # x
  # 
  StackSwitcher* = ref GSmartPtr[TStackSwitcher]
  TStackSwitcher* = object of TBox
    # omitted field for base class:
    # widget_gtkstackswitcher: ptr TBox

  # x
  # 
  StatusIcon* = ref GSmartPtr[TStatusIcon]
  TStatusIcon* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkstatusicon: ptr GObject2.TObject
    priv_gtkstatusicon: ptr TStatusIconPrivate

  # x
  # 
  Statusbar* = ref GSmartPtr[TStatusbar]
  TStatusbar* = object of TBox
    # omitted field for base class:
    # parent_widget_gtkstatusbar: ptr TBox
    priv_gtkstatusbar: ptr TStatusbarPrivate

  # x
  # 
  StatusbarAccessible* = ref GSmartPtr[TStatusbarAccessible]
  TStatusbarAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkstatusbaraccessible: ptr TContainerAccessible
    priv_gtkstatusbaraccessible: ptr TStatusbarAccessiblePrivate

  # x
  # 
  Style* = ref GSmartPtr[TStyle]
  TStyle* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkstyle: ptr GObject2.TObject
    fg_gtkstyle: array[5, Gdk3.TColor]
    bg_gtkstyle: array[5, Gdk3.TColor]
    light_gtkstyle: array[5, Gdk3.TColor]
    dark_gtkstyle: array[5, Gdk3.TColor]
    mid_gtkstyle: array[5, Gdk3.TColor]
    text_gtkstyle: array[5, Gdk3.TColor]
    base_gtkstyle: array[5, Gdk3.TColor]
    text_aa_gtkstyle: array[5, Gdk3.TColor]
    black_gtkstyle: Gdk3.TColor
    white_gtkstyle: Gdk3.TColor
    font_desc_gtkstyle: ptr Pango1.TFontDescription
    xthickness_gtkstyle: int32
    ythickness_gtkstyle: int32
    background_gtkstyle: array[5, ptr cairo1.TPattern]
    attach_count_gtkstyle: int32
    visual_gtkstyle: ptr Gdk3.TVisual
    private_font_desc_gtkstyle: ptr Pango1.TFontDescription
    rc_style_gtkstyle: ptr TRcStyle
    styles_gtkstyle: ptr GSLIST_TODO
    property_cache_gtkstyle: ptr array[-1, pointer]
    icon_factories_gtkstyle: ptr GSLIST_TODO

  # x
  # 
  StyleContext* = ref GSmartPtr[TStyleContext]
  TStyleContext* = object of GObject2.TObject
    # omitted field for base class:
    # parent_object_gtkstylecontext: ptr GObject2.TObject
    priv_gtkstylecontext: ptr TStyleContextPrivate

  # x
  # 
  StyleProperties* = ref GSmartPtr[TStyleProperties]
  TStyleProperties* = object of GObject2.TObject
    # omitted field for base class:
    # parent_object_gtkstyleproperties: ptr GObject2.TObject
    priv_gtkstyleproperties: ptr TStylePropertiesPrivate

  # x
  # 
  Switch* = ref GSmartPtr[TSwitch]
  TSwitch* = object of TWidget
    # omitted field for base class:
    # parent_instance_gtkswitch: ptr TWidget
    priv_gtkswitch: ptr TSwitchPrivate

  # x
  # 
  SwitchAccessible* = ref GSmartPtr[TSwitchAccessible]
  TSwitchAccessible* = object of TWidgetAccessible
    # omitted field for base class:
    # parent_gtkswitchaccessible: ptr TWidgetAccessible
    priv_gtkswitchaccessible: ptr TSwitchAccessiblePrivate

  # x
  # 
  Table* = ref GSmartPtr[TTable]
  TTable* = object of TContainer
    # omitted field for base class:
    # container_gtktable: ptr TContainer
    priv_gtktable: ptr TTablePrivate

  # x
  # 
  TearoffMenuItem* = ref GSmartPtr[TTearoffMenuItem]
  TTearoffMenuItem* = object of TMenuItem
    # omitted field for base class:
    # menu_item_gtktearoffmenuitem: ptr TMenuItem
    priv_gtktearoffmenuitem: ptr TTearoffMenuItemPrivate

  # x
  # 
  TextBuffer* = ref GSmartPtr[TTextBuffer]
  TTextBuffer* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtktextbuffer: ptr GObject2.TObject
    priv_gtktextbuffer: ptr TTextBufferPrivate

  # x
  # 
  TextCellAccessible* = ref GSmartPtr[TTextCellAccessible]
  TTextCellAccessible* = object of TRendererCellAccessible
    # omitted field for base class:
    # parent_gtktextcellaccessible: ptr TRendererCellAccessible
    priv_gtktextcellaccessible: ptr TTextCellAccessiblePrivate

  # x
  # 
  TextChildAnchor* = ref GSmartPtr[TTextChildAnchor]
  TTextChildAnchor* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtktextchildanchor: ptr GObject2.TObject
    segment_gtktextchildanchor: pointer

  # x
  # 
  TextMark* = ref GSmartPtr[TTextMark]
  TTextMark* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtktextmark: ptr GObject2.TObject
    segment_gtktextmark: pointer

  # x
  # 
  TextTag* = ref GSmartPtr[TTextTag]
  TTextTag* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtktexttag: ptr GObject2.TObject
    priv_gtktexttag: ptr TTextTagPrivate

  # x
  # 
  TextTagTable* = ref GSmartPtr[TTextTagTable]
  TTextTagTable* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtktexttagtable: ptr GObject2.TObject
    priv_gtktexttagtable: ptr TTextTagTablePrivate

  # x
  # 
  TextView* = ref GSmartPtr[TTextView]
  TTextView* = object of TContainer
    # omitted field for base class:
    # parent_instance_gtktextview: ptr TContainer
    priv_gtktextview: ptr TTextViewPrivate

  # x
  # 
  TextViewAccessible* = ref GSmartPtr[TTextViewAccessible]
  TTextViewAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtktextviewaccessible: ptr TContainerAccessible
    priv_gtktextviewaccessible: ptr TTextViewAccessiblePrivate

  # x
  # 
  ThemingEngine* = ref GSmartPtr[TThemingEngine]
  TThemingEngine* = object of GObject2.TObject
    # omitted field for base class:
    # parent_object_gtkthemingengine: ptr GObject2.TObject
    priv_gtkthemingengine: ptr TThemingEnginePrivate

  # x
  # 
  ToolItemGroup* = ref GSmartPtr[TToolItemGroup]
  TToolItemGroup* = object of TContainer
    # omitted field for base class:
    # parent_instance_gtktoolitemgroup: ptr TContainer
    priv_gtktoolitemgroup: ptr TToolItemGroupPrivate

  # x
  # 
  ToolPalette* = ref GSmartPtr[TToolPalette]
  TToolPalette* = object of TContainer
    # omitted field for base class:
    # parent_instance_gtktoolpalette: ptr TContainer
    priv_gtktoolpalette: ptr TToolPalettePrivate

  # x
  # 
  Toolbar* = ref GSmartPtr[TToolbar]
  TToolbar* = object of TContainer
    # omitted field for base class:
    # container_gtktoolbar: ptr TContainer
    priv_gtktoolbar: ptr TToolbarPrivate

  # x
  # 
  Tooltip* = ref GSmartPtr[TTooltip]
  TTooltip* = object of GObject2.TObject

  # x
  # 
  ToplevelAccessible* = ref GSmartPtr[TToplevelAccessible]
  TToplevelAccessible* = object of Atk1.TObject
    # omitted field for base class:
    # parent_gtktoplevelaccessible: ptr Atk1.TObject
    priv_gtktoplevelaccessible: ptr TToplevelAccessiblePrivate

  # x
  # 
  TreeModelFilter* = ref GSmartPtr[TTreeModelFilter]
  TTreeModelFilter* = object of GObject2.TObject
    # omitted field for base class:
    # parent_gtktreemodelfilter: ptr GObject2.TObject
    priv_gtktreemodelfilter: ptr TTreeModelFilterPrivate

  # x
  # 
  TreeModelSort* = ref GSmartPtr[TTreeModelSort]
  TTreeModelSort* = object of GObject2.TObject
    # omitted field for base class:
    # parent_gtktreemodelsort: ptr GObject2.TObject
    priv_gtktreemodelsort: ptr TTreeModelSortPrivate

  # x
  # 
  TreeSelection* = ref GSmartPtr[TTreeSelection]
  TTreeSelection* = object of GObject2.TObject
    # omitted field for base class:
    # parent_gtktreeselection: ptr GObject2.TObject
    priv_gtktreeselection: ptr TTreeSelectionPrivate

  # x
  # 
  TreeStore* = ref GSmartPtr[TTreeStore]
  TTreeStore* = object of GObject2.TObject
    # omitted field for base class:
    # parent_gtktreestore: ptr GObject2.TObject
    priv_gtktreestore: ptr TTreeStorePrivate

  # x
  # 
  TreeView* = ref GSmartPtr[TTreeView]
  TTreeView* = object of TContainer
    # omitted field for base class:
    # parent_gtktreeview: ptr TContainer
    priv_gtktreeview: ptr TTreeViewPrivate

  # x
  # 
  TreeViewAccessible* = ref GSmartPtr[TTreeViewAccessible]
  TTreeViewAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtktreeviewaccessible: ptr TContainerAccessible
    priv_gtktreeviewaccessible: ptr TTreeViewAccessiblePrivate

  # x
  # 
  TreeViewColumn* = ref GSmartPtr[TTreeViewColumn]
  TTreeViewColumn* = object of GObject2.TInitiallyUnowned
    # omitted field for base class:
    # parent_instance_gtktreeviewcolumn: ptr GObject2.TInitiallyUnowned
    priv_gtktreeviewcolumn: ptr TTreeViewColumnPrivate

  # x
  # 
  UIManager* = ref GSmartPtr[TUIManager]
  TUIManager* = object of GObject2.TObject
    # omitted field for base class:
    # parent_gtkuimanager: ptr GObject2.TObject
    private_data_gtkuimanager: ptr TUIManagerPrivate

  # x
  # 
  VBox* = ref GSmartPtr[TVBox]
  TVBox* = object of TBox
    # omitted field for base class:
    # box_gtkvbox: ptr TBox

  # x
  # 
  VButtonBox* = ref GSmartPtr[TVButtonBox]
  TVButtonBox* = object of TButtonBox
    # omitted field for base class:
    # button_box_gtkvbuttonbox: ptr TButtonBox

  # x
  # 
  VPaned* = ref GSmartPtr[TVPaned]
  TVPaned* = object of TPaned
    # omitted field for base class:
    # paned_gtkvpaned: ptr TPaned

  # x
  # 
  VScale* = ref GSmartPtr[TVScale]
  TVScale* = object of TScale
    # omitted field for base class:
    # scale_gtkvscale: ptr TScale

  # x
  # 
  VScrollbar* = ref GSmartPtr[TVScrollbar]
  TVScrollbar* = object of TScrollbar
    # omitted field for base class:
    # scrollbar_gtkvscrollbar: ptr TScrollbar

  # x
  # 
  VSeparator* = ref GSmartPtr[TVSeparator]
  TVSeparator* = object of TSeparator
    # omitted field for base class:
    # separator_gtkvseparator: ptr TSeparator

  # x
  # 
  Viewport* = ref GSmartPtr[TViewport]
  TViewport* = object of TBin
    # omitted field for base class:
    # bin_gtkviewport: ptr TBin
    priv_gtkviewport: ptr TViewportPrivate

  # x
  # 
  VolumeButton* = ref GSmartPtr[TVolumeButton]
  TVolumeButton* = object of TScaleButton
    # omitted field for base class:
    # parent_gtkvolumebutton: ptr TScaleButton

  # x
  # 
  WindowAccessible* = ref GSmartPtr[TWindowAccessible]
  TWindowAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkwindowaccessible: ptr TContainerAccessible
    priv_gtkwindowaccessible: ptr TWindowAccessiblePrivate

  # x
  # 
  WindowGroup* = ref GSmartPtr[TWindowGroup]
  TWindowGroup* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkwindowgroup: ptr GObject2.TObject
    priv_gtkwindowgroup: ptr TWindowGroupPrivate

  # structs
  #------------------
  TAboutDialogClass* = object
    parent_class*: TDialogClass
    activate_link*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  AboutDialogClass* = ref GSmartPtr[TAboutDialogClass]

  TAboutDialogPrivate* = object
  AboutDialogPrivate* = ref GSmartPtr[TAboutDialogPrivate]

  TAccelGroupClass* = object
    parent_class*: GObject2.TObjectClass
    accel_changed*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  AccelGroupClass* = ref GSmartPtr[TAccelGroupClass]

  TAccelGroupEntry* = object
    key*: TAccelKey
    closure*: ptr GObject2.TClosure
    accel_path_quark*: uint32
  AccelGroupEntry* = ref GSmartPtr[TAccelGroupEntry]

  TAccelGroupPrivate* = object
  AccelGroupPrivate* = ref GSmartPtr[TAccelGroupPrivate]

  TAccelKey* = object
    accel_key*: uint32
    accel_mods*: Gdk3.SModifierType
    accel_flags*: uint32
  AccelKey* = ref GSmartPtr[TAccelKey]

  TAccelLabelClass* = object
    parent_class*: TLabelClass
    signal_quote1*: ucstring
    signal_quote2*: ucstring
    mod_name_shift*: ucstring
    mod_name_control*: ucstring
    mod_name_alt*: ucstring
    mod_separator*: ucstring
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  AccelLabelClass* = ref GSmartPtr[TAccelLabelClass]

  TAccelLabelPrivate* = object
  AccelLabelPrivate* = ref GSmartPtr[TAccelLabelPrivate]

  TAccelMapClass* = object
  AccelMapClass* = ref GSmartPtr[TAccelMapClass]

  TAccessibleClass* = object
    parent_class*: Atk1.TObjectClass
    connect_widget_destroyed*: pointer
    widget_set*: pointer
    widget_unset*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  AccessibleClass* = ref GSmartPtr[TAccessibleClass]

  TAccessiblePrivate* = object
  AccessiblePrivate* = ref GSmartPtr[TAccessiblePrivate]

  TActionBarClass* = object
    parent_class*: TBinClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ActionBarClass* = ref GSmartPtr[TActionBarClass]

  TActionBarPrivate* = object
  ActionBarPrivate* = ref GSmartPtr[TActionBarPrivate]

  TActionClass* = object
    parent_class*: GObject2.TObjectClass
    activate*: pointer
    menu_item_type*: GType
    toolbar_item_type*: GType
    create_menu_item*: pointer
    create_tool_item*: pointer
    connect_proxy*: pointer
    disconnect_proxy*: pointer
    create_menu*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ActionClass* = ref GSmartPtr[TActionClass]

  TActionEntry* = object
    name*: ucstring
    stock_id*: ucstring
    label*: ucstring
    accelerator*: ucstring
    tooltip*: ucstring
    callback*: pointer
  ActionEntry* = ref GSmartPtr[TActionEntry]

  TActionGroupClass* = object
    parent_class*: GObject2.TObjectClass
    get_action*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ActionGroupClass* = ref GSmartPtr[TActionGroupClass]

  TActionGroupPrivate* = object
  ActionGroupPrivate* = ref GSmartPtr[TActionGroupPrivate]

  TActionPrivate* = object
  ActionPrivate* = ref GSmartPtr[TActionPrivate]

  TActionableInterface* = object
    g_iface*: GObject2.TTypeInterface
    get_action_name*: pointer
    set_action_name*: pointer
    get_action_target_value*: pointer
    set_action_target_value*: pointer
  ActionableInterface* = ref GSmartPtr[TActionableInterface]

  TActivatableIface* = object
    g_iface*: GObject2.TTypeInterface
    update*: pointer
    sync_action_properties*: pointer
  ActivatableIface* = ref GSmartPtr[TActivatableIface]

  TAdjustmentClass* = object
    parent_class*: GObject2.TInitiallyUnownedClass
    changed*: pointer
    value_changed*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  AdjustmentClass* = ref GSmartPtr[TAdjustmentClass]

  TAdjustmentPrivate* = object
  AdjustmentPrivate* = ref GSmartPtr[TAdjustmentPrivate]

  TAlignmentClass* = object
    parent_class*: TBinClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  AlignmentClass* = ref GSmartPtr[TAlignmentClass]

  TAlignmentPrivate* = object
  AlignmentPrivate* = ref GSmartPtr[TAlignmentPrivate]

  TAppChooserButtonClass* = object
    parent_class*: TComboBoxClass
    custom_item_activated*: pointer
    padding*: array[16, pointer]
  AppChooserButtonClass* = ref GSmartPtr[TAppChooserButtonClass]

  TAppChooserButtonPrivate* = object
  AppChooserButtonPrivate* = ref GSmartPtr[TAppChooserButtonPrivate]

  TAppChooserDialogClass* = object
    parent_class*: TDialogClass
    padding*: array[16, pointer]
  AppChooserDialogClass* = ref GSmartPtr[TAppChooserDialogClass]

  TAppChooserDialogPrivate* = object
  AppChooserDialogPrivate* = ref GSmartPtr[TAppChooserDialogPrivate]

  TAppChooserWidgetClass* = object
    parent_class*: TBoxClass
    application_selected*: pointer
    application_activated*: pointer
    populate_popup*: pointer
    padding*: array[16, pointer]
  AppChooserWidgetClass* = ref GSmartPtr[TAppChooserWidgetClass]

  TAppChooserWidgetPrivate* = object
  AppChooserWidgetPrivate* = ref GSmartPtr[TAppChooserWidgetPrivate]

  TApplicationClass* = object
    parent_class*: Gio2.TApplicationClass
    window_added*: pointer
    window_removed*: pointer
    padding*: array[12, pointer]
  ApplicationClass* = ref GSmartPtr[TApplicationClass]

  TApplicationPrivate* = object
  ApplicationPrivate* = ref GSmartPtr[TApplicationPrivate]

  TApplicationWindowClass* = object
    parent_class*: TWindowClass
    padding*: array[14, pointer]
  ApplicationWindowClass* = ref GSmartPtr[TApplicationWindowClass]

  TApplicationWindowPrivate* = object
  ApplicationWindowPrivate* = ref GSmartPtr[TApplicationWindowPrivate]

  TArrowAccessibleClass* = object
    parent_class*: TWidgetAccessibleClass
  ArrowAccessibleClass* = ref GSmartPtr[TArrowAccessibleClass]

  TArrowAccessiblePrivate* = object
  ArrowAccessiblePrivate* = ref GSmartPtr[TArrowAccessiblePrivate]

  TArrowClass* = object
    parent_class*: TMiscClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ArrowClass* = ref GSmartPtr[TArrowClass]

  TArrowPrivate* = object
  ArrowPrivate* = ref GSmartPtr[TArrowPrivate]

  TAspectFrameClass* = object
    parent_class*: TFrameClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  AspectFrameClass* = ref GSmartPtr[TAspectFrameClass]

  TAspectFramePrivate* = object
  AspectFramePrivate* = ref GSmartPtr[TAspectFramePrivate]

  TAssistantClass* = object
    parent_class*: TWindowClass
    prepare*: pointer
    apply*: pointer
    close*: pointer
    cancel*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
    x_gtk_reserved5*: pointer
  AssistantClass* = ref GSmartPtr[TAssistantClass]

  TAssistantPrivate* = object
  AssistantPrivate* = ref GSmartPtr[TAssistantPrivate]

  TBinClass* = object
    parent_class*: TContainerClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  BinClass* = ref GSmartPtr[TBinClass]

  TBinPrivate* = object
  BinPrivate* = ref GSmartPtr[TBinPrivate]

  TBindingArg* = object
    arg_type*: GType
  BindingArg* = ref GSmartPtr[TBindingArg]

  TBindingEntry* = object
    keyval*: uint32
    modifiers*: Gdk3.SModifierType
    binding_set*: ptr TBindingSet
    destroyed*: uint32
    in_emission*: uint32
    marks_unbound*: uint32
    set_next*: ptr TBindingEntry
    hash_next*: ptr TBindingEntry
    signals*: ptr TBindingSignal
  BindingEntry* = ref GSmartPtr[TBindingEntry]

  TBindingSet* = object
    set_name*: ucstring
    priority*: int32
    widget_path_pspecs*: ptr GSLIST_TODO
    widget_class_pspecs*: ptr GSLIST_TODO
    class_branch_pspecs*: ptr GSLIST_TODO
    entries*: ptr TBindingEntry
    current*: ptr TBindingEntry
    parsed*: uint32
  BindingSet* = ref GSmartPtr[TBindingSet]

  TBindingSignal* = object
    next*: ptr TBindingSignal
    signal_name*: ucstring
    n_args*: uint32
    args*: ptr array[-1, TBindingArg]
  BindingSignal* = ref GSmartPtr[TBindingSignal]

  TBooleanCellAccessibleClass* = object
    parent_class*: TRendererCellAccessibleClass
  BooleanCellAccessibleClass* = ref GSmartPtr[TBooleanCellAccessibleClass]

  TBooleanCellAccessiblePrivate* = object
  BooleanCellAccessiblePrivate* = ref GSmartPtr[TBooleanCellAccessiblePrivate]

  TBorder* = object
    left*: int16
    right*: int16
    top*: int16
    bottom*: int16
  Border* = ref GSmartPtr[TBorder]

  TBoxClass* = object
    parent_class*: TContainerClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  BoxClass* = ref GSmartPtr[TBoxClass]

  TBoxPrivate* = object
  BoxPrivate* = ref GSmartPtr[TBoxPrivate]

  TBuildableIface* = object
    g_iface*: GObject2.TTypeInterface
    set_name*: pointer
    get_name*: pointer
    add_child*: pointer
    set_buildable_property*: pointer
    construct_child*: pointer
    custom_tag_start*: pointer
    custom_tag_end*: pointer
    custom_finished*: pointer
    parser_finished*: pointer
    get_internal_child*: pointer
  BuildableIface* = ref GSmartPtr[TBuildableIface]

  TBuilderClass* = object
    parent_class*: GObject2.TObjectClass
    get_type_from_name*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
    x_gtk_reserved5*: pointer
    x_gtk_reserved6*: pointer
    x_gtk_reserved7*: pointer
    x_gtk_reserved8*: pointer
  BuilderClass* = ref GSmartPtr[TBuilderClass]

  TBuilderPrivate* = object
  BuilderPrivate* = ref GSmartPtr[TBuilderPrivate]

  TButtonAccessibleClass* = object
    parent_class*: TContainerAccessibleClass
  ButtonAccessibleClass* = ref GSmartPtr[TButtonAccessibleClass]

  TButtonAccessiblePrivate* = object
  ButtonAccessiblePrivate* = ref GSmartPtr[TButtonAccessiblePrivate]

  TButtonBoxClass* = object
    parent_class*: TBoxClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ButtonBoxClass* = ref GSmartPtr[TButtonBoxClass]

  TButtonBoxPrivate* = object
  ButtonBoxPrivate* = ref GSmartPtr[TButtonBoxPrivate]

  TButtonClass* = object
    parent_class*: TBinClass
    pressed*: pointer
    released*: pointer
    clicked*: pointer
    enter*: pointer
    leave*: pointer
    activate*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ButtonClass* = ref GSmartPtr[TButtonClass]

  TButtonPrivate* = object
  ButtonPrivate* = ref GSmartPtr[TButtonPrivate]

  TCalendarClass* = object
    parent_class*: TWidgetClass
    month_changed*: pointer
    day_selected*: pointer
    day_selected_double_click*: pointer
    prev_month*: pointer
    next_month*: pointer
    prev_year*: pointer
    next_year*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  CalendarClass* = ref GSmartPtr[TCalendarClass]

  TCalendarPrivate* = object
  CalendarPrivate* = ref GSmartPtr[TCalendarPrivate]

  TCellAccessibleClass* = object
    parent_class*: TAccessibleClass
    update_cache*: pointer
  CellAccessibleClass* = ref GSmartPtr[TCellAccessibleClass]

  TCellAccessibleParentIface* = object
    parent*: GObject2.TTypeInterface
    get_cell_extents*: pointer
    get_cell_area*: pointer
    grab_focus*: pointer
    get_child_index*: pointer
    get_renderer_state*: pointer
    expand_collapse*: pointer
    activate*: pointer
    edit*: pointer
    update_relationset*: pointer
  CellAccessibleParentIface* = ref GSmartPtr[TCellAccessibleParentIface]

  TCellAccessiblePrivate* = object
  CellAccessiblePrivate* = ref GSmartPtr[TCellAccessiblePrivate]

  TCellAreaBoxClass* = object
    parent_class*: TCellAreaClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  CellAreaBoxClass* = ref GSmartPtr[TCellAreaBoxClass]

  TCellAreaBoxPrivate* = object
  CellAreaBoxPrivate* = ref GSmartPtr[TCellAreaBoxPrivate]

  TCellAreaClass* = object
    parent_class*: GObject2.TInitiallyUnownedClass
    add*: pointer
    remove*: pointer
    foreach*: pointer
    foreach_alloc*: pointer
    event*: pointer
    render*: pointer
    apply_attributes*: pointer
    create_context*: pointer
    copy_context*: pointer
    get_request_mode*: pointer
    get_preferred_width*: pointer
    get_preferred_height_for_width*: pointer
    get_preferred_height*: pointer
    get_preferred_width_for_height*: pointer
    set_cell_property*: pointer
    get_cell_property*: pointer
    focus*: pointer
    is_activatable*: pointer
    activate*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
    x_gtk_reserved5*: pointer
    x_gtk_reserved6*: pointer
    x_gtk_reserved7*: pointer
    x_gtk_reserved8*: pointer
  CellAreaClass* = ref GSmartPtr[TCellAreaClass]

  TCellAreaContextClass* = object
    parent_class*: GObject2.TObjectClass
    allocate*: pointer
    reset*: pointer
    get_preferred_height_for_width*: pointer
    get_preferred_width_for_height*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
    x_gtk_reserved5*: pointer
    x_gtk_reserved6*: pointer
  CellAreaContextClass* = ref GSmartPtr[TCellAreaContextClass]

  TCellAreaContextPrivate* = object
  CellAreaContextPrivate* = ref GSmartPtr[TCellAreaContextPrivate]

  TCellAreaPrivate* = object
  CellAreaPrivate* = ref GSmartPtr[TCellAreaPrivate]

  TCellEditableIface* = object
    g_iface*: GObject2.TTypeInterface
    editing_done*: pointer
    remove_widget*: pointer
    start_editing*: pointer
  CellEditableIface* = ref GSmartPtr[TCellEditableIface]

  TCellLayoutIface* = object
    g_iface*: GObject2.TTypeInterface
    pack_start*: pointer
    pack_end*: pointer
    clear*: pointer
    add_attribute*: pointer
    set_cell_data_func*: pointer
    clear_attributes*: pointer
    reorder*: pointer
    get_cells*: pointer
    get_area*: pointer
  CellLayoutIface* = ref GSmartPtr[TCellLayoutIface]

  TCellRendererAccelClass* = object
    parent_class*: TCellRendererTextClass
    accel_edited*: pointer
    accel_cleared*: pointer
    x_gtk_reserved0*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  CellRendererAccelClass* = ref GSmartPtr[TCellRendererAccelClass]

  TCellRendererAccelPrivate* = object
  CellRendererAccelPrivate* = ref GSmartPtr[TCellRendererAccelPrivate]

  TCellRendererClass* = object
    parent_class*: GObject2.TInitiallyUnownedClass
    get_request_mode*: pointer
    get_preferred_width*: pointer
    get_preferred_height_for_width*: pointer
    get_preferred_height*: pointer
    get_preferred_width_for_height*: pointer
    get_aligned_area*: pointer
    get_size*: pointer
    render*: pointer
    activate*: pointer
    start_editing*: pointer
    editing_canceled*: pointer
    editing_started*: pointer
    priv*: ptr TCellRendererClassPrivate
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  CellRendererClass* = ref GSmartPtr[TCellRendererClass]

  TCellRendererClassPrivate* = object
  CellRendererClassPrivate* = ref GSmartPtr[TCellRendererClassPrivate]

  TCellRendererComboClass* = object
    parent*: TCellRendererTextClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  CellRendererComboClass* = ref GSmartPtr[TCellRendererComboClass]

  TCellRendererComboPrivate* = object
  CellRendererComboPrivate* = ref GSmartPtr[TCellRendererComboPrivate]

  TCellRendererPixbufClass* = object
    parent_class*: TCellRendererClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  CellRendererPixbufClass* = ref GSmartPtr[TCellRendererPixbufClass]

  TCellRendererPixbufPrivate* = object
  CellRendererPixbufPrivate* = ref GSmartPtr[TCellRendererPixbufPrivate]

  TCellRendererPrivate* = object
  CellRendererPrivate* = ref GSmartPtr[TCellRendererPrivate]

  TCellRendererProgressClass* = object
    parent_class*: TCellRendererClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  CellRendererProgressClass* = ref GSmartPtr[TCellRendererProgressClass]

  TCellRendererProgressPrivate* = object
  CellRendererProgressPrivate* = ref GSmartPtr[TCellRendererProgressPrivate]

  TCellRendererSpinClass* = object
    parent*: TCellRendererTextClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  CellRendererSpinClass* = ref GSmartPtr[TCellRendererSpinClass]

  TCellRendererSpinPrivate* = object
  CellRendererSpinPrivate* = ref GSmartPtr[TCellRendererSpinPrivate]

  TCellRendererSpinnerClass* = object
    parent_class*: TCellRendererClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  CellRendererSpinnerClass* = ref GSmartPtr[TCellRendererSpinnerClass]

  TCellRendererSpinnerPrivate* = object
  CellRendererSpinnerPrivate* = ref GSmartPtr[TCellRendererSpinnerPrivate]

  TCellRendererTextClass* = object
    parent_class*: TCellRendererClass
    edited*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  CellRendererTextClass* = ref GSmartPtr[TCellRendererTextClass]

  TCellRendererTextPrivate* = object
  CellRendererTextPrivate* = ref GSmartPtr[TCellRendererTextPrivate]

  TCellRendererToggleClass* = object
    parent_class*: TCellRendererClass
    toggled*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  CellRendererToggleClass* = ref GSmartPtr[TCellRendererToggleClass]

  TCellRendererTogglePrivate* = object
  CellRendererTogglePrivate* = ref GSmartPtr[TCellRendererTogglePrivate]

  TCellViewClass* = object
    parent_class*: TWidgetClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  CellViewClass* = ref GSmartPtr[TCellViewClass]

  TCellViewPrivate* = object
  CellViewPrivate* = ref GSmartPtr[TCellViewPrivate]

  TCheckButtonClass* = object
    parent_class*: TToggleButtonClass
    draw_indicator*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  CheckButtonClass* = ref GSmartPtr[TCheckButtonClass]

  TCheckMenuItemAccessibleClass* = object
    parent_class*: TMenuItemAccessibleClass
  CheckMenuItemAccessibleClass* = ref GSmartPtr[TCheckMenuItemAccessibleClass]

  TCheckMenuItemAccessiblePrivate* = object
  CheckMenuItemAccessiblePrivate* = ref GSmartPtr[TCheckMenuItemAccessiblePrivate]

  TCheckMenuItemClass* = object
    parent_class*: TMenuItemClass
    toggled*: pointer
    draw_indicator*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  CheckMenuItemClass* = ref GSmartPtr[TCheckMenuItemClass]

  TCheckMenuItemPrivate* = object
  CheckMenuItemPrivate* = ref GSmartPtr[TCheckMenuItemPrivate]

  TColorButtonClass* = object
    parent_class*: TButtonClass
    color_set*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ColorButtonClass* = ref GSmartPtr[TColorButtonClass]

  TColorButtonPrivate* = object
  ColorButtonPrivate* = ref GSmartPtr[TColorButtonPrivate]

  TColorChooserDialogClass* = object
    parent_class*: TDialogClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ColorChooserDialogClass* = ref GSmartPtr[TColorChooserDialogClass]

  TColorChooserDialogPrivate* = object
  ColorChooserDialogPrivate* = ref GSmartPtr[TColorChooserDialogPrivate]

  TColorChooserInterface* = object
    base_interface*: GObject2.TTypeInterface
    get_rgba*: pointer
    set_rgba*: pointer
    add_palette*: pointer
    color_activated*: pointer
    padding*: array[12, pointer]
  ColorChooserInterface* = ref GSmartPtr[TColorChooserInterface]

  TColorChooserWidgetClass* = object
    parent_class*: TBoxClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
    x_gtk_reserved5*: pointer
    x_gtk_reserved6*: pointer
    x_gtk_reserved7*: pointer
    x_gtk_reserved8*: pointer
  ColorChooserWidgetClass* = ref GSmartPtr[TColorChooserWidgetClass]

  TColorChooserWidgetPrivate* = object
  ColorChooserWidgetPrivate* = ref GSmartPtr[TColorChooserWidgetPrivate]

  TColorSelectionClass* = object
    parent_class*: TBoxClass
    color_changed*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ColorSelectionClass* = ref GSmartPtr[TColorSelectionClass]

  TColorSelectionDialogClass* = object
    parent_class*: TDialogClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ColorSelectionDialogClass* = ref GSmartPtr[TColorSelectionDialogClass]

  TColorSelectionDialogPrivate* = object
  ColorSelectionDialogPrivate* = ref GSmartPtr[TColorSelectionDialogPrivate]

  TColorSelectionPrivate* = object
  ColorSelectionPrivate* = ref GSmartPtr[TColorSelectionPrivate]

  TComboBoxAccessibleClass* = object
    parent_class*: TContainerAccessibleClass
  ComboBoxAccessibleClass* = ref GSmartPtr[TComboBoxAccessibleClass]

  TComboBoxAccessiblePrivate* = object
  ComboBoxAccessiblePrivate* = ref GSmartPtr[TComboBoxAccessiblePrivate]

  TComboBoxClass* = object
    parent_class*: TBinClass
    changed*: pointer
    format_entry_text*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
  ComboBoxClass* = ref GSmartPtr[TComboBoxClass]

  TComboBoxPrivate* = object
  ComboBoxPrivate* = ref GSmartPtr[TComboBoxPrivate]

  TComboBoxTextClass* = object
    parent_class*: TComboBoxClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ComboBoxTextClass* = ref GSmartPtr[TComboBoxTextClass]

  TComboBoxTextPrivate* = object
  ComboBoxTextPrivate* = ref GSmartPtr[TComboBoxTextPrivate]

  TContainerAccessibleClass* = object
    parent_class*: TWidgetAccessibleClass
    add_gtk*: pointer
    remove_gtk*: pointer
  ContainerAccessibleClass* = ref GSmartPtr[TContainerAccessibleClass]

  TContainerAccessiblePrivate* = object
  ContainerAccessiblePrivate* = ref GSmartPtr[TContainerAccessiblePrivate]

  TContainerCellAccessibleClass* = object
    parent_class*: TCellAccessibleClass
  ContainerCellAccessibleClass* = ref GSmartPtr[TContainerCellAccessibleClass]

  TContainerCellAccessiblePrivate* = object
  ContainerCellAccessiblePrivate* = ref GSmartPtr[TContainerCellAccessiblePrivate]

  TContainerClass* = object
    parent_class*: TWidgetClass
    add*: pointer
    remove*: pointer
    check_resize*: pointer
    forall*: pointer
    set_focus_child*: pointer
    child_type*: pointer
    composite_name*: pointer
    set_child_property*: pointer
    get_child_property*: pointer
    get_path_for_child*: pointer
    x_handle_border_width*: uint32
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
    x_gtk_reserved5*: pointer
    x_gtk_reserved6*: pointer
    x_gtk_reserved7*: pointer
    x_gtk_reserved8*: pointer
  ContainerClass* = ref GSmartPtr[TContainerClass]

  TContainerPrivate* = object
  ContainerPrivate* = ref GSmartPtr[TContainerPrivate]

  TCssProviderClass* = object
    parent_class*: GObject2.TObjectClass
    parsing_error*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  CssProviderClass* = ref GSmartPtr[TCssProviderClass]

  TCssProviderPrivate* = object
  CssProviderPrivate* = ref GSmartPtr[TCssProviderPrivate]

  TCssSection* = object
  CssSection* = ref GSmartPtr[TCssSection]

  TDialogClass* = object
    parent_class*: TWindowClass
    response*: pointer
    close*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  DialogClass* = ref GSmartPtr[TDialogClass]

  TDialogPrivate* = object
  DialogPrivate* = ref GSmartPtr[TDialogPrivate]

  TDrawingAreaClass* = object
    parent_class*: TWidgetClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  DrawingAreaClass* = ref GSmartPtr[TDrawingAreaClass]

  TEditableInterface* = object
    base_iface*: GObject2.TTypeInterface
    insert_text*: pointer
    delete_text*: pointer
    changed*: pointer
    do_insert_text*: pointer
    do_delete_text*: pointer
    get_chars*: pointer
    set_selection_bounds*: pointer
    get_selection_bounds*: pointer
    set_position*: pointer
    get_position*: pointer
  EditableInterface* = ref GSmartPtr[TEditableInterface]

  TEntryAccessibleClass* = object
    parent_class*: TWidgetAccessibleClass
  EntryAccessibleClass* = ref GSmartPtr[TEntryAccessibleClass]

  TEntryAccessiblePrivate* = object
  EntryAccessiblePrivate* = ref GSmartPtr[TEntryAccessiblePrivate]

  TEntryBufferClass* = object
    parent_class*: GObject2.TObjectClass
    inserted_text*: pointer
    deleted_text*: pointer
    get_text*: pointer
    get_length*: pointer
    insert_text*: pointer
    delete_text*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
    x_gtk_reserved5*: pointer
    x_gtk_reserved6*: pointer
    x_gtk_reserved7*: pointer
    x_gtk_reserved8*: pointer
  EntryBufferClass* = ref GSmartPtr[TEntryBufferClass]

  TEntryBufferPrivate* = object
  EntryBufferPrivate* = ref GSmartPtr[TEntryBufferPrivate]

  TEntryClass* = object
    parent_class*: TWidgetClass
    populate_popup*: pointer
    activate*: pointer
    move_cursor*: pointer
    insert_at_cursor*: pointer
    delete_from_cursor*: pointer
    backspace*: pointer
    cut_clipboard*: pointer
    copy_clipboard*: pointer
    paste_clipboard*: pointer
    toggle_overwrite*: pointer
    get_text_area_size*: pointer
    get_frame_size*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
    x_gtk_reserved5*: pointer
    x_gtk_reserved6*: pointer
    x_gtk_reserved7*: pointer
  EntryClass* = ref GSmartPtr[TEntryClass]

  TEntryCompletionClass* = object
    parent_class*: GObject2.TObjectClass
    match_selected*: pointer
    action_activated*: pointer
    insert_prefix*: pointer
    cursor_on_match*: pointer
    no_matches*: pointer
    x_gtk_reserved0*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
  EntryCompletionClass* = ref GSmartPtr[TEntryCompletionClass]

  TEntryCompletionPrivate* = object
  EntryCompletionPrivate* = ref GSmartPtr[TEntryCompletionPrivate]

  TEntryPrivate* = object
  EntryPrivate* = ref GSmartPtr[TEntryPrivate]

  TEventBoxClass* = object
    parent_class*: TBinClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  EventBoxClass* = ref GSmartPtr[TEventBoxClass]

  TEventBoxPrivate* = object
  EventBoxPrivate* = ref GSmartPtr[TEventBoxPrivate]

  TEventControllerClass* = object
  EventControllerClass* = ref GSmartPtr[TEventControllerClass]

  TExpanderAccessibleClass* = object
    parent_class*: TContainerAccessibleClass
  ExpanderAccessibleClass* = ref GSmartPtr[TExpanderAccessibleClass]

  TExpanderAccessiblePrivate* = object
  ExpanderAccessiblePrivate* = ref GSmartPtr[TExpanderAccessiblePrivate]

  TExpanderClass* = object
    parent_class*: TBinClass
    activate*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ExpanderClass* = ref GSmartPtr[TExpanderClass]

  TExpanderPrivate* = object
  ExpanderPrivate* = ref GSmartPtr[TExpanderPrivate]

  TFileChooserButtonClass* = object
    parent_class*: TBoxClass
    file_set*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  FileChooserButtonClass* = ref GSmartPtr[TFileChooserButtonClass]

  TFileChooserButtonPrivate* = object
  FileChooserButtonPrivate* = ref GSmartPtr[TFileChooserButtonPrivate]

  TFileChooserDialogClass* = object
    parent_class*: TDialogClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  FileChooserDialogClass* = ref GSmartPtr[TFileChooserDialogClass]

  TFileChooserDialogPrivate* = object
  FileChooserDialogPrivate* = ref GSmartPtr[TFileChooserDialogPrivate]

  TFileChooserWidgetClass* = object
    parent_class*: TBoxClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  FileChooserWidgetClass* = ref GSmartPtr[TFileChooserWidgetClass]

  TFileChooserWidgetPrivate* = object
  FileChooserWidgetPrivate* = ref GSmartPtr[TFileChooserWidgetPrivate]

  TFileFilterInfo* = object
    contains*: SFileFilterFlags
    filename*: ucstring
    uri*: ucstring
    display_name*: ucstring
    mime_type*: ucstring
  FileFilterInfo* = ref GSmartPtr[TFileFilterInfo]

  TFixedChild* = object
    widget*: ptr TWidget
    x*: int32
    y*: int32
  FixedChild* = ref GSmartPtr[TFixedChild]

  TFixedClass* = object
    parent_class*: TContainerClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  FixedClass* = ref GSmartPtr[TFixedClass]

  TFixedPrivate* = object
  FixedPrivate* = ref GSmartPtr[TFixedPrivate]

  TFlowBoxAccessibleClass* = object
    parent_class*: TContainerAccessibleClass
  FlowBoxAccessibleClass* = ref GSmartPtr[TFlowBoxAccessibleClass]

  TFlowBoxAccessiblePrivate* = object
  FlowBoxAccessiblePrivate* = ref GSmartPtr[TFlowBoxAccessiblePrivate]

  TFlowBoxChildAccessibleClass* = object
    parent_class*: TContainerAccessibleClass
  FlowBoxChildAccessibleClass* = ref GSmartPtr[TFlowBoxChildAccessibleClass]

  TFlowBoxChildClass* = object
    parent_class*: TBinClass
    activate*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
  FlowBoxChildClass* = ref GSmartPtr[TFlowBoxChildClass]

  TFlowBoxClass* = object
    parent_class*: TContainerClass
    child_activated*: pointer
    selected_children_changed*: pointer
    activate_cursor_child*: pointer
    toggle_cursor_child*: pointer
    move_cursor*: pointer
    select_all*: pointer
    unselect_all*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
    x_gtk_reserved5*: pointer
    x_gtk_reserved6*: pointer
  FlowBoxClass* = ref GSmartPtr[TFlowBoxClass]

  TFontButtonClass* = object
    parent_class*: TButtonClass
    font_set*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  FontButtonClass* = ref GSmartPtr[TFontButtonClass]

  TFontButtonPrivate* = object
  FontButtonPrivate* = ref GSmartPtr[TFontButtonPrivate]

  TFontChooserDialogClass* = object
    parent_class*: TDialogClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  FontChooserDialogClass* = ref GSmartPtr[TFontChooserDialogClass]

  TFontChooserDialogPrivate* = object
  FontChooserDialogPrivate* = ref GSmartPtr[TFontChooserDialogPrivate]

  TFontChooserIface* = object
    base_iface*: GObject2.TTypeInterface
    get_font_family*: pointer
    get_font_face*: pointer
    get_font_size*: pointer
    set_filter_func*: pointer
    font_activated*: pointer
    padding*: array[12, pointer]
  FontChooserIface* = ref GSmartPtr[TFontChooserIface]

  TFontChooserWidgetClass* = object
    parent_class*: TBoxClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
    x_gtk_reserved5*: pointer
    x_gtk_reserved6*: pointer
    x_gtk_reserved7*: pointer
    x_gtk_reserved8*: pointer
  FontChooserWidgetClass* = ref GSmartPtr[TFontChooserWidgetClass]

  TFontChooserWidgetPrivate* = object
  FontChooserWidgetPrivate* = ref GSmartPtr[TFontChooserWidgetPrivate]

  TFontSelectionClass* = object
    parent_class*: TBoxClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  FontSelectionClass* = ref GSmartPtr[TFontSelectionClass]

  TFontSelectionDialogClass* = object
    parent_class*: TDialogClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  FontSelectionDialogClass* = ref GSmartPtr[TFontSelectionDialogClass]

  TFontSelectionDialogPrivate* = object
  FontSelectionDialogPrivate* = ref GSmartPtr[TFontSelectionDialogPrivate]

  TFontSelectionPrivate* = object
  FontSelectionPrivate* = ref GSmartPtr[TFontSelectionPrivate]

  TFrameAccessibleClass* = object
    parent_class*: TContainerAccessibleClass
  FrameAccessibleClass* = ref GSmartPtr[TFrameAccessibleClass]

  TFrameAccessiblePrivate* = object
  FrameAccessiblePrivate* = ref GSmartPtr[TFrameAccessiblePrivate]

  TFrameClass* = object
    parent_class*: TBinClass
    compute_child_allocation*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  FrameClass* = ref GSmartPtr[TFrameClass]

  TFramePrivate* = object
  FramePrivate* = ref GSmartPtr[TFramePrivate]

  TGestureClass* = object
  GestureClass* = ref GSmartPtr[TGestureClass]

  TGestureDragClass* = object
  GestureDragClass* = ref GSmartPtr[TGestureDragClass]

  TGestureLongPressClass* = object
  GestureLongPressClass* = ref GSmartPtr[TGestureLongPressClass]

  TGestureMultiPressClass* = object
  GestureMultiPressClass* = ref GSmartPtr[TGestureMultiPressClass]

  TGesturePanClass* = object
  GesturePanClass* = ref GSmartPtr[TGesturePanClass]

  TGestureRotateClass* = object
  GestureRotateClass* = ref GSmartPtr[TGestureRotateClass]

  TGestureSingleClass* = object
  GestureSingleClass* = ref GSmartPtr[TGestureSingleClass]

  TGestureSwipeClass* = object
  GestureSwipeClass* = ref GSmartPtr[TGestureSwipeClass]

  TGestureZoomClass* = object
  GestureZoomClass* = ref GSmartPtr[TGestureZoomClass]

  TGradient* = object
  Gradient* = ref GSmartPtr[TGradient]

  TGridClass* = object
    parent_class*: TContainerClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
    x_gtk_reserved5*: pointer
    x_gtk_reserved6*: pointer
    x_gtk_reserved7*: pointer
    x_gtk_reserved8*: pointer
  GridClass* = ref GSmartPtr[TGridClass]

  TGridPrivate* = object
  GridPrivate* = ref GSmartPtr[TGridPrivate]

  THBoxClass* = object
    parent_class*: TBoxClass
  HBoxClass* = ref GSmartPtr[THBoxClass]

  THButtonBoxClass* = object
    parent_class*: TButtonBoxClass
  HButtonBoxClass* = ref GSmartPtr[THButtonBoxClass]

  THPanedClass* = object
    parent_class*: TPanedClass
  HPanedClass* = ref GSmartPtr[THPanedClass]

  THSVClass* = object
    parent_class*: TWidgetClass
    changed*: pointer
    move*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  HSVClass* = ref GSmartPtr[THSVClass]

  THSVPrivate* = object
  HSVPrivate* = ref GSmartPtr[THSVPrivate]

  THScaleClass* = object
    parent_class*: TScaleClass
  HScaleClass* = ref GSmartPtr[THScaleClass]

  THScrollbarClass* = object
    parent_class*: TScrollbarClass
  HScrollbarClass* = ref GSmartPtr[THScrollbarClass]

  THSeparatorClass* = object
    parent_class*: TSeparatorClass
  HSeparatorClass* = ref GSmartPtr[THSeparatorClass]

  THandleBoxClass* = object
    parent_class*: TBinClass
    child_attached*: pointer
    child_detached*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  HandleBoxClass* = ref GSmartPtr[THandleBoxClass]

  THandleBoxPrivate* = object
  HandleBoxPrivate* = ref GSmartPtr[THandleBoxPrivate]

  THeaderBarClass* = object
    parent_class*: TContainerClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  HeaderBarClass* = ref GSmartPtr[THeaderBarClass]

  THeaderBarPrivate* = object
  HeaderBarPrivate* = ref GSmartPtr[THeaderBarPrivate]

  TIMContextClass* = object
    parent_class*: GObject2.TObjectClass
    preedit_start*: pointer
    preedit_end*: pointer
    preedit_changed*: pointer
    commit*: pointer
    retrieve_surrounding*: pointer
    delete_surrounding*: pointer
    set_client_window*: pointer
    get_preedit_string*: pointer
    filter_keypress*: pointer
    focus_in*: pointer
    focus_out*: pointer
    reset*: pointer
    set_cursor_location*: pointer
    set_use_preedit*: pointer
    set_surrounding*: pointer
    get_surrounding*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
    x_gtk_reserved5*: pointer
    x_gtk_reserved6*: pointer
  IMContextClass* = ref GSmartPtr[TIMContextClass]

  TIMContextInfo* = object
    context_id*: ucstring
    context_name*: ucstring
    domain*: ucstring
    domain_dirname*: ucstring
    default_locales*: ucstring
  IMContextInfo* = ref GSmartPtr[TIMContextInfo]

  TIMContextSimpleClass* = object
    parent_class*: TIMContextClass
  IMContextSimpleClass* = ref GSmartPtr[TIMContextSimpleClass]

  TIMContextSimplePrivate* = object
  IMContextSimplePrivate* = ref GSmartPtr[TIMContextSimplePrivate]

  TIMMulticontextClass* = object
    parent_class*: TIMContextClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  IMMulticontextClass* = ref GSmartPtr[TIMMulticontextClass]

  TIMMulticontextPrivate* = object
  IMMulticontextPrivate* = ref GSmartPtr[TIMMulticontextPrivate]

  TIconFactoryClass* = object
    parent_class*: GObject2.TObjectClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  IconFactoryClass* = ref GSmartPtr[TIconFactoryClass]

  TIconFactoryPrivate* = object
  IconFactoryPrivate* = ref GSmartPtr[TIconFactoryPrivate]

  TIconInfoClass* = object
  IconInfoClass* = ref GSmartPtr[TIconInfoClass]

  TIconSet* = object
  IconSet* = ref GSmartPtr[TIconSet]

  TIconSource* = object
  IconSource* = ref GSmartPtr[TIconSource]

  TIconThemeClass* = object
    parent_class*: GObject2.TObjectClass
    changed*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  IconThemeClass* = ref GSmartPtr[TIconThemeClass]

  TIconThemePrivate* = object
  IconThemePrivate* = ref GSmartPtr[TIconThemePrivate]

  TIconViewAccessibleClass* = object
    parent_class*: TContainerAccessibleClass
  IconViewAccessibleClass* = ref GSmartPtr[TIconViewAccessibleClass]

  TIconViewAccessiblePrivate* = object
  IconViewAccessiblePrivate* = ref GSmartPtr[TIconViewAccessiblePrivate]

  TIconViewClass* = object
    parent_class*: TContainerClass
    item_activated*: pointer
    selection_changed*: pointer
    select_all*: pointer
    unselect_all*: pointer
    select_cursor_item*: pointer
    toggle_cursor_item*: pointer
    move_cursor*: pointer
    activate_cursor_item*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  IconViewClass* = ref GSmartPtr[TIconViewClass]

  TIconViewPrivate* = object
  IconViewPrivate* = ref GSmartPtr[TIconViewPrivate]

  TImageAccessibleClass* = object
    parent_class*: TWidgetAccessibleClass
  ImageAccessibleClass* = ref GSmartPtr[TImageAccessibleClass]

  TImageAccessiblePrivate* = object
  ImageAccessiblePrivate* = ref GSmartPtr[TImageAccessiblePrivate]

  TImageCellAccessibleClass* = object
    parent_class*: TRendererCellAccessibleClass
  ImageCellAccessibleClass* = ref GSmartPtr[TImageCellAccessibleClass]

  TImageCellAccessiblePrivate* = object
  ImageCellAccessiblePrivate* = ref GSmartPtr[TImageCellAccessiblePrivate]

  TImageClass* = object
    parent_class*: TMiscClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ImageClass* = ref GSmartPtr[TImageClass]

  TImageMenuItemClass* = object
    parent_class*: TMenuItemClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ImageMenuItemClass* = ref GSmartPtr[TImageMenuItemClass]

  TImageMenuItemPrivate* = object
  ImageMenuItemPrivate* = ref GSmartPtr[TImageMenuItemPrivate]

  TImagePrivate* = object
  ImagePrivate* = ref GSmartPtr[TImagePrivate]

  TInfoBarClass* = object
    parent_class*: TBoxClass
    response*: pointer
    close*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  InfoBarClass* = ref GSmartPtr[TInfoBarClass]

  TInfoBarPrivate* = object
  InfoBarPrivate* = ref GSmartPtr[TInfoBarPrivate]

  TInvisibleClass* = object
    parent_class*: TWidgetClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  InvisibleClass* = ref GSmartPtr[TInvisibleClass]

  TInvisiblePrivate* = object
  InvisiblePrivate* = ref GSmartPtr[TInvisiblePrivate]

  TLabelAccessibleClass* = object
    parent_class*: TWidgetAccessibleClass
  LabelAccessibleClass* = ref GSmartPtr[TLabelAccessibleClass]

  TLabelAccessiblePrivate* = object
  LabelAccessiblePrivate* = ref GSmartPtr[TLabelAccessiblePrivate]

  TLabelClass* = object
    parent_class*: TMiscClass
    move_cursor*: pointer
    copy_clipboard*: pointer
    populate_popup*: pointer
    activate_link*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
    x_gtk_reserved5*: pointer
    x_gtk_reserved6*: pointer
    x_gtk_reserved7*: pointer
    x_gtk_reserved8*: pointer
  LabelClass* = ref GSmartPtr[TLabelClass]

  TLabelPrivate* = object
  LabelPrivate* = ref GSmartPtr[TLabelPrivate]

  TLabelSelectionInfo* = object
  LabelSelectionInfo* = ref GSmartPtr[TLabelSelectionInfo]

  TLayoutClass* = object
    parent_class*: TContainerClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  LayoutClass* = ref GSmartPtr[TLayoutClass]

  TLayoutPrivate* = object
  LayoutPrivate* = ref GSmartPtr[TLayoutPrivate]

  TLevelBarAccessibleClass* = object
    parent_class*: TWidgetAccessibleClass
  LevelBarAccessibleClass* = ref GSmartPtr[TLevelBarAccessibleClass]

  TLevelBarAccessiblePrivate* = object
  LevelBarAccessiblePrivate* = ref GSmartPtr[TLevelBarAccessiblePrivate]

  TLevelBarClass* = object
    parent_class*: TWidgetClass
    offset_changed*: pointer
    padding*: array[16, pointer]
  LevelBarClass* = ref GSmartPtr[TLevelBarClass]

  TLevelBarPrivate* = object
  LevelBarPrivate* = ref GSmartPtr[TLevelBarPrivate]

  TLinkButtonAccessibleClass* = object
    parent_class*: TButtonAccessibleClass
  LinkButtonAccessibleClass* = ref GSmartPtr[TLinkButtonAccessibleClass]

  TLinkButtonAccessiblePrivate* = object
  LinkButtonAccessiblePrivate* = ref GSmartPtr[TLinkButtonAccessiblePrivate]

  TLinkButtonClass* = object
    parent_class*: TButtonClass
    activate_link*: pointer
    x_gtk_padding1*: pointer
    x_gtk_padding2*: pointer
    x_gtk_padding3*: pointer
    x_gtk_padding4*: pointer
  LinkButtonClass* = ref GSmartPtr[TLinkButtonClass]

  TLinkButtonPrivate* = object
  LinkButtonPrivate* = ref GSmartPtr[TLinkButtonPrivate]

  TListBoxAccessibleClass* = object
    parent_class*: TContainerAccessibleClass
  ListBoxAccessibleClass* = ref GSmartPtr[TListBoxAccessibleClass]

  TListBoxAccessiblePrivate* = object
  ListBoxAccessiblePrivate* = ref GSmartPtr[TListBoxAccessiblePrivate]

  TListBoxClass* = object
    parent_class*: TContainerClass
    row_selected*: pointer
    row_activated*: pointer
    activate_cursor_row*: pointer
    toggle_cursor_row*: pointer
    move_cursor*: pointer
    selected_rows_changed*: pointer
    select_all*: pointer
    unselect_all*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
  ListBoxClass* = ref GSmartPtr[TListBoxClass]

  TListBoxRowAccessibleClass* = object
    parent_class*: TContainerAccessibleClass
  ListBoxRowAccessibleClass* = ref GSmartPtr[TListBoxRowAccessibleClass]

  TListBoxRowClass* = object
    parent_class*: TBinClass
    activate*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
  ListBoxRowClass* = ref GSmartPtr[TListBoxRowClass]

  TListStoreClass* = object
    parent_class*: GObject2.TObjectClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ListStoreClass* = ref GSmartPtr[TListStoreClass]

  TListStorePrivate* = object
  ListStorePrivate* = ref GSmartPtr[TListStorePrivate]

  TLockButtonAccessibleClass* = object
    parent_class*: TButtonAccessibleClass
  LockButtonAccessibleClass* = ref GSmartPtr[TLockButtonAccessibleClass]

  TLockButtonAccessiblePrivate* = object
  LockButtonAccessiblePrivate* = ref GSmartPtr[TLockButtonAccessiblePrivate]

  TLockButtonClass* = object
    parent_class*: TButtonClass
    reserved0*: pointer
    reserved1*: pointer
    reserved2*: pointer
    reserved3*: pointer
    reserved4*: pointer
    reserved5*: pointer
    reserved6*: pointer
    reserved7*: pointer
  LockButtonClass* = ref GSmartPtr[TLockButtonClass]

  TLockButtonPrivate* = object
  LockButtonPrivate* = ref GSmartPtr[TLockButtonPrivate]

  TMenuAccessibleClass* = object
    parent_class*: TMenuShellAccessibleClass
  MenuAccessibleClass* = ref GSmartPtr[TMenuAccessibleClass]

  TMenuAccessiblePrivate* = object
  MenuAccessiblePrivate* = ref GSmartPtr[TMenuAccessiblePrivate]

  TMenuBarClass* = object
    parent_class*: TMenuShellClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  MenuBarClass* = ref GSmartPtr[TMenuBarClass]

  TMenuBarPrivate* = object
  MenuBarPrivate* = ref GSmartPtr[TMenuBarPrivate]

  TMenuButtonAccessibleClass* = object
    parent_class*: TToggleButtonAccessibleClass
  MenuButtonAccessibleClass* = ref GSmartPtr[TMenuButtonAccessibleClass]

  TMenuButtonAccessiblePrivate* = object
  MenuButtonAccessiblePrivate* = ref GSmartPtr[TMenuButtonAccessiblePrivate]

  TMenuButtonClass* = object
    parent_class*: TToggleButtonClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  MenuButtonClass* = ref GSmartPtr[TMenuButtonClass]

  TMenuButtonPrivate* = object
  MenuButtonPrivate* = ref GSmartPtr[TMenuButtonPrivate]

  TMenuClass* = object
    parent_class*: TMenuShellClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  MenuClass* = ref GSmartPtr[TMenuClass]

  TMenuItemAccessibleClass* = object
    parent_class*: TContainerAccessibleClass
  MenuItemAccessibleClass* = ref GSmartPtr[TMenuItemAccessibleClass]

  TMenuItemAccessiblePrivate* = object
  MenuItemAccessiblePrivate* = ref GSmartPtr[TMenuItemAccessiblePrivate]

  TMenuItemClass* = object
    parent_class*: TBinClass
    hide_on_activate*: uint32
    activate*: pointer
    activate_item*: pointer
    toggle_size_request*: pointer
    toggle_size_allocate*: pointer
    set_label*: pointer
    get_label*: pointer
    select*: pointer
    deselect*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  MenuItemClass* = ref GSmartPtr[TMenuItemClass]

  TMenuItemPrivate* = object
  MenuItemPrivate* = ref GSmartPtr[TMenuItemPrivate]

  TMenuPrivate* = object
  MenuPrivate* = ref GSmartPtr[TMenuPrivate]

  TMenuShellAccessibleClass* = object
    parent_class*: TContainerAccessibleClass
  MenuShellAccessibleClass* = ref GSmartPtr[TMenuShellAccessibleClass]

  TMenuShellAccessiblePrivate* = object
  MenuShellAccessiblePrivate* = ref GSmartPtr[TMenuShellAccessiblePrivate]

  TMenuShellClass* = object
    parent_class*: TContainerClass
    submenu_placement*: uint32
    deactivate*: pointer
    selection_done*: pointer
    move_current*: pointer
    activate_current*: pointer
    cancel*: pointer
    select_item*: pointer
    insert*: pointer
    get_popup_delay*: pointer
    move_selected*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  MenuShellClass* = ref GSmartPtr[TMenuShellClass]

  TMenuShellPrivate* = object
  MenuShellPrivate* = ref GSmartPtr[TMenuShellPrivate]

  TMenuToolButtonClass* = object
    parent_class*: TToolButtonClass
    show_menu*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  MenuToolButtonClass* = ref GSmartPtr[TMenuToolButtonClass]

  TMenuToolButtonPrivate* = object
  MenuToolButtonPrivate* = ref GSmartPtr[TMenuToolButtonPrivate]

  TMessageDialogClass* = object
    parent_class*: TDialogClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  MessageDialogClass* = ref GSmartPtr[TMessageDialogClass]

  TMessageDialogPrivate* = object
  MessageDialogPrivate* = ref GSmartPtr[TMessageDialogPrivate]

  TMiscClass* = object
    parent_class*: TWidgetClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  MiscClass* = ref GSmartPtr[TMiscClass]

  TMiscPrivate* = object
  MiscPrivate* = ref GSmartPtr[TMiscPrivate]

  TMountOperationClass* = object
    parent_class*: Gio2.TMountOperationClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  MountOperationClass* = ref GSmartPtr[TMountOperationClass]

  TMountOperationPrivate* = object
  MountOperationPrivate* = ref GSmartPtr[TMountOperationPrivate]

  TNotebookAccessibleClass* = object
    parent_class*: TContainerAccessibleClass
  NotebookAccessibleClass* = ref GSmartPtr[TNotebookAccessibleClass]

  TNotebookAccessiblePrivate* = object
  NotebookAccessiblePrivate* = ref GSmartPtr[TNotebookAccessiblePrivate]

  TNotebookClass* = object
    parent_class*: TContainerClass
    switch_page*: pointer
    select_page*: pointer
    focus_tab*: pointer
    change_current_page*: pointer
    move_focus_out*: pointer
    reorder_tab*: pointer
    insert_page*: pointer
    create_window*: pointer
    page_reordered*: pointer
    page_removed*: pointer
    page_added*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
    x_gtk_reserved5*: pointer
    x_gtk_reserved6*: pointer
    x_gtk_reserved7*: pointer
    x_gtk_reserved8*: pointer
  NotebookClass* = ref GSmartPtr[TNotebookClass]

  TNotebookPageAccessibleClass* = object
    parent_class*: Atk1.TObjectClass
  NotebookPageAccessibleClass* = ref GSmartPtr[TNotebookPageAccessibleClass]

  TNotebookPageAccessiblePrivate* = object
  NotebookPageAccessiblePrivate* = ref GSmartPtr[TNotebookPageAccessiblePrivate]

  TNotebookPrivate* = object
  NotebookPrivate* = ref GSmartPtr[TNotebookPrivate]

  TNumerableIconClass* = object
    parent_class*: Gio2.TEmblemedIconClass
    padding*: array[16, pointer]
  NumerableIconClass* = ref GSmartPtr[TNumerableIconClass]

  TNumerableIconPrivate* = object
  NumerableIconPrivate* = ref GSmartPtr[TNumerableIconPrivate]

  TOffscreenWindowClass* = object
    parent_class*: TWindowClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  OffscreenWindowClass* = ref GSmartPtr[TOffscreenWindowClass]

  TOrientableIface* = object
    base_iface*: GObject2.TTypeInterface
  OrientableIface* = ref GSmartPtr[TOrientableIface]

  TOverlayClass* = object
    parent_class*: TBinClass
    get_child_position*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
    x_gtk_reserved5*: pointer
    x_gtk_reserved6*: pointer
    x_gtk_reserved7*: pointer
    x_gtk_reserved8*: pointer
  OverlayClass* = ref GSmartPtr[TOverlayClass]

  TOverlayPrivate* = object
  OverlayPrivate* = ref GSmartPtr[TOverlayPrivate]

  TPageRange* = object
    start*: int32
    end_x*: int32
  PageRange* = ref GSmartPtr[TPageRange]

  TPanedAccessibleClass* = object
    parent_class*: TContainerAccessibleClass
  PanedAccessibleClass* = ref GSmartPtr[TPanedAccessibleClass]

  TPanedAccessiblePrivate* = object
  PanedAccessiblePrivate* = ref GSmartPtr[TPanedAccessiblePrivate]

  TPanedClass* = object
    parent_class*: TContainerClass
    cycle_child_focus*: pointer
    toggle_handle_focus*: pointer
    move_handle*: pointer
    cycle_handle_focus*: pointer
    accept_position*: pointer
    cancel_position*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  PanedClass* = ref GSmartPtr[TPanedClass]

  TPanedPrivate* = object
  PanedPrivate* = ref GSmartPtr[TPanedPrivate]

  TPaperSize* = object
  PaperSize* = ref GSmartPtr[TPaperSize]

  TPlacesSidebarClass* = object
  PlacesSidebarClass* = ref GSmartPtr[TPlacesSidebarClass]

  TPopoverAccessibleClass* = object
    parent_class*: TContainerAccessibleClass
  PopoverAccessibleClass* = ref GSmartPtr[TPopoverAccessibleClass]

  TPopoverClass* = object
    parent_class*: TBinClass
    closed*: pointer
    reserved*: array[10, pointer]
  PopoverClass* = ref GSmartPtr[TPopoverClass]

  TPopoverPrivate* = object
  PopoverPrivate* = ref GSmartPtr[TPopoverPrivate]

  TPrintOperationClass* = object
    parent_class*: GObject2.TObjectClass
    done*: pointer
    begin_print*: pointer
    paginate*: pointer
    request_page_setup*: pointer
    draw_page*: pointer
    end_print*: pointer
    status_changed*: pointer
    create_custom_widget*: pointer
    custom_widget_apply*: pointer
    preview*: pointer
    update_custom_widget*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
    x_gtk_reserved5*: pointer
    x_gtk_reserved6*: pointer
    x_gtk_reserved7*: pointer
    x_gtk_reserved8*: pointer
  PrintOperationClass* = ref GSmartPtr[TPrintOperationClass]

  TPrintOperationPreviewIface* = object
    g_iface*: GObject2.TTypeInterface
    ready*: pointer
    got_page_size*: pointer
    render_page*: pointer
    is_selected*: pointer
    end_preview*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
    x_gtk_reserved5*: pointer
    x_gtk_reserved6*: pointer
    x_gtk_reserved7*: pointer
    x_gtk_reserved8*: pointer
  PrintOperationPreviewIface* = ref GSmartPtr[TPrintOperationPreviewIface]

  TPrintOperationPrivate* = object
  PrintOperationPrivate* = ref GSmartPtr[TPrintOperationPrivate]

  TProgressBarAccessibleClass* = object
    parent_class*: TWidgetAccessibleClass
  ProgressBarAccessibleClass* = ref GSmartPtr[TProgressBarAccessibleClass]

  TProgressBarAccessiblePrivate* = object
  ProgressBarAccessiblePrivate* = ref GSmartPtr[TProgressBarAccessiblePrivate]

  TProgressBarClass* = object
    parent_class*: TWidgetClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ProgressBarClass* = ref GSmartPtr[TProgressBarClass]

  TProgressBarPrivate* = object
  ProgressBarPrivate* = ref GSmartPtr[TProgressBarPrivate]

  TRadioActionClass* = object
    parent_class*: TToggleActionClass
    changed*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  RadioActionClass* = ref GSmartPtr[TRadioActionClass]

  TRadioActionEntry* = object
    name*: ucstring
    stock_id*: ucstring
    label*: ucstring
    accelerator*: ucstring
    tooltip*: ucstring
    value*: int32
  RadioActionEntry* = ref GSmartPtr[TRadioActionEntry]

  TRadioActionPrivate* = object
  RadioActionPrivate* = ref GSmartPtr[TRadioActionPrivate]

  TRadioButtonAccessibleClass* = object
    parent_class*: TToggleButtonAccessibleClass
  RadioButtonAccessibleClass* = ref GSmartPtr[TRadioButtonAccessibleClass]

  TRadioButtonAccessiblePrivate* = object
  RadioButtonAccessiblePrivate* = ref GSmartPtr[TRadioButtonAccessiblePrivate]

  TRadioButtonClass* = object
    parent_class*: TCheckButtonClass
    group_changed*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  RadioButtonClass* = ref GSmartPtr[TRadioButtonClass]

  TRadioButtonPrivate* = object
  RadioButtonPrivate* = ref GSmartPtr[TRadioButtonPrivate]

  TRadioMenuItemAccessibleClass* = object
    parent_class*: TCheckMenuItemAccessibleClass
  RadioMenuItemAccessibleClass* = ref GSmartPtr[TRadioMenuItemAccessibleClass]

  TRadioMenuItemAccessiblePrivate* = object
  RadioMenuItemAccessiblePrivate* = ref GSmartPtr[TRadioMenuItemAccessiblePrivate]

  TRadioMenuItemClass* = object
    parent_class*: TCheckMenuItemClass
    group_changed*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  RadioMenuItemClass* = ref GSmartPtr[TRadioMenuItemClass]

  TRadioMenuItemPrivate* = object
  RadioMenuItemPrivate* = ref GSmartPtr[TRadioMenuItemPrivate]

  TRadioToolButtonClass* = object
    parent_class*: TToggleToolButtonClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  RadioToolButtonClass* = ref GSmartPtr[TRadioToolButtonClass]

  TRangeAccessibleClass* = object
    parent_class*: TWidgetAccessibleClass
  RangeAccessibleClass* = ref GSmartPtr[TRangeAccessibleClass]

  TRangeAccessiblePrivate* = object
  RangeAccessiblePrivate* = ref GSmartPtr[TRangeAccessiblePrivate]

  TRangeClass* = object
    parent_class*: TWidgetClass
    slider_detail*: ucstring
    stepper_detail*: ucstring
    value_changed*: pointer
    adjust_bounds*: pointer
    move_slider*: pointer
    get_range_border*: pointer
    change_value*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  RangeClass* = ref GSmartPtr[TRangeClass]

  TRangePrivate* = object
  RangePrivate* = ref GSmartPtr[TRangePrivate]

  TRcContext* = object
  RcContext* = ref GSmartPtr[TRcContext]

  TRcProperty* = object
    type_name*: uint32
    property_name*: uint32
    origin*: ucstring
    value*: GObject2.TValue
  RcProperty* = ref GSmartPtr[TRcProperty]

  TRcStyleClass* = object
    parent_class*: GObject2.TObjectClass
    create_rc_style*: pointer
    parse*: pointer
    merge*: pointer
    create_style*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  RcStyleClass* = ref GSmartPtr[TRcStyleClass]

  TRecentActionClass* = object
    parent_class*: TActionClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  RecentActionClass* = ref GSmartPtr[TRecentActionClass]

  TRecentActionPrivate* = object
  RecentActionPrivate* = ref GSmartPtr[TRecentActionPrivate]

  TRecentChooserDialogClass* = object
    parent_class*: TDialogClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  RecentChooserDialogClass* = ref GSmartPtr[TRecentChooserDialogClass]

  TRecentChooserDialogPrivate* = object
  RecentChooserDialogPrivate* = ref GSmartPtr[TRecentChooserDialogPrivate]

  TRecentChooserIface* = object
    base_iface*: GObject2.TTypeInterface
    set_current_uri*: pointer
    get_current_uri*: pointer
    select_uri*: pointer
    unselect_uri*: pointer
    select_all*: pointer
    unselect_all*: pointer
    get_items*: pointer
    get_recent_manager*: pointer
    add_filter*: pointer
    remove_filter*: pointer
    list_filters*: pointer
    set_sort_func*: pointer
    item_activated*: pointer
    selection_changed*: pointer
  RecentChooserIface* = ref GSmartPtr[TRecentChooserIface]

  TRecentChooserMenuClass* = object
    parent_class*: TMenuClass
    gtk_recent1*: pointer
    gtk_recent2*: pointer
    gtk_recent3*: pointer
    gtk_recent4*: pointer
  RecentChooserMenuClass* = ref GSmartPtr[TRecentChooserMenuClass]

  TRecentChooserMenuPrivate* = object
  RecentChooserMenuPrivate* = ref GSmartPtr[TRecentChooserMenuPrivate]

  TRecentChooserWidgetClass* = object
    parent_class*: TBoxClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  RecentChooserWidgetClass* = ref GSmartPtr[TRecentChooserWidgetClass]

  TRecentChooserWidgetPrivate* = object
  RecentChooserWidgetPrivate* = ref GSmartPtr[TRecentChooserWidgetPrivate]

  TRecentData* = object
    display_name*: ucstring
    description*: ucstring
    mime_type*: ucstring
    app_name*: ucstring
    app_exec*: ucstring
    groups*: ptr zeroTerminatedArray[ucstring]
    is_private*: bool
  RecentData* = ref GSmartPtr[TRecentData]

  TRecentFilterInfo* = object
    contains*: SRecentFilterFlags
    uri*: ucstring
    display_name*: ucstring
    mime_type*: ucstring
    applications*: ptr zeroTerminatedArray[ucstring]
    groups*: ptr zeroTerminatedArray[ucstring]
    age*: int32
  RecentFilterInfo* = ref GSmartPtr[TRecentFilterInfo]

  TRecentInfo* = object
  RecentInfo* = ref GSmartPtr[TRecentInfo]

  TRecentManagerClass* = object
    parent_class*: GObject2.TObjectClass
    changed*: pointer
    x_gtk_recent1*: pointer
    x_gtk_recent2*: pointer
    x_gtk_recent3*: pointer
    x_gtk_recent4*: pointer
  RecentManagerClass* = ref GSmartPtr[TRecentManagerClass]

  TRecentManagerPrivate* = object
  RecentManagerPrivate* = ref GSmartPtr[TRecentManagerPrivate]

  TRendererCellAccessibleClass* = object
    parent_class*: TCellAccessibleClass
  RendererCellAccessibleClass* = ref GSmartPtr[TRendererCellAccessibleClass]

  TRendererCellAccessiblePrivate* = object
  RendererCellAccessiblePrivate* = ref GSmartPtr[TRendererCellAccessiblePrivate]

  TRequestedSize* = object
    data*: pointer
    minimum_size*: int32
    natural_size*: int32
  RequestedSize* = ref GSmartPtr[TRequestedSize]

  TRequisition* = object
    width*: int32
    height*: int32
  Requisition* = ref GSmartPtr[TRequisition]

  TRevealerClass* = object
    parent_class*: TBinClass
  RevealerClass* = ref GSmartPtr[TRevealerClass]

  TScaleAccessibleClass* = object
    parent_class*: TRangeAccessibleClass
  ScaleAccessibleClass* = ref GSmartPtr[TScaleAccessibleClass]

  TScaleAccessiblePrivate* = object
  ScaleAccessiblePrivate* = ref GSmartPtr[TScaleAccessiblePrivate]

  TScaleButtonAccessibleClass* = object
    parent_class*: TButtonAccessibleClass
  ScaleButtonAccessibleClass* = ref GSmartPtr[TScaleButtonAccessibleClass]

  TScaleButtonAccessiblePrivate* = object
  ScaleButtonAccessiblePrivate* = ref GSmartPtr[TScaleButtonAccessiblePrivate]

  TScaleButtonClass* = object
    parent_class*: TButtonClass
    value_changed*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ScaleButtonClass* = ref GSmartPtr[TScaleButtonClass]

  TScaleButtonPrivate* = object
  ScaleButtonPrivate* = ref GSmartPtr[TScaleButtonPrivate]

  TScaleClass* = object
    parent_class*: TRangeClass
    format_value*: pointer
    draw_value*: pointer
    get_layout_offsets*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ScaleClass* = ref GSmartPtr[TScaleClass]

  TScalePrivate* = object
  ScalePrivate* = ref GSmartPtr[TScalePrivate]

  TScrollableInterface* = object
    base_iface*: GObject2.TTypeInterface
  ScrollableInterface* = ref GSmartPtr[TScrollableInterface]

  TScrollbarClass* = object
    parent_class*: TRangeClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ScrollbarClass* = ref GSmartPtr[TScrollbarClass]

  TScrolledWindowAccessibleClass* = object
    parent_class*: TContainerAccessibleClass
  ScrolledWindowAccessibleClass* = ref GSmartPtr[TScrolledWindowAccessibleClass]

  TScrolledWindowAccessiblePrivate* = object
  ScrolledWindowAccessiblePrivate* = ref GSmartPtr[TScrolledWindowAccessiblePrivate]

  TScrolledWindowClass* = object
    parent_class*: TBinClass
    scrollbar_spacing*: int32
    scroll_child*: pointer
    move_focus_out*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ScrolledWindowClass* = ref GSmartPtr[TScrolledWindowClass]

  TScrolledWindowPrivate* = object
  ScrolledWindowPrivate* = ref GSmartPtr[TScrolledWindowPrivate]

  TSearchBarClass* = object
    parent_class*: TBinClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  SearchBarClass* = ref GSmartPtr[TSearchBarClass]

  TSearchEntryClass* = object
    parent_class*: TEntryClass
    search_changed*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
  SearchEntryClass* = ref GSmartPtr[TSearchEntryClass]

  TSelectionData* = object
  SelectionData* = ref GSmartPtr[TSelectionData]

  TSeparatorClass* = object
    parent_class*: TWidgetClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  SeparatorClass* = ref GSmartPtr[TSeparatorClass]

  TSeparatorMenuItemClass* = object
    parent_class*: TMenuItemClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  SeparatorMenuItemClass* = ref GSmartPtr[TSeparatorMenuItemClass]

  TSeparatorPrivate* = object
  SeparatorPrivate* = ref GSmartPtr[TSeparatorPrivate]

  TSeparatorToolItemClass* = object
    parent_class*: TToolItemClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  SeparatorToolItemClass* = ref GSmartPtr[TSeparatorToolItemClass]

  TSeparatorToolItemPrivate* = object
  SeparatorToolItemPrivate* = ref GSmartPtr[TSeparatorToolItemPrivate]

  TSettingsClass* = object
    parent_class*: GObject2.TObjectClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  SettingsClass* = ref GSmartPtr[TSettingsClass]

  TSettingsPrivate* = object
  SettingsPrivate* = ref GSmartPtr[TSettingsPrivate]

  TSettingsValue* = object
    origin*: ucstring
    value*: GObject2.TValue
  SettingsValue* = ref GSmartPtr[TSettingsValue]

  TSizeGroupClass* = object
    parent_class*: GObject2.TObjectClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  SizeGroupClass* = ref GSmartPtr[TSizeGroupClass]

  TSizeGroupPrivate* = object
  SizeGroupPrivate* = ref GSmartPtr[TSizeGroupPrivate]

  TSpinButtonAccessibleClass* = object
    parent_class*: TEntryAccessibleClass
  SpinButtonAccessibleClass* = ref GSmartPtr[TSpinButtonAccessibleClass]

  TSpinButtonAccessiblePrivate* = object
  SpinButtonAccessiblePrivate* = ref GSmartPtr[TSpinButtonAccessiblePrivate]

  TSpinButtonClass* = object
    parent_class*: TEntryClass
    input*: pointer
    output*: pointer
    value_changed*: pointer
    change_value*: pointer
    wrapped*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  SpinButtonClass* = ref GSmartPtr[TSpinButtonClass]

  TSpinButtonPrivate* = object
  SpinButtonPrivate* = ref GSmartPtr[TSpinButtonPrivate]

  TSpinnerAccessibleClass* = object
    parent_class*: TWidgetAccessibleClass
  SpinnerAccessibleClass* = ref GSmartPtr[TSpinnerAccessibleClass]

  TSpinnerAccessiblePrivate* = object
  SpinnerAccessiblePrivate* = ref GSmartPtr[TSpinnerAccessiblePrivate]

  TSpinnerClass* = object
    parent_class*: TWidgetClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  SpinnerClass* = ref GSmartPtr[TSpinnerClass]

  TSpinnerPrivate* = object
  SpinnerPrivate* = ref GSmartPtr[TSpinnerPrivate]

  TStackClass* = object
    parent_class*: TContainerClass
  StackClass* = ref GSmartPtr[TStackClass]

  TStackSwitcherClass* = object
    parent_class*: TBoxClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  StackSwitcherClass* = ref GSmartPtr[TStackSwitcherClass]

  TStatusIconClass* = object
    parent_class*: GObject2.TObjectClass
    activate*: pointer
    popup_menu*: pointer
    size_changed*: pointer
    button_press_event*: pointer
    button_release_event*: pointer
    scroll_event*: pointer
    query_tooltip*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  StatusIconClass* = ref GSmartPtr[TStatusIconClass]

  TStatusIconPrivate* = object
  StatusIconPrivate* = ref GSmartPtr[TStatusIconPrivate]

  TStatusbarAccessibleClass* = object
    parent_class*: TContainerAccessibleClass
  StatusbarAccessibleClass* = ref GSmartPtr[TStatusbarAccessibleClass]

  TStatusbarAccessiblePrivate* = object
  StatusbarAccessiblePrivate* = ref GSmartPtr[TStatusbarAccessiblePrivate]

  TStatusbarClass* = object
    parent_class*: TBoxClass
    reserved*: pointer
    text_pushed*: pointer
    text_popped*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  StatusbarClass* = ref GSmartPtr[TStatusbarClass]

  TStatusbarPrivate* = object
  StatusbarPrivate* = ref GSmartPtr[TStatusbarPrivate]

  TStockItem* = object
    stock_id*: ucstring
    label*: ucstring
    modifier*: Gdk3.SModifierType
    keyval*: uint32
    translation_domain*: ucstring
  StockItem* = ref GSmartPtr[TStockItem]

  TStyleClass* = object
    parent_class*: GObject2.TObjectClass
    realize*: pointer
    unrealize*: pointer
    copy*: pointer
    clone*: pointer
    init_from_rc*: pointer
    set_background*: pointer
    render_icon*: pointer
    draw_hline*: pointer
    draw_vline*: pointer
    draw_shadow*: pointer
    draw_arrow*: pointer
    draw_diamond*: pointer
    draw_box*: pointer
    draw_flat_box*: pointer
    draw_check*: pointer
    draw_option*: pointer
    draw_tab*: pointer
    draw_shadow_gap*: pointer
    draw_box_gap*: pointer
    draw_extension*: pointer
    draw_focus*: pointer
    draw_slider*: pointer
    draw_handle*: pointer
    draw_expander*: pointer
    draw_layout*: pointer
    draw_resize_grip*: pointer
    draw_spinner*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
    x_gtk_reserved5*: pointer
    x_gtk_reserved6*: pointer
    x_gtk_reserved7*: pointer
    x_gtk_reserved8*: pointer
    x_gtk_reserved9*: pointer
    x_gtk_reserved10*: pointer
    x_gtk_reserved11*: pointer
  StyleClass* = ref GSmartPtr[TStyleClass]

  TStyleContextClass* = object
    parent_class*: GObject2.TObjectClass
    changed*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  StyleContextClass* = ref GSmartPtr[TStyleContextClass]

  TStyleContextPrivate* = object
  StyleContextPrivate* = ref GSmartPtr[TStyleContextPrivate]

  TStylePropertiesClass* = object
    parent_class*: GObject2.TObjectClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  StylePropertiesClass* = ref GSmartPtr[TStylePropertiesClass]

  TStylePropertiesPrivate* = object
  StylePropertiesPrivate* = ref GSmartPtr[TStylePropertiesPrivate]

  TStyleProviderIface* = object
    g_iface*: GObject2.TTypeInterface
    get_style*: pointer
    get_style_property*: pointer
    get_icon_factory*: pointer
  StyleProviderIface* = ref GSmartPtr[TStyleProviderIface]

  TSwitchAccessibleClass* = object
    parent_class*: TWidgetAccessibleClass
  SwitchAccessibleClass* = ref GSmartPtr[TSwitchAccessibleClass]

  TSwitchAccessiblePrivate* = object
  SwitchAccessiblePrivate* = ref GSmartPtr[TSwitchAccessiblePrivate]

  TSwitchClass* = object
    parent_class*: TWidgetClass
    activate*: pointer
    state_set*: pointer
    x_switch_padding_1*: pointer
    x_switch_padding_2*: pointer
    x_switch_padding_3*: pointer
    x_switch_padding_4*: pointer
    x_switch_padding_5*: pointer
  SwitchClass* = ref GSmartPtr[TSwitchClass]

  TSwitchPrivate* = object
  SwitchPrivate* = ref GSmartPtr[TSwitchPrivate]

  TSymbolicColor* = object
  SymbolicColor* = ref GSmartPtr[TSymbolicColor]

  TTableChild* = object
    widget*: ptr TWidget
    left_attach*: uint16
    right_attach*: uint16
    top_attach*: uint16
    bottom_attach*: uint16
    xpadding*: uint16
    ypadding*: uint16
    xexpand*: uint32
    yexpand*: uint32
    xshrink*: uint32
    yshrink*: uint32
    xfill*: uint32
    yfill*: uint32
  TableChild* = ref GSmartPtr[TTableChild]

  TTableClass* = object
    parent_class*: TContainerClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  TableClass* = ref GSmartPtr[TTableClass]

  TTablePrivate* = object
  TablePrivate* = ref GSmartPtr[TTablePrivate]

  TTableRowCol* = object
    requisition*: uint16
    allocation*: uint16
    spacing*: uint16
    need_expand*: uint32
    need_shrink*: uint32
    expand*: uint32
    shrink*: uint32
    empty*: uint32
  TableRowCol* = ref GSmartPtr[TTableRowCol]

  TTargetEntry* = object
    target*: ucstring
    flags*: uint32
    info*: uint32
  TargetEntry* = ref GSmartPtr[TTargetEntry]

  TTargetList* = object
  TargetList* = ref GSmartPtr[TTargetList]

  TTargetPair* = object
    target*: ptr Gdk3.TAtom
    flags*: uint32
    info*: uint32
  TargetPair* = ref GSmartPtr[TTargetPair]

  TTearoffMenuItemClass* = object
    parent_class*: TMenuItemClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  TearoffMenuItemClass* = ref GSmartPtr[TTearoffMenuItemClass]

  TTearoffMenuItemPrivate* = object
  TearoffMenuItemPrivate* = ref GSmartPtr[TTearoffMenuItemPrivate]

  TTextAppearance* = object
    bg_color*: Gdk3.TColor
    fg_color*: Gdk3.TColor
    rise*: int32
    underline*: uint32
    strikethrough*: uint32
    draw_bg*: uint32
    inside_selection*: uint32
    is_text*: uint32
  TextAppearance* = ref GSmartPtr[TTextAppearance]

  TTextAttributes* = object
    refcount*: uint32
    appearance*: TTextAppearance
    justification*: Justification
    direction*: TextDirection
    font*: ptr Pango1.TFontDescription
    font_scale*: float64
    left_margin*: int32
    right_margin*: int32
    indent*: int32
    pixels_above_lines*: int32
    pixels_below_lines*: int32
    pixels_inside_wrap*: int32
    tabs*: ptr Pango1.TTabArray
    wrap_mode*: WrapMode
    language*: ptr Pango1.TLanguage
    pg_bg_color*: ptr Gdk3.TColor
    invisible*: uint32
    bg_full_height*: uint32
    editable*: uint32
    pg_bg_rgba*: ptr Gdk3.TRGBA
    padding*: array[3, uint32]
  TextAttributes* = ref GSmartPtr[TTextAttributes]

  TTextBTree* = object
  TextBTree* = ref GSmartPtr[TTextBTree]

  TTextBufferClass* = object
    parent_class*: GObject2.TObjectClass
    insert_text*: pointer
    insert_pixbuf*: pointer
    insert_child_anchor*: pointer
    delete_range*: pointer
    changed*: pointer
    modified_changed*: pointer
    mark_set*: pointer
    mark_deleted*: pointer
    apply_tag*: pointer
    remove_tag*: pointer
    begin_user_action*: pointer
    end_user_action*: pointer
    paste_done*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  TextBufferClass* = ref GSmartPtr[TTextBufferClass]

  TTextBufferPrivate* = object
  TextBufferPrivate* = ref GSmartPtr[TTextBufferPrivate]

  TTextCellAccessibleClass* = object
    parent_class*: TRendererCellAccessibleClass
  TextCellAccessibleClass* = ref GSmartPtr[TTextCellAccessibleClass]

  TTextCellAccessiblePrivate* = object
  TextCellAccessiblePrivate* = ref GSmartPtr[TTextCellAccessiblePrivate]

  TTextChildAnchorClass* = object
    parent_class*: GObject2.TObjectClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  TextChildAnchorClass* = ref GSmartPtr[TTextChildAnchorClass]

  TTextIter* = object
    dummy1*: pointer
    dummy2*: pointer
    dummy3*: int32
    dummy4*: int32
    dummy5*: int32
    dummy6*: int32
    dummy7*: int32
    dummy8*: int32
    dummy9*: pointer
    dummy10*: pointer
    dummy11*: int32
    dummy12*: int32
    dummy13*: int32
    dummy14*: pointer
  TextIter* = ref GSmartPtr[TTextIter]

  TTextMarkClass* = object
    parent_class*: GObject2.TObjectClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  TextMarkClass* = ref GSmartPtr[TTextMarkClass]

  TTextTagClass* = object
    parent_class*: GObject2.TObjectClass
    event*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  TextTagClass* = ref GSmartPtr[TTextTagClass]

  TTextTagPrivate* = object
  TextTagPrivate* = ref GSmartPtr[TTextTagPrivate]

  TTextTagTableClass* = object
    parent_class*: GObject2.TObjectClass
    tag_changed*: pointer
    tag_added*: pointer
    tag_removed*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  TextTagTableClass* = ref GSmartPtr[TTextTagTableClass]

  TTextTagTablePrivate* = object
  TextTagTablePrivate* = ref GSmartPtr[TTextTagTablePrivate]

  TTextViewAccessibleClass* = object
    parent_class*: TContainerAccessibleClass
  TextViewAccessibleClass* = ref GSmartPtr[TTextViewAccessibleClass]

  TTextViewAccessiblePrivate* = object
  TextViewAccessiblePrivate* = ref GSmartPtr[TTextViewAccessiblePrivate]

  TTextViewClass* = object
    parent_class*: TContainerClass
    populate_popup*: pointer
    move_cursor*: pointer
    set_anchor*: pointer
    insert_at_cursor*: pointer
    delete_from_cursor*: pointer
    backspace*: pointer
    cut_clipboard*: pointer
    copy_clipboard*: pointer
    paste_clipboard*: pointer
    toggle_overwrite*: pointer
    create_buffer*: pointer
    draw_layer*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
    x_gtk_reserved5*: pointer
    x_gtk_reserved6*: pointer
  TextViewClass* = ref GSmartPtr[TTextViewClass]

  TTextViewPrivate* = object
  TextViewPrivate* = ref GSmartPtr[TTextViewPrivate]

  TThemeEngine* = object
  ThemeEngine* = ref GSmartPtr[TThemeEngine]

  TThemingEngineClass* = object
    parent_class*: GObject2.TObjectClass
    render_line*: pointer
    render_background*: pointer
    render_frame*: pointer
    render_frame_gap*: pointer
    render_extension*: pointer
    render_check*: pointer
    render_option*: pointer
    render_arrow*: pointer
    render_expander*: pointer
    render_focus*: pointer
    render_layout*: pointer
    render_slider*: pointer
    render_handle*: pointer
    render_activity*: pointer
    render_icon_pixbuf*: pointer
    render_icon*: pointer
    render_icon_surface*: pointer
    padding*: array[14, pointer]
  ThemingEngineClass* = ref GSmartPtr[TThemingEngineClass]

  TThemingEnginePrivate* = object
  ThemingEnginePrivate* = ref GSmartPtr[TThemingEnginePrivate]

  TToggleActionClass* = object
    parent_class*: TActionClass
    toggled*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ToggleActionClass* = ref GSmartPtr[TToggleActionClass]

  TToggleActionEntry* = object
    name*: ucstring
    stock_id*: ucstring
    label*: ucstring
    accelerator*: ucstring
    tooltip*: ucstring
    callback*: pointer
    is_active*: bool
  ToggleActionEntry* = ref GSmartPtr[TToggleActionEntry]

  TToggleActionPrivate* = object
  ToggleActionPrivate* = ref GSmartPtr[TToggleActionPrivate]

  TToggleButtonAccessibleClass* = object
    parent_class*: TButtonAccessibleClass
  ToggleButtonAccessibleClass* = ref GSmartPtr[TToggleButtonAccessibleClass]

  TToggleButtonAccessiblePrivate* = object
  ToggleButtonAccessiblePrivate* = ref GSmartPtr[TToggleButtonAccessiblePrivate]

  TToggleButtonClass* = object
    parent_class*: TButtonClass
    toggled*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ToggleButtonClass* = ref GSmartPtr[TToggleButtonClass]

  TToggleButtonPrivate* = object
  ToggleButtonPrivate* = ref GSmartPtr[TToggleButtonPrivate]

  TToggleToolButtonClass* = object
    parent_class*: TToolButtonClass
    toggled*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ToggleToolButtonClass* = ref GSmartPtr[TToggleToolButtonClass]

  TToggleToolButtonPrivate* = object
  ToggleToolButtonPrivate* = ref GSmartPtr[TToggleToolButtonPrivate]

  TToolButtonClass* = object
    parent_class*: TToolItemClass
    button_type*: GType
    clicked*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ToolButtonClass* = ref GSmartPtr[TToolButtonClass]

  TToolButtonPrivate* = object
  ToolButtonPrivate* = ref GSmartPtr[TToolButtonPrivate]

  TToolItemClass* = object
    parent_class*: TBinClass
    create_menu_proxy*: pointer
    toolbar_reconfigured*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ToolItemClass* = ref GSmartPtr[TToolItemClass]

  TToolItemGroupClass* = object
    parent_class*: TContainerClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ToolItemGroupClass* = ref GSmartPtr[TToolItemGroupClass]

  TToolItemGroupPrivate* = object
  ToolItemGroupPrivate* = ref GSmartPtr[TToolItemGroupPrivate]

  TToolItemPrivate* = object
  ToolItemPrivate* = ref GSmartPtr[TToolItemPrivate]

  TToolPaletteClass* = object
    parent_class*: TContainerClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ToolPaletteClass* = ref GSmartPtr[TToolPaletteClass]

  TToolPalettePrivate* = object
  ToolPalettePrivate* = ref GSmartPtr[TToolPalettePrivate]

  TToolShellIface* = object
    g_iface*: GObject2.TTypeInterface
    get_icon_size*: pointer
    get_orientation*: pointer
    get_style*: pointer
    get_relief_style*: pointer
    rebuild_menu*: pointer
    get_text_orientation*: pointer
    get_text_alignment*: pointer
    get_ellipsize_mode*: pointer
    get_text_size_group*: pointer
  ToolShellIface* = ref GSmartPtr[TToolShellIface]

  TToolbarClass* = object
    parent_class*: TContainerClass
    orientation_changed*: pointer
    style_changed*: pointer
    popup_context_menu*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ToolbarClass* = ref GSmartPtr[TToolbarClass]

  TToolbarPrivate* = object
  ToolbarPrivate* = ref GSmartPtr[TToolbarPrivate]

  TToplevelAccessibleClass* = object
    parent_class*: Atk1.TObjectClass
  ToplevelAccessibleClass* = ref GSmartPtr[TToplevelAccessibleClass]

  TToplevelAccessiblePrivate* = object
  ToplevelAccessiblePrivate* = ref GSmartPtr[TToplevelAccessiblePrivate]

  TTreeDragDestIface* = object
    g_iface*: GObject2.TTypeInterface
    drag_data_received*: pointer
    row_drop_possible*: pointer
  TreeDragDestIface* = ref GSmartPtr[TTreeDragDestIface]

  TTreeDragSourceIface* = object
    g_iface*: GObject2.TTypeInterface
    row_draggable*: pointer
    drag_data_get*: pointer
    drag_data_delete*: pointer
  TreeDragSourceIface* = ref GSmartPtr[TTreeDragSourceIface]

  TTreeIter* = object
    stamp*: int32
    user_data*: pointer
    user_data2*: pointer
    user_data3*: pointer
  TreeIter* = ref GSmartPtr[TTreeIter]

  TTreeModelFilterClass* = object
    parent_class*: GObject2.TObjectClass
    visible*: pointer
    modify*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  TreeModelFilterClass* = ref GSmartPtr[TTreeModelFilterClass]

  TTreeModelFilterPrivate* = object
  TreeModelFilterPrivate* = ref GSmartPtr[TTreeModelFilterPrivate]

  TTreeModelIface* = object
    g_iface*: GObject2.TTypeInterface
    row_changed*: pointer
    row_inserted*: pointer
    row_has_child_toggled*: pointer
    row_deleted*: pointer
    rows_reordered*: pointer
    get_flags*: pointer
    get_n_columns*: pointer
    get_column_type*: pointer
    get_iter*: pointer
    get_path*: pointer
    get_value*: pointer
    iter_next*: pointer
    iter_previous*: pointer
    iter_children*: pointer
    iter_has_child*: pointer
    iter_n_children*: pointer
    iter_nth_child*: pointer
    iter_parent*: pointer
    ref_node*: pointer
    unref_node*: pointer
  TreeModelIface* = ref GSmartPtr[TTreeModelIface]

  TTreeModelSortClass* = object
    parent_class*: GObject2.TObjectClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  TreeModelSortClass* = ref GSmartPtr[TTreeModelSortClass]

  TTreeModelSortPrivate* = object
  TreeModelSortPrivate* = ref GSmartPtr[TTreeModelSortPrivate]

  TTreePath* = object
  TreePath* = ref GSmartPtr[TTreePath]

  TTreeRowReference* = object
  TreeRowReference* = ref GSmartPtr[TTreeRowReference]

  TTreeSelectionClass* = object
    parent_class*: GObject2.TObjectClass
    changed*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  TreeSelectionClass* = ref GSmartPtr[TTreeSelectionClass]

  TTreeSelectionPrivate* = object
  TreeSelectionPrivate* = ref GSmartPtr[TTreeSelectionPrivate]

  TTreeSortableIface* = object
    g_iface*: GObject2.TTypeInterface
    sort_column_changed*: pointer
    get_sort_column_id*: pointer
    set_sort_column_id*: pointer
    set_sort_func*: pointer
    set_default_sort_func*: pointer
    has_default_sort_func*: pointer
  TreeSortableIface* = ref GSmartPtr[TTreeSortableIface]

  TTreeStoreClass* = object
    parent_class*: GObject2.TObjectClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  TreeStoreClass* = ref GSmartPtr[TTreeStoreClass]

  TTreeStorePrivate* = object
  TreeStorePrivate* = ref GSmartPtr[TTreeStorePrivate]

  TTreeViewAccessibleClass* = object
    parent_class*: TContainerAccessibleClass
  TreeViewAccessibleClass* = ref GSmartPtr[TTreeViewAccessibleClass]

  TTreeViewAccessiblePrivate* = object
  TreeViewAccessiblePrivate* = ref GSmartPtr[TTreeViewAccessiblePrivate]

  TTreeViewClass* = object
    parent_class*: TContainerClass
    row_activated*: pointer
    test_expand_row*: pointer
    test_collapse_row*: pointer
    row_expanded*: pointer
    row_collapsed*: pointer
    columns_changed*: pointer
    cursor_changed*: pointer
    move_cursor*: pointer
    select_all*: pointer
    unselect_all*: pointer
    select_cursor_row*: pointer
    toggle_cursor_row*: pointer
    expand_collapse_cursor_row*: pointer
    select_cursor_parent*: pointer
    start_interactive_search*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
    x_gtk_reserved5*: pointer
    x_gtk_reserved6*: pointer
    x_gtk_reserved7*: pointer
    x_gtk_reserved8*: pointer
  TreeViewClass* = ref GSmartPtr[TTreeViewClass]

  TTreeViewColumnClass* = object
    parent_class*: GObject2.TInitiallyUnownedClass
    clicked*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  TreeViewColumnClass* = ref GSmartPtr[TTreeViewColumnClass]

  TTreeViewColumnPrivate* = object
  TreeViewColumnPrivate* = ref GSmartPtr[TTreeViewColumnPrivate]

  TTreeViewPrivate* = object
  TreeViewPrivate* = ref GSmartPtr[TTreeViewPrivate]

  TUIManagerClass* = object
    parent_class*: GObject2.TObjectClass
    add_widget*: pointer
    actions_changed*: pointer
    connect_proxy*: pointer
    disconnect_proxy*: pointer
    pre_activate*: pointer
    post_activate*: pointer
    get_widget*: pointer
    get_action*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  UIManagerClass* = ref GSmartPtr[TUIManagerClass]

  TUIManagerPrivate* = object
  UIManagerPrivate* = ref GSmartPtr[TUIManagerPrivate]

  TVBoxClass* = object
    parent_class*: TBoxClass
  VBoxClass* = ref GSmartPtr[TVBoxClass]

  TVButtonBoxClass* = object
    parent_class*: TButtonBoxClass
  VButtonBoxClass* = ref GSmartPtr[TVButtonBoxClass]

  TVPanedClass* = object
    parent_class*: TPanedClass
  VPanedClass* = ref GSmartPtr[TVPanedClass]

  TVScaleClass* = object
    parent_class*: TScaleClass
  VScaleClass* = ref GSmartPtr[TVScaleClass]

  TVScrollbarClass* = object
    parent_class*: TScrollbarClass
  VScrollbarClass* = ref GSmartPtr[TVScrollbarClass]

  TVSeparatorClass* = object
    parent_class*: TSeparatorClass
  VSeparatorClass* = ref GSmartPtr[TVSeparatorClass]

  TViewportClass* = object
    parent_class*: TBinClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  ViewportClass* = ref GSmartPtr[TViewportClass]

  TViewportPrivate* = object
  ViewportPrivate* = ref GSmartPtr[TViewportPrivate]

  TVolumeButtonClass* = object
    parent_class*: TScaleButtonClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  VolumeButtonClass* = ref GSmartPtr[TVolumeButtonClass]

  TWidgetAccessibleClass* = object
    parent_class*: TAccessibleClass
    notify_gtk*: pointer
  WidgetAccessibleClass* = ref GSmartPtr[TWidgetAccessibleClass]

  TWidgetAccessiblePrivate* = object
  WidgetAccessiblePrivate* = ref GSmartPtr[TWidgetAccessiblePrivate]

  TWidgetAuxInfo* = object
    width*: int32
    height*: int32
    halign*: uint32
    valign*: uint32
    margin*: TBorder
  WidgetAuxInfo* = ref GSmartPtr[TWidgetAuxInfo]

  TWidgetClass* = object
    parent_class*: GObject2.TInitiallyUnownedClass
    activate_signal*: uint32
    dispatch_child_properties_changed*: pointer
    destroy*: pointer
    show*: pointer
    show_all*: pointer
    hide*: pointer
    map*: pointer
    unmap*: pointer
    realize*: pointer
    unrealize*: pointer
    size_allocate*: pointer
    state_changed*: pointer
    state_flags_changed*: pointer
    parent_set*: pointer
    hierarchy_changed*: pointer
    style_set*: pointer
    direction_changed*: pointer
    grab_notify*: pointer
    child_notify*: pointer
    draw*: pointer
    get_request_mode*: pointer
    get_preferred_height*: pointer
    get_preferred_width_for_height*: pointer
    get_preferred_width*: pointer
    get_preferred_height_for_width*: pointer
    mnemonic_activate*: pointer
    grab_focus*: pointer
    focus*: pointer
    move_focus*: pointer
    keynav_failed*: pointer
    event*: pointer
    button_press_event*: pointer
    button_release_event*: pointer
    scroll_event*: pointer
    motion_notify_event*: pointer
    delete_event*: pointer
    destroy_event*: pointer
    key_press_event*: pointer
    key_release_event*: pointer
    enter_notify_event*: pointer
    leave_notify_event*: pointer
    configure_event*: pointer
    focus_in_event*: pointer
    focus_out_event*: pointer
    map_event*: pointer
    unmap_event*: pointer
    property_notify_event*: pointer
    selection_clear_event*: pointer
    selection_request_event*: pointer
    selection_notify_event*: pointer
    proximity_in_event*: pointer
    proximity_out_event*: pointer
    visibility_notify_event*: pointer
    window_state_event*: pointer
    damage_event*: pointer
    grab_broken_event*: pointer
    selection_get*: pointer
    selection_received*: pointer
    drag_begin*: pointer
    drag_end*: pointer
    drag_data_get*: pointer
    drag_data_delete*: pointer
    drag_leave*: pointer
    drag_motion*: pointer
    drag_drop*: pointer
    drag_data_received*: pointer
    drag_failed*: pointer
    popup_menu*: pointer
    show_help*: pointer
    get_accessible*: pointer
    screen_changed*: pointer
    can_activate_accel*: pointer
    composited_changed*: pointer
    query_tooltip*: pointer
    compute_expand*: pointer
    adjust_size_request*: pointer
    adjust_size_allocation*: pointer
    style_updated*: pointer
    touch_event*: pointer
    get_preferred_height_and_baseline_for_width*: pointer
    adjust_baseline_request*: pointer
    adjust_baseline_allocation*: pointer
    queue_draw_region*: pointer
    priv*: ptr TWidgetClassPrivate
    x_gtk_reserved6*: pointer
    x_gtk_reserved7*: pointer
  WidgetClass* = ref GSmartPtr[TWidgetClass]

  TWidgetClassPrivate* = object
  WidgetClassPrivate* = ref GSmartPtr[TWidgetClassPrivate]

  TWidgetPath* = object
  WidgetPath* = ref GSmartPtr[TWidgetPath]

  TWidgetPrivate* = object
  WidgetPrivate* = ref GSmartPtr[TWidgetPrivate]

  TWindowAccessibleClass* = object
    parent_class*: TContainerAccessibleClass
  WindowAccessibleClass* = ref GSmartPtr[TWindowAccessibleClass]

  TWindowAccessiblePrivate* = object
  WindowAccessiblePrivate* = ref GSmartPtr[TWindowAccessiblePrivate]

  TWindowClass* = object
    parent_class*: TBinClass
    set_focus*: pointer
    activate_focus*: pointer
    activate_default*: pointer
    keys_changed*: pointer
    enable_debugging*: pointer
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
  WindowClass* = ref GSmartPtr[TWindowClass]

  TWindowGeometryInfo* = object
  WindowGeometryInfo* = ref GSmartPtr[TWindowGeometryInfo]

  TWindowGroupClass* = object
    parent_class*: GObject2.TObjectClass
    x_gtk_reserved1*: pointer
    x_gtk_reserved2*: pointer
    x_gtk_reserved3*: pointer
    x_gtk_reserved4*: pointer
  WindowGroupClass* = ref GSmartPtr[TWindowGroupClass]

  TWindowGroupPrivate* = object
  WindowGroupPrivate* = ref GSmartPtr[TWindowGroupPrivate]

  TWindowPrivate* = object
  WindowPrivate* = ref GSmartPtr[TWindowPrivate]

  # unions
  #------------------
  # interfaces
  #------------------
  TActionable* = object
    discard
  Actionable* = ref GSmartPtr[TActionable]

  TActivatable* = object
    discard
  Activatable* = ref GSmartPtr[TActivatable]

  TAppChooser* = object
    discard
  AppChooser* = ref GSmartPtr[TAppChooser]

  TBuildable* = object
    discard
  Buildable* = ref GSmartPtr[TBuildable]

  TCellAccessibleParent* = object
    discard
  CellAccessibleParent* = ref GSmartPtr[TCellAccessibleParent]

  TCellEditable* = object
    discard
  CellEditable* = ref GSmartPtr[TCellEditable]

  TCellLayout* = object
    discard
  CellLayout* = ref GSmartPtr[TCellLayout]

  TColorChooser* = object
    discard
  ColorChooser* = ref GSmartPtr[TColorChooser]

  TEditable* = object
    discard
  Editable* = ref GSmartPtr[TEditable]

  TFileChooser* = object
    discard
  FileChooser* = ref GSmartPtr[TFileChooser]

  TFontChooser* = object
    discard
  FontChooser* = ref GSmartPtr[TFontChooser]

  TOrientable* = object
    discard
  Orientable* = ref GSmartPtr[TOrientable]

  TPrintOperationPreview* = object
    discard
  PrintOperationPreview* = ref GSmartPtr[TPrintOperationPreview]

  TRecentChooser* = object
    discard
  RecentChooser* = ref GSmartPtr[TRecentChooser]

  TScrollable* = object
    discard
  Scrollable* = ref GSmartPtr[TScrollable]

  TStyleProvider* = object
    discard
  StyleProvider* = ref GSmartPtr[TStyleProvider]

  TToolShell* = object
    discard
  ToolShell* = ref GSmartPtr[TToolShell]

  TTreeDragDest* = object
    discard
  TreeDragDest* = ref GSmartPtr[TTreeDragDest]

  TTreeDragSource* = object
    discard
  TreeDragSource* = ref GSmartPtr[TTreeDragSource]

  TTreeModel* = object
    discard
  TreeModel* = ref GSmartPtr[TTreeModel]

  TTreeSortable* = object
    discard
  TreeSortable* = ref GSmartPtr[TTreeSortable]

  # enums
  #------------------
  # flags
  SAccelFlags* = uint32
  AccelFlags* {.pure,size: sizeof(uint32).} = enum
    visible = 1,
    locked = 2,
    mask = 7,


  Align* {.pure,size: sizeof(uint32).} = enum
    fill,
    start,
    `end`,
    center,
    baseline,


  # flags
  SApplicationInhibitFlags* = uint32
  ApplicationInhibitFlags* {.pure,size: sizeof(uint32).} = enum
    logout = 1,
    switch = 2,
    suspend = 4,
    idle = 8,


  ArrowPlacement* {.pure,size: sizeof(uint32).} = enum
    both,
    start,
    `end`,


  ArrowType* {.pure,size: sizeof(uint32).} = enum
    up,
    down,
    left,
    right,
    none,


  AssistantPageType* {.pure,size: sizeof(uint32).} = enum
    content,
    intro,
    confirm,
    summary,
    progress,
    custom,


  # flags
  SAttachOptions* = uint32
  AttachOptions* {.pure,size: sizeof(uint32).} = enum
    expand = 1,
    shrink = 2,
    fill = 4,


  BaselinePosition* {.pure,size: sizeof(uint32).} = enum
    top,
    center,
    bottom,


  BorderStyle* {.pure,size: sizeof(uint32).} = enum
    none,
    solid,
    inset,
    outset,
    hidden,
    dotted,
    dashed,
    double,
    groove,
    ridge,


  BuilderError* {.pure,size: sizeof(uint32).} = enum
    invalid_type_function,
    unhandled_tag,
    missing_attribute,
    invalid_attribute,
    invalid_tag,
    missing_property_value,
    invalid_value,
    version_mismatch,
    duplicate_id,
    object_type_refused,
    template_mismatch,
    invalid_property,
    invalid_signal,


  ButtonBoxStyle* {.pure,size: sizeof(uint32).} = enum
    spread = 1,
    edge,
    start,
    `end`,
    center,
    expand,


  ButtonsType* {.pure,size: sizeof(uint32).} = enum
    none,
    ok,
    close,
    cancel,
    yes_no,
    ok_cancel,


  # flags
  SCalendarDisplayOptions* = uint32
  CalendarDisplayOptions* {.pure,size: sizeof(uint32).} = enum
    show_heading = 1,
    show_day_names = 2,
    no_month_change = 4,
    show_week_numbers = 8,
    show_details = 32,


  CellRendererAccelMode* {.pure,size: sizeof(uint32).} = enum
    gtk,
    other,


  CellRendererMode* {.pure,size: sizeof(uint32).} = enum
    inert,
    activatable,
    editable,


  # flags
  SCellRendererState* = uint32
  CellRendererState* {.pure,size: sizeof(uint32).} = enum
    selected = 1,
    prelit = 2,
    insensitive = 4,
    sorted = 8,
    focused = 16,
    expandable = 32,
    expanded = 64,


  CornerType* {.pure,size: sizeof(uint32).} = enum
    top_left,
    bottom_left,
    top_right,
    bottom_right,


  CssProviderError* {.pure,size: sizeof(uint32).} = enum
    failed,
    syntax,
    `import`,
    name,
    deprecated,
    unknown_value,


  CssSectionType* {.pure,size: sizeof(uint32).} = enum
    document,
    `import`,
    color_definition,
    binding_set,
    ruleset,
    selector,
    declaration,
    value,
    keyframes,


  # flags
  SDebugFlag* = uint32
  DebugFlag* {.pure,size: sizeof(uint32).} = enum
    misc = 1,
    plugsocket = 2,
    text = 4,
    tree = 8,
    updates = 16,
    keybindings = 32,
    multihead = 64,
    modules = 128,
    geometry = 256,
    icontheme = 512,
    printing = 1024,
    builder = 2048,
    size_request = 4096,
    no_css_cache = 8192,
    baselines = 16384,
    pixel_cache = 32768,
    no_pixel_cache = 65536,
    interactive = 131072,
    touchscreen = 262144,
    actions = 524288,


  DeleteType* {.pure,size: sizeof(uint32).} = enum
    chars,
    word_ends,
    words,
    display_lines,
    display_line_ends,
    paragraph_ends,
    paragraphs,
    whitespace,


  # flags
  SDestDefaults* = uint32
  DestDefaults* {.pure,size: sizeof(uint32).} = enum
    motion = 1,
    highlight = 2,
    drop = 4,
    all = 7,


  # flags
  SDialogFlags* = uint32
  DialogFlags* {.pure,size: sizeof(uint32).} = enum
    modal = 1,
    destroy_with_parent = 2,
    use_header_bar = 4,


  DirectionType* {.pure,size: sizeof(uint32).} = enum
    tab_forward,
    tab_backward,
    up,
    down,
    left,
    right,


  DragResult* {.pure,size: sizeof(uint32).} = enum
    success,
    no_target,
    user_cancelled,
    timeout_expired,
    grab_broken,
    error,


  EntryIconPosition* {.pure,size: sizeof(uint32).} = enum
    primary,
    secondary,


  EventSequenceState* {.pure,size: sizeof(uint32).} = enum
    none,
    claimed,
    denied,


  ExpanderStyle* {.pure,size: sizeof(uint32).} = enum
    collapsed,
    semi_collapsed,
    semi_expanded,
    expanded,


  FileChooserAction* {.pure,size: sizeof(uint32).} = enum
    open,
    save,
    select_folder,
    create_folder,


  FileChooserConfirmation* {.pure,size: sizeof(uint32).} = enum
    confirm,
    accept_filename,
    select_again,


  FileChooserError* {.pure,size: sizeof(uint32).} = enum
    nonexistent,
    bad_filename,
    already_exists,
    incomplete_hostname,


  # flags
  SFileFilterFlags* = uint32
  FileFilterFlags* {.pure,size: sizeof(uint32).} = enum
    filename = 1,
    uri = 2,
    display_name = 4,
    mime_type = 8,


  IMPreeditStyle* {.pure,size: sizeof(uint32).} = enum
    nothing,
    callback,
    none,


  IMStatusStyle* {.pure,size: sizeof(uint32).} = enum
    nothing,
    callback,
    none,


  # flags
  SIconLookupFlags* = uint32
  IconLookupFlags* {.pure,size: sizeof(uint32).} = enum
    no_svg = 1,
    force_svg = 2,
    use_builtin = 4,
    generic_fallback = 8,
    force_size = 16,
    force_regular = 32,
    force_symbolic = 64,
    dir_ltr = 128,
    dir_rtl = 256,


  IconSize* {.pure,size: sizeof(uint32).} = enum
    invalid,
    menu,
    small_toolbar,
    large_toolbar,
    button,
    dnd,
    dialog,


  IconThemeError* {.pure,size: sizeof(uint32).} = enum
    not_found,
    failed,


  IconViewDropPosition* {.pure,size: sizeof(uint32).} = enum
    no_drop,
    drop_into,
    drop_left,
    drop_right,
    drop_above,
    drop_below,


  ImageType* {.pure,size: sizeof(uint32).} = enum
    empty,
    pixbuf,
    stock,
    icon_set,
    animation,
    icon_name,
    gicon,
    surface,


  # flags
  SInputHints* = uint32
  InputHints* {.pure,size: sizeof(uint32).} = enum
    none = 0,
    spellcheck = 1,
    no_spellcheck = 2,
    word_completion = 4,
    lowercase = 8,
    uppercase_chars = 16,
    uppercase_words = 32,
    uppercase_sentences = 64,
    inhibit_osk = 128,


  InputPurpose* {.pure,size: sizeof(uint32).} = enum
    free_form,
    alpha,
    digits,
    number,
    phone,
    url,
    email,
    name,
    password,
    pin,


  # flags
  SJunctionSides* = uint32
  JunctionSides* {.pure,size: sizeof(uint32).} = enum
    none = 0,
    corner_topleft = 1,
    corner_topright = 2,
    top = 3,
    corner_bottomleft = 4,
    left = 5,
    corner_bottomright = 8,
    right = 10,
    bottom = 12,


  Justification* {.pure,size: sizeof(uint32).} = enum
    left,
    right,
    center,
    fill,


  LevelBarMode* {.pure,size: sizeof(uint32).} = enum
    continuous,
    discrete,


  License* {.pure,size: sizeof(uint32).} = enum
    unknown,
    custom,
    gpl_2_0,
    gpl_3_0,
    lgpl_2_1,
    lgpl_3_0,
    bsd,
    mit_x11,
    artistic,
    gpl_2_0_only,
    gpl_3_0_only,
    lgpl_2_1_only,
    lgpl_3_0_only,


  MenuDirectionType* {.pure,size: sizeof(uint32).} = enum
    parent,
    child,
    next,
    prev,


  MessageType* {.pure,size: sizeof(uint32).} = enum
    info,
    warning,
    question,
    error,
    other,


  MovementStep* {.pure,size: sizeof(uint32).} = enum
    logical_positions,
    visual_positions,
    words,
    display_lines,
    display_line_ends,
    paragraphs,
    paragraph_ends,
    pages,
    buffer_ends,
    horizontal_pages,


  NotebookTab* {.pure,size: sizeof(uint32).} = enum
    first,
    last,


  NumberUpLayout* {.pure,size: sizeof(uint32).} = enum
    lrtb,
    lrbt,
    rltb,
    rlbt,
    tblr,
    tbrl,
    btlr,
    btrl,


  Orientation* {.pure,size: sizeof(uint32).} = enum
    horizontal,
    vertical,


  PackDirection* {.pure,size: sizeof(uint32).} = enum
    ltr,
    rtl,
    ttb,
    btt,


  PackType* {.pure,size: sizeof(uint32).} = enum
    start,
    `end`,


  PageOrientation* {.pure,size: sizeof(uint32).} = enum
    portrait,
    landscape,
    reverse_portrait,
    reverse_landscape,


  PageSet* {.pure,size: sizeof(uint32).} = enum
    all,
    even,
    odd,


  PanDirection* {.pure,size: sizeof(uint32).} = enum
    left,
    right,
    up,
    down,


  PathPriorityType* {.pure,size: sizeof(uint32).} = enum
    lowest,
    gtk = 4,
    application = 8,
    theme = 10,
    rc = 12,
    highest = 15,


  PathType* {.pure,size: sizeof(uint32).} = enum
    widget,
    widget_class,
    class,


  # flags
  SPlacesOpenFlags* = uint32
  PlacesOpenFlags* {.pure,size: sizeof(uint32).} = enum
    normal = 1,
    new_tab = 2,
    new_window = 4,


  PolicyType* {.pure,size: sizeof(uint32).} = enum
    always,
    automatic,
    never,


  PositionType* {.pure,size: sizeof(uint32).} = enum
    left,
    right,
    top,
    bottom,


  PrintDuplex* {.pure,size: sizeof(uint32).} = enum
    simplex,
    horizontal,
    vertical,


  PrintError* {.pure,size: sizeof(uint32).} = enum
    general,
    internal_error,
    nomem,
    invalid_file,


  PrintOperationAction* {.pure,size: sizeof(uint32).} = enum
    print_dialog,
    print,
    preview,
    `export`,


  PrintOperationResult* {.pure,size: sizeof(uint32).} = enum
    error,
    apply,
    cancel,
    in_progress,


  PrintPages* {.pure,size: sizeof(uint32).} = enum
    all,
    current,
    ranges,
    selection,


  PrintQuality* {.pure,size: sizeof(uint32).} = enum
    low,
    normal,
    high,
    draft,


  PrintStatus* {.pure,size: sizeof(uint32).} = enum
    initial,
    preparing,
    generating_data,
    sending_data,
    pending,
    pending_issue,
    printing,
    finished,
    finished_aborted,


  PropagationPhase* {.pure,size: sizeof(uint32).} = enum
    none,
    capture,
    bubble,
    target,


  # flags
  SRcFlags* = uint32
  RcFlags* {.pure,size: sizeof(uint32).} = enum
    fg = 1,
    bg = 2,
    text = 4,
    base = 8,


  RcTokenType* {.pure,size: sizeof(uint32).} = enum
    invalid = 270,
    `include`,
    normal,
    active,
    prelight,
    selected,
    insensitive,
    fg,
    bg,
    text,
    base,
    xthickness,
    ythickness,
    font,
    fontset,
    font_name,
    bg_pixmap,
    pixmap_path,
    style,
    binding,
    `bind`,
    widget,
    widget_class,
    class,
    lowest,
    gtk,
    application,
    theme,
    rc,
    highest,
    engine,
    module_path,
    im_module_path,
    im_module_file,
    stock,
    ltr,
    rtl,
    color,
    unbind,
    last,


  RecentChooserError* {.pure,size: sizeof(uint32).} = enum
    not_found,
    invalid_uri,


  # flags
  SRecentFilterFlags* = uint32
  RecentFilterFlags* {.pure,size: sizeof(uint32).} = enum
    uri = 1,
    display_name = 2,
    mime_type = 4,
    application = 8,
    group = 16,
    age = 32,


  RecentManagerError* {.pure,size: sizeof(uint32).} = enum
    not_found,
    invalid_uri,
    invalid_encoding,
    not_registered,
    read,
    write,
    unknown,


  RecentSortType* {.pure,size: sizeof(uint32).} = enum
    none,
    mru,
    lru,
    custom,


  # flags
  SRegionFlags* = uint32
  RegionFlags* {.pure,size: sizeof(uint32).} = enum
    even = 1,
    odd = 2,
    first = 4,
    last = 8,
    only = 16,
    sorted = 32,


  ReliefStyle* {.pure,size: sizeof(uint32).} = enum
    normal,
    half,
    none,


  ResizeMode* {.pure,size: sizeof(uint32).} = enum
    parent,
    queue,
    immediate,


  ResponseType* {.pure,size: sizeof(int32).} = enum
    help = -11,
    apply,
    no,
    yes,
    close,
    cancel,
    ok,
    delete_event,
    accept,
    reject,
    none,


  RevealerTransitionType* {.pure,size: sizeof(uint32).} = enum
    none,
    crossfade,
    slide_right,
    slide_left,
    slide_up,
    slide_down,


  ScrollStep* {.pure,size: sizeof(uint32).} = enum
    steps,
    pages,
    ends,
    horizontal_steps,
    horizontal_pages,
    horizontal_ends,


  ScrollType* {.pure,size: sizeof(uint32).} = enum
    none,
    jump,
    step_backward,
    step_forward,
    page_backward,
    page_forward,
    step_up,
    step_down,
    page_up,
    page_down,
    step_left,
    step_right,
    page_left,
    page_right,
    start,
    `end`,


  ScrollablePolicy* {.pure,size: sizeof(uint32).} = enum
    minimum,
    natural,


  SelectionMode* {.pure,size: sizeof(uint32).} = enum
    none,
    single,
    browse,
    multiple,


  SensitivityType* {.pure,size: sizeof(uint32).} = enum
    auto,
    on,
    off,


  ShadowType* {.pure,size: sizeof(uint32).} = enum
    none,
    `in`,
    `out`,
    etched_in,
    etched_out,


  SizeGroupMode* {.pure,size: sizeof(uint32).} = enum
    none,
    horizontal,
    vertical,
    both,


  SizeRequestMode* {.pure,size: sizeof(uint32).} = enum
    height_for_width,
    width_for_height,
    constant_size,


  SortType* {.pure,size: sizeof(uint32).} = enum
    ascending,
    descending,


  SpinButtonUpdatePolicy* {.pure,size: sizeof(uint32).} = enum
    always,
    if_valid,


  SpinType* {.pure,size: sizeof(uint32).} = enum
    step_forward,
    step_backward,
    page_forward,
    page_backward,
    home,
    `end`,
    user_defined,


  StackTransitionType* {.pure,size: sizeof(uint32).} = enum
    none,
    crossfade,
    slide_right,
    slide_left,
    slide_up,
    slide_down,
    slide_left_right,
    slide_up_down,
    over_up,
    over_down,
    over_left,
    over_right,
    under_up,
    under_down,
    under_left,
    under_right,
    over_up_down,
    over_down_up,
    over_left_right,
    over_right_left,


  # flags
  SStateFlags* = uint32
  StateFlags* {.pure,size: sizeof(uint32).} = enum
    normal = 0,
    active = 1,
    prelight = 2,
    selected = 4,
    insensitive = 8,
    inconsistent = 16,
    focused = 32,
    backdrop = 64,
    dir_ltr = 128,
    dir_rtl = 256,
    link = 512,
    visited = 1024,
    checked = 2048,


  StateType* {.pure,size: sizeof(uint32).} = enum
    normal,
    active,
    prelight,
    selected,
    insensitive,
    inconsistent,
    focused,


  # flags
  STargetFlags* = uint32
  TargetFlags* {.pure,size: sizeof(uint32).} = enum
    same_app = 1,
    same_widget = 2,
    other_app = 4,
    other_widget = 8,


  TextBufferTargetInfo* {.pure,size: sizeof(int32).} = enum
    text = -3,
    rich_text,
    buffer_contents,


  TextDirection* {.pure,size: sizeof(uint32).} = enum
    none,
    ltr,
    rtl,


  # flags
  STextSearchFlags* = uint32
  TextSearchFlags* {.pure,size: sizeof(uint32).} = enum
    visible_only = 1,
    text_only = 2,
    case_insensitive = 4,


  TextViewLayer* {.pure,size: sizeof(uint32).} = enum
    below,
    above,


  TextWindowType* {.pure,size: sizeof(uint32).} = enum
    private,
    widget,
    text,
    left,
    right,
    top,
    bottom,


  # flags
  SToolPaletteDragTargets* = uint32
  ToolPaletteDragTargets* {.pure,size: sizeof(uint32).} = enum
    items = 1,
    groups = 2,


  ToolbarSpaceStyle* {.pure,size: sizeof(uint32).} = enum
    empty,
    line,


  ToolbarStyle* {.pure,size: sizeof(uint32).} = enum
    icons,
    text,
    both,
    both_horiz,


  # flags
  STreeModelFlags* = uint32
  TreeModelFlags* {.pure,size: sizeof(uint32).} = enum
    iters_persist = 1,
    list_only = 2,


  TreeViewColumnSizing* {.pure,size: sizeof(uint32).} = enum
    grow_only,
    autosize,
    fixed,


  TreeViewDropPosition* {.pure,size: sizeof(uint32).} = enum
    before,
    after,
    into_or_before,
    into_or_after,


  TreeViewGridLines* {.pure,size: sizeof(uint32).} = enum
    none,
    horizontal,
    vertical,
    both,


  # flags
  SUIManagerItemType* = uint32
  UIManagerItemType* {.pure,size: sizeof(uint32).} = enum
    auto = 0,
    menubar = 1,
    menu = 2,
    toolbar = 4,
    placeholder = 8,
    popup = 16,
    menuitem = 32,
    toolitem = 64,
    separator = 128,
    accelerator = 256,
    popup_with_accels = 512,


  Unit* {.pure,size: sizeof(uint32).} = enum
    none,
    points,
    inch,
    mm,


  WidgetHelpType* {.pure,size: sizeof(uint32).} = enum
    tooltip,
    whats_this,


  WindowPosition* {.pure,size: sizeof(uint32).} = enum
    none,
    center,
    mouse,
    center_always,
    center_on_parent,


  WindowType* {.pure,size: sizeof(uint32).} = enum
    toplevel,
    popup,


  WrapMode* {.pure,size: sizeof(uint32).} = enum
    none,
    char,
    word,
    word_char,


declareSubclass(TWidget, GObject2.TInitiallyUnowned)
declareSubclass(TContainer, TWidget)
declareSubclass(TBin, TContainer)
declareSubclass(TWindow, TBin)
declareSubclass(TDialog, TWindow)
declareSubclass(TAboutDialog, TDialog)
declareSubclass(TAccelGroup, GObject2.TObject)
declareSubclass(TMisc, TWidget)
declareSubclass(TLabel, TMisc)
declareSubclass(TAccelLabel, TLabel)
declareSubclass(TAccelMap, GObject2.TObject)
declareSubclass(TAccessible, Atk1.TObject)
declareSubclass(TAction, GObject2.TObject)
declareSubclass(TActionBar, TBin)
declareSubclass(TActionGroup, GObject2.TObject)
declareSubclass(TAdjustment, GObject2.TInitiallyUnowned)
declareSubclass(TAlignment, TBin)
declareSubclass(TComboBox, TBin)
declareSubclass(TAppChooserButton, TComboBox)
declareSubclass(TAppChooserDialog, TDialog)
declareSubclass(TBox, TContainer)
declareSubclass(TAppChooserWidget, TBox)
declareSubclass(TApplication, Gio2.TApplication)
declareSubclass(TApplicationWindow, TWindow)
declareSubclass(TArrow, TMisc)
declareSubclass(TWidgetAccessible, TAccessible)
declareSubclass(TArrowAccessible, TWidgetAccessible)
declareSubclass(TFrame, TBin)
declareSubclass(TAspectFrame, TFrame)
declareSubclass(TAssistant, TWindow)
declareSubclass(TCellAccessible, TAccessible)
declareSubclass(TRendererCellAccessible, TCellAccessible)
declareSubclass(TBooleanCellAccessible, TRendererCellAccessible)
declareSubclass(TBuilder, GObject2.TObject)
declareSubclass(TButton, TBin)
declareSubclass(TContainerAccessible, TWidgetAccessible)
declareSubclass(TButtonAccessible, TContainerAccessible)
declareSubclass(TButtonBox, TBox)
declareSubclass(TCalendar, TWidget)
declareSubclass(TCellArea, GObject2.TInitiallyUnowned)
declareSubclass(TCellAreaBox, TCellArea)
declareSubclass(TCellAreaContext, GObject2.TObject)
declareSubclass(TCellRenderer, GObject2.TInitiallyUnowned)
declareSubclass(TCellRendererText, TCellRenderer)
declareSubclass(TCellRendererAccel, TCellRendererText)
declareSubclass(TCellRendererCombo, TCellRendererText)
declareSubclass(TCellRendererPixbuf, TCellRenderer)
declareSubclass(TCellRendererProgress, TCellRenderer)
declareSubclass(TCellRendererSpin, TCellRendererText)
declareSubclass(TCellRendererSpinner, TCellRenderer)
declareSubclass(TCellRendererToggle, TCellRenderer)
declareSubclass(TCellView, TWidget)
declareSubclass(TToggleButton, TButton)
declareSubclass(TCheckButton, TToggleButton)
declareSubclass(TMenuItem, TBin)
declareSubclass(TCheckMenuItem, TMenuItem)
declareSubclass(TMenuItemAccessible, TContainerAccessible)
declareSubclass(TCheckMenuItemAccessible, TMenuItemAccessible)
declareSubclass(TClipboard, GObject2.TObject)
declareSubclass(TColorButton, TButton)
declareSubclass(TColorChooserDialog, TDialog)
declareSubclass(TColorChooserWidget, TBox)
declareSubclass(TColorSelection, TBox)
declareSubclass(TColorSelectionDialog, TDialog)
declareSubclass(TComboBoxAccessible, TContainerAccessible)
declareSubclass(TComboBoxText, TComboBox)
declareSubclass(TContainerCellAccessible, TCellAccessible)
declareSubclass(TCssProvider, GObject2.TObject)
declareSubclass(TDrawingArea, TWidget)
declareSubclass(TEntry, TWidget)
declareSubclass(TEntryAccessible, TWidgetAccessible)
declareSubclass(TEntryBuffer, GObject2.TObject)
declareSubclass(TEntryCompletion, GObject2.TObject)
declareSubclass(TEntryIconAccessible, Atk1.TObject)
declareSubclass(TEventBox, TBin)
declareSubclass(TEventController, GObject2.TObject)
declareSubclass(TExpander, TBin)
declareSubclass(TExpanderAccessible, TContainerAccessible)
declareSubclass(TFileChooserButton, TBox)
declareSubclass(TFileChooserDialog, TDialog)
declareSubclass(TFileChooserWidget, TBox)
declareSubclass(TFileFilter, GObject2.TInitiallyUnowned)
declareSubclass(TFixed, TContainer)
declareSubclass(TFlowBox, TContainer)
declareSubclass(TFlowBoxAccessible, TContainerAccessible)
declareSubclass(TFlowBoxChild, TBin)
declareSubclass(TFlowBoxChildAccessible, TContainerAccessible)
declareSubclass(TFontButton, TButton)
declareSubclass(TFontChooserDialog, TDialog)
declareSubclass(TFontChooserWidget, TBox)
declareSubclass(TFontSelection, TBox)
declareSubclass(TFontSelectionDialog, TDialog)
declareSubclass(TFrameAccessible, TContainerAccessible)
declareSubclass(TGesture, TEventController)
declareSubclass(TGestureSingle, TGesture)
declareSubclass(TGestureDrag, TGestureSingle)
declareSubclass(TGestureLongPress, TGestureSingle)
declareSubclass(TGestureMultiPress, TGestureSingle)
declareSubclass(TGesturePan, TGestureDrag)
declareSubclass(TGestureRotate, TGesture)
declareSubclass(TGestureSwipe, TGestureSingle)
declareSubclass(TGestureZoom, TGesture)
declareSubclass(TGrid, TContainer)
declareSubclass(THBox, TBox)
declareSubclass(THButtonBox, TButtonBox)
declareSubclass(TPaned, TContainer)
declareSubclass(THPaned, TPaned)
declareSubclass(THSV, TWidget)
declareSubclass(TRange, TWidget)
declareSubclass(TScale, TRange)
declareSubclass(THScale, TScale)
declareSubclass(TScrollbar, TRange)
declareSubclass(THScrollbar, TScrollbar)
declareSubclass(TSeparator, TWidget)
declareSubclass(THSeparator, TSeparator)
declareSubclass(THandleBox, TBin)
declareSubclass(THeaderBar, TContainer)
declareSubclass(TIMContext, GObject2.TObject)
declareSubclass(TIMContextSimple, TIMContext)
declareSubclass(TIMMulticontext, TIMContext)
declareSubclass(TIconFactory, GObject2.TObject)
declareSubclass(TIconInfo, GObject2.TObject)
declareSubclass(TIconTheme, GObject2.TObject)
declareSubclass(TIconView, TContainer)
declareSubclass(TIconViewAccessible, TContainerAccessible)
declareSubclass(TImage, TMisc)
declareSubclass(TImageAccessible, TWidgetAccessible)
declareSubclass(TImageCellAccessible, TRendererCellAccessible)
declareSubclass(TImageMenuItem, TMenuItem)
declareSubclass(TInfoBar, TBox)
declareSubclass(TInvisible, TWidget)
declareSubclass(TLabelAccessible, TWidgetAccessible)
declareSubclass(TLayout, TContainer)
declareSubclass(TLevelBar, TWidget)
declareSubclass(TLevelBarAccessible, TWidgetAccessible)
declareSubclass(TLinkButton, TButton)
declareSubclass(TLinkButtonAccessible, TButtonAccessible)
declareSubclass(TListBox, TContainer)
declareSubclass(TListBoxAccessible, TContainerAccessible)
declareSubclass(TListBoxRow, TBin)
declareSubclass(TListBoxRowAccessible, TContainerAccessible)
declareSubclass(TListStore, GObject2.TObject)
declareSubclass(TLockButton, TButton)
declareSubclass(TLockButtonAccessible, TButtonAccessible)
declareSubclass(TMenuShell, TContainer)
declareSubclass(TMenu, TMenuShell)
declareSubclass(TMenuShellAccessible, TContainerAccessible)
declareSubclass(TMenuAccessible, TMenuShellAccessible)
declareSubclass(TMenuBar, TMenuShell)
declareSubclass(TMenuButton, TToggleButton)
declareSubclass(TToggleButtonAccessible, TButtonAccessible)
declareSubclass(TMenuButtonAccessible, TToggleButtonAccessible)
declareSubclass(TToolItem, TBin)
declareSubclass(TToolButton, TToolItem)
declareSubclass(TMenuToolButton, TToolButton)
declareSubclass(TMessageDialog, TDialog)
declareSubclass(TMountOperation, Gio2.TMountOperation)
declareSubclass(TNotebook, TContainer)
declareSubclass(TNotebookAccessible, TContainerAccessible)
declareSubclass(TNotebookPageAccessible, Atk1.TObject)
declareSubclass(TNumerableIcon, Gio2.TEmblemedIcon)
declareSubclass(TOffscreenWindow, TWindow)
declareSubclass(TOverlay, TBin)
declareSubclass(TPageSetup, GObject2.TObject)
declareSubclass(TPanedAccessible, TContainerAccessible)
declareSubclass(TScrolledWindow, TBin)
declareSubclass(TPlacesSidebar, TScrolledWindow)
declareSubclass(TPopover, TBin)
declareSubclass(TPopoverAccessible, TContainerAccessible)
declareSubclass(TPrintContext, GObject2.TObject)
declareSubclass(TPrintOperation, GObject2.TObject)
declareSubclass(TPrintSettings, GObject2.TObject)
declareSubclass(TProgressBar, TWidget)
declareSubclass(TProgressBarAccessible, TWidgetAccessible)
declareSubclass(TToggleAction, TAction)
declareSubclass(TRadioAction, TToggleAction)
declareSubclass(TRadioButton, TCheckButton)
declareSubclass(TRadioButtonAccessible, TToggleButtonAccessible)
declareSubclass(TRadioMenuItem, TCheckMenuItem)
declareSubclass(TRadioMenuItemAccessible, TCheckMenuItemAccessible)
declareSubclass(TToggleToolButton, TToolButton)
declareSubclass(TRadioToolButton, TToggleToolButton)
declareSubclass(TRangeAccessible, TWidgetAccessible)
declareSubclass(TRcStyle, GObject2.TObject)
declareSubclass(TRecentAction, TAction)
declareSubclass(TRecentChooserDialog, TDialog)
declareSubclass(TRecentChooserMenu, TMenu)
declareSubclass(TRecentChooserWidget, TBox)
declareSubclass(TRecentFilter, GObject2.TInitiallyUnowned)
declareSubclass(TRecentManager, GObject2.TObject)
declareSubclass(TRevealer, TBin)
declareSubclass(TScaleAccessible, TRangeAccessible)
declareSubclass(TScaleButton, TButton)
declareSubclass(TScaleButtonAccessible, TButtonAccessible)
declareSubclass(TScrolledWindowAccessible, TContainerAccessible)
declareSubclass(TSearchBar, TBin)
declareSubclass(TSearchEntry, TEntry)
declareSubclass(TSeparatorMenuItem, TMenuItem)
declareSubclass(TSeparatorToolItem, TToolItem)
declareSubclass(TSettings, GObject2.TObject)
declareSubclass(TSizeGroup, GObject2.TObject)
declareSubclass(TSpinButton, TEntry)
declareSubclass(TSpinButtonAccessible, TEntryAccessible)
declareSubclass(TSpinner, TWidget)
declareSubclass(TSpinnerAccessible, TWidgetAccessible)
declareSubclass(TStack, TContainer)
declareSubclass(TStackSwitcher, TBox)
declareSubclass(TStatusIcon, GObject2.TObject)
declareSubclass(TStatusbar, TBox)
declareSubclass(TStatusbarAccessible, TContainerAccessible)
declareSubclass(TStyle, GObject2.TObject)
declareSubclass(TStyleContext, GObject2.TObject)
declareSubclass(TStyleProperties, GObject2.TObject)
declareSubclass(TSwitch, TWidget)
declareSubclass(TSwitchAccessible, TWidgetAccessible)
declareSubclass(TTable, TContainer)
declareSubclass(TTearoffMenuItem, TMenuItem)
declareSubclass(TTextBuffer, GObject2.TObject)
declareSubclass(TTextCellAccessible, TRendererCellAccessible)
declareSubclass(TTextChildAnchor, GObject2.TObject)
declareSubclass(TTextMark, GObject2.TObject)
declareSubclass(TTextTag, GObject2.TObject)
declareSubclass(TTextTagTable, GObject2.TObject)
declareSubclass(TTextView, TContainer)
declareSubclass(TTextViewAccessible, TContainerAccessible)
declareSubclass(TThemingEngine, GObject2.TObject)
declareSubclass(TToolItemGroup, TContainer)
declareSubclass(TToolPalette, TContainer)
declareSubclass(TToolbar, TContainer)
declareSubclass(TTooltip, GObject2.TObject)
declareSubclass(TToplevelAccessible, Atk1.TObject)
declareSubclass(TTreeModelFilter, GObject2.TObject)
declareSubclass(TTreeModelSort, GObject2.TObject)
declareSubclass(TTreeSelection, GObject2.TObject)
declareSubclass(TTreeStore, GObject2.TObject)
declareSubclass(TTreeView, TContainer)
declareSubclass(TTreeViewAccessible, TContainerAccessible)
declareSubclass(TTreeViewColumn, GObject2.TInitiallyUnowned)
declareSubclass(TUIManager, GObject2.TObject)
declareSubclass(TVBox, TBox)
declareSubclass(TVButtonBox, TButtonBox)
declareSubclass(TVPaned, TPaned)
declareSubclass(TVScale, TScale)
declareSubclass(TVScrollbar, TScrollbar)
declareSubclass(TVSeparator, TSeparator)
declareSubclass(TViewport, TBin)
declareSubclass(TVolumeButton, TScaleButton)
declareSubclass(TWindowAccessible, TContainerAccessible)
declareSubclass(TWindowGroup, GObject2.TObject)

# implicit unwrapping
# for some reason, this is not picked up from gobjectutils (bug?)
converter unwrap[T](s: ref GSmartPtr[T]): ptr T = s.pointer
  # free functions
  #------------------
# gtk_accel_groups_activate
# flags: {} container: -
# object 'GObject2.Object' 'ptr GObject2.TObject' IN (diff., need sugar)
# accel_key 'uint32' 'uint32' IN
# accel_mods 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# 'bool' 'bool'
proc gtk_accel_groups_activate(object_x: ptr GObject2.TObject, accel_key: uint32, accel_mods: Gdk3.SModifierType): bool {.cdecl, dynlib: lib, importc: "gtk_accel_groups_activate".}
proc gtk_accel_groups_activate*(object_x: GObject2.Object, accel_key: uint32, accel_mods: Gdk3.SModifierType): bool {.inline.} =
  gtk_accel_groups_activate(object_x.getPointer, accel_key, accel_mods)
# proc gtk_accel_groups_activate*(object_x: GObject2.Object, accel_key: uint32, accel_mods: Gdk3.SModifierType): bool {.inline.} =

# gtk_accel_groups_from_object
# flags: {} container: -
# object 'GObject2.Object' 'ptr GObject2.TObject' IN (diff., need sugar)
# 'ptr GSLIST_TODO' 'ptr GSLIST_TODO'
proc gtk_accel_groups_from_object(object_x: ptr GObject2.TObject): ptr GSLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_accel_groups_from_object".}
proc gtk_accel_groups_from_object*(object_x: GObject2.Object): ptr GSLIST_TODO {.inline.} =
  gtk_accel_groups_from_object(object_x.getPointer)
# proc gtk_accel_groups_from_object*(object_x: GObject2.Object): ptr GSLIST_TODO {.inline.} =

# gtk_accelerator_get_default_mod_mask
# flags: {} container: -
# 'Gdk3.SModifierType' 'Gdk3.SModifierType'
proc gtk_accelerator_get_default_mod_mask*(): Gdk3.SModifierType {.cdecl, dynlib: lib, importc: "gtk_accelerator_get_default_mod_mask".}
# gtk_accelerator_get_label
# flags: {} container: -
# accelerator_key 'uint32' 'uint32' IN
# accelerator_mods 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_accelerator_get_label_import(accelerator_key: uint32, accelerator_mods: Gdk3.SModifierType): ucstring {.cdecl, dynlib: lib, importc: "gtk_accelerator_get_label".}
proc gtk_accelerator_get_label*(accelerator_key: uint32, accelerator_mods: Gdk3.SModifierType): ustring {.inline.} =
  ustring($(gtk_accelerator_get_label_import(accelerator_key, accelerator_mods)))
# proc gtk_accelerator_get_label*(accelerator_key: uint32, accelerator_mods: Gdk3.SModifierType): ustring {.inline.} =

# gtk_accelerator_get_label_with_keycode
# flags: {} container: -
# display 'Gdk3.Display' 'ptr Gdk3.TDisplay' IN (diff., need sugar)
# accelerator_key 'uint32' 'uint32' IN
# keycode 'uint32' 'uint32' IN
# accelerator_mods 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_accelerator_get_label_with_keycode(display: ptr Gdk3.TDisplay, accelerator_key: uint32, keycode: uint32, accelerator_mods: Gdk3.SModifierType): ucstring {.cdecl, dynlib: lib, importc: "gtk_accelerator_get_label_with_keycode".}
proc gtk_accelerator_get_label_with_keycode*(display: Gdk3.Display, accelerator_key: uint32, keycode: uint32, accelerator_mods: Gdk3.SModifierType): ustring {.inline.} =
  ustring($(gtk_accelerator_get_label_with_keycode(display.getPointer, accelerator_key, keycode, accelerator_mods)))
# proc gtk_accelerator_get_label_with_keycode*(display: Gdk3.Display, accelerator_key: uint32, keycode: uint32, accelerator_mods: Gdk3.SModifierType): ustring {.inline.} =

# gtk_accelerator_name
# flags: {} container: -
# accelerator_key 'uint32' 'uint32' IN
# accelerator_mods 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_accelerator_name_import(accelerator_key: uint32, accelerator_mods: Gdk3.SModifierType): ucstring {.cdecl, dynlib: lib, importc: "gtk_accelerator_name".}
proc gtk_accelerator_name*(accelerator_key: uint32, accelerator_mods: Gdk3.SModifierType): ustring {.inline.} =
  ustring($(gtk_accelerator_name_import(accelerator_key, accelerator_mods)))
# proc gtk_accelerator_name*(accelerator_key: uint32, accelerator_mods: Gdk3.SModifierType): ustring {.inline.} =

# gtk_accelerator_name_with_keycode
# flags: {} container: -
# display 'Gdk3.Display' 'ptr Gdk3.TDisplay' IN (diff., need sugar)
# accelerator_key 'uint32' 'uint32' IN
# keycode 'uint32' 'uint32' IN
# accelerator_mods 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_accelerator_name_with_keycode(display: ptr Gdk3.TDisplay, accelerator_key: uint32, keycode: uint32, accelerator_mods: Gdk3.SModifierType): ucstring {.cdecl, dynlib: lib, importc: "gtk_accelerator_name_with_keycode".}
proc gtk_accelerator_name_with_keycode*(display: Gdk3.Display, accelerator_key: uint32, keycode: uint32, accelerator_mods: Gdk3.SModifierType): ustring {.inline.} =
  ustring($(gtk_accelerator_name_with_keycode(display.getPointer, accelerator_key, keycode, accelerator_mods)))
# proc gtk_accelerator_name_with_keycode*(display: Gdk3.Display, accelerator_key: uint32, keycode: uint32, accelerator_mods: Gdk3.SModifierType): ustring {.inline.} =

# gtk_accelerator_parse
# flags: {} container: -
# accelerator 'ustring' 'ucstring' IN (diff., need sugar)
# accelerator_key 'var uint32' 'ptr uint32' OUT (diff., need sugar) optional
# accelerator_mods 'Gdk3.SModifierType' 'Gdk3.SModifierType' OUT optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_accelerator_parse(accelerator: ucstring, accelerator_key: ptr uint32, accelerator_mods: Gdk3.SModifierType) {.cdecl, dynlib: lib, importc: "gtk_accelerator_parse".}
proc gtk_accelerator_parse*(accelerator: ustring, accelerator_key: var uint32, accelerator_mods: Gdk3.SModifierType) {.inline.} =
  gtk_accelerator_parse(ucstring(accelerator), addr(accelerator_key), accelerator_mods)
# tuple-return
# accelerator_key: var uint32
# accelerator_mods: Gdk3.SModifierType
# proc gtk_accelerator_parse*(accelerator: ustring) {.inline.} =

# gtk_accelerator_parse_with_keycode
# flags: {} container: -
# accelerator 'ustring' 'ucstring' IN (diff., need sugar)
# accelerator_key 'var uint32' 'ptr uint32' OUT (diff., need sugar) optional
# accelerator_codes 'uncheckedArray[uint32]' 'uncheckedArray[uint32]' OUT array zero-terminated optional
# accelerator_mods 'Gdk3.SModifierType' 'Gdk3.SModifierType' OUT optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_accelerator_parse_with_keycode(accelerator: ucstring, accelerator_key: ptr uint32, accelerator_codes: uncheckedArray[uint32], accelerator_mods: Gdk3.SModifierType) {.cdecl, dynlib: lib, importc: "gtk_accelerator_parse_with_keycode".}
proc gtk_accelerator_parse_with_keycode*(accelerator: ustring, accelerator_key: var uint32, accelerator_codes: uncheckedArray[uint32], accelerator_mods: Gdk3.SModifierType) {.inline.} =
  gtk_accelerator_parse_with_keycode(ucstring(accelerator), addr(accelerator_key), accelerator_codes, accelerator_mods)
# tuple-return
# accelerator_key: var uint32
# accelerator_codes: uncheckedArray[uint32]
# accelerator_mods: Gdk3.SModifierType
# proc gtk_accelerator_parse_with_keycode*(accelerator: ustring) {.inline.} =

# gtk_accelerator_set_default_mod_mask
# flags: {} container: -
# default_mod_mask 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_accelerator_set_default_mod_mask*(default_mod_mask: Gdk3.SModifierType) {.cdecl, dynlib: lib, importc: "gtk_accelerator_set_default_mod_mask".}
# gtk_accelerator_valid
# flags: {} container: -
# keyval 'uint32' 'uint32' IN
# modifiers 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# 'bool' 'bool'
proc gtk_accelerator_valid*(keyval: uint32, modifiers: Gdk3.SModifierType): bool {.cdecl, dynlib: lib, importc: "gtk_accelerator_valid".}
# gtk_alternative_dialog_button_order
# flags: {} container: - (deprecated)
# gtk_binding_entry_add_signal_from_string
# flags: {} container: -
# binding_set 'TBindingSet' 'ptr TBindingSet' IN (diff., need sugar)
# signal_desc 'ustring' 'ucstring' IN (diff., need sugar)
# 'GLib2.TokenType' 'GLib2.TokenType'
proc gtk_binding_entry_add_signal_from_string(binding_set: ptr TBindingSet, signal_desc: ucstring): GLib2.TokenType {.cdecl, dynlib: lib, importc: "gtk_binding_entry_add_signal_from_string".}
proc gtk_binding_entry_add_signal_from_string*(binding_set: TBindingSet, signal_desc: ustring): GLib2.TokenType {.inline.} =
  gtk_binding_entry_add_signal_from_string(myUnsafeAddr(binding_set), ucstring(signal_desc))
# proc gtk_binding_entry_add_signal_from_string*(binding_set: TBindingSet, signal_desc: ustring): GLib2.TokenType {.inline.} =

# gtk_binding_entry_add_signall
# flags: {} container: -
# binding_set 'TBindingSet' 'ptr TBindingSet' IN (diff., need sugar)
# keyval 'uint32' 'uint32' IN
# modifiers 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# signal_name 'ustring' 'ucstring' IN (diff., need sugar)
# binding_args 'ptr GSLIST_TODO' 'ptr GSLIST_TODO' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_binding_entry_add_signall(binding_set: ptr TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType, signal_name: ucstring, binding_args: ptr GSLIST_TODO) {.cdecl, dynlib: lib, importc: "gtk_binding_entry_add_signall".}
proc gtk_binding_entry_add_signall*(binding_set: TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType, signal_name: ustring, binding_args: ptr GSLIST_TODO) {.inline.} =
  gtk_binding_entry_add_signall(myUnsafeAddr(binding_set), keyval, modifiers, ucstring(signal_name), binding_args)
# proc gtk_binding_entry_add_signall*(binding_set: TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType, signal_name: ustring, binding_args: ptr GSLIST_TODO) {.inline.} =

# gtk_binding_entry_remove
# flags: {} container: -
# binding_set 'TBindingSet' 'ptr TBindingSet' IN (diff., need sugar)
# keyval 'uint32' 'uint32' IN
# modifiers 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_binding_entry_remove(binding_set: ptr TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType) {.cdecl, dynlib: lib, importc: "gtk_binding_entry_remove".}
proc gtk_binding_entry_remove*(binding_set: TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType) {.inline.} =
  gtk_binding_entry_remove(myUnsafeAddr(binding_set), keyval, modifiers)
# proc gtk_binding_entry_remove*(binding_set: TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType) {.inline.} =

# gtk_binding_entry_skip
# flags: {} container: -
# binding_set 'TBindingSet' 'ptr TBindingSet' IN (diff., need sugar)
# keyval 'uint32' 'uint32' IN
# modifiers 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_binding_entry_skip(binding_set: ptr TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType) {.cdecl, dynlib: lib, importc: "gtk_binding_entry_skip".}
proc gtk_binding_entry_skip*(binding_set: TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType) {.inline.} =
  gtk_binding_entry_skip(myUnsafeAddr(binding_set), keyval, modifiers)
# proc gtk_binding_entry_skip*(binding_set: TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType) {.inline.} =

# gtk_binding_set_find
# flags: {} container: -
# set_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'TBindingSet' 'ptr TBindingSet' (diff., need sugar)
proc gtk_binding_set_find(set_name: ucstring): ptr TBindingSet {.cdecl, dynlib: lib, importc: "gtk_binding_set_find".}
proc gtk_binding_set_find*(set_name: ustring): TBindingSet {.inline.} =
  (gtk_binding_set_find(ucstring(set_name)))[]
# proc gtk_binding_set_find*(set_name: ustring): TBindingSet {.inline.} =

# gtk_bindings_activate
# flags: {} container: -
# object 'GObject2.Object' 'ptr GObject2.TObject' IN (diff., need sugar)
# keyval 'uint32' 'uint32' IN
# modifiers 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# 'bool' 'bool'
proc gtk_bindings_activate(object_x: ptr GObject2.TObject, keyval: uint32, modifiers: Gdk3.SModifierType): bool {.cdecl, dynlib: lib, importc: "gtk_bindings_activate".}
proc gtk_bindings_activate*(object_x: GObject2.Object, keyval: uint32, modifiers: Gdk3.SModifierType): bool {.inline.} =
  gtk_bindings_activate(object_x.getPointer, keyval, modifiers)
# proc gtk_bindings_activate*(object_x: GObject2.Object, keyval: uint32, modifiers: Gdk3.SModifierType): bool {.inline.} =

# gtk_bindings_activate_event
# flags: {} container: -
# object 'GObject2.Object' 'ptr GObject2.TObject' IN (diff., need sugar)
# event 'Gdk3.TEventKey' 'ptr Gdk3.TEventKey' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_bindings_activate_event(object_x: ptr GObject2.TObject, event: ptr Gdk3.TEventKey): bool {.cdecl, dynlib: lib, importc: "gtk_bindings_activate_event".}
proc gtk_bindings_activate_event*(object_x: GObject2.Object, event: Gdk3.TEventKey): bool {.inline.} =
  gtk_bindings_activate_event(object_x.getPointer, myUnsafeAddr(event))
# proc gtk_bindings_activate_event*(object_x: GObject2.Object, event: Gdk3.TEventKey): bool {.inline.} =

# gtk_builder_error_quark
# flags: {} container: -
# 'uint32' 'uint32'
proc gtk_builder_error_quark*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_builder_error_quark".}
# gtk_cairo_should_draw_window
# flags: {} container: -
# cr 'cairo1.TContext' 'ptr cairo1.TContext' IN (diff., need sugar)
# window 'Gdk3.Window' 'ptr Gdk3.TWindow' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_cairo_should_draw_window(cr: ptr cairo1.TContext, window: ptr Gdk3.TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_cairo_should_draw_window".}
proc gtk_cairo_should_draw_window*(cr: cairo1.TContext, window: Gdk3.Window): bool {.inline.} =
  gtk_cairo_should_draw_window(myUnsafeAddr(cr), window.getPointer)
# proc gtk_cairo_should_draw_window*(cr: cairo1.TContext, window: Gdk3.Window): bool {.inline.} =

# gtk_cairo_transform_to_window
# flags: {} container: -
# cr 'cairo1.TContext' 'ptr cairo1.TContext' IN (diff., need sugar)
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# window 'Gdk3.Window' 'ptr Gdk3.TWindow' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cairo_transform_to_window(cr: ptr cairo1.TContext, widget: ptr TWidget, window: ptr Gdk3.TWindow) {.cdecl, dynlib: lib, importc: "gtk_cairo_transform_to_window".}
proc gtk_cairo_transform_to_window*(cr: cairo1.TContext, widget: Widget, window: Gdk3.Window) {.inline.} =
  gtk_cairo_transform_to_window(myUnsafeAddr(cr), widget.getPointer, window.getPointer)
# proc gtk_cairo_transform_to_window*(cr: cairo1.TContext, widget: Widget, window: Gdk3.Window) {.inline.} =

# gtk_check_version
# flags: {} container: -
# required_major 'uint32' 'uint32' IN
# required_minor 'uint32' 'uint32' IN
# required_micro 'uint32' 'uint32' IN
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_check_version_import(required_major: uint32, required_minor: uint32, required_micro: uint32): ucstring {.cdecl, dynlib: lib, importc: "gtk_check_version".}
proc gtk_check_version*(required_major: uint32, required_minor: uint32, required_micro: uint32): ustring {.inline.} =
  ustring($(gtk_check_version_import(required_major, required_minor, required_micro)))
# proc gtk_check_version*(required_major: uint32, required_minor: uint32, required_micro: uint32): ustring {.inline.} =

# gtk_css_provider_error_quark
# flags: {} container: -
# 'uint32' 'uint32'
proc gtk_css_provider_error_quark*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_css_provider_error_quark".}
# gtk_device_grab_add
# flags: {} container: -
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# device 'Gdk3.Device' 'ptr Gdk3.TDevice' IN (diff., need sugar)
# block_others 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_device_grab_add(widget: ptr TWidget, device: ptr Gdk3.TDevice, block_others: bool) {.cdecl, dynlib: lib, importc: "gtk_device_grab_add".}
proc gtk_device_grab_add*(widget: Widget, device: Gdk3.Device, block_others: bool) {.inline.} =
  gtk_device_grab_add(widget.getPointer, device.getPointer, block_others)
# proc gtk_device_grab_add*(widget: Widget, device: Gdk3.Device, block_others: bool) {.inline.} =

# gtk_device_grab_remove
# flags: {} container: -
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# device 'Gdk3.Device' 'ptr Gdk3.TDevice' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_device_grab_remove(widget: ptr TWidget, device: ptr Gdk3.TDevice) {.cdecl, dynlib: lib, importc: "gtk_device_grab_remove".}
proc gtk_device_grab_remove*(widget: Widget, device: Gdk3.Device) {.inline.} =
  gtk_device_grab_remove(widget.getPointer, device.getPointer)
# proc gtk_device_grab_remove*(widget: Widget, device: Gdk3.Device) {.inline.} =

# gtk_disable_setlocale
# flags: {} container: -
# 'VOID_TODO' 'VOID_TODO'
proc gtk_disable_setlocale*() {.cdecl, dynlib: lib, importc: "gtk_disable_setlocale".}
# gtk_distribute_natural_allocation
# flags: {} container: -
# extra_space 'int32' 'int32' IN
# n_requested_sizes 'uint32' 'uint32' IN
# sizes 'TRequestedSize' 'ptr TRequestedSize' IN (diff., need sugar)
# 'int32' 'int32'
proc gtk_distribute_natural_allocation(extra_space: int32, n_requested_sizes: uint32, sizes: ptr TRequestedSize): int32 {.cdecl, dynlib: lib, importc: "gtk_distribute_natural_allocation".}
proc gtk_distribute_natural_allocation*(extra_space: int32, n_requested_sizes: uint32, sizes: TRequestedSize): int32 {.inline.} =
  gtk_distribute_natural_allocation(extra_space, n_requested_sizes, myUnsafeAddr(sizes))
# proc gtk_distribute_natural_allocation*(extra_space: int32, n_requested_sizes: uint32, sizes: TRequestedSize): int32 {.inline.} =

# gtk_drag_finish
# flags: {} container: -
# context 'Gdk3.DragContext' 'ptr Gdk3.TDragContext' IN (diff., need sugar)
# success 'bool' 'bool' IN
# del 'bool' 'bool' IN
# time_ 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_finish(context: ptr Gdk3.TDragContext, success: bool, del: bool, time_x: uint32) {.cdecl, dynlib: lib, importc: "gtk_drag_finish".}
proc gtk_drag_finish*(context: Gdk3.DragContext, success: bool, del: bool, time_x: uint32) {.inline.} =
  gtk_drag_finish(context.getPointer, success, del, time_x)
# proc gtk_drag_finish*(context: Gdk3.DragContext, success: bool, del: bool, time_x: uint32) {.inline.} =

# gtk_drag_get_source_widget
# flags: {} container: -
# context 'Gdk3.DragContext' 'ptr Gdk3.TDragContext' IN (diff., need sugar)
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_drag_get_source_widget(context: ptr Gdk3.TDragContext): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_drag_get_source_widget".}
proc gtk_drag_get_source_widget*(context: Gdk3.DragContext): Widget {.inline.} =
  wrap(gtk_drag_get_source_widget(context.getPointer))
# proc gtk_drag_get_source_widget*(context: Gdk3.DragContext): Widget {.inline.} =

# gtk_drag_set_icon_default
# flags: {} container: -
# context 'Gdk3.DragContext' 'ptr Gdk3.TDragContext' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_set_icon_default(context: ptr Gdk3.TDragContext) {.cdecl, dynlib: lib, importc: "gtk_drag_set_icon_default".}
proc gtk_drag_set_icon_default*(context: Gdk3.DragContext) {.inline.} =
  gtk_drag_set_icon_default(context.getPointer)
# proc gtk_drag_set_icon_default*(context: Gdk3.DragContext) {.inline.} =

# gtk_drag_set_icon_gicon
# flags: {} container: -
# context 'Gdk3.DragContext' 'ptr Gdk3.TDragContext' IN (diff., need sugar)
# icon 'Gio2.Icon' 'ptr Gio2.TIcon' IN (diff., need sugar)
# hot_x 'int32' 'int32' IN
# hot_y 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_set_icon_gicon(context: ptr Gdk3.TDragContext, icon: ptr Gio2.TIcon, hot_x: int32, hot_y: int32) {.cdecl, dynlib: lib, importc: "gtk_drag_set_icon_gicon".}
proc gtk_drag_set_icon_gicon*(context: Gdk3.DragContext, icon: Gio2.Icon, hot_x: int32, hot_y: int32) {.inline.} =
  gtk_drag_set_icon_gicon(context.getPointer, unwrap(icon), hot_x, hot_y)
# proc gtk_drag_set_icon_gicon*(context: Gdk3.DragContext, icon: Gio2.Icon, hot_x: int32, hot_y: int32) {.inline.} =

# gtk_drag_set_icon_name
# flags: {} container: -
# context 'Gdk3.DragContext' 'ptr Gdk3.TDragContext' IN (diff., need sugar)
# icon_name 'ustring' 'ucstring' IN (diff., need sugar)
# hot_x 'int32' 'int32' IN
# hot_y 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_set_icon_name(context: ptr Gdk3.TDragContext, icon_name: ucstring, hot_x: int32, hot_y: int32) {.cdecl, dynlib: lib, importc: "gtk_drag_set_icon_name".}
proc gtk_drag_set_icon_name*(context: Gdk3.DragContext, icon_name: ustring, hot_x: int32, hot_y: int32) {.inline.} =
  gtk_drag_set_icon_name(context.getPointer, ucstring(icon_name), hot_x, hot_y)
# proc gtk_drag_set_icon_name*(context: Gdk3.DragContext, icon_name: ustring, hot_x: int32, hot_y: int32) {.inline.} =

# gtk_drag_set_icon_pixbuf
# flags: {} container: -
# context 'Gdk3.DragContext' 'ptr Gdk3.TDragContext' IN (diff., need sugar)
# pixbuf 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# hot_x 'int32' 'int32' IN
# hot_y 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_set_icon_pixbuf(context: ptr Gdk3.TDragContext, pixbuf: ptr GdkPixbuf2.TPixbuf, hot_x: int32, hot_y: int32) {.cdecl, dynlib: lib, importc: "gtk_drag_set_icon_pixbuf".}
proc gtk_drag_set_icon_pixbuf*(context: Gdk3.DragContext, pixbuf: GdkPixbuf2.Pixbuf, hot_x: int32, hot_y: int32) {.inline.} =
  gtk_drag_set_icon_pixbuf(context.getPointer, pixbuf.getPointer, hot_x, hot_y)
# proc gtk_drag_set_icon_pixbuf*(context: Gdk3.DragContext, pixbuf: GdkPixbuf2.Pixbuf, hot_x: int32, hot_y: int32) {.inline.} =

# gtk_drag_set_icon_stock
# flags: {} container: - (deprecated)
# gtk_drag_set_icon_surface
# flags: {} container: -
# context 'Gdk3.DragContext' 'ptr Gdk3.TDragContext' IN (diff., need sugar)
# surface 'cairo1.TSurface' 'ptr cairo1.TSurface' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_set_icon_surface(context: ptr Gdk3.TDragContext, surface: ptr cairo1.TSurface) {.cdecl, dynlib: lib, importc: "gtk_drag_set_icon_surface".}
proc gtk_drag_set_icon_surface*(context: Gdk3.DragContext, surface: cairo1.TSurface) {.inline.} =
  gtk_drag_set_icon_surface(context.getPointer, myUnsafeAddr(surface))
# proc gtk_drag_set_icon_surface*(context: Gdk3.DragContext, surface: cairo1.TSurface) {.inline.} =

# gtk_drag_set_icon_widget
# flags: {} container: -
# context 'Gdk3.DragContext' 'ptr Gdk3.TDragContext' IN (diff., need sugar)
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# hot_x 'int32' 'int32' IN
# hot_y 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_set_icon_widget(context: ptr Gdk3.TDragContext, widget: ptr TWidget, hot_x: int32, hot_y: int32) {.cdecl, dynlib: lib, importc: "gtk_drag_set_icon_widget".}
proc gtk_drag_set_icon_widget*(context: Gdk3.DragContext, widget: Widget, hot_x: int32, hot_y: int32) {.inline.} =
  gtk_drag_set_icon_widget(context.getPointer, widget.getPointer, hot_x, hot_y)
# proc gtk_drag_set_icon_widget*(context: Gdk3.DragContext, widget: Widget, hot_x: int32, hot_y: int32) {.inline.} =

# gtk_draw_insertion_cursor
# flags: {} container: - (deprecated)
# gtk_events_pending
# flags: {} container: -
# 'bool' 'bool'
proc gtk_events_pending*(): bool {.cdecl, dynlib: lib, importc: "gtk_events_pending".}
# gtk_false
# flags: {} container: -
# 'bool' 'bool'
proc gtk_false*(): bool {.cdecl, dynlib: lib, importc: "gtk_false".}
# gtk_file_chooser_error_quark
# flags: {} container: -
# 'uint32' 'uint32'
proc gtk_file_chooser_error_quark*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_file_chooser_error_quark".}
# gtk_get_binary_age
# flags: {} container: -
# 'uint32' 'uint32'
proc gtk_get_binary_age*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_get_binary_age".}
# gtk_get_current_event
# flags: {} container: -
# 'Gdk3.TEvent' 'ptr Gdk3.TEvent' (diff., need sugar)
proc gtk_get_current_event_import(): ptr Gdk3.TEvent {.cdecl, dynlib: lib, importc: "gtk_get_current_event".}
proc gtk_get_current_event*(): Gdk3.TEvent {.inline.} =
  (gtk_get_current_event_import())[]
# proc gtk_get_current_event*(): Gdk3.TEvent {.inline.} =

# gtk_get_current_event_device
# flags: {} container: -
# 'Gdk3.Device' 'TransferNone[Gdk3.TDevice]' (diff., need sugar)
proc gtk_get_current_event_device_import(): TransferNone[Gdk3.TDevice] {.cdecl, dynlib: lib, importc: "gtk_get_current_event_device".}
proc gtk_get_current_event_device*(): Gdk3.Device {.inline.} =
  wrap(gtk_get_current_event_device_import())
# proc gtk_get_current_event_device*(): Gdk3.Device {.inline.} =

# gtk_get_current_event_state
# flags: {} container: -
# state 'Gdk3.SModifierType' 'Gdk3.SModifierType' OUT
# 'bool' 'bool'
proc gtk_get_current_event_state*(state: Gdk3.SModifierType): bool {.cdecl, dynlib: lib, importc: "gtk_get_current_event_state".}
# gtk_get_current_event_time
# flags: {} container: -
# 'uint32' 'uint32'
proc gtk_get_current_event_time*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_get_current_event_time".}
# gtk_get_debug_flags
# flags: {} container: -
# 'uint32' 'uint32'
proc gtk_get_debug_flags*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_get_debug_flags".}
# gtk_get_default_language
# flags: {} container: -
# 'Pango1.TLanguage' 'ptr Pango1.TLanguage' (diff., need sugar)
proc gtk_get_default_language_import(): ptr Pango1.TLanguage {.cdecl, dynlib: lib, importc: "gtk_get_default_language".}
proc gtk_get_default_language*(): Pango1.TLanguage {.inline.} =
  (gtk_get_default_language_import())[]
# proc gtk_get_default_language*(): Pango1.TLanguage {.inline.} =

# gtk_get_event_widget
# flags: {} container: -
# event 'Gdk3.TEvent' 'ptr Gdk3.TEvent' IN (diff., need sugar)
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_get_event_widget(event: ptr Gdk3.TEvent): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_get_event_widget".}
proc gtk_get_event_widget*(event: Gdk3.TEvent): Widget {.inline.} =
  wrap(gtk_get_event_widget(myUnsafeAddr(event)))
# proc gtk_get_event_widget*(event: Gdk3.TEvent): Widget {.inline.} =

# gtk_get_interface_age
# flags: {} container: -
# 'uint32' 'uint32'
proc gtk_get_interface_age*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_get_interface_age".}
# gtk_get_locale_direction
# flags: {} container: -
# 'TextDirection' 'TextDirection'
proc gtk_get_locale_direction*(): TextDirection {.cdecl, dynlib: lib, importc: "gtk_get_locale_direction".}
# gtk_get_major_version
# flags: {} container: -
# 'uint32' 'uint32'
proc gtk_get_major_version*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_get_major_version".}
# gtk_get_micro_version
# flags: {} container: -
# 'uint32' 'uint32'
proc gtk_get_micro_version*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_get_micro_version".}
# gtk_get_minor_version
# flags: {} container: -
# 'uint32' 'uint32'
proc gtk_get_minor_version*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_get_minor_version".}
# gtk_grab_get_current
# flags: {} container: -
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_grab_get_current_import(): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_grab_get_current".}
proc gtk_grab_get_current*(): Widget {.inline.} =
  wrap(gtk_grab_get_current_import())
# proc gtk_grab_get_current*(): Widget {.inline.} =

# gtk_icon_size_from_name
# flags: {} container: - (deprecated)
# gtk_icon_size_get_name
# flags: {} container: - (deprecated)
# gtk_icon_size_lookup
# flags: {} container: -
# size 'int32' 'int32' IN
# width 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# height 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'bool' 'bool'
proc gtk_icon_size_lookup(size: int32, width: ptr int32, height: ptr int32): bool {.cdecl, dynlib: lib, importc: "gtk_icon_size_lookup".}
proc gtk_icon_size_lookup*(size: int32, width: var int32, height: var int32): bool {.inline.} =
  gtk_icon_size_lookup(size, addr(width), addr(height))
# tuple-return
# width: var int32
# height: var int32
# proc gtk_icon_size_lookup*(size: int32): bool {.inline.} =

# gtk_icon_size_lookup_for_settings
# flags: {} container: - (deprecated)
# gtk_icon_size_register
# flags: {} container: - (deprecated)
# gtk_icon_size_register_alias
# flags: {} container: - (deprecated)
# gtk_icon_theme_error_quark
# flags: {} container: -
# 'uint32' 'uint32'
proc gtk_icon_theme_error_quark*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_icon_theme_error_quark".}
# gtk_init
# flags: {} container: -
# argc 'var int32' 'ptr int32' INOUT (diff., need sugar)
# argv 'var uncheckedArray[ucstring]' 'var uncheckedArray[ucstring]' INOUT array lengthArg: 0 optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_init(argc: ptr int32, argv: var uncheckedArray[ucstring]) {.cdecl, dynlib: lib, importc: "gtk_init".}
proc gtk_init*(argc: var int32, argv: var uncheckedArray[ucstring]) {.inline.} =
  gtk_init(addr(argc), argv)
# proc gtk_init*(argc: var int32, argv: var uncheckedArray[ucstring]) {.inline.} =

# gtk_init_abi_check
# flags: {} container: -
# argc 'ptr int32' 'ptr int32' IN
# argv 'ustring' 'ucstring' IN (diff., need sugar)
# num_checks 'int32' 'int32' IN
# sizeof_GtkWindow 'uint32' 'uint32' IN
# sizeof_GtkBox 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_init_abi_check(argc: ptr int32, argv: ucstring, num_checks: int32, sizeof_GtkWindow: uint32, sizeof_GtkBox: uint32) {.cdecl, dynlib: lib, importc: "gtk_init_abi_check".}
proc gtk_init_abi_check*(argc: ptr int32, argv: ustring, num_checks: int32, sizeof_GtkWindow: uint32, sizeof_GtkBox: uint32) {.inline.} =
  gtk_init_abi_check(argc, ucstring(argv), num_checks, sizeof_GtkWindow, sizeof_GtkBox)
# proc gtk_init_abi_check*(argc: ptr int32, argv: ustring, num_checks: int32, sizeof_GtkWindow: uint32, sizeof_GtkBox: uint32) {.inline.} =

# gtk_init_check
# flags: {} container: -
# argc 'var int32' 'ptr int32' INOUT (diff., need sugar)
# argv 'var uncheckedArray[ucstring]' 'var uncheckedArray[ucstring]' INOUT array lengthArg: 0 optional
# 'bool' 'bool'
proc gtk_init_check(argc: ptr int32, argv: var uncheckedArray[ucstring]): bool {.cdecl, dynlib: lib, importc: "gtk_init_check".}
proc gtk_init_check*(argc: var int32, argv: var uncheckedArray[ucstring]): bool {.inline.} =
  gtk_init_check(addr(argc), argv)
# proc gtk_init_check*(argc: var int32, argv: var uncheckedArray[ucstring]): bool {.inline.} =

# gtk_init_check_abi_check
# flags: {} container: -
# argc 'ptr int32' 'ptr int32' IN
# argv 'ustring' 'ucstring' IN (diff., need sugar)
# num_checks 'int32' 'int32' IN
# sizeof_GtkWindow 'uint32' 'uint32' IN
# sizeof_GtkBox 'uint32' 'uint32' IN
# 'bool' 'bool'
proc gtk_init_check_abi_check(argc: ptr int32, argv: ucstring, num_checks: int32, sizeof_GtkWindow: uint32, sizeof_GtkBox: uint32): bool {.cdecl, dynlib: lib, importc: "gtk_init_check_abi_check".}
proc gtk_init_check_abi_check*(argc: ptr int32, argv: ustring, num_checks: int32, sizeof_GtkWindow: uint32, sizeof_GtkBox: uint32): bool {.inline.} =
  gtk_init_check_abi_check(argc, ucstring(argv), num_checks, sizeof_GtkWindow, sizeof_GtkBox)
# proc gtk_init_check_abi_check*(argc: ptr int32, argv: ustring, num_checks: int32, sizeof_GtkWindow: uint32, sizeof_GtkBox: uint32): bool {.inline.} =

# gtk_init_with_args
# flags: {throws} container: -
# can throw
# argc 'var int32' 'ptr int32' INOUT (diff., need sugar)
# argv 'var uncheckedArray[ucstring]' 'var uncheckedArray[ucstring]' INOUT array lengthArg: 0 optional
# parameter_string 'ustring' 'ucstring' IN (diff., need sugar)
# entries 'uncheckedArray[GLib2.TOptionEntry]' 'uncheckedArray[GLib2.TOptionEntry]' IN array zero-terminated
# translation_domain 'ustring' 'ucstring' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_init_with_args(argc: ptr int32, argv: var uncheckedArray[ucstring], parameter_string: ucstring, entries: uncheckedArray[GLib2.TOptionEntry], translation_domain: ucstring, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_init_with_args".}
proc gtk_init_with_args*(argc: var int32, argv: var uncheckedArray[ucstring], parameter_string: ustring, entries: uncheckedArray[GLib2.TOptionEntry], translation_domain: ustring): bool {.inline.} =
  gtk_init_with_args(addr(argc), argv, ucstring(parameter_string), entries, ucstring(translation_domain))
# proc gtk_init_with_args*(argc: var int32, argv: var uncheckedArray[ucstring], parameter_string: ustring, entries: uncheckedArray[GLib2.TOptionEntry], translation_domain: ustring): bool {.inline.} =

# gtk_key_snooper_remove
# flags: {} container: - (deprecated)
# gtk_main
# flags: {} container: -
# 'VOID_TODO' 'VOID_TODO'
proc gtk_main*() {.cdecl, dynlib: lib, importc: "gtk_main".}
# gtk_main_do_event
# flags: {} container: -
# event 'Gdk3.TEvent' 'ptr Gdk3.TEvent' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_main_do_event(event: ptr Gdk3.TEvent) {.cdecl, dynlib: lib, importc: "gtk_main_do_event".}
proc gtk_main_do_event*(event: Gdk3.TEvent) {.inline.} =
  gtk_main_do_event(myUnsafeAddr(event))
# proc gtk_main_do_event*(event: Gdk3.TEvent) {.inline.} =

# gtk_main_iteration
# flags: {} container: -
# 'bool' 'bool'
proc gtk_main_iteration*(): bool {.cdecl, dynlib: lib, importc: "gtk_main_iteration".}
# gtk_main_iteration_do
# flags: {} container: -
# blocking 'bool' 'bool' IN
# 'bool' 'bool'
proc gtk_main_iteration_do*(blocking: bool): bool {.cdecl, dynlib: lib, importc: "gtk_main_iteration_do".}
# gtk_main_level
# flags: {} container: -
# 'uint32' 'uint32'
proc gtk_main_level*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_main_level".}
# gtk_main_quit
# flags: {} container: -
# 'VOID_TODO' 'VOID_TODO'
proc gtk_main_quit*() {.cdecl, dynlib: lib, importc: "gtk_main_quit".}
# gtk_paint_arrow
# flags: {} container: - (deprecated)
# gtk_paint_box
# flags: {} container: - (deprecated)
# gtk_paint_box_gap
# flags: {} container: - (deprecated)
# gtk_paint_check
# flags: {} container: - (deprecated)
# gtk_paint_diamond
# flags: {} container: - (deprecated)
# gtk_paint_expander
# flags: {} container: - (deprecated)
# gtk_paint_extension
# flags: {} container: - (deprecated)
# gtk_paint_flat_box
# flags: {} container: - (deprecated)
# gtk_paint_focus
# flags: {} container: - (deprecated)
# gtk_paint_handle
# flags: {} container: - (deprecated)
# gtk_paint_hline
# flags: {} container: - (deprecated)
# gtk_paint_layout
# flags: {} container: - (deprecated)
# gtk_paint_option
# flags: {} container: - (deprecated)
# gtk_paint_resize_grip
# flags: {} container: - (deprecated)
# gtk_paint_shadow
# flags: {} container: - (deprecated)
# gtk_paint_shadow_gap
# flags: {} container: - (deprecated)
# gtk_paint_slider
# flags: {} container: - (deprecated)
# gtk_paint_spinner
# flags: {} container: - (deprecated)
# gtk_paint_tab
# flags: {} container: - (deprecated)
# gtk_paint_vline
# flags: {} container: - (deprecated)
# gtk_paper_size_get_default
# flags: {} container: -
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_paper_size_get_default_import(): ucstring {.cdecl, dynlib: lib, importc: "gtk_paper_size_get_default".}
proc gtk_paper_size_get_default*(): ustring {.inline.} =
  ustring($(gtk_paper_size_get_default_import()))
# proc gtk_paper_size_get_default*(): ustring {.inline.} =

# gtk_paper_size_get_paper_sizes
# flags: {} container: -
# include_custom 'bool' 'bool' IN
# 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_paper_size_get_paper_sizes*(include_custom: bool): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_paper_size_get_paper_sizes".}
# gtk_parse_args
# flags: {} container: -
# argc 'var int32' 'ptr int32' INOUT (diff., need sugar)
# argv 'var uncheckedArray[ucstring]' 'var uncheckedArray[ucstring]' INOUT array lengthArg: 0
# 'bool' 'bool'
proc gtk_parse_args(argc: ptr int32, argv: var uncheckedArray[ucstring]): bool {.cdecl, dynlib: lib, importc: "gtk_parse_args".}
proc gtk_parse_args*(argc: var int32, argv: var uncheckedArray[ucstring]): bool {.inline.} =
  gtk_parse_args(addr(argc), argv)
# proc gtk_parse_args*(argc: var int32, argv: var uncheckedArray[ucstring]): bool {.inline.} =

# gtk_print_error_quark
# flags: {} container: -
# 'uint32' 'uint32'
proc gtk_print_error_quark*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_print_error_quark".}
# gtk_print_run_page_setup_dialog
# flags: {} container: -
# parent 'Window' 'ptr TWindow' IN (diff., need sugar)
# page_setup 'PageSetup' 'ptr TPageSetup' IN (diff., need sugar)
# settings 'PrintSettings' 'ptr TPrintSettings' IN (diff., need sugar)
# 'PageSetup' 'TransferFull[TPageSetup]' (diff., need sugar)
proc gtk_print_run_page_setup_dialog(parent: ptr TWindow, page_setup: ptr TPageSetup, settings: ptr TPrintSettings): TransferFull[TPageSetup] {.cdecl, dynlib: lib, importc: "gtk_print_run_page_setup_dialog".}
proc gtk_print_run_page_setup_dialog*(parent: Window, page_setup: PageSetup, settings: PrintSettings): PageSetup {.inline.} =
  wrap(gtk_print_run_page_setup_dialog(parent.getPointer, page_setup.getPointer, settings.getPointer))
# proc gtk_print_run_page_setup_dialog*(parent: Window, page_setup: PageSetup, settings: PrintSettings): PageSetup {.inline.} =

# gtk_print_run_page_setup_dialog_async
# flags: {} container: -
# parent 'Window' 'ptr TWindow' IN (diff., need sugar)
# page_setup 'PageSetup' 'ptr TPageSetup' IN (diff., need sugar)
# settings 'PrintSettings' 'ptr TPrintSettings' IN (diff., need sugar)
# done_cb 'pointer' 'pointer' IN
# data 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_run_page_setup_dialog_async(parent: ptr TWindow, page_setup: ptr TPageSetup, settings: ptr TPrintSettings, done_cb: pointer, data: pointer) {.cdecl, dynlib: lib, importc: "gtk_print_run_page_setup_dialog_async".}
proc gtk_print_run_page_setup_dialog_async*(parent: Window, page_setup: PageSetup, settings: PrintSettings, done_cb: pointer, data: pointer) {.inline.} =
  gtk_print_run_page_setup_dialog_async(parent.getPointer, page_setup.getPointer, settings.getPointer, done_cb, data)
# proc gtk_print_run_page_setup_dialog_async*(parent: Window, page_setup: PageSetup, settings: PrintSettings, done_cb: pointer, data: pointer) {.inline.} =

# gtk_propagate_event
# flags: {} container: -
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# event 'Gdk3.TEvent' 'ptr Gdk3.TEvent' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_propagate_event(widget: ptr TWidget, event: ptr Gdk3.TEvent) {.cdecl, dynlib: lib, importc: "gtk_propagate_event".}
proc gtk_propagate_event*(widget: Widget, event: Gdk3.TEvent) {.inline.} =
  gtk_propagate_event(widget.getPointer, myUnsafeAddr(event))
# proc gtk_propagate_event*(widget: Widget, event: Gdk3.TEvent) {.inline.} =

# gtk_rc_add_default_file
# flags: {} container: - (deprecated)
# gtk_rc_find_module_in_path
# flags: {} container: - (deprecated)
# gtk_rc_find_pixmap_in_path
# flags: {} container: - (deprecated)
# gtk_rc_get_default_files
# flags: {} container: - (deprecated)
# gtk_rc_get_im_module_file
# flags: {} container: - (deprecated)
# gtk_rc_get_im_module_path
# flags: {} container: - (deprecated)
# gtk_rc_get_module_dir
# flags: {} container: - (deprecated)
# gtk_rc_get_style
# flags: {} container: - (deprecated)
# gtk_rc_get_style_by_paths
# flags: {} container: - (deprecated)
# gtk_rc_get_theme_dir
# flags: {} container: - (deprecated)
# gtk_rc_parse
# flags: {} container: - (deprecated)
# gtk_rc_parse_color
# flags: {} container: - (deprecated)
# gtk_rc_parse_color_full
# flags: {} container: - (deprecated)
# gtk_rc_parse_priority
# flags: {} container: - (deprecated)
# gtk_rc_parse_state
# flags: {} container: - (deprecated)
# gtk_rc_parse_string
# flags: {} container: - (deprecated)
# gtk_rc_property_parse_border
# flags: {} container: -
# pspec 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# gstring 'GLib2.TString' 'ptr GLib2.TString' IN (diff., need sugar)
# property_value 'GObject2.TValue' 'ptr GObject2.TValue' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_rc_property_parse_border(pspec: ptr GObject2.TParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.cdecl, dynlib: lib, importc: "gtk_rc_property_parse_border".}
proc gtk_rc_property_parse_border*(pspec: GObject2.ParamSpec, gstring: GLib2.TString, property_value: GObject2.TValue): bool {.inline.} =
  gtk_rc_property_parse_border(pspec.getPointer, myUnsafeAddr(gstring), myUnsafeAddr(property_value))
# proc gtk_rc_property_parse_border*(pspec: GObject2.ParamSpec, gstring: GLib2.TString, property_value: GObject2.TValue): bool {.inline.} =

# gtk_rc_property_parse_color
# flags: {} container: -
# pspec 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# gstring 'GLib2.TString' 'ptr GLib2.TString' IN (diff., need sugar)
# property_value 'GObject2.TValue' 'ptr GObject2.TValue' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_rc_property_parse_color(pspec: ptr GObject2.TParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.cdecl, dynlib: lib, importc: "gtk_rc_property_parse_color".}
proc gtk_rc_property_parse_color*(pspec: GObject2.ParamSpec, gstring: GLib2.TString, property_value: GObject2.TValue): bool {.inline.} =
  gtk_rc_property_parse_color(pspec.getPointer, myUnsafeAddr(gstring), myUnsafeAddr(property_value))
# proc gtk_rc_property_parse_color*(pspec: GObject2.ParamSpec, gstring: GLib2.TString, property_value: GObject2.TValue): bool {.inline.} =

# gtk_rc_property_parse_enum
# flags: {} container: -
# pspec 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# gstring 'GLib2.TString' 'ptr GLib2.TString' IN (diff., need sugar)
# property_value 'GObject2.TValue' 'ptr GObject2.TValue' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_rc_property_parse_enum(pspec: ptr GObject2.TParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.cdecl, dynlib: lib, importc: "gtk_rc_property_parse_enum".}
proc gtk_rc_property_parse_enum*(pspec: GObject2.ParamSpec, gstring: GLib2.TString, property_value: GObject2.TValue): bool {.inline.} =
  gtk_rc_property_parse_enum(pspec.getPointer, myUnsafeAddr(gstring), myUnsafeAddr(property_value))
# proc gtk_rc_property_parse_enum*(pspec: GObject2.ParamSpec, gstring: GLib2.TString, property_value: GObject2.TValue): bool {.inline.} =

# gtk_rc_property_parse_flags
# flags: {} container: -
# pspec 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# gstring 'GLib2.TString' 'ptr GLib2.TString' IN (diff., need sugar)
# property_value 'GObject2.TValue' 'ptr GObject2.TValue' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_rc_property_parse_flags(pspec: ptr GObject2.TParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.cdecl, dynlib: lib, importc: "gtk_rc_property_parse_flags".}
proc gtk_rc_property_parse_flags*(pspec: GObject2.ParamSpec, gstring: GLib2.TString, property_value: GObject2.TValue): bool {.inline.} =
  gtk_rc_property_parse_flags(pspec.getPointer, myUnsafeAddr(gstring), myUnsafeAddr(property_value))
# proc gtk_rc_property_parse_flags*(pspec: GObject2.ParamSpec, gstring: GLib2.TString, property_value: GObject2.TValue): bool {.inline.} =

# gtk_rc_property_parse_requisition
# flags: {} container: -
# pspec 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# gstring 'GLib2.TString' 'ptr GLib2.TString' IN (diff., need sugar)
# property_value 'GObject2.TValue' 'ptr GObject2.TValue' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_rc_property_parse_requisition(pspec: ptr GObject2.TParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.cdecl, dynlib: lib, importc: "gtk_rc_property_parse_requisition".}
proc gtk_rc_property_parse_requisition*(pspec: GObject2.ParamSpec, gstring: GLib2.TString, property_value: GObject2.TValue): bool {.inline.} =
  gtk_rc_property_parse_requisition(pspec.getPointer, myUnsafeAddr(gstring), myUnsafeAddr(property_value))
# proc gtk_rc_property_parse_requisition*(pspec: GObject2.ParamSpec, gstring: GLib2.TString, property_value: GObject2.TValue): bool {.inline.} =

# gtk_rc_reparse_all
# flags: {} container: - (deprecated)
# gtk_rc_reparse_all_for_settings
# flags: {} container: - (deprecated)
# gtk_rc_reset_styles
# flags: {} container: - (deprecated)
# gtk_rc_set_default_files
# flags: {} container: - (deprecated)
# gtk_recent_chooser_error_quark
# flags: {} container: -
# 'uint32' 'uint32'
proc gtk_recent_chooser_error_quark*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_recent_chooser_error_quark".}
# gtk_recent_manager_error_quark
# flags: {} container: -
# 'uint32' 'uint32'
proc gtk_recent_manager_error_quark*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_recent_manager_error_quark".}
# gtk_render_activity
# flags: {} container: -
# context 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# cr 'cairo1.TContext' 'ptr cairo1.TContext' IN (diff., need sugar)
# x 'float64' 'float64' IN
# y 'float64' 'float64' IN
# width 'float64' 'float64' IN
# height 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_render_activity(context: ptr TStyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.cdecl, dynlib: lib, importc: "gtk_render_activity".}
proc gtk_render_activity*(context: StyleContext, cr: cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =
  gtk_render_activity(context.getPointer, myUnsafeAddr(cr), x, y, width, height)
# proc gtk_render_activity*(context: StyleContext, cr: cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =

# gtk_render_arrow
# flags: {} container: -
# context 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# cr 'cairo1.TContext' 'ptr cairo1.TContext' IN (diff., need sugar)
# angle 'float64' 'float64' IN
# x 'float64' 'float64' IN
# y 'float64' 'float64' IN
# size 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_render_arrow(context: ptr TStyleContext, cr: ptr cairo1.TContext, angle: float64, x: float64, y: float64, size: float64) {.cdecl, dynlib: lib, importc: "gtk_render_arrow".}
proc gtk_render_arrow*(context: StyleContext, cr: cairo1.TContext, angle: float64, x: float64, y: float64, size: float64) {.inline.} =
  gtk_render_arrow(context.getPointer, myUnsafeAddr(cr), angle, x, y, size)
# proc gtk_render_arrow*(context: StyleContext, cr: cairo1.TContext, angle: float64, x: float64, y: float64, size: float64) {.inline.} =

# gtk_render_background
# flags: {} container: -
# context 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# cr 'cairo1.TContext' 'ptr cairo1.TContext' IN (diff., need sugar)
# x 'float64' 'float64' IN
# y 'float64' 'float64' IN
# width 'float64' 'float64' IN
# height 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_render_background(context: ptr TStyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.cdecl, dynlib: lib, importc: "gtk_render_background".}
proc gtk_render_background*(context: StyleContext, cr: cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =
  gtk_render_background(context.getPointer, myUnsafeAddr(cr), x, y, width, height)
# proc gtk_render_background*(context: StyleContext, cr: cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =

# gtk_render_check
# flags: {} container: -
# context 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# cr 'cairo1.TContext' 'ptr cairo1.TContext' IN (diff., need sugar)
# x 'float64' 'float64' IN
# y 'float64' 'float64' IN
# width 'float64' 'float64' IN
# height 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_render_check(context: ptr TStyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.cdecl, dynlib: lib, importc: "gtk_render_check".}
proc gtk_render_check*(context: StyleContext, cr: cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =
  gtk_render_check(context.getPointer, myUnsafeAddr(cr), x, y, width, height)
# proc gtk_render_check*(context: StyleContext, cr: cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =

# gtk_render_expander
# flags: {} container: -
# context 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# cr 'cairo1.TContext' 'ptr cairo1.TContext' IN (diff., need sugar)
# x 'float64' 'float64' IN
# y 'float64' 'float64' IN
# width 'float64' 'float64' IN
# height 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_render_expander(context: ptr TStyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.cdecl, dynlib: lib, importc: "gtk_render_expander".}
proc gtk_render_expander*(context: StyleContext, cr: cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =
  gtk_render_expander(context.getPointer, myUnsafeAddr(cr), x, y, width, height)
# proc gtk_render_expander*(context: StyleContext, cr: cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =

# gtk_render_extension
# flags: {} container: -
# context 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# cr 'cairo1.TContext' 'ptr cairo1.TContext' IN (diff., need sugar)
# x 'float64' 'float64' IN
# y 'float64' 'float64' IN
# width 'float64' 'float64' IN
# height 'float64' 'float64' IN
# gap_side 'PositionType' 'PositionType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_render_extension(context: ptr TStyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64, gap_side: PositionType) {.cdecl, dynlib: lib, importc: "gtk_render_extension".}
proc gtk_render_extension*(context: StyleContext, cr: cairo1.TContext, x: float64, y: float64, width: float64, height: float64, gap_side: PositionType) {.inline.} =
  gtk_render_extension(context.getPointer, myUnsafeAddr(cr), x, y, width, height, gap_side)
# proc gtk_render_extension*(context: StyleContext, cr: cairo1.TContext, x: float64, y: float64, width: float64, height: float64, gap_side: PositionType) {.inline.} =

# gtk_render_focus
# flags: {} container: -
# context 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# cr 'cairo1.TContext' 'ptr cairo1.TContext' IN (diff., need sugar)
# x 'float64' 'float64' IN
# y 'float64' 'float64' IN
# width 'float64' 'float64' IN
# height 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_render_focus(context: ptr TStyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.cdecl, dynlib: lib, importc: "gtk_render_focus".}
proc gtk_render_focus*(context: StyleContext, cr: cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =
  gtk_render_focus(context.getPointer, myUnsafeAddr(cr), x, y, width, height)
# proc gtk_render_focus*(context: StyleContext, cr: cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =

# gtk_render_frame
# flags: {} container: -
# context 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# cr 'cairo1.TContext' 'ptr cairo1.TContext' IN (diff., need sugar)
# x 'float64' 'float64' IN
# y 'float64' 'float64' IN
# width 'float64' 'float64' IN
# height 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_render_frame(context: ptr TStyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.cdecl, dynlib: lib, importc: "gtk_render_frame".}
proc gtk_render_frame*(context: StyleContext, cr: cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =
  gtk_render_frame(context.getPointer, myUnsafeAddr(cr), x, y, width, height)
# proc gtk_render_frame*(context: StyleContext, cr: cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =

# gtk_render_frame_gap
# flags: {} container: -
# context 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# cr 'cairo1.TContext' 'ptr cairo1.TContext' IN (diff., need sugar)
# x 'float64' 'float64' IN
# y 'float64' 'float64' IN
# width 'float64' 'float64' IN
# height 'float64' 'float64' IN
# gap_side 'PositionType' 'PositionType' IN
# xy0_gap 'float64' 'float64' IN
# xy1_gap 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_render_frame_gap(context: ptr TStyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64, gap_side: PositionType, xy0_gap: float64, xy1_gap: float64) {.cdecl, dynlib: lib, importc: "gtk_render_frame_gap".}
proc gtk_render_frame_gap*(context: StyleContext, cr: cairo1.TContext, x: float64, y: float64, width: float64, height: float64, gap_side: PositionType, xy0_gap: float64, xy1_gap: float64) {.inline.} =
  gtk_render_frame_gap(context.getPointer, myUnsafeAddr(cr), x, y, width, height, gap_side, xy0_gap, xy1_gap)
# proc gtk_render_frame_gap*(context: StyleContext, cr: cairo1.TContext, x: float64, y: float64, width: float64, height: float64, gap_side: PositionType, xy0_gap: float64, xy1_gap: float64) {.inline.} =

# gtk_render_handle
# flags: {} container: -
# context 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# cr 'cairo1.TContext' 'ptr cairo1.TContext' IN (diff., need sugar)
# x 'float64' 'float64' IN
# y 'float64' 'float64' IN
# width 'float64' 'float64' IN
# height 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_render_handle(context: ptr TStyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.cdecl, dynlib: lib, importc: "gtk_render_handle".}
proc gtk_render_handle*(context: StyleContext, cr: cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =
  gtk_render_handle(context.getPointer, myUnsafeAddr(cr), x, y, width, height)
# proc gtk_render_handle*(context: StyleContext, cr: cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =

# gtk_render_icon
# flags: {} container: -
# context 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# cr 'cairo1.TContext' 'ptr cairo1.TContext' IN (diff., need sugar)
# pixbuf 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# x 'float64' 'float64' IN
# y 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_render_icon(context: ptr TStyleContext, cr: ptr cairo1.TContext, pixbuf: ptr GdkPixbuf2.TPixbuf, x: float64, y: float64) {.cdecl, dynlib: lib, importc: "gtk_render_icon".}
proc gtk_render_icon*(context: StyleContext, cr: cairo1.TContext, pixbuf: GdkPixbuf2.Pixbuf, x: float64, y: float64) {.inline.} =
  gtk_render_icon(context.getPointer, myUnsafeAddr(cr), pixbuf.getPointer, x, y)
# proc gtk_render_icon*(context: StyleContext, cr: cairo1.TContext, pixbuf: GdkPixbuf2.Pixbuf, x: float64, y: float64) {.inline.} =

# gtk_render_icon_pixbuf
# flags: {} container: - (deprecated)
# gtk_render_icon_surface
# flags: {} container: -
# context 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# cr 'cairo1.TContext' 'ptr cairo1.TContext' IN (diff., need sugar)
# surface 'cairo1.TSurface' 'ptr cairo1.TSurface' IN (diff., need sugar)
# x 'float64' 'float64' IN
# y 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_render_icon_surface(context: ptr TStyleContext, cr: ptr cairo1.TContext, surface: ptr cairo1.TSurface, x: float64, y: float64) {.cdecl, dynlib: lib, importc: "gtk_render_icon_surface".}
proc gtk_render_icon_surface*(context: StyleContext, cr: cairo1.TContext, surface: cairo1.TSurface, x: float64, y: float64) {.inline.} =
  gtk_render_icon_surface(context.getPointer, myUnsafeAddr(cr), myUnsafeAddr(surface), x, y)
# proc gtk_render_icon_surface*(context: StyleContext, cr: cairo1.TContext, surface: cairo1.TSurface, x: float64, y: float64) {.inline.} =

# gtk_render_insertion_cursor
# flags: {} container: -
# context 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# cr 'cairo1.TContext' 'ptr cairo1.TContext' IN (diff., need sugar)
# x 'float64' 'float64' IN
# y 'float64' 'float64' IN
# layout 'Pango1.Layout' 'ptr Pango1.TLayout' IN (diff., need sugar)
# index 'int32' 'int32' IN
# direction 'Pango1.Direction' 'Pango1.Direction' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_render_insertion_cursor(context: ptr TStyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, layout: ptr Pango1.TLayout, index: int32, direction: Pango1.Direction) {.cdecl, dynlib: lib, importc: "gtk_render_insertion_cursor".}
proc gtk_render_insertion_cursor*(context: StyleContext, cr: cairo1.TContext, x: float64, y: float64, layout: Pango1.Layout, index: int32, direction: Pango1.Direction) {.inline.} =
  gtk_render_insertion_cursor(context.getPointer, myUnsafeAddr(cr), x, y, layout.getPointer, index, direction)
# proc gtk_render_insertion_cursor*(context: StyleContext, cr: cairo1.TContext, x: float64, y: float64, layout: Pango1.Layout, index: int32, direction: Pango1.Direction) {.inline.} =

# gtk_render_layout
# flags: {} container: -
# context 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# cr 'cairo1.TContext' 'ptr cairo1.TContext' IN (diff., need sugar)
# x 'float64' 'float64' IN
# y 'float64' 'float64' IN
# layout 'Pango1.Layout' 'ptr Pango1.TLayout' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_render_layout(context: ptr TStyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, layout: ptr Pango1.TLayout) {.cdecl, dynlib: lib, importc: "gtk_render_layout".}
proc gtk_render_layout*(context: StyleContext, cr: cairo1.TContext, x: float64, y: float64, layout: Pango1.Layout) {.inline.} =
  gtk_render_layout(context.getPointer, myUnsafeAddr(cr), x, y, layout.getPointer)
# proc gtk_render_layout*(context: StyleContext, cr: cairo1.TContext, x: float64, y: float64, layout: Pango1.Layout) {.inline.} =

# gtk_render_line
# flags: {} container: -
# context 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# cr 'cairo1.TContext' 'ptr cairo1.TContext' IN (diff., need sugar)
# x0 'float64' 'float64' IN
# y0 'float64' 'float64' IN
# x1 'float64' 'float64' IN
# y1 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_render_line(context: ptr TStyleContext, cr: ptr cairo1.TContext, x0: float64, y0: float64, x1: float64, y1: float64) {.cdecl, dynlib: lib, importc: "gtk_render_line".}
proc gtk_render_line*(context: StyleContext, cr: cairo1.TContext, x0: float64, y0: float64, x1: float64, y1: float64) {.inline.} =
  gtk_render_line(context.getPointer, myUnsafeAddr(cr), x0, y0, x1, y1)
# proc gtk_render_line*(context: StyleContext, cr: cairo1.TContext, x0: float64, y0: float64, x1: float64, y1: float64) {.inline.} =

# gtk_render_option
# flags: {} container: -
# context 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# cr 'cairo1.TContext' 'ptr cairo1.TContext' IN (diff., need sugar)
# x 'float64' 'float64' IN
# y 'float64' 'float64' IN
# width 'float64' 'float64' IN
# height 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_render_option(context: ptr TStyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.cdecl, dynlib: lib, importc: "gtk_render_option".}
proc gtk_render_option*(context: StyleContext, cr: cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =
  gtk_render_option(context.getPointer, myUnsafeAddr(cr), x, y, width, height)
# proc gtk_render_option*(context: StyleContext, cr: cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =

# gtk_render_slider
# flags: {} container: -
# context 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# cr 'cairo1.TContext' 'ptr cairo1.TContext' IN (diff., need sugar)
# x 'float64' 'float64' IN
# y 'float64' 'float64' IN
# width 'float64' 'float64' IN
# height 'float64' 'float64' IN
# orientation 'Orientation' 'Orientation' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_render_slider(context: ptr TStyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64, orientation: Orientation) {.cdecl, dynlib: lib, importc: "gtk_render_slider".}
proc gtk_render_slider*(context: StyleContext, cr: cairo1.TContext, x: float64, y: float64, width: float64, height: float64, orientation: Orientation) {.inline.} =
  gtk_render_slider(context.getPointer, myUnsafeAddr(cr), x, y, width, height, orientation)
# proc gtk_render_slider*(context: StyleContext, cr: cairo1.TContext, x: float64, y: float64, width: float64, height: float64, orientation: Orientation) {.inline.} =

# gtk_rgb_to_hsv
# flags: {} container: -
# r 'float64' 'float64' IN
# g 'float64' 'float64' IN
# b 'float64' 'float64' IN
# h 'var float64' 'ptr float64' OUT (diff., need sugar)
# s 'var float64' 'ptr float64' OUT (diff., need sugar)
# v 'var float64' 'ptr float64' OUT (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_rgb_to_hsv(r: float64, g: float64, b: float64, h: ptr float64, s: ptr float64, v: ptr float64) {.cdecl, dynlib: lib, importc: "gtk_rgb_to_hsv".}
proc gtk_rgb_to_hsv*(r: float64, g: float64, b: float64, h: var float64, s: var float64, v: var float64) {.inline.} =
  gtk_rgb_to_hsv(r, g, b, addr(h), addr(s), addr(v))
# tuple-return
# h: var float64
# s: var float64
# v: var float64
# proc gtk_rgb_to_hsv*(r: float64, g: float64, b: float64) {.inline.} =

# gtk_selection_add_target
# flags: {} container: -
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# selection 'Gdk3.TAtom' 'ptr Gdk3.TAtom' IN (diff., need sugar)
# target 'Gdk3.TAtom' 'ptr Gdk3.TAtom' IN (diff., need sugar)
# info 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_selection_add_target(widget: ptr TWidget, selection: ptr Gdk3.TAtom, target: ptr Gdk3.TAtom, info: uint32) {.cdecl, dynlib: lib, importc: "gtk_selection_add_target".}
proc gtk_selection_add_target*(widget: Widget, selection: Gdk3.TAtom, target: Gdk3.TAtom, info: uint32) {.inline.} =
  gtk_selection_add_target(widget.getPointer, myUnsafeAddr(selection), myUnsafeAddr(target), info)
# proc gtk_selection_add_target*(widget: Widget, selection: Gdk3.TAtom, target: Gdk3.TAtom, info: uint32) {.inline.} =

# gtk_selection_add_targets
# flags: {} container: -
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# selection 'Gdk3.TAtom' 'ptr Gdk3.TAtom' IN (diff., need sugar)
# targets 'var openarray[TTargetEntry]' 'openarray[TTargetEntry]' IN (diff., need sugar) array lengthArg: 3
# ntargets 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_selection_add_targets(widget: ptr TWidget, selection: ptr Gdk3.TAtom, targets: openarray[TTargetEntry], ntargets: uint32) {.cdecl, dynlib: lib, importc: "gtk_selection_add_targets".}
proc gtk_selection_add_targets*(widget: Widget, selection: Gdk3.TAtom, targets: var openarray[TTargetEntry]) {.inline.} =
  gtk_selection_add_targets(widget.getPointer, myUnsafeAddr(selection), targets, targets.len.uint32)
# proc gtk_selection_add_targets*(widget: Widget, selection: Gdk3.TAtom, targets: var openarray[TTargetEntry]) {.inline.} =

# gtk_selection_clear_targets
# flags: {} container: -
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# selection 'Gdk3.TAtom' 'ptr Gdk3.TAtom' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_selection_clear_targets(widget: ptr TWidget, selection: ptr Gdk3.TAtom) {.cdecl, dynlib: lib, importc: "gtk_selection_clear_targets".}
proc gtk_selection_clear_targets*(widget: Widget, selection: Gdk3.TAtom) {.inline.} =
  gtk_selection_clear_targets(widget.getPointer, myUnsafeAddr(selection))
# proc gtk_selection_clear_targets*(widget: Widget, selection: Gdk3.TAtom) {.inline.} =

# gtk_selection_convert
# flags: {} container: -
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# selection 'Gdk3.TAtom' 'ptr Gdk3.TAtom' IN (diff., need sugar)
# target 'Gdk3.TAtom' 'ptr Gdk3.TAtom' IN (diff., need sugar)
# time_ 'uint32' 'uint32' IN
# 'bool' 'bool'
proc gtk_selection_convert(widget: ptr TWidget, selection: ptr Gdk3.TAtom, target: ptr Gdk3.TAtom, time_x: uint32): bool {.cdecl, dynlib: lib, importc: "gtk_selection_convert".}
proc gtk_selection_convert*(widget: Widget, selection: Gdk3.TAtom, target: Gdk3.TAtom, time_x: uint32): bool {.inline.} =
  gtk_selection_convert(widget.getPointer, myUnsafeAddr(selection), myUnsafeAddr(target), time_x)
# proc gtk_selection_convert*(widget: Widget, selection: Gdk3.TAtom, target: Gdk3.TAtom, time_x: uint32): bool {.inline.} =

# gtk_selection_owner_set
# flags: {} container: -
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# selection 'Gdk3.TAtom' 'ptr Gdk3.TAtom' IN (diff., need sugar)
# time_ 'uint32' 'uint32' IN
# 'bool' 'bool'
proc gtk_selection_owner_set(widget: ptr TWidget, selection: ptr Gdk3.TAtom, time_x: uint32): bool {.cdecl, dynlib: lib, importc: "gtk_selection_owner_set".}
proc gtk_selection_owner_set*(widget: Widget, selection: Gdk3.TAtom, time_x: uint32): bool {.inline.} =
  gtk_selection_owner_set(widget.getPointer, myUnsafeAddr(selection), time_x)
# proc gtk_selection_owner_set*(widget: Widget, selection: Gdk3.TAtom, time_x: uint32): bool {.inline.} =

# gtk_selection_owner_set_for_display
# flags: {} container: -
# display 'Gdk3.Display' 'ptr Gdk3.TDisplay' IN (diff., need sugar)
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# selection 'Gdk3.TAtom' 'ptr Gdk3.TAtom' IN (diff., need sugar)
# time_ 'uint32' 'uint32' IN
# 'bool' 'bool'
proc gtk_selection_owner_set_for_display(display: ptr Gdk3.TDisplay, widget: ptr TWidget, selection: ptr Gdk3.TAtom, time_x: uint32): bool {.cdecl, dynlib: lib, importc: "gtk_selection_owner_set_for_display".}
proc gtk_selection_owner_set_for_display*(display: Gdk3.Display, widget: Widget, selection: Gdk3.TAtom, time_x: uint32): bool {.inline.} =
  gtk_selection_owner_set_for_display(display.getPointer, widget.getPointer, myUnsafeAddr(selection), time_x)
# proc gtk_selection_owner_set_for_display*(display: Gdk3.Display, widget: Widget, selection: Gdk3.TAtom, time_x: uint32): bool {.inline.} =

# gtk_selection_remove_all
# flags: {} container: -
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_selection_remove_all(widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_selection_remove_all".}
proc gtk_selection_remove_all*(widget: Widget) {.inline.} =
  gtk_selection_remove_all(widget.getPointer)
# proc gtk_selection_remove_all*(widget: Widget) {.inline.} =

# gtk_set_debug_flags
# flags: {} container: -
# flags 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_set_debug_flags*(flags: uint32) {.cdecl, dynlib: lib, importc: "gtk_set_debug_flags".}
# gtk_show_uri
# flags: {throws} container: -
# can throw
# screen 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# uri 'ustring' 'ucstring' IN (diff., need sugar)
# timestamp 'uint32' 'uint32' IN
# 'bool' 'bool'
proc gtk_show_uri(screen: ptr Gdk3.TScreen, uri: ucstring, timestamp: uint32, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_show_uri".}
proc gtk_show_uri*(screen: Gdk3.Screen, uri: ustring, timestamp: uint32): bool {.inline.} =
  gtk_show_uri(screen.getPointer, ucstring(uri), timestamp)
# proc gtk_show_uri*(screen: Gdk3.Screen, uri: ustring, timestamp: uint32): bool {.inline.} =

# gtk_stock_add
# flags: {} container: - (deprecated)
# gtk_stock_add_static
# flags: {} container: - (deprecated)
# gtk_stock_list_ids
# flags: {} container: - (deprecated)
# gtk_stock_lookup
# flags: {} container: - (deprecated)
# gtk_stock_set_translate_func
# flags: {} container: - (deprecated)
# gtk_target_table_free
# flags: {} container: -
# targets 'var openarray[TTargetEntry]' 'openarray[TTargetEntry]' IN (diff., need sugar) array lengthArg: 1
# n_targets 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_target_table_free(targets: openarray[TTargetEntry], n_targets: int32) {.cdecl, dynlib: lib, importc: "gtk_target_table_free".}
proc gtk_target_table_free*(targets: var openarray[TTargetEntry]) {.inline.} =
  gtk_target_table_free(targets, targets.len.int32)
# proc gtk_target_table_free*(targets: var openarray[TTargetEntry]) {.inline.} =

# gtk_target_table_new_from_list
# flags: {} container: -
# list 'TTargetList' 'ptr TTargetList' IN (diff., need sugar)
# n_targets 'var int32' 'ptr int32' OUT (diff., need sugar)
# 'zeroTerminatedArray[TTargetEntry]' 'zeroTerminatedArray[TTargetEntry]'
proc gtk_target_table_new_from_list(list: ptr TTargetList, n_targets: ptr int32): zeroTerminatedArray[TTargetEntry] {.cdecl, dynlib: lib, importc: "gtk_target_table_new_from_list".}
proc gtk_target_table_new_from_list*(list: TTargetList, n_targets: var int32): zeroTerminatedArray[TTargetEntry] {.inline.} =
  gtk_target_table_new_from_list(myUnsafeAddr(list), addr(n_targets))
# tuple-return
# n_targets: var int32
# proc gtk_target_table_new_from_list*(list: TTargetList): zeroTerminatedArray[TTargetEntry] {.inline.} =

# gtk_targets_include_image
# flags: {} container: -
# targets 'var openarray[ptr Gdk3.TAtom]' 'openarray[ptr Gdk3.TAtom]' IN (diff., need sugar) array lengthArg: 1
# n_targets 'int32' 'int32' IN
# writable 'bool' 'bool' IN
# 'bool' 'bool'
proc gtk_targets_include_image(targets: openarray[ptr Gdk3.TAtom], n_targets: int32, writable: bool): bool {.cdecl, dynlib: lib, importc: "gtk_targets_include_image".}
proc gtk_targets_include_image*(targets: var openarray[ptr Gdk3.TAtom], writable: bool): bool {.inline.} =
  gtk_targets_include_image(targets, targets.len.int32, writable)
# proc gtk_targets_include_image*(targets: var openarray[ptr Gdk3.TAtom], writable: bool): bool {.inline.} =

# gtk_targets_include_rich_text
# flags: {} container: -
# targets 'var openarray[ptr Gdk3.TAtom]' 'openarray[ptr Gdk3.TAtom]' IN (diff., need sugar) array lengthArg: 1
# n_targets 'int32' 'int32' IN
# buffer 'TextBuffer' 'ptr TTextBuffer' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_targets_include_rich_text(targets: openarray[ptr Gdk3.TAtom], n_targets: int32, buffer: ptr TTextBuffer): bool {.cdecl, dynlib: lib, importc: "gtk_targets_include_rich_text".}
proc gtk_targets_include_rich_text*(targets: var openarray[ptr Gdk3.TAtom], buffer: TextBuffer): bool {.inline.} =
  gtk_targets_include_rich_text(targets, targets.len.int32, buffer.getPointer)
# proc gtk_targets_include_rich_text*(targets: var openarray[ptr Gdk3.TAtom], buffer: TextBuffer): bool {.inline.} =

# gtk_targets_include_text
# flags: {} container: -
# targets 'var openarray[ptr Gdk3.TAtom]' 'openarray[ptr Gdk3.TAtom]' IN (diff., need sugar) array lengthArg: 1
# n_targets 'int32' 'int32' IN
# 'bool' 'bool'
proc gtk_targets_include_text(targets: openarray[ptr Gdk3.TAtom], n_targets: int32): bool {.cdecl, dynlib: lib, importc: "gtk_targets_include_text".}
proc gtk_targets_include_text*(targets: var openarray[ptr Gdk3.TAtom]): bool {.inline.} =
  gtk_targets_include_text(targets, targets.len.int32)
# proc gtk_targets_include_text*(targets: var openarray[ptr Gdk3.TAtom]): bool {.inline.} =

# gtk_targets_include_uri
# flags: {} container: -
# targets 'var openarray[ptr Gdk3.TAtom]' 'openarray[ptr Gdk3.TAtom]' IN (diff., need sugar) array lengthArg: 1
# n_targets 'int32' 'int32' IN
# 'bool' 'bool'
proc gtk_targets_include_uri(targets: openarray[ptr Gdk3.TAtom], n_targets: int32): bool {.cdecl, dynlib: lib, importc: "gtk_targets_include_uri".}
proc gtk_targets_include_uri*(targets: var openarray[ptr Gdk3.TAtom]): bool {.inline.} =
  gtk_targets_include_uri(targets, targets.len.int32)
# proc gtk_targets_include_uri*(targets: var openarray[ptr Gdk3.TAtom]): bool {.inline.} =

# gtk_test_create_simple_window
# flags: {} container: -
# window_title 'ustring' 'ucstring' IN (diff., need sugar)
# dialog_text 'ustring' 'ucstring' IN (diff., need sugar)
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_test_create_simple_window(window_title: ucstring, dialog_text: ucstring): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_test_create_simple_window".}
proc gtk_test_create_simple_window*(window_title: ustring, dialog_text: ustring): Widget {.inline.} =
  wrap(gtk_test_create_simple_window(ucstring(window_title), ucstring(dialog_text)))
# proc gtk_test_create_simple_window*(window_title: ustring, dialog_text: ustring): Widget {.inline.} =

# gtk_test_find_label
# flags: {} container: -
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# label_pattern 'ustring' 'ucstring' IN (diff., need sugar)
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_test_find_label(widget: ptr TWidget, label_pattern: ucstring): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_test_find_label".}
proc gtk_test_find_label*(widget: Widget, label_pattern: ustring): Widget {.inline.} =
  wrap(gtk_test_find_label(widget.getPointer, ucstring(label_pattern)))
# proc gtk_test_find_label*(widget: Widget, label_pattern: ustring): Widget {.inline.} =

# gtk_test_find_sibling
# flags: {} container: -
# base_widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# widget_type 'GType' 'GType' IN
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_test_find_sibling(base_widget: ptr TWidget, widget_type: GType): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_test_find_sibling".}
proc gtk_test_find_sibling*(base_widget: Widget, widget_type: GType): Widget {.inline.} =
  wrap(gtk_test_find_sibling(base_widget.getPointer, widget_type))
# proc gtk_test_find_sibling*(base_widget: Widget, widget_type: GType): Widget {.inline.} =

# gtk_test_find_widget
# flags: {} container: -
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# label_pattern 'ustring' 'ucstring' IN (diff., need sugar)
# widget_type 'GType' 'GType' IN
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_test_find_widget(widget: ptr TWidget, label_pattern: ucstring, widget_type: GType): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_test_find_widget".}
proc gtk_test_find_widget*(widget: Widget, label_pattern: ustring, widget_type: GType): Widget {.inline.} =
  wrap(gtk_test_find_widget(widget.getPointer, ucstring(label_pattern), widget_type))
# proc gtk_test_find_widget*(widget: Widget, label_pattern: ustring, widget_type: GType): Widget {.inline.} =

# gtk_test_list_all_types
# flags: {} container: -
# n_types 'var uint32' 'ptr uint32' OUT (diff., need sugar)
# 'zeroTerminatedArray[GType]' 'zeroTerminatedArray[GType]'
proc gtk_test_list_all_types(n_types: ptr uint32): zeroTerminatedArray[GType] {.cdecl, dynlib: lib, importc: "gtk_test_list_all_types".}
proc gtk_test_list_all_types*(n_types: var uint32): zeroTerminatedArray[GType] {.inline.} =
  gtk_test_list_all_types(addr(n_types))
# tuple-return
# n_types: var uint32
# proc gtk_test_list_all_types*(): zeroTerminatedArray[GType] {.inline.} =

# gtk_test_register_all_types
# flags: {} container: -
# 'VOID_TODO' 'VOID_TODO'
proc gtk_test_register_all_types*() {.cdecl, dynlib: lib, importc: "gtk_test_register_all_types".}
# gtk_test_slider_get_value
# flags: {} container: -
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'float64' 'float64'
proc gtk_test_slider_get_value(widget: ptr TWidget): float64 {.cdecl, dynlib: lib, importc: "gtk_test_slider_get_value".}
proc gtk_test_slider_get_value*(widget: Widget): float64 {.inline.} =
  gtk_test_slider_get_value(widget.getPointer)
# proc gtk_test_slider_get_value*(widget: Widget): float64 {.inline.} =

# gtk_test_slider_set_perc
# flags: {} container: -
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# percentage 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_test_slider_set_perc(widget: ptr TWidget, percentage: float64) {.cdecl, dynlib: lib, importc: "gtk_test_slider_set_perc".}
proc gtk_test_slider_set_perc*(widget: Widget, percentage: float64) {.inline.} =
  gtk_test_slider_set_perc(widget.getPointer, percentage)
# proc gtk_test_slider_set_perc*(widget: Widget, percentage: float64) {.inline.} =

# gtk_test_spin_button_click
# flags: {} container: -
# spinner 'SpinButton' 'ptr TSpinButton' IN (diff., need sugar)
# button 'uint32' 'uint32' IN
# upwards 'bool' 'bool' IN
# 'bool' 'bool'
proc gtk_test_spin_button_click(spinner: ptr TSpinButton, button: uint32, upwards: bool): bool {.cdecl, dynlib: lib, importc: "gtk_test_spin_button_click".}
proc gtk_test_spin_button_click*(spinner: SpinButton, button: uint32, upwards: bool): bool {.inline.} =
  gtk_test_spin_button_click(spinner.getPointer, button, upwards)
# proc gtk_test_spin_button_click*(spinner: SpinButton, button: uint32, upwards: bool): bool {.inline.} =

# gtk_test_text_get
# flags: {} container: -
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_test_text_get(widget: ptr TWidget): ucstring {.cdecl, dynlib: lib, importc: "gtk_test_text_get".}
proc gtk_test_text_get*(widget: Widget): ustring {.inline.} =
  ustring($(gtk_test_text_get(widget.getPointer)))
# proc gtk_test_text_get*(widget: Widget): ustring {.inline.} =

# gtk_test_text_set
# flags: {} container: -
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# string 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_test_text_set(widget: ptr TWidget, string: ucstring) {.cdecl, dynlib: lib, importc: "gtk_test_text_set".}
proc gtk_test_text_set*(widget: Widget, string: ustring) {.inline.} =
  gtk_test_text_set(widget.getPointer, ucstring(string))
# proc gtk_test_text_set*(widget: Widget, string: ustring) {.inline.} =

# gtk_test_widget_click
# flags: {} container: -
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# button 'uint32' 'uint32' IN
# modifiers 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# 'bool' 'bool'
proc gtk_test_widget_click(widget: ptr TWidget, button: uint32, modifiers: Gdk3.SModifierType): bool {.cdecl, dynlib: lib, importc: "gtk_test_widget_click".}
proc gtk_test_widget_click*(widget: Widget, button: uint32, modifiers: Gdk3.SModifierType): bool {.inline.} =
  gtk_test_widget_click(widget.getPointer, button, modifiers)
# proc gtk_test_widget_click*(widget: Widget, button: uint32, modifiers: Gdk3.SModifierType): bool {.inline.} =

# gtk_test_widget_send_key
# flags: {} container: -
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# keyval 'uint32' 'uint32' IN
# modifiers 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# 'bool' 'bool'
proc gtk_test_widget_send_key(widget: ptr TWidget, keyval: uint32, modifiers: Gdk3.SModifierType): bool {.cdecl, dynlib: lib, importc: "gtk_test_widget_send_key".}
proc gtk_test_widget_send_key*(widget: Widget, keyval: uint32, modifiers: Gdk3.SModifierType): bool {.inline.} =
  gtk_test_widget_send_key(widget.getPointer, keyval, modifiers)
# proc gtk_test_widget_send_key*(widget: Widget, keyval: uint32, modifiers: Gdk3.SModifierType): bool {.inline.} =

# gtk_test_widget_wait_for_draw
# flags: {} container: -
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_test_widget_wait_for_draw(widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_test_widget_wait_for_draw".}
proc gtk_test_widget_wait_for_draw*(widget: Widget) {.inline.} =
  gtk_test_widget_wait_for_draw(widget.getPointer)
# proc gtk_test_widget_wait_for_draw*(widget: Widget) {.inline.} =

# gtk_tree_get_row_drag_data
# flags: {} container: -
# selection_data 'TSelectionData' 'ptr TSelectionData' IN (diff., need sugar)
# tree_model 'var TreeModel' 'ptr TTreeModel' OUT (diff., need sugar)
# path 'var TTreePath' 'ptr TTreePath' OUT (diff., need sugar)
# 'bool' 'bool'
proc gtk_tree_get_row_drag_data(selection_data: ptr TSelectionData, tree_model: ptr TTreeModel, path: ptr TTreePath): bool {.cdecl, dynlib: lib, importc: "gtk_tree_get_row_drag_data".}
proc gtk_tree_get_row_drag_data*(selection_data: TSelectionData, tree_model: var TreeModel, path: var TTreePath): bool {.inline.} =
  gtk_tree_get_row_drag_data(myUnsafeAddr(selection_data), unwrap(tree_model), addr(path))
# tuple-return
# tree_model: var TreeModel
# path: var TTreePath
# proc gtk_tree_get_row_drag_data*(selection_data: TSelectionData): bool {.inline.} =

# gtk_tree_row_reference_deleted
# flags: {} container: -
# proxy 'GObject2.Object' 'ptr GObject2.TObject' IN (diff., need sugar)
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_row_reference_deleted(proxy: ptr GObject2.TObject, path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_tree_row_reference_deleted".}
proc gtk_tree_row_reference_deleted*(proxy: GObject2.Object, path: TTreePath) {.inline.} =
  gtk_tree_row_reference_deleted(proxy.getPointer, myUnsafeAddr(path))
# proc gtk_tree_row_reference_deleted*(proxy: GObject2.Object, path: TTreePath) {.inline.} =

# gtk_tree_row_reference_inserted
# flags: {} container: -
# proxy 'GObject2.Object' 'ptr GObject2.TObject' IN (diff., need sugar)
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_row_reference_inserted(proxy: ptr GObject2.TObject, path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_tree_row_reference_inserted".}
proc gtk_tree_row_reference_inserted*(proxy: GObject2.Object, path: TTreePath) {.inline.} =
  gtk_tree_row_reference_inserted(proxy.getPointer, myUnsafeAddr(path))
# proc gtk_tree_row_reference_inserted*(proxy: GObject2.Object, path: TTreePath) {.inline.} =

# gtk_tree_set_row_drag_data
# flags: {} container: -
# selection_data 'TSelectionData' 'ptr TSelectionData' IN (diff., need sugar)
# tree_model 'TreeModel' 'ptr TTreeModel' IN (diff., need sugar)
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_tree_set_row_drag_data(selection_data: ptr TSelectionData, tree_model: ptr TTreeModel, path: ptr TTreePath): bool {.cdecl, dynlib: lib, importc: "gtk_tree_set_row_drag_data".}
proc gtk_tree_set_row_drag_data*(selection_data: TSelectionData, tree_model: TreeModel, path: TTreePath): bool {.inline.} =
  gtk_tree_set_row_drag_data(myUnsafeAddr(selection_data), unwrap(tree_model), myUnsafeAddr(path))
# proc gtk_tree_set_row_drag_data*(selection_data: TSelectionData, tree_model: TreeModel, path: TTreePath): bool {.inline.} =

# gtk_true
# flags: {} container: -
# 'bool' 'bool'
proc gtk_true*(): bool {.cdecl, dynlib: lib, importc: "gtk_true".}
  # object methods
  #------------------
# gtk_about_dialog_new
# flags: {isConstructor} container: AboutDialog
# need sugar: is static method
# 'AboutDialog' 'TransferNone[TAboutDialog]' (diff., need sugar)
proc gtk_about_dialog_new(): TransferNone[TAboutDialog] {.cdecl, dynlib: lib, importc: "gtk_about_dialog_new".}
proc new_aboutdialog*(): AboutDialog {.inline.} =
  wrap(gtk_about_dialog_new())
# proc new_aboutdialog*(): AboutDialog {.inline.} =

# gtk_about_dialog_add_credit_section
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# section_name 'ustring' 'ucstring' IN (diff., need sugar)
# people 'uncheckedArray[ucstring]' 'uncheckedArray[ucstring]' IN array zero-terminated
# 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_add_credit_section(self: ptr TAboutDialog, section_name: ucstring, people: uncheckedArray[ucstring]) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_add_credit_section".}
proc add_credit_section*(self: AboutDialog, section_name: ustring, people: uncheckedArray[ucstring]) {.inline.} =
  gtk_about_dialog_add_credit_section(self, ucstring(section_name), people)
# proc add_credit_section*(self: AboutDialog, section_name: ustring, people: uncheckedArray[ucstring]) {.inline.} =

# gtk_about_dialog_get_artists
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# 'zeroTerminatedArray[ucstring]' 'zeroTerminatedArray[ucstring]'
proc gtk_about_dialog_get_artists(self: ptr TAboutDialog): zeroTerminatedArray[ucstring] {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_artists".}
proc get_artists*(self: AboutDialog): zeroTerminatedArray[ucstring] {.inline.} =
  gtk_about_dialog_get_artists(self)
# proc get_artists*(self: AboutDialog): zeroTerminatedArray[ucstring] {.inline.} =

# gtk_about_dialog_get_authors
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# 'zeroTerminatedArray[ucstring]' 'zeroTerminatedArray[ucstring]'
proc gtk_about_dialog_get_authors(self: ptr TAboutDialog): zeroTerminatedArray[ucstring] {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_authors".}
proc get_authors*(self: AboutDialog): zeroTerminatedArray[ucstring] {.inline.} =
  gtk_about_dialog_get_authors(self)
# proc get_authors*(self: AboutDialog): zeroTerminatedArray[ucstring] {.inline.} =

# gtk_about_dialog_get_comments
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_about_dialog_get_comments(self: ptr TAboutDialog): ucstring {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_comments".}
proc get_comments*(self: AboutDialog): ustring {.inline.} =
  ustring($(gtk_about_dialog_get_comments(self)))
# proc get_comments*(self: AboutDialog): ustring {.inline.} =

# gtk_about_dialog_get_copyright
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_about_dialog_get_copyright(self: ptr TAboutDialog): ucstring {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_copyright".}
proc get_copyright*(self: AboutDialog): ustring {.inline.} =
  ustring($(gtk_about_dialog_get_copyright(self)))
# proc get_copyright*(self: AboutDialog): ustring {.inline.} =

# gtk_about_dialog_get_documenters
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# 'zeroTerminatedArray[ucstring]' 'zeroTerminatedArray[ucstring]'
proc gtk_about_dialog_get_documenters(self: ptr TAboutDialog): zeroTerminatedArray[ucstring] {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_documenters".}
proc get_documenters*(self: AboutDialog): zeroTerminatedArray[ucstring] {.inline.} =
  gtk_about_dialog_get_documenters(self)
# proc get_documenters*(self: AboutDialog): zeroTerminatedArray[ucstring] {.inline.} =

# gtk_about_dialog_get_license
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_about_dialog_get_license(self: ptr TAboutDialog): ucstring {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_license".}
proc get_license*(self: AboutDialog): ustring {.inline.} =
  ustring($(gtk_about_dialog_get_license(self)))
# proc get_license*(self: AboutDialog): ustring {.inline.} =

# gtk_about_dialog_get_license_type
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# 'License' 'License'
proc gtk_about_dialog_get_license_type(self: ptr TAboutDialog): License {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_license_type".}
proc get_license_type*(self: AboutDialog): License {.inline.} =
  gtk_about_dialog_get_license_type(self)
# proc get_license_type*(self: AboutDialog): License {.inline.} =

# gtk_about_dialog_get_logo
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# 'GdkPixbuf2.Pixbuf' 'TransferNone[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_about_dialog_get_logo(self: ptr TAboutDialog): TransferNone[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_logo".}
proc get_logo*(self: AboutDialog): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_about_dialog_get_logo(self))
# proc get_logo*(self: AboutDialog): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_about_dialog_get_logo_icon_name
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_about_dialog_get_logo_icon_name(self: ptr TAboutDialog): ucstring {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_logo_icon_name".}
proc get_logo_icon_name*(self: AboutDialog): ustring {.inline.} =
  ustring($(gtk_about_dialog_get_logo_icon_name(self)))
# proc get_logo_icon_name*(self: AboutDialog): ustring {.inline.} =

# gtk_about_dialog_get_program_name
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_about_dialog_get_program_name(self: ptr TAboutDialog): ucstring {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_program_name".}
proc get_program_name*(self: AboutDialog): ustring {.inline.} =
  ustring($(gtk_about_dialog_get_program_name(self)))
# proc get_program_name*(self: AboutDialog): ustring {.inline.} =

# gtk_about_dialog_get_translator_credits
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_about_dialog_get_translator_credits(self: ptr TAboutDialog): ucstring {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_translator_credits".}
proc get_translator_credits*(self: AboutDialog): ustring {.inline.} =
  ustring($(gtk_about_dialog_get_translator_credits(self)))
# proc get_translator_credits*(self: AboutDialog): ustring {.inline.} =

# gtk_about_dialog_get_version
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_about_dialog_get_version(self: ptr TAboutDialog): ucstring {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_version".}
proc get_version*(self: AboutDialog): ustring {.inline.} =
  ustring($(gtk_about_dialog_get_version(self)))
# proc get_version*(self: AboutDialog): ustring {.inline.} =

# gtk_about_dialog_get_website
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_about_dialog_get_website(self: ptr TAboutDialog): ucstring {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_website".}
proc get_website*(self: AboutDialog): ustring {.inline.} =
  ustring($(gtk_about_dialog_get_website(self)))
# proc get_website*(self: AboutDialog): ustring {.inline.} =

# gtk_about_dialog_get_website_label
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_about_dialog_get_website_label(self: ptr TAboutDialog): ucstring {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_website_label".}
proc get_website_label*(self: AboutDialog): ustring {.inline.} =
  ustring($(gtk_about_dialog_get_website_label(self)))
# proc get_website_label*(self: AboutDialog): ustring {.inline.} =

# gtk_about_dialog_get_wrap_license
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# 'bool' 'bool'
proc gtk_about_dialog_get_wrap_license(self: ptr TAboutDialog): bool {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_wrap_license".}
proc get_wrap_license*(self: AboutDialog): bool {.inline.} =
  gtk_about_dialog_get_wrap_license(self)
# proc get_wrap_license*(self: AboutDialog): bool {.inline.} =

# gtk_about_dialog_set_artists
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# artists 'uncheckedArray[ucstring]' 'uncheckedArray[ucstring]' IN array zero-terminated
# 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_artists(self: ptr TAboutDialog, artists: uncheckedArray[ucstring]) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_artists".}
proc set_artists*(self: AboutDialog, artists: uncheckedArray[ucstring]) {.inline.} =
  gtk_about_dialog_set_artists(self, artists)
# proc set_artists*(self: AboutDialog, artists: uncheckedArray[ucstring]) {.inline.} =

# gtk_about_dialog_set_authors
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# authors 'uncheckedArray[ucstring]' 'uncheckedArray[ucstring]' IN array zero-terminated
# 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_authors(self: ptr TAboutDialog, authors: uncheckedArray[ucstring]) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_authors".}
proc set_authors*(self: AboutDialog, authors: uncheckedArray[ucstring]) {.inline.} =
  gtk_about_dialog_set_authors(self, authors)
# proc set_authors*(self: AboutDialog, authors: uncheckedArray[ucstring]) {.inline.} =

# gtk_about_dialog_set_comments
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# comments 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_comments(self: ptr TAboutDialog, comments: ucstring) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_comments".}
proc set_comments*(self: AboutDialog, comments: ustring) {.inline.} =
  gtk_about_dialog_set_comments(self, ucstring(comments))
# proc set_comments*(self: AboutDialog, comments: ustring) {.inline.} =

# gtk_about_dialog_set_copyright
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# copyright 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_copyright(self: ptr TAboutDialog, copyright: ucstring) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_copyright".}
proc set_copyright*(self: AboutDialog, copyright: ustring) {.inline.} =
  gtk_about_dialog_set_copyright(self, ucstring(copyright))
# proc set_copyright*(self: AboutDialog, copyright: ustring) {.inline.} =

# gtk_about_dialog_set_documenters
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# documenters 'uncheckedArray[ucstring]' 'uncheckedArray[ucstring]' IN array zero-terminated
# 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_documenters(self: ptr TAboutDialog, documenters: uncheckedArray[ucstring]) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_documenters".}
proc set_documenters*(self: AboutDialog, documenters: uncheckedArray[ucstring]) {.inline.} =
  gtk_about_dialog_set_documenters(self, documenters)
# proc set_documenters*(self: AboutDialog, documenters: uncheckedArray[ucstring]) {.inline.} =

# gtk_about_dialog_set_license
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# license 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_license(self: ptr TAboutDialog, license: ucstring) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_license".}
proc set_license*(self: AboutDialog, license: ustring) {.inline.} =
  gtk_about_dialog_set_license(self, ucstring(license))
# proc set_license*(self: AboutDialog, license: ustring) {.inline.} =

# gtk_about_dialog_set_license_type
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# license_type 'License' 'License' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_license_type(self: ptr TAboutDialog, license_type: License) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_license_type".}
proc set_license_type*(self: AboutDialog, license_type: License) {.inline.} =
  gtk_about_dialog_set_license_type(self, license_type)
# proc set_license_type*(self: AboutDialog, license_type: License) {.inline.} =

# gtk_about_dialog_set_logo
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# logo 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_logo(self: ptr TAboutDialog, logo: ptr GdkPixbuf2.TPixbuf) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_logo".}
proc set_logo*(self: AboutDialog, logo: GdkPixbuf2.Pixbuf) {.inline.} =
  gtk_about_dialog_set_logo(self, logo.getPointer)
# proc set_logo*(self: AboutDialog, logo: GdkPixbuf2.Pixbuf) {.inline.} =

# gtk_about_dialog_set_logo_icon_name
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# icon_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_logo_icon_name(self: ptr TAboutDialog, icon_name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_logo_icon_name".}
proc set_logo_icon_name*(self: AboutDialog, icon_name: ustring) {.inline.} =
  gtk_about_dialog_set_logo_icon_name(self, ucstring(icon_name))
# proc set_logo_icon_name*(self: AboutDialog, icon_name: ustring) {.inline.} =

# gtk_about_dialog_set_program_name
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_program_name(self: ptr TAboutDialog, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_program_name".}
proc set_program_name*(self: AboutDialog, name: ustring) {.inline.} =
  gtk_about_dialog_set_program_name(self, ucstring(name))
# proc set_program_name*(self: AboutDialog, name: ustring) {.inline.} =

# gtk_about_dialog_set_translator_credits
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# translator_credits 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_translator_credits(self: ptr TAboutDialog, translator_credits: ucstring) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_translator_credits".}
proc set_translator_credits*(self: AboutDialog, translator_credits: ustring) {.inline.} =
  gtk_about_dialog_set_translator_credits(self, ucstring(translator_credits))
# proc set_translator_credits*(self: AboutDialog, translator_credits: ustring) {.inline.} =

# gtk_about_dialog_set_version
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# version 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_version(self: ptr TAboutDialog, version: ucstring) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_version".}
proc set_version*(self: AboutDialog, version: ustring) {.inline.} =
  gtk_about_dialog_set_version(self, ucstring(version))
# proc set_version*(self: AboutDialog, version: ustring) {.inline.} =

# gtk_about_dialog_set_website
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# website 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_website(self: ptr TAboutDialog, website: ucstring) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_website".}
proc set_website*(self: AboutDialog, website: ustring) {.inline.} =
  gtk_about_dialog_set_website(self, ucstring(website))
# proc set_website*(self: AboutDialog, website: ustring) {.inline.} =

# gtk_about_dialog_set_website_label
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# website_label 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_website_label(self: ptr TAboutDialog, website_label: ucstring) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_website_label".}
proc set_website_label*(self: AboutDialog, website_label: ustring) {.inline.} =
  gtk_about_dialog_set_website_label(self, ucstring(website_label))
# proc set_website_label*(self: AboutDialog, website_label: ustring) {.inline.} =

# gtk_about_dialog_set_wrap_license
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# wrap_license 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_wrap_license(self: ptr TAboutDialog, wrap_license: bool) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_wrap_license".}
proc set_wrap_license*(self: AboutDialog, wrap_license: bool) {.inline.} =
  gtk_about_dialog_set_wrap_license(self, wrap_license)
# proc set_wrap_license*(self: AboutDialog, wrap_license: bool) {.inline.} =

# gtk_accel_group_new
# flags: {isConstructor} container: AccelGroup
# need sugar: is static method
# 'AccelGroup' 'TransferFull[TAccelGroup]' (diff., need sugar)
proc gtk_accel_group_new(): TransferFull[TAccelGroup] {.cdecl, dynlib: lib, importc: "gtk_accel_group_new".}
proc new_accelgroup*(): AccelGroup {.inline.} =
  wrap(gtk_accel_group_new())
# proc new_accelgroup*(): AccelGroup {.inline.} =

# gtk_accel_group_from_accel_closure
# flags: {} container: AccelGroup
# need sugar: is static method
# closure 'GObject2.TClosure' 'ptr GObject2.TClosure' IN (diff., need sugar)
# 'AccelGroup' 'TransferNone[TAccelGroup]' (diff., need sugar)
proc gtk_accel_group_from_accel_closure(closure: ptr GObject2.TClosure): TransferNone[TAccelGroup] {.cdecl, dynlib: lib, importc: "gtk_accel_group_from_accel_closure".}
template from_accel_closure*(klass_parameter: typedesc[AccelGroup], closure: GObject2.TClosure): AccelGroup =
  wrap(gtk_accel_group_from_accel_closure(myUnsafeAddr(closure)))
# template from_accel_closure*(klass_parameter: typedesc[AccelGroup], closure: GObject2.TClosure): AccelGroup =

# gtk_accel_group_activate
# flags: {isMethod} container: AccelGroup
# need sugar: is method
# accel_quark 'uint32' 'uint32' IN
# acceleratable 'GObject2.Object' 'ptr GObject2.TObject' IN (diff., need sugar)
# accel_key 'uint32' 'uint32' IN
# accel_mods 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# 'bool' 'bool'
proc gtk_accel_group_activate(self: ptr TAccelGroup, accel_quark: uint32, acceleratable: ptr GObject2.TObject, accel_key: uint32, accel_mods: Gdk3.SModifierType): bool {.cdecl, dynlib: lib, importc: "gtk_accel_group_activate".}
proc activate*(self: AccelGroup, accel_quark: uint32, acceleratable: GObject2.Object, accel_key: uint32, accel_mods: Gdk3.SModifierType): bool {.inline.} =
  gtk_accel_group_activate(self, accel_quark, acceleratable.getPointer, accel_key, accel_mods)
# proc activate*(self: AccelGroup, accel_quark: uint32, acceleratable: GObject2.Object, accel_key: uint32, accel_mods: Gdk3.SModifierType): bool {.inline.} =

# gtk_accel_group_connect
# flags: {isMethod} container: AccelGroup
# need sugar: is method
# accel_key 'uint32' 'uint32' IN
# accel_mods 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# accel_flags 'SAccelFlags' 'SAccelFlags' IN
# closure 'GObject2.TClosure' 'ptr GObject2.TClosure' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_group_connect(self: ptr TAccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType, accel_flags: SAccelFlags, closure: ptr GObject2.TClosure) {.cdecl, dynlib: lib, importc: "gtk_accel_group_connect".}
proc connect*(self: AccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType, accel_flags: SAccelFlags, closure: GObject2.TClosure) {.inline.} =
  gtk_accel_group_connect(self, accel_key, accel_mods, accel_flags, myUnsafeAddr(closure))
# proc connect*(self: AccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType, accel_flags: SAccelFlags, closure: GObject2.TClosure) {.inline.} =

# gtk_accel_group_connect_by_path
# flags: {isMethod} container: AccelGroup
# need sugar: is method
# accel_path 'ustring' 'ucstring' IN (diff., need sugar)
# closure 'GObject2.TClosure' 'ptr GObject2.TClosure' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_group_connect_by_path(self: ptr TAccelGroup, accel_path: ucstring, closure: ptr GObject2.TClosure) {.cdecl, dynlib: lib, importc: "gtk_accel_group_connect_by_path".}
proc connect_by_path*(self: AccelGroup, accel_path: ustring, closure: GObject2.TClosure) {.inline.} =
  gtk_accel_group_connect_by_path(self, ucstring(accel_path), myUnsafeAddr(closure))
# proc connect_by_path*(self: AccelGroup, accel_path: ustring, closure: GObject2.TClosure) {.inline.} =

# gtk_accel_group_disconnect
# flags: {isMethod} container: AccelGroup
# need sugar: is method
# closure 'GObject2.TClosure' 'ptr GObject2.TClosure' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_accel_group_disconnect(self: ptr TAccelGroup, closure: ptr GObject2.TClosure): bool {.cdecl, dynlib: lib, importc: "gtk_accel_group_disconnect".}
proc disconnect*(self: AccelGroup, closure: GObject2.TClosure): bool {.inline.} =
  gtk_accel_group_disconnect(self, myUnsafeAddr(closure))
# proc disconnect*(self: AccelGroup, closure: GObject2.TClosure): bool {.inline.} =

# gtk_accel_group_disconnect_key
# flags: {isMethod} container: AccelGroup
# need sugar: is method
# accel_key 'uint32' 'uint32' IN
# accel_mods 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# 'bool' 'bool'
proc gtk_accel_group_disconnect_key(self: ptr TAccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType): bool {.cdecl, dynlib: lib, importc: "gtk_accel_group_disconnect_key".}
proc disconnect_key*(self: AccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType): bool {.inline.} =
  gtk_accel_group_disconnect_key(self, accel_key, accel_mods)
# proc disconnect_key*(self: AccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType): bool {.inline.} =

# gtk_accel_group_find
# flags: {isMethod} container: AccelGroup
# need sugar: is method
# find_func 'pointer' 'pointer' IN
# data 'pointer' 'pointer' IN
# 'TAccelKey' 'ptr TAccelKey' (diff., need sugar)
proc gtk_accel_group_find(self: ptr TAccelGroup, find_func: pointer, data: pointer): ptr TAccelKey {.cdecl, dynlib: lib, importc: "gtk_accel_group_find".}
proc find*(self: AccelGroup, find_func: pointer, data: pointer): TAccelKey {.inline.} =
  (gtk_accel_group_find(self, find_func, data))[]
# proc find*(self: AccelGroup, find_func: pointer, data: pointer): TAccelKey {.inline.} =

# gtk_accel_group_get_is_locked
# flags: {isMethod} container: AccelGroup
# need sugar: is method
# 'bool' 'bool'
proc gtk_accel_group_get_is_locked(self: ptr TAccelGroup): bool {.cdecl, dynlib: lib, importc: "gtk_accel_group_get_is_locked".}
proc get_is_locked*(self: AccelGroup): bool {.inline.} =
  gtk_accel_group_get_is_locked(self)
# proc get_is_locked*(self: AccelGroup): bool {.inline.} =

# gtk_accel_group_get_modifier_mask
# flags: {isMethod} container: AccelGroup
# need sugar: is method
# 'Gdk3.SModifierType' 'Gdk3.SModifierType'
proc gtk_accel_group_get_modifier_mask(self: ptr TAccelGroup): Gdk3.SModifierType {.cdecl, dynlib: lib, importc: "gtk_accel_group_get_modifier_mask".}
proc get_modifier_mask*(self: AccelGroup): Gdk3.SModifierType {.inline.} =
  gtk_accel_group_get_modifier_mask(self)
# proc get_modifier_mask*(self: AccelGroup): Gdk3.SModifierType {.inline.} =

# gtk_accel_group_lock
# flags: {isMethod} container: AccelGroup
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_group_lock(self: ptr TAccelGroup) {.cdecl, dynlib: lib, importc: "gtk_accel_group_lock".}
proc lock*(self: AccelGroup) {.inline.} =
  gtk_accel_group_lock(self)
# proc lock*(self: AccelGroup) {.inline.} =

# gtk_accel_group_query
# flags: {isMethod} container: AccelGroup
# need sugar: is method
# accel_key 'uint32' 'uint32' IN
# accel_mods 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# n_entries 'var uint32' 'ptr uint32' OUT (diff., need sugar) optional
# 'zeroTerminatedArray[TAccelGroupEntry]' 'zeroTerminatedArray[TAccelGroupEntry]'
proc gtk_accel_group_query(self: ptr TAccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType, n_entries: ptr uint32): zeroTerminatedArray[TAccelGroupEntry] {.cdecl, dynlib: lib, importc: "gtk_accel_group_query".}
proc query*(self: AccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType, n_entries: var uint32): zeroTerminatedArray[TAccelGroupEntry] {.inline.} =
  gtk_accel_group_query(self, accel_key, accel_mods, addr(n_entries))
# tuple-return
# n_entries: var uint32
# proc query*(self: AccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType): zeroTerminatedArray[TAccelGroupEntry] {.inline.} =

# gtk_accel_group_unlock
# flags: {isMethod} container: AccelGroup
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_group_unlock(self: ptr TAccelGroup) {.cdecl, dynlib: lib, importc: "gtk_accel_group_unlock".}
proc unlock*(self: AccelGroup) {.inline.} =
  gtk_accel_group_unlock(self)
# proc unlock*(self: AccelGroup) {.inline.} =

# gtk_accel_label_new
# flags: {isConstructor} container: AccelLabel
# need sugar: is static method
# string 'ustring' 'ucstring' IN (diff., need sugar)
# 'AccelLabel' 'TransferNone[TAccelLabel]' (diff., need sugar)
proc gtk_accel_label_new(string: ucstring): TransferNone[TAccelLabel] {.cdecl, dynlib: lib, importc: "gtk_accel_label_new".}
proc new_accellabel*(string: ustring): AccelLabel {.inline.} =
  wrap(gtk_accel_label_new(ucstring(string)))
# proc new_accellabel*(string: ustring): AccelLabel {.inline.} =

# gtk_accel_label_get_accel
# flags: {isMethod} container: AccelLabel
# need sugar: is method
# accelerator_key 'var uint32' 'ptr uint32' OUT (diff., need sugar)
# accelerator_mods 'Gdk3.SModifierType' 'Gdk3.SModifierType' OUT
# 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_label_get_accel(self: ptr TAccelLabel, accelerator_key: ptr uint32, accelerator_mods: Gdk3.SModifierType) {.cdecl, dynlib: lib, importc: "gtk_accel_label_get_accel".}
proc get_accel*(self: AccelLabel, accelerator_key: var uint32, accelerator_mods: Gdk3.SModifierType) {.inline.} =
  gtk_accel_label_get_accel(self, addr(accelerator_key), accelerator_mods)
# tuple-return
# accelerator_key: var uint32
# accelerator_mods: Gdk3.SModifierType
# proc get_accel*(self: AccelLabel) {.inline.} =

# gtk_accel_label_get_accel_widget
# flags: {isMethod} container: AccelLabel
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_accel_label_get_accel_widget(self: ptr TAccelLabel): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_accel_label_get_accel_widget".}
proc get_accel_widget*(self: AccelLabel): Widget {.inline.} =
  wrap(gtk_accel_label_get_accel_widget(self))
# proc get_accel_widget*(self: AccelLabel): Widget {.inline.} =

# gtk_accel_label_get_accel_width
# flags: {isMethod} container: AccelLabel
# need sugar: is method
# 'uint32' 'uint32'
proc gtk_accel_label_get_accel_width(self: ptr TAccelLabel): uint32 {.cdecl, dynlib: lib, importc: "gtk_accel_label_get_accel_width".}
proc get_accel_width*(self: AccelLabel): uint32 {.inline.} =
  gtk_accel_label_get_accel_width(self)
# proc get_accel_width*(self: AccelLabel): uint32 {.inline.} =

# gtk_accel_label_refetch
# flags: {isMethod} container: AccelLabel
# need sugar: is method
# 'bool' 'bool'
proc gtk_accel_label_refetch(self: ptr TAccelLabel): bool {.cdecl, dynlib: lib, importc: "gtk_accel_label_refetch".}
proc refetch*(self: AccelLabel): bool {.inline.} =
  gtk_accel_label_refetch(self)
# proc refetch*(self: AccelLabel): bool {.inline.} =

# gtk_accel_label_set_accel
# flags: {isMethod} container: AccelLabel
# need sugar: is method
# accelerator_key 'uint32' 'uint32' IN
# accelerator_mods 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_label_set_accel(self: ptr TAccelLabel, accelerator_key: uint32, accelerator_mods: Gdk3.SModifierType) {.cdecl, dynlib: lib, importc: "gtk_accel_label_set_accel".}
proc set_accel*(self: AccelLabel, accelerator_key: uint32, accelerator_mods: Gdk3.SModifierType) {.inline.} =
  gtk_accel_label_set_accel(self, accelerator_key, accelerator_mods)
# proc set_accel*(self: AccelLabel, accelerator_key: uint32, accelerator_mods: Gdk3.SModifierType) {.inline.} =

# gtk_accel_label_set_accel_closure
# flags: {isMethod} container: AccelLabel
# need sugar: is method
# accel_closure 'GObject2.TClosure' 'ptr GObject2.TClosure' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_label_set_accel_closure(self: ptr TAccelLabel, accel_closure: ptr GObject2.TClosure) {.cdecl, dynlib: lib, importc: "gtk_accel_label_set_accel_closure".}
proc set_accel_closure*(self: AccelLabel, accel_closure: GObject2.TClosure) {.inline.} =
  gtk_accel_label_set_accel_closure(self, myUnsafeAddr(accel_closure))
# proc set_accel_closure*(self: AccelLabel, accel_closure: GObject2.TClosure) {.inline.} =

# gtk_accel_label_set_accel_widget
# flags: {isMethod} container: AccelLabel
# need sugar: is method
# accel_widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_label_set_accel_widget(self: ptr TAccelLabel, accel_widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_accel_label_set_accel_widget".}
proc set_accel_widget*(self: AccelLabel, accel_widget: Widget) {.inline.} =
  gtk_accel_label_set_accel_widget(self, accel_widget.getPointer)
# proc set_accel_widget*(self: AccelLabel, accel_widget: Widget) {.inline.} =

# gtk_accel_map_add_entry
# flags: {} container: AccelMap
# need sugar: is static method
# accel_path 'ustring' 'ucstring' IN (diff., need sugar)
# accel_key 'uint32' 'uint32' IN
# accel_mods 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_map_add_entry(accel_path: ucstring, accel_key: uint32, accel_mods: Gdk3.SModifierType) {.cdecl, dynlib: lib, importc: "gtk_accel_map_add_entry".}
template add_entry*(klass_parameter: typedesc[AccelMap], accel_path: ustring, accel_key: uint32, accel_mods: Gdk3.SModifierType) =
  gtk_accel_map_add_entry(ucstring(accel_path), accel_key, accel_mods)
# template add_entry*(klass_parameter: typedesc[AccelMap], accel_path: ustring, accel_key: uint32, accel_mods: Gdk3.SModifierType) =

# gtk_accel_map_add_filter
# flags: {} container: AccelMap
# need sugar: is static method
# filter_pattern 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_map_add_filter(filter_pattern: ucstring) {.cdecl, dynlib: lib, importc: "gtk_accel_map_add_filter".}
template add_filter*(klass_parameter: typedesc[AccelMap], filter_pattern: ustring) =
  gtk_accel_map_add_filter(ucstring(filter_pattern))
# template add_filter*(klass_parameter: typedesc[AccelMap], filter_pattern: ustring) =

# gtk_accel_map_change_entry
# flags: {} container: AccelMap
# need sugar: is static method
# accel_path 'ustring' 'ucstring' IN (diff., need sugar)
# accel_key 'uint32' 'uint32' IN
# accel_mods 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# replace 'bool' 'bool' IN
# 'bool' 'bool'
proc gtk_accel_map_change_entry(accel_path: ucstring, accel_key: uint32, accel_mods: Gdk3.SModifierType, replace: bool): bool {.cdecl, dynlib: lib, importc: "gtk_accel_map_change_entry".}
template change_entry*(klass_parameter: typedesc[AccelMap], accel_path: ustring, accel_key: uint32, accel_mods: Gdk3.SModifierType, replace: bool): bool =
  gtk_accel_map_change_entry(ucstring(accel_path), accel_key, accel_mods, replace)
# template change_entry*(klass_parameter: typedesc[AccelMap], accel_path: ustring, accel_key: uint32, accel_mods: Gdk3.SModifierType, replace: bool): bool =

# gtk_accel_map_foreach
# flags: {} container: AccelMap
# need sugar: is static method
# data 'pointer' 'pointer' IN
# foreach_func 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_map_foreach(data: pointer, foreach_func: pointer) {.cdecl, dynlib: lib, importc: "gtk_accel_map_foreach".}
template foreach*(klass_parameter: typedesc[AccelMap], data: pointer, foreach_func: pointer) =
  gtk_accel_map_foreach(data, foreach_func)
# template foreach*(klass_parameter: typedesc[AccelMap], data: pointer, foreach_func: pointer) =

# gtk_accel_map_foreach_unfiltered
# flags: {} container: AccelMap
# need sugar: is static method
# data 'pointer' 'pointer' IN
# foreach_func 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_map_foreach_unfiltered(data: pointer, foreach_func: pointer) {.cdecl, dynlib: lib, importc: "gtk_accel_map_foreach_unfiltered".}
template foreach_unfiltered*(klass_parameter: typedesc[AccelMap], data: pointer, foreach_func: pointer) =
  gtk_accel_map_foreach_unfiltered(data, foreach_func)
# template foreach_unfiltered*(klass_parameter: typedesc[AccelMap], data: pointer, foreach_func: pointer) =

# gtk_accel_map_get
# flags: {} container: AccelMap
# need sugar: is static method
# 'AccelMap' 'TransferNone[TAccelMap]' (diff., need sugar)
proc gtk_accel_map_get(): TransferNone[TAccelMap] {.cdecl, dynlib: lib, importc: "gtk_accel_map_get".}
template get*(klass_parameter: typedesc[AccelMap]): AccelMap =
  wrap(gtk_accel_map_get())
# template get*(klass_parameter: typedesc[AccelMap]): AccelMap =

# gtk_accel_map_load
# flags: {} container: AccelMap
# need sugar: is static method
# file_name 'string' 'cstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_map_load(file_name: cstring) {.cdecl, dynlib: lib, importc: "gtk_accel_map_load".}
template load*(klass_parameter: typedesc[AccelMap], file_name: string) =
  gtk_accel_map_load(cstring(file_name))
# template load*(klass_parameter: typedesc[AccelMap], file_name: string) =

# gtk_accel_map_load_fd
# flags: {} container: AccelMap
# need sugar: is static method
# fd 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_map_load_fd(fd: int32) {.cdecl, dynlib: lib, importc: "gtk_accel_map_load_fd".}
template load_fd*(klass_parameter: typedesc[AccelMap], fd: int32) =
  gtk_accel_map_load_fd(fd)
# template load_fd*(klass_parameter: typedesc[AccelMap], fd: int32) =

# gtk_accel_map_load_scanner
# flags: {} container: AccelMap
# need sugar: is static method
# scanner 'GLib2.TScanner' 'ptr GLib2.TScanner' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_map_load_scanner(scanner: ptr GLib2.TScanner) {.cdecl, dynlib: lib, importc: "gtk_accel_map_load_scanner".}
template load_scanner*(klass_parameter: typedesc[AccelMap], scanner: GLib2.TScanner) =
  gtk_accel_map_load_scanner(myUnsafeAddr(scanner))
# template load_scanner*(klass_parameter: typedesc[AccelMap], scanner: GLib2.TScanner) =

# gtk_accel_map_lock_path
# flags: {} container: AccelMap
# need sugar: is static method
# accel_path 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_map_lock_path(accel_path: ucstring) {.cdecl, dynlib: lib, importc: "gtk_accel_map_lock_path".}
template lock_path*(klass_parameter: typedesc[AccelMap], accel_path: ustring) =
  gtk_accel_map_lock_path(ucstring(accel_path))
# template lock_path*(klass_parameter: typedesc[AccelMap], accel_path: ustring) =

# gtk_accel_map_lookup_entry
# flags: {} container: AccelMap
# need sugar: is static method
# accel_path 'ustring' 'ucstring' IN (diff., need sugar)
# key 'var TAccelKey' 'ptr TAccelKey' OUT (diff., need sugar) caller-allocates optional
# 'bool' 'bool'
proc gtk_accel_map_lookup_entry(accel_path: ucstring, key: ptr TAccelKey): bool {.cdecl, dynlib: lib, importc: "gtk_accel_map_lookup_entry".}
template lookup_entry*(klass_parameter: typedesc[AccelMap], accel_path: ustring, key: var TAccelKey): bool =
  gtk_accel_map_lookup_entry(ucstring(accel_path), addr(key))
# tuple-return
# key: var TAccelKey
# template lookup_entry*(klass_parameter: typedesc[AccelMap], accel_path: ustring): bool =

# gtk_accel_map_save
# flags: {} container: AccelMap
# need sugar: is static method
# file_name 'string' 'cstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_map_save(file_name: cstring) {.cdecl, dynlib: lib, importc: "gtk_accel_map_save".}
template save*(klass_parameter: typedesc[AccelMap], file_name: string) =
  gtk_accel_map_save(cstring(file_name))
# template save*(klass_parameter: typedesc[AccelMap], file_name: string) =

# gtk_accel_map_save_fd
# flags: {} container: AccelMap
# need sugar: is static method
# fd 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_map_save_fd(fd: int32) {.cdecl, dynlib: lib, importc: "gtk_accel_map_save_fd".}
template save_fd*(klass_parameter: typedesc[AccelMap], fd: int32) =
  gtk_accel_map_save_fd(fd)
# template save_fd*(klass_parameter: typedesc[AccelMap], fd: int32) =

# gtk_accel_map_unlock_path
# flags: {} container: AccelMap
# need sugar: is static method
# accel_path 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_map_unlock_path(accel_path: ucstring) {.cdecl, dynlib: lib, importc: "gtk_accel_map_unlock_path".}
template unlock_path*(klass_parameter: typedesc[AccelMap], accel_path: ustring) =
  gtk_accel_map_unlock_path(ucstring(accel_path))
# template unlock_path*(klass_parameter: typedesc[AccelMap], accel_path: ustring) =

# gtk_accessible_connect_widget_destroyed
# flags: {isMethod} container: Accessible (deprecated)
# gtk_accessible_get_widget
# flags: {isMethod} container: Accessible
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_accessible_get_widget(self: ptr TAccessible): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_accessible_get_widget".}
proc get_widget*(self: Accessible): Widget {.inline.} =
  wrap(gtk_accessible_get_widget(self))
# proc get_widget*(self: Accessible): Widget {.inline.} =

# gtk_accessible_set_widget
# flags: {isMethod} container: Accessible
# need sugar: is method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_accessible_set_widget(self: ptr TAccessible, widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_accessible_set_widget".}
proc set_widget*(self: Accessible, widget: Widget) {.inline.} =
  gtk_accessible_set_widget(self, widget.getPointer)
# proc set_widget*(self: Accessible, widget: Widget) {.inline.} =

# gtk_action_new
# flags: {isConstructor} container: Action (deprecated)
# gtk_action_activate
# flags: {isMethod} container: Action (deprecated)
# gtk_action_block_activate
# flags: {isMethod} container: Action (deprecated)
# gtk_action_connect_accelerator
# flags: {isMethod} container: Action (deprecated)
# gtk_action_create_icon
# flags: {isMethod} container: Action (deprecated)
# gtk_action_create_menu
# flags: {isMethod} container: Action (deprecated)
# gtk_action_create_menu_item
# flags: {isMethod} container: Action (deprecated)
# gtk_action_create_tool_item
# flags: {isMethod} container: Action (deprecated)
# gtk_action_disconnect_accelerator
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_accel_closure
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_accel_path
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_always_show_image
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_gicon
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_icon_name
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_is_important
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_label
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_name
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_proxies
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_sensitive
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_short_label
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_stock_id
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_tooltip
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_visible
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_visible_horizontal
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_visible_vertical
# flags: {isMethod} container: Action (deprecated)
# gtk_action_is_sensitive
# flags: {isMethod} container: Action (deprecated)
# gtk_action_is_visible
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_accel_group
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_accel_path
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_always_show_image
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_gicon
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_icon_name
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_is_important
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_label
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_sensitive
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_short_label
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_stock_id
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_tooltip
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_visible
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_visible_horizontal
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_visible_vertical
# flags: {isMethod} container: Action (deprecated)
# gtk_action_unblock_activate
# flags: {isMethod} container: Action (deprecated)
# gtk_action_bar_new
# flags: {isConstructor} container: ActionBar
# need sugar: is static method
# 'ActionBar' 'TransferNone[TActionBar]' (diff., need sugar)
proc gtk_action_bar_new(): TransferNone[TActionBar] {.cdecl, dynlib: lib, importc: "gtk_action_bar_new".}
proc new_actionbar*(): ActionBar {.inline.} =
  wrap(gtk_action_bar_new())
# proc new_actionbar*(): ActionBar {.inline.} =

# gtk_action_bar_get_center_widget
# flags: {isMethod} container: ActionBar
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_action_bar_get_center_widget(self: ptr TActionBar): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_action_bar_get_center_widget".}
proc get_center_widget*(self: ActionBar): Widget {.inline.} =
  wrap(gtk_action_bar_get_center_widget(self))
# proc get_center_widget*(self: ActionBar): Widget {.inline.} =

# gtk_action_bar_pack_end
# flags: {isMethod} container: ActionBar
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_action_bar_pack_end(self: ptr TActionBar, child: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_action_bar_pack_end".}
proc pack_end*(self: ActionBar, child: Widget) {.inline.} =
  gtk_action_bar_pack_end(self, child.getPointer)
# proc pack_end*(self: ActionBar, child: Widget) {.inline.} =

# gtk_action_bar_pack_start
# flags: {isMethod} container: ActionBar
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_action_bar_pack_start(self: ptr TActionBar, child: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_action_bar_pack_start".}
proc pack_start*(self: ActionBar, child: Widget) {.inline.} =
  gtk_action_bar_pack_start(self, child.getPointer)
# proc pack_start*(self: ActionBar, child: Widget) {.inline.} =

# gtk_action_bar_set_center_widget
# flags: {isMethod} container: ActionBar
# need sugar: is method
# center_widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_action_bar_set_center_widget(self: ptr TActionBar, center_widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_action_bar_set_center_widget".}
proc set_center_widget*(self: ActionBar, center_widget: Widget) {.inline.} =
  gtk_action_bar_set_center_widget(self, center_widget.getPointer)
# proc set_center_widget*(self: ActionBar, center_widget: Widget) {.inline.} =

# gtk_action_group_new
# flags: {isConstructor} container: ActionGroup (deprecated)
# gtk_action_group_add_action
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_add_action_with_accel
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_get_accel_group
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_get_action
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_get_name
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_get_sensitive
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_get_visible
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_list_actions
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_remove_action
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_set_accel_group
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_set_sensitive
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_set_translate_func
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_set_translation_domain
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_set_visible
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_translate_string
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_adjustment_new
# flags: {isConstructor} container: Adjustment
# need sugar: is static method
# value 'float64' 'float64' IN
# lower 'float64' 'float64' IN
# upper 'float64' 'float64' IN
# step_increment 'float64' 'float64' IN
# page_increment 'float64' 'float64' IN
# page_size 'float64' 'float64' IN
# 'Adjustment' 'TransferNone[TAdjustment]' (diff., need sugar)
proc gtk_adjustment_new(value: float64, lower: float64, upper: float64, step_increment: float64, page_increment: float64, page_size: float64): TransferNone[TAdjustment] {.cdecl, dynlib: lib, importc: "gtk_adjustment_new".}
proc new_adjustment*(value: float64, lower: float64, upper: float64, step_increment: float64, page_increment: float64, page_size: float64): Adjustment {.inline.} =
  wrap(gtk_adjustment_new(value, lower, upper, step_increment, page_increment, page_size))
# proc new_adjustment*(value: float64, lower: float64, upper: float64, step_increment: float64, page_increment: float64, page_size: float64): Adjustment {.inline.} =

# gtk_adjustment_changed
# flags: {isMethod} container: Adjustment
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_adjustment_changed(self: ptr TAdjustment) {.cdecl, dynlib: lib, importc: "gtk_adjustment_changed".}
proc changed*(self: Adjustment) {.inline.} =
  gtk_adjustment_changed(self)
# proc changed*(self: Adjustment) {.inline.} =

# gtk_adjustment_clamp_page
# flags: {isMethod} container: Adjustment
# need sugar: is method
# lower 'float64' 'float64' IN
# upper 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_adjustment_clamp_page(self: ptr TAdjustment, lower: float64, upper: float64) {.cdecl, dynlib: lib, importc: "gtk_adjustment_clamp_page".}
proc clamp_page*(self: Adjustment, lower: float64, upper: float64) {.inline.} =
  gtk_adjustment_clamp_page(self, lower, upper)
# proc clamp_page*(self: Adjustment, lower: float64, upper: float64) {.inline.} =

# gtk_adjustment_configure
# flags: {isMethod} container: Adjustment
# need sugar: is method
# value 'float64' 'float64' IN
# lower 'float64' 'float64' IN
# upper 'float64' 'float64' IN
# step_increment 'float64' 'float64' IN
# page_increment 'float64' 'float64' IN
# page_size 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_adjustment_configure(self: ptr TAdjustment, value: float64, lower: float64, upper: float64, step_increment: float64, page_increment: float64, page_size: float64) {.cdecl, dynlib: lib, importc: "gtk_adjustment_configure".}
proc configure*(self: Adjustment, value: float64, lower: float64, upper: float64, step_increment: float64, page_increment: float64, page_size: float64) {.inline.} =
  gtk_adjustment_configure(self, value, lower, upper, step_increment, page_increment, page_size)
# proc configure*(self: Adjustment, value: float64, lower: float64, upper: float64, step_increment: float64, page_increment: float64, page_size: float64) {.inline.} =

# gtk_adjustment_get_lower
# flags: {isMethod} container: Adjustment
# need sugar: is method
# 'float64' 'float64'
proc gtk_adjustment_get_lower(self: ptr TAdjustment): float64 {.cdecl, dynlib: lib, importc: "gtk_adjustment_get_lower".}
proc get_lower*(self: Adjustment): float64 {.inline.} =
  gtk_adjustment_get_lower(self)
# proc get_lower*(self: Adjustment): float64 {.inline.} =

# gtk_adjustment_get_minimum_increment
# flags: {isMethod} container: Adjustment
# need sugar: is method
# 'float64' 'float64'
proc gtk_adjustment_get_minimum_increment(self: ptr TAdjustment): float64 {.cdecl, dynlib: lib, importc: "gtk_adjustment_get_minimum_increment".}
proc get_minimum_increment*(self: Adjustment): float64 {.inline.} =
  gtk_adjustment_get_minimum_increment(self)
# proc get_minimum_increment*(self: Adjustment): float64 {.inline.} =

# gtk_adjustment_get_page_increment
# flags: {isMethod} container: Adjustment
# need sugar: is method
# 'float64' 'float64'
proc gtk_adjustment_get_page_increment(self: ptr TAdjustment): float64 {.cdecl, dynlib: lib, importc: "gtk_adjustment_get_page_increment".}
proc get_page_increment*(self: Adjustment): float64 {.inline.} =
  gtk_adjustment_get_page_increment(self)
# proc get_page_increment*(self: Adjustment): float64 {.inline.} =

# gtk_adjustment_get_page_size
# flags: {isMethod} container: Adjustment
# need sugar: is method
# 'float64' 'float64'
proc gtk_adjustment_get_page_size(self: ptr TAdjustment): float64 {.cdecl, dynlib: lib, importc: "gtk_adjustment_get_page_size".}
proc get_page_size*(self: Adjustment): float64 {.inline.} =
  gtk_adjustment_get_page_size(self)
# proc get_page_size*(self: Adjustment): float64 {.inline.} =

# gtk_adjustment_get_step_increment
# flags: {isMethod} container: Adjustment
# need sugar: is method
# 'float64' 'float64'
proc gtk_adjustment_get_step_increment(self: ptr TAdjustment): float64 {.cdecl, dynlib: lib, importc: "gtk_adjustment_get_step_increment".}
proc get_step_increment*(self: Adjustment): float64 {.inline.} =
  gtk_adjustment_get_step_increment(self)
# proc get_step_increment*(self: Adjustment): float64 {.inline.} =

# gtk_adjustment_get_upper
# flags: {isMethod} container: Adjustment
# need sugar: is method
# 'float64' 'float64'
proc gtk_adjustment_get_upper(self: ptr TAdjustment): float64 {.cdecl, dynlib: lib, importc: "gtk_adjustment_get_upper".}
proc get_upper*(self: Adjustment): float64 {.inline.} =
  gtk_adjustment_get_upper(self)
# proc get_upper*(self: Adjustment): float64 {.inline.} =

# gtk_adjustment_get_value
# flags: {isMethod} container: Adjustment
# need sugar: is method
# 'float64' 'float64'
proc gtk_adjustment_get_value(self: ptr TAdjustment): float64 {.cdecl, dynlib: lib, importc: "gtk_adjustment_get_value".}
proc get_value*(self: Adjustment): float64 {.inline.} =
  gtk_adjustment_get_value(self)
# proc get_value*(self: Adjustment): float64 {.inline.} =

# gtk_adjustment_set_lower
# flags: {isMethod} container: Adjustment
# need sugar: is method
# lower 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_adjustment_set_lower(self: ptr TAdjustment, lower: float64) {.cdecl, dynlib: lib, importc: "gtk_adjustment_set_lower".}
proc set_lower*(self: Adjustment, lower: float64) {.inline.} =
  gtk_adjustment_set_lower(self, lower)
# proc set_lower*(self: Adjustment, lower: float64) {.inline.} =

# gtk_adjustment_set_page_increment
# flags: {isMethod} container: Adjustment
# need sugar: is method
# page_increment 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_adjustment_set_page_increment(self: ptr TAdjustment, page_increment: float64) {.cdecl, dynlib: lib, importc: "gtk_adjustment_set_page_increment".}
proc set_page_increment*(self: Adjustment, page_increment: float64) {.inline.} =
  gtk_adjustment_set_page_increment(self, page_increment)
# proc set_page_increment*(self: Adjustment, page_increment: float64) {.inline.} =

# gtk_adjustment_set_page_size
# flags: {isMethod} container: Adjustment
# need sugar: is method
# page_size 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_adjustment_set_page_size(self: ptr TAdjustment, page_size: float64) {.cdecl, dynlib: lib, importc: "gtk_adjustment_set_page_size".}
proc set_page_size*(self: Adjustment, page_size: float64) {.inline.} =
  gtk_adjustment_set_page_size(self, page_size)
# proc set_page_size*(self: Adjustment, page_size: float64) {.inline.} =

# gtk_adjustment_set_step_increment
# flags: {isMethod} container: Adjustment
# need sugar: is method
# step_increment 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_adjustment_set_step_increment(self: ptr TAdjustment, step_increment: float64) {.cdecl, dynlib: lib, importc: "gtk_adjustment_set_step_increment".}
proc set_step_increment*(self: Adjustment, step_increment: float64) {.inline.} =
  gtk_adjustment_set_step_increment(self, step_increment)
# proc set_step_increment*(self: Adjustment, step_increment: float64) {.inline.} =

# gtk_adjustment_set_upper
# flags: {isMethod} container: Adjustment
# need sugar: is method
# upper 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_adjustment_set_upper(self: ptr TAdjustment, upper: float64) {.cdecl, dynlib: lib, importc: "gtk_adjustment_set_upper".}
proc set_upper*(self: Adjustment, upper: float64) {.inline.} =
  gtk_adjustment_set_upper(self, upper)
# proc set_upper*(self: Adjustment, upper: float64) {.inline.} =

# gtk_adjustment_set_value
# flags: {isMethod} container: Adjustment
# need sugar: is method
# value 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_adjustment_set_value(self: ptr TAdjustment, value: float64) {.cdecl, dynlib: lib, importc: "gtk_adjustment_set_value".}
proc set_value*(self: Adjustment, value: float64) {.inline.} =
  gtk_adjustment_set_value(self, value)
# proc set_value*(self: Adjustment, value: float64) {.inline.} =

# gtk_adjustment_value_changed
# flags: {isMethod} container: Adjustment
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_adjustment_value_changed(self: ptr TAdjustment) {.cdecl, dynlib: lib, importc: "gtk_adjustment_value_changed".}
proc value_changed*(self: Adjustment) {.inline.} =
  gtk_adjustment_value_changed(self)
# proc value_changed*(self: Adjustment) {.inline.} =

# gtk_alignment_new
# flags: {isConstructor} container: Alignment (deprecated)
# gtk_alignment_get_padding
# flags: {isMethod} container: Alignment (deprecated)
# gtk_alignment_set
# flags: {isMethod} container: Alignment (deprecated)
# gtk_alignment_set_padding
# flags: {isMethod} container: Alignment (deprecated)
# gtk_app_chooser_button_new
# flags: {isConstructor} container: AppChooserButton
# need sugar: is static method
# content_type 'ustring' 'ucstring' IN (diff., need sugar)
# 'AppChooserButton' 'TransferNone[TAppChooserButton]' (diff., need sugar)
proc gtk_app_chooser_button_new(content_type: ucstring): TransferNone[TAppChooserButton] {.cdecl, dynlib: lib, importc: "gtk_app_chooser_button_new".}
proc new_appchooserbutton*(content_type: ustring): AppChooserButton {.inline.} =
  wrap(gtk_app_chooser_button_new(ucstring(content_type)))
# proc new_appchooserbutton*(content_type: ustring): AppChooserButton {.inline.} =

# gtk_app_chooser_button_append_custom_item
# flags: {isMethod} container: AppChooserButton
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# label 'ustring' 'ucstring' IN (diff., need sugar)
# icon 'Gio2.Icon' 'ptr Gio2.TIcon' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_app_chooser_button_append_custom_item(self: ptr TAppChooserButton, name: ucstring, label: ucstring, icon: ptr Gio2.TIcon) {.cdecl, dynlib: lib, importc: "gtk_app_chooser_button_append_custom_item".}
proc append_custom_item*(self: AppChooserButton, name: ustring, label: ustring, icon: Gio2.Icon) {.inline.} =
  gtk_app_chooser_button_append_custom_item(self, ucstring(name), ucstring(label), unwrap(icon))
# proc append_custom_item*(self: AppChooserButton, name: ustring, label: ustring, icon: Gio2.Icon) {.inline.} =

# gtk_app_chooser_button_append_separator
# flags: {isMethod} container: AppChooserButton
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_app_chooser_button_append_separator(self: ptr TAppChooserButton) {.cdecl, dynlib: lib, importc: "gtk_app_chooser_button_append_separator".}
proc append_separator*(self: AppChooserButton) {.inline.} =
  gtk_app_chooser_button_append_separator(self)
# proc append_separator*(self: AppChooserButton) {.inline.} =

# gtk_app_chooser_button_get_heading
# flags: {isMethod} container: AppChooserButton
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_app_chooser_button_get_heading(self: ptr TAppChooserButton): ucstring {.cdecl, dynlib: lib, importc: "gtk_app_chooser_button_get_heading".}
proc get_heading*(self: AppChooserButton): ustring {.inline.} =
  ustring($(gtk_app_chooser_button_get_heading(self)))
# proc get_heading*(self: AppChooserButton): ustring {.inline.} =

# gtk_app_chooser_button_get_show_default_item
# flags: {isMethod} container: AppChooserButton
# need sugar: is method
# 'bool' 'bool'
proc gtk_app_chooser_button_get_show_default_item(self: ptr TAppChooserButton): bool {.cdecl, dynlib: lib, importc: "gtk_app_chooser_button_get_show_default_item".}
proc get_show_default_item*(self: AppChooserButton): bool {.inline.} =
  gtk_app_chooser_button_get_show_default_item(self)
# proc get_show_default_item*(self: AppChooserButton): bool {.inline.} =

# gtk_app_chooser_button_get_show_dialog_item
# flags: {isMethod} container: AppChooserButton
# need sugar: is method
# 'bool' 'bool'
proc gtk_app_chooser_button_get_show_dialog_item(self: ptr TAppChooserButton): bool {.cdecl, dynlib: lib, importc: "gtk_app_chooser_button_get_show_dialog_item".}
proc get_show_dialog_item*(self: AppChooserButton): bool {.inline.} =
  gtk_app_chooser_button_get_show_dialog_item(self)
# proc get_show_dialog_item*(self: AppChooserButton): bool {.inline.} =

# gtk_app_chooser_button_set_active_custom_item
# flags: {isMethod} container: AppChooserButton
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_app_chooser_button_set_active_custom_item(self: ptr TAppChooserButton, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_app_chooser_button_set_active_custom_item".}
proc set_active_custom_item*(self: AppChooserButton, name: ustring) {.inline.} =
  gtk_app_chooser_button_set_active_custom_item(self, ucstring(name))
# proc set_active_custom_item*(self: AppChooserButton, name: ustring) {.inline.} =

# gtk_app_chooser_button_set_heading
# flags: {isMethod} container: AppChooserButton
# need sugar: is method
# heading 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_app_chooser_button_set_heading(self: ptr TAppChooserButton, heading: ucstring) {.cdecl, dynlib: lib, importc: "gtk_app_chooser_button_set_heading".}
proc set_heading*(self: AppChooserButton, heading: ustring) {.inline.} =
  gtk_app_chooser_button_set_heading(self, ucstring(heading))
# proc set_heading*(self: AppChooserButton, heading: ustring) {.inline.} =

# gtk_app_chooser_button_set_show_default_item
# flags: {isMethod} container: AppChooserButton
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_app_chooser_button_set_show_default_item(self: ptr TAppChooserButton, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_app_chooser_button_set_show_default_item".}
proc set_show_default_item*(self: AppChooserButton, setting: bool) {.inline.} =
  gtk_app_chooser_button_set_show_default_item(self, setting)
# proc set_show_default_item*(self: AppChooserButton, setting: bool) {.inline.} =

# gtk_app_chooser_button_set_show_dialog_item
# flags: {isMethod} container: AppChooserButton
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_app_chooser_button_set_show_dialog_item(self: ptr TAppChooserButton, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_app_chooser_button_set_show_dialog_item".}
proc set_show_dialog_item*(self: AppChooserButton, setting: bool) {.inline.} =
  gtk_app_chooser_button_set_show_dialog_item(self, setting)
# proc set_show_dialog_item*(self: AppChooserButton, setting: bool) {.inline.} =

# gtk_app_chooser_dialog_new
# flags: {isConstructor} container: AppChooserDialog
# need sugar: is static method
# parent 'Window' 'ptr TWindow' IN (diff., need sugar)
# flags 'SDialogFlags' 'SDialogFlags' IN
# file 'Gio2.File' 'ptr Gio2.TFile' IN (diff., need sugar)
# 'AppChooserDialog' 'TransferNone[TAppChooserDialog]' (diff., need sugar)
proc gtk_app_chooser_dialog_new(parent: ptr TWindow, flags: SDialogFlags, file: ptr Gio2.TFile): TransferNone[TAppChooserDialog] {.cdecl, dynlib: lib, importc: "gtk_app_chooser_dialog_new".}
proc new_appchooserdialog*(parent: Window, flags: SDialogFlags, file: Gio2.File): AppChooserDialog {.inline.} =
  wrap(gtk_app_chooser_dialog_new(parent.getPointer, flags, unwrap(file)))
# proc new_appchooserdialog*(parent: Window, flags: SDialogFlags, file: Gio2.File): AppChooserDialog {.inline.} =

# gtk_app_chooser_dialog_new_for_content_type
# flags: {isConstructor} container: AppChooserDialog
# need sugar: is static method
# parent 'Window' 'ptr TWindow' IN (diff., need sugar)
# flags 'SDialogFlags' 'SDialogFlags' IN
# content_type 'ustring' 'ucstring' IN (diff., need sugar)
# 'AppChooserDialog' 'TransferNone[TAppChooserDialog]' (diff., need sugar)
proc gtk_app_chooser_dialog_new_for_content_type(parent: ptr TWindow, flags: SDialogFlags, content_type: ucstring): TransferNone[TAppChooserDialog] {.cdecl, dynlib: lib, importc: "gtk_app_chooser_dialog_new_for_content_type".}
proc new_appchooserdialog_for_content_type*(parent: Window, flags: SDialogFlags, content_type: ustring): AppChooserDialog {.inline.} =
  wrap(gtk_app_chooser_dialog_new_for_content_type(parent.getPointer, flags, ucstring(content_type)))
# proc new_appchooserdialog_for_content_type*(parent: Window, flags: SDialogFlags, content_type: ustring): AppChooserDialog {.inline.} =

# gtk_app_chooser_dialog_get_heading
# flags: {isMethod} container: AppChooserDialog
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_app_chooser_dialog_get_heading(self: ptr TAppChooserDialog): ucstring {.cdecl, dynlib: lib, importc: "gtk_app_chooser_dialog_get_heading".}
proc get_heading*(self: AppChooserDialog): ustring {.inline.} =
  ustring($(gtk_app_chooser_dialog_get_heading(self)))
# proc get_heading*(self: AppChooserDialog): ustring {.inline.} =

# gtk_app_chooser_dialog_get_widget
# flags: {isMethod} container: AppChooserDialog
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_app_chooser_dialog_get_widget(self: ptr TAppChooserDialog): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_app_chooser_dialog_get_widget".}
proc get_widget*(self: AppChooserDialog): Widget {.inline.} =
  wrap(gtk_app_chooser_dialog_get_widget(self))
# proc get_widget*(self: AppChooserDialog): Widget {.inline.} =

# gtk_app_chooser_dialog_set_heading
# flags: {isMethod} container: AppChooserDialog
# need sugar: is method
# heading 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_app_chooser_dialog_set_heading(self: ptr TAppChooserDialog, heading: ucstring) {.cdecl, dynlib: lib, importc: "gtk_app_chooser_dialog_set_heading".}
proc set_heading*(self: AppChooserDialog, heading: ustring) {.inline.} =
  gtk_app_chooser_dialog_set_heading(self, ucstring(heading))
# proc set_heading*(self: AppChooserDialog, heading: ustring) {.inline.} =

# gtk_app_chooser_widget_new
# flags: {isConstructor} container: AppChooserWidget
# need sugar: is static method
# content_type 'ustring' 'ucstring' IN (diff., need sugar)
# 'AppChooserWidget' 'TransferNone[TAppChooserWidget]' (diff., need sugar)
proc gtk_app_chooser_widget_new(content_type: ucstring): TransferNone[TAppChooserWidget] {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_new".}
proc new_appchooserwidget*(content_type: ustring): AppChooserWidget {.inline.} =
  wrap(gtk_app_chooser_widget_new(ucstring(content_type)))
# proc new_appchooserwidget*(content_type: ustring): AppChooserWidget {.inline.} =

# gtk_app_chooser_widget_get_default_text
# flags: {isMethod} container: AppChooserWidget
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_app_chooser_widget_get_default_text(self: ptr TAppChooserWidget): ucstring {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_get_default_text".}
proc get_default_text*(self: AppChooserWidget): ustring {.inline.} =
  ustring($(gtk_app_chooser_widget_get_default_text(self)))
# proc get_default_text*(self: AppChooserWidget): ustring {.inline.} =

# gtk_app_chooser_widget_get_show_all
# flags: {isMethod} container: AppChooserWidget
# need sugar: is method
# 'bool' 'bool'
proc gtk_app_chooser_widget_get_show_all(self: ptr TAppChooserWidget): bool {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_get_show_all".}
proc get_show_all*(self: AppChooserWidget): bool {.inline.} =
  gtk_app_chooser_widget_get_show_all(self)
# proc get_show_all*(self: AppChooserWidget): bool {.inline.} =

# gtk_app_chooser_widget_get_show_default
# flags: {isMethod} container: AppChooserWidget
# need sugar: is method
# 'bool' 'bool'
proc gtk_app_chooser_widget_get_show_default(self: ptr TAppChooserWidget): bool {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_get_show_default".}
proc get_show_default*(self: AppChooserWidget): bool {.inline.} =
  gtk_app_chooser_widget_get_show_default(self)
# proc get_show_default*(self: AppChooserWidget): bool {.inline.} =

# gtk_app_chooser_widget_get_show_fallback
# flags: {isMethod} container: AppChooserWidget
# need sugar: is method
# 'bool' 'bool'
proc gtk_app_chooser_widget_get_show_fallback(self: ptr TAppChooserWidget): bool {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_get_show_fallback".}
proc get_show_fallback*(self: AppChooserWidget): bool {.inline.} =
  gtk_app_chooser_widget_get_show_fallback(self)
# proc get_show_fallback*(self: AppChooserWidget): bool {.inline.} =

# gtk_app_chooser_widget_get_show_other
# flags: {isMethod} container: AppChooserWidget
# need sugar: is method
# 'bool' 'bool'
proc gtk_app_chooser_widget_get_show_other(self: ptr TAppChooserWidget): bool {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_get_show_other".}
proc get_show_other*(self: AppChooserWidget): bool {.inline.} =
  gtk_app_chooser_widget_get_show_other(self)
# proc get_show_other*(self: AppChooserWidget): bool {.inline.} =

# gtk_app_chooser_widget_get_show_recommended
# flags: {isMethod} container: AppChooserWidget
# need sugar: is method
# 'bool' 'bool'
proc gtk_app_chooser_widget_get_show_recommended(self: ptr TAppChooserWidget): bool {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_get_show_recommended".}
proc get_show_recommended*(self: AppChooserWidget): bool {.inline.} =
  gtk_app_chooser_widget_get_show_recommended(self)
# proc get_show_recommended*(self: AppChooserWidget): bool {.inline.} =

# gtk_app_chooser_widget_set_default_text
# flags: {isMethod} container: AppChooserWidget
# need sugar: is method
# text 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_app_chooser_widget_set_default_text(self: ptr TAppChooserWidget, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_set_default_text".}
proc set_default_text*(self: AppChooserWidget, text: ustring) {.inline.} =
  gtk_app_chooser_widget_set_default_text(self, ucstring(text))
# proc set_default_text*(self: AppChooserWidget, text: ustring) {.inline.} =

# gtk_app_chooser_widget_set_show_all
# flags: {isMethod} container: AppChooserWidget
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_app_chooser_widget_set_show_all(self: ptr TAppChooserWidget, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_set_show_all".}
proc set_show_all*(self: AppChooserWidget, setting: bool) {.inline.} =
  gtk_app_chooser_widget_set_show_all(self, setting)
# proc set_show_all*(self: AppChooserWidget, setting: bool) {.inline.} =

# gtk_app_chooser_widget_set_show_default
# flags: {isMethod} container: AppChooserWidget
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_app_chooser_widget_set_show_default(self: ptr TAppChooserWidget, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_set_show_default".}
proc set_show_default*(self: AppChooserWidget, setting: bool) {.inline.} =
  gtk_app_chooser_widget_set_show_default(self, setting)
# proc set_show_default*(self: AppChooserWidget, setting: bool) {.inline.} =

# gtk_app_chooser_widget_set_show_fallback
# flags: {isMethod} container: AppChooserWidget
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_app_chooser_widget_set_show_fallback(self: ptr TAppChooserWidget, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_set_show_fallback".}
proc set_show_fallback*(self: AppChooserWidget, setting: bool) {.inline.} =
  gtk_app_chooser_widget_set_show_fallback(self, setting)
# proc set_show_fallback*(self: AppChooserWidget, setting: bool) {.inline.} =

# gtk_app_chooser_widget_set_show_other
# flags: {isMethod} container: AppChooserWidget
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_app_chooser_widget_set_show_other(self: ptr TAppChooserWidget, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_set_show_other".}
proc set_show_other*(self: AppChooserWidget, setting: bool) {.inline.} =
  gtk_app_chooser_widget_set_show_other(self, setting)
# proc set_show_other*(self: AppChooserWidget, setting: bool) {.inline.} =

# gtk_app_chooser_widget_set_show_recommended
# flags: {isMethod} container: AppChooserWidget
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_app_chooser_widget_set_show_recommended(self: ptr TAppChooserWidget, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_set_show_recommended".}
proc set_show_recommended*(self: AppChooserWidget, setting: bool) {.inline.} =
  gtk_app_chooser_widget_set_show_recommended(self, setting)
# proc set_show_recommended*(self: AppChooserWidget, setting: bool) {.inline.} =

# gtk_application_new
# flags: {isConstructor} container: Application
# need sugar: is static method
# application_id 'ustring' 'ucstring' IN (diff., need sugar)
# flags 'Gio2.SApplicationFlags' 'Gio2.SApplicationFlags' IN
# 'Application' 'TransferFull[TApplication]' (diff., need sugar)
proc gtk_application_new(application_id: ucstring, flags: Gio2.SApplicationFlags): TransferFull[TApplication] {.cdecl, dynlib: lib, importc: "gtk_application_new".}
proc new_application*(application_id: ustring, flags: Gio2.SApplicationFlags): Application {.inline.} =
  wrap(gtk_application_new(ucstring(application_id), flags))
# proc new_application*(application_id: ustring, flags: Gio2.SApplicationFlags): Application {.inline.} =

# gtk_application_add_accelerator
# flags: {isMethod} container: Application (deprecated)
# gtk_application_add_window
# flags: {isMethod} container: Application
# need sugar: is method
# window 'Window' 'ptr TWindow' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_application_add_window(self: ptr TApplication, window: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_application_add_window".}
proc add_window*(self: Application, window: Window) {.inline.} =
  gtk_application_add_window(self, window.getPointer)
# proc add_window*(self: Application, window: Window) {.inline.} =

# gtk_application_get_accels_for_action
# flags: {isMethod} container: Application
# need sugar: is method
# detailed_action_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'zeroTerminatedArray[ucstring]' 'zeroTerminatedArray[ucstring]'
proc gtk_application_get_accels_for_action(self: ptr TApplication, detailed_action_name: ucstring): zeroTerminatedArray[ucstring] {.cdecl, dynlib: lib, importc: "gtk_application_get_accels_for_action".}
proc get_accels_for_action*(self: Application, detailed_action_name: ustring): zeroTerminatedArray[ucstring] {.inline.} =
  gtk_application_get_accels_for_action(self, ucstring(detailed_action_name))
# proc get_accels_for_action*(self: Application, detailed_action_name: ustring): zeroTerminatedArray[ucstring] {.inline.} =

# gtk_application_get_actions_for_accel
# flags: {isMethod} container: Application
# need sugar: is method
# accel 'ustring' 'ucstring' IN (diff., need sugar)
# 'zeroTerminatedArray[ucstring]' 'zeroTerminatedArray[ucstring]'
proc gtk_application_get_actions_for_accel(self: ptr TApplication, accel: ucstring): zeroTerminatedArray[ucstring] {.cdecl, dynlib: lib, importc: "gtk_application_get_actions_for_accel".}
proc get_actions_for_accel*(self: Application, accel: ustring): zeroTerminatedArray[ucstring] {.inline.} =
  gtk_application_get_actions_for_accel(self, ucstring(accel))
# proc get_actions_for_accel*(self: Application, accel: ustring): zeroTerminatedArray[ucstring] {.inline.} =

# gtk_application_get_active_window
# flags: {isMethod} container: Application
# need sugar: is method
# 'Window' 'TransferNone[TWindow]' (diff., need sugar)
proc gtk_application_get_active_window(self: ptr TApplication): TransferNone[TWindow] {.cdecl, dynlib: lib, importc: "gtk_application_get_active_window".}
proc get_active_window*(self: Application): Window {.inline.} =
  wrap(gtk_application_get_active_window(self))
# proc get_active_window*(self: Application): Window {.inline.} =

# gtk_application_get_app_menu
# flags: {isMethod} container: Application
# need sugar: is method
# 'Gio2.MenuModel' 'TransferNone[Gio2.TMenuModel]' (diff., need sugar)
proc gtk_application_get_app_menu(self: ptr TApplication): TransferNone[Gio2.TMenuModel] {.cdecl, dynlib: lib, importc: "gtk_application_get_app_menu".}
proc get_app_menu*(self: Application): Gio2.MenuModel {.inline.} =
  wrap(gtk_application_get_app_menu(self))
# proc get_app_menu*(self: Application): Gio2.MenuModel {.inline.} =

# gtk_application_get_menu_by_id
# flags: {isMethod} container: Application
# need sugar: is method
# id 'ustring' 'ucstring' IN (diff., need sugar)
# 'Gio2.Menu' 'TransferNone[Gio2.TMenu]' (diff., need sugar)
proc gtk_application_get_menu_by_id(self: ptr TApplication, id: ucstring): TransferNone[Gio2.TMenu] {.cdecl, dynlib: lib, importc: "gtk_application_get_menu_by_id".}
proc get_menu_by_id*(self: Application, id: ustring): Gio2.Menu {.inline.} =
  wrap(gtk_application_get_menu_by_id(self, ucstring(id)))
# proc get_menu_by_id*(self: Application, id: ustring): Gio2.Menu {.inline.} =

# gtk_application_get_menubar
# flags: {isMethod} container: Application
# need sugar: is method
# 'Gio2.MenuModel' 'TransferNone[Gio2.TMenuModel]' (diff., need sugar)
proc gtk_application_get_menubar(self: ptr TApplication): TransferNone[Gio2.TMenuModel] {.cdecl, dynlib: lib, importc: "gtk_application_get_menubar".}
proc get_menubar*(self: Application): Gio2.MenuModel {.inline.} =
  wrap(gtk_application_get_menubar(self))
# proc get_menubar*(self: Application): Gio2.MenuModel {.inline.} =

# gtk_application_get_window_by_id
# flags: {isMethod} container: Application
# need sugar: is method
# id 'uint32' 'uint32' IN
# 'Window' 'TransferNone[TWindow]' (diff., need sugar)
proc gtk_application_get_window_by_id(self: ptr TApplication, id: uint32): TransferNone[TWindow] {.cdecl, dynlib: lib, importc: "gtk_application_get_window_by_id".}
proc get_window_by_id*(self: Application, id: uint32): Window {.inline.} =
  wrap(gtk_application_get_window_by_id(self, id))
# proc get_window_by_id*(self: Application, id: uint32): Window {.inline.} =

# gtk_application_get_windows
# flags: {isMethod} container: Application
# need sugar: is method
# 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_application_get_windows(self: ptr TApplication): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_application_get_windows".}
proc get_windows*(self: Application): ptr GLIST_TODO {.inline.} =
  gtk_application_get_windows(self)
# proc get_windows*(self: Application): ptr GLIST_TODO {.inline.} =

# gtk_application_inhibit
# flags: {isMethod} container: Application
# need sugar: is method
# window 'Window' 'ptr TWindow' IN (diff., need sugar)
# flags 'SApplicationInhibitFlags' 'SApplicationInhibitFlags' IN
# reason 'ustring' 'ucstring' IN (diff., need sugar)
# 'uint32' 'uint32'
proc gtk_application_inhibit(self: ptr TApplication, window: ptr TWindow, flags: SApplicationInhibitFlags, reason: ucstring): uint32 {.cdecl, dynlib: lib, importc: "gtk_application_inhibit".}
proc inhibit*(self: Application, window: Window, flags: SApplicationInhibitFlags, reason: ustring): uint32 {.inline.} =
  gtk_application_inhibit(self, window.getPointer, flags, ucstring(reason))
# proc inhibit*(self: Application, window: Window, flags: SApplicationInhibitFlags, reason: ustring): uint32 {.inline.} =

# gtk_application_is_inhibited
# flags: {isMethod} container: Application
# need sugar: is method
# flags 'SApplicationInhibitFlags' 'SApplicationInhibitFlags' IN
# 'bool' 'bool'
proc gtk_application_is_inhibited(self: ptr TApplication, flags: SApplicationInhibitFlags): bool {.cdecl, dynlib: lib, importc: "gtk_application_is_inhibited".}
proc is_inhibited*(self: Application, flags: SApplicationInhibitFlags): bool {.inline.} =
  gtk_application_is_inhibited(self, flags)
# proc is_inhibited*(self: Application, flags: SApplicationInhibitFlags): bool {.inline.} =

# gtk_application_list_action_descriptions
# flags: {isMethod} container: Application
# need sugar: is method
# 'zeroTerminatedArray[ucstring]' 'zeroTerminatedArray[ucstring]'
proc gtk_application_list_action_descriptions(self: ptr TApplication): zeroTerminatedArray[ucstring] {.cdecl, dynlib: lib, importc: "gtk_application_list_action_descriptions".}
proc list_action_descriptions*(self: Application): zeroTerminatedArray[ucstring] {.inline.} =
  gtk_application_list_action_descriptions(self)
# proc list_action_descriptions*(self: Application): zeroTerminatedArray[ucstring] {.inline.} =

# gtk_application_prefers_app_menu
# flags: {isMethod} container: Application
# need sugar: is method
# 'bool' 'bool'
proc gtk_application_prefers_app_menu(self: ptr TApplication): bool {.cdecl, dynlib: lib, importc: "gtk_application_prefers_app_menu".}
proc prefers_app_menu*(self: Application): bool {.inline.} =
  gtk_application_prefers_app_menu(self)
# proc prefers_app_menu*(self: Application): bool {.inline.} =

# gtk_application_remove_accelerator
# flags: {isMethod} container: Application (deprecated)
# gtk_application_remove_window
# flags: {isMethod} container: Application
# need sugar: is method
# window 'Window' 'ptr TWindow' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_application_remove_window(self: ptr TApplication, window: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_application_remove_window".}
proc remove_window*(self: Application, window: Window) {.inline.} =
  gtk_application_remove_window(self, window.getPointer)
# proc remove_window*(self: Application, window: Window) {.inline.} =

# gtk_application_set_accels_for_action
# flags: {isMethod} container: Application
# need sugar: is method
# detailed_action_name 'ustring' 'ucstring' IN (diff., need sugar)
# accels 'uncheckedArray[ucstring]' 'uncheckedArray[ucstring]' IN array zero-terminated
# 'VOID_TODO' 'VOID_TODO'
proc gtk_application_set_accels_for_action(self: ptr TApplication, detailed_action_name: ucstring, accels: uncheckedArray[ucstring]) {.cdecl, dynlib: lib, importc: "gtk_application_set_accels_for_action".}
proc set_accels_for_action*(self: Application, detailed_action_name: ustring, accels: uncheckedArray[ucstring]) {.inline.} =
  gtk_application_set_accels_for_action(self, ucstring(detailed_action_name), accels)
# proc set_accels_for_action*(self: Application, detailed_action_name: ustring, accels: uncheckedArray[ucstring]) {.inline.} =

# gtk_application_set_app_menu
# flags: {isMethod} container: Application
# need sugar: is method
# app_menu 'Gio2.MenuModel' 'ptr Gio2.TMenuModel' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_application_set_app_menu(self: ptr TApplication, app_menu: ptr Gio2.TMenuModel) {.cdecl, dynlib: lib, importc: "gtk_application_set_app_menu".}
proc set_app_menu*(self: Application, app_menu: Gio2.MenuModel) {.inline.} =
  gtk_application_set_app_menu(self, app_menu.getPointer)
# proc set_app_menu*(self: Application, app_menu: Gio2.MenuModel) {.inline.} =

# gtk_application_set_menubar
# flags: {isMethod} container: Application
# need sugar: is method
# menubar 'Gio2.MenuModel' 'ptr Gio2.TMenuModel' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_application_set_menubar(self: ptr TApplication, menubar: ptr Gio2.TMenuModel) {.cdecl, dynlib: lib, importc: "gtk_application_set_menubar".}
proc set_menubar*(self: Application, menubar: Gio2.MenuModel) {.inline.} =
  gtk_application_set_menubar(self, menubar.getPointer)
# proc set_menubar*(self: Application, menubar: Gio2.MenuModel) {.inline.} =

# gtk_application_uninhibit
# flags: {isMethod} container: Application
# need sugar: is method
# cookie 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_application_uninhibit(self: ptr TApplication, cookie: uint32) {.cdecl, dynlib: lib, importc: "gtk_application_uninhibit".}
proc uninhibit*(self: Application, cookie: uint32) {.inline.} =
  gtk_application_uninhibit(self, cookie)
# proc uninhibit*(self: Application, cookie: uint32) {.inline.} =

# gtk_application_window_new
# flags: {isConstructor} container: ApplicationWindow
# need sugar: is static method
# application 'Application' 'ptr TApplication' IN (diff., need sugar)
# 'ApplicationWindow' 'TransferNone[TApplicationWindow]' (diff., need sugar)
proc gtk_application_window_new(application: ptr TApplication): TransferNone[TApplicationWindow] {.cdecl, dynlib: lib, importc: "gtk_application_window_new".}
proc new_applicationwindow*(application: Application): ApplicationWindow {.inline.} =
  wrap(gtk_application_window_new(application.getPointer))
# proc new_applicationwindow*(application: Application): ApplicationWindow {.inline.} =

# gtk_application_window_get_id
# flags: {isMethod} container: ApplicationWindow
# need sugar: is method
# 'uint32' 'uint32'
proc gtk_application_window_get_id(self: ptr TApplicationWindow): uint32 {.cdecl, dynlib: lib, importc: "gtk_application_window_get_id".}
proc get_id*(self: ApplicationWindow): uint32 {.inline.} =
  gtk_application_window_get_id(self)
# proc get_id*(self: ApplicationWindow): uint32 {.inline.} =

# gtk_application_window_get_show_menubar
# flags: {isMethod} container: ApplicationWindow
# need sugar: is method
# 'bool' 'bool'
proc gtk_application_window_get_show_menubar(self: ptr TApplicationWindow): bool {.cdecl, dynlib: lib, importc: "gtk_application_window_get_show_menubar".}
proc get_show_menubar*(self: ApplicationWindow): bool {.inline.} =
  gtk_application_window_get_show_menubar(self)
# proc get_show_menubar*(self: ApplicationWindow): bool {.inline.} =

# gtk_application_window_set_show_menubar
# flags: {isMethod} container: ApplicationWindow
# need sugar: is method
# show_menubar 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_application_window_set_show_menubar(self: ptr TApplicationWindow, show_menubar: bool) {.cdecl, dynlib: lib, importc: "gtk_application_window_set_show_menubar".}
proc set_show_menubar*(self: ApplicationWindow, show_menubar: bool) {.inline.} =
  gtk_application_window_set_show_menubar(self, show_menubar)
# proc set_show_menubar*(self: ApplicationWindow, show_menubar: bool) {.inline.} =

# gtk_arrow_new
# flags: {isConstructor} container: Arrow (deprecated)
# gtk_arrow_set
# flags: {isMethod} container: Arrow (deprecated)
# gtk_aspect_frame_new
# flags: {isConstructor} container: AspectFrame
# need sugar: is static method
# label 'ustring' 'ucstring' IN (diff., need sugar)
# xalign 'float32' 'float32' IN
# yalign 'float32' 'float32' IN
# ratio 'float32' 'float32' IN
# obey_child 'bool' 'bool' IN
# 'AspectFrame' 'TransferNone[TAspectFrame]' (diff., need sugar)
proc gtk_aspect_frame_new(label: ucstring, xalign: float32, yalign: float32, ratio: float32, obey_child: bool): TransferNone[TAspectFrame] {.cdecl, dynlib: lib, importc: "gtk_aspect_frame_new".}
proc new_aspectframe*(label: ustring, xalign: float32, yalign: float32, ratio: float32, obey_child: bool): AspectFrame {.inline.} =
  wrap(gtk_aspect_frame_new(ucstring(label), xalign, yalign, ratio, obey_child))
# proc new_aspectframe*(label: ustring, xalign: float32, yalign: float32, ratio: float32, obey_child: bool): AspectFrame {.inline.} =

# gtk_aspect_frame_set
# flags: {isMethod} container: AspectFrame
# need sugar: is method
# xalign 'float32' 'float32' IN
# yalign 'float32' 'float32' IN
# ratio 'float32' 'float32' IN
# obey_child 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_aspect_frame_set(self: ptr TAspectFrame, xalign: float32, yalign: float32, ratio: float32, obey_child: bool) {.cdecl, dynlib: lib, importc: "gtk_aspect_frame_set".}
proc set*(self: AspectFrame, xalign: float32, yalign: float32, ratio: float32, obey_child: bool) {.inline.} =
  gtk_aspect_frame_set(self, xalign, yalign, ratio, obey_child)
# proc set*(self: AspectFrame, xalign: float32, yalign: float32, ratio: float32, obey_child: bool) {.inline.} =

# gtk_assistant_new
# flags: {isConstructor} container: Assistant
# need sugar: is static method
# 'Assistant' 'TransferNone[TAssistant]' (diff., need sugar)
proc gtk_assistant_new(): TransferNone[TAssistant] {.cdecl, dynlib: lib, importc: "gtk_assistant_new".}
proc new_assistant*(): Assistant {.inline.} =
  wrap(gtk_assistant_new())
# proc new_assistant*(): Assistant {.inline.} =

# gtk_assistant_add_action_widget
# flags: {isMethod} container: Assistant
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_assistant_add_action_widget(self: ptr TAssistant, child: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_assistant_add_action_widget".}
proc add_action_widget*(self: Assistant, child: Widget) {.inline.} =
  gtk_assistant_add_action_widget(self, child.getPointer)
# proc add_action_widget*(self: Assistant, child: Widget) {.inline.} =

# gtk_assistant_append_page
# flags: {isMethod} container: Assistant
# need sugar: is method
# page 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'int32' 'int32'
proc gtk_assistant_append_page(self: ptr TAssistant, page: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_assistant_append_page".}
proc append_page*(self: Assistant, page: Widget): int32 {.inline.} =
  gtk_assistant_append_page(self, page.getPointer)
# proc append_page*(self: Assistant, page: Widget): int32 {.inline.} =

# gtk_assistant_commit
# flags: {isMethod} container: Assistant
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_assistant_commit(self: ptr TAssistant) {.cdecl, dynlib: lib, importc: "gtk_assistant_commit".}
proc commit*(self: Assistant) {.inline.} =
  gtk_assistant_commit(self)
# proc commit*(self: Assistant) {.inline.} =

# gtk_assistant_get_current_page
# flags: {isMethod} container: Assistant
# need sugar: is method
# 'int32' 'int32'
proc gtk_assistant_get_current_page(self: ptr TAssistant): int32 {.cdecl, dynlib: lib, importc: "gtk_assistant_get_current_page".}
proc get_current_page*(self: Assistant): int32 {.inline.} =
  gtk_assistant_get_current_page(self)
# proc get_current_page*(self: Assistant): int32 {.inline.} =

# gtk_assistant_get_n_pages
# flags: {isMethod} container: Assistant
# need sugar: is method
# 'int32' 'int32'
proc gtk_assistant_get_n_pages(self: ptr TAssistant): int32 {.cdecl, dynlib: lib, importc: "gtk_assistant_get_n_pages".}
proc get_n_pages*(self: Assistant): int32 {.inline.} =
  gtk_assistant_get_n_pages(self)
# proc get_n_pages*(self: Assistant): int32 {.inline.} =

# gtk_assistant_get_nth_page
# flags: {isMethod} container: Assistant
# need sugar: is method
# page_num 'int32' 'int32' IN
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_assistant_get_nth_page(self: ptr TAssistant, page_num: int32): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_assistant_get_nth_page".}
proc get_nth_page*(self: Assistant, page_num: int32): Widget {.inline.} =
  wrap(gtk_assistant_get_nth_page(self, page_num))
# proc get_nth_page*(self: Assistant, page_num: int32): Widget {.inline.} =

# gtk_assistant_get_page_complete
# flags: {isMethod} container: Assistant
# need sugar: is method
# page 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_assistant_get_page_complete(self: ptr TAssistant, page: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_assistant_get_page_complete".}
proc get_page_complete*(self: Assistant, page: Widget): bool {.inline.} =
  gtk_assistant_get_page_complete(self, page.getPointer)
# proc get_page_complete*(self: Assistant, page: Widget): bool {.inline.} =

# gtk_assistant_get_page_header_image
# flags: {isMethod} container: Assistant (deprecated)
# gtk_assistant_get_page_side_image
# flags: {isMethod} container: Assistant (deprecated)
# gtk_assistant_get_page_title
# flags: {isMethod} container: Assistant
# need sugar: is method
# page 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_assistant_get_page_title(self: ptr TAssistant, page: ptr TWidget): ucstring {.cdecl, dynlib: lib, importc: "gtk_assistant_get_page_title".}
proc get_page_title*(self: Assistant, page: Widget): ustring {.inline.} =
  ustring($(gtk_assistant_get_page_title(self, page.getPointer)))
# proc get_page_title*(self: Assistant, page: Widget): ustring {.inline.} =

# gtk_assistant_get_page_type
# flags: {isMethod} container: Assistant
# need sugar: is method
# page 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'AssistantPageType' 'AssistantPageType'
proc gtk_assistant_get_page_type(self: ptr TAssistant, page: ptr TWidget): AssistantPageType {.cdecl, dynlib: lib, importc: "gtk_assistant_get_page_type".}
proc get_page_type*(self: Assistant, page: Widget): AssistantPageType {.inline.} =
  gtk_assistant_get_page_type(self, page.getPointer)
# proc get_page_type*(self: Assistant, page: Widget): AssistantPageType {.inline.} =

# gtk_assistant_insert_page
# flags: {isMethod} container: Assistant
# need sugar: is method
# page 'Widget' 'ptr TWidget' IN (diff., need sugar)
# position 'int32' 'int32' IN
# 'int32' 'int32'
proc gtk_assistant_insert_page(self: ptr TAssistant, page: ptr TWidget, position: int32): int32 {.cdecl, dynlib: lib, importc: "gtk_assistant_insert_page".}
proc insert_page*(self: Assistant, page: Widget, position: int32): int32 {.inline.} =
  gtk_assistant_insert_page(self, page.getPointer, position)
# proc insert_page*(self: Assistant, page: Widget, position: int32): int32 {.inline.} =

# gtk_assistant_next_page
# flags: {isMethod} container: Assistant
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_assistant_next_page(self: ptr TAssistant) {.cdecl, dynlib: lib, importc: "gtk_assistant_next_page".}
proc next_page*(self: Assistant) {.inline.} =
  gtk_assistant_next_page(self)
# proc next_page*(self: Assistant) {.inline.} =

# gtk_assistant_prepend_page
# flags: {isMethod} container: Assistant
# need sugar: is method
# page 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'int32' 'int32'
proc gtk_assistant_prepend_page(self: ptr TAssistant, page: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_assistant_prepend_page".}
proc prepend_page*(self: Assistant, page: Widget): int32 {.inline.} =
  gtk_assistant_prepend_page(self, page.getPointer)
# proc prepend_page*(self: Assistant, page: Widget): int32 {.inline.} =

# gtk_assistant_previous_page
# flags: {isMethod} container: Assistant
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_assistant_previous_page(self: ptr TAssistant) {.cdecl, dynlib: lib, importc: "gtk_assistant_previous_page".}
proc previous_page*(self: Assistant) {.inline.} =
  gtk_assistant_previous_page(self)
# proc previous_page*(self: Assistant) {.inline.} =

# gtk_assistant_remove_action_widget
# flags: {isMethod} container: Assistant
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_assistant_remove_action_widget(self: ptr TAssistant, child: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_assistant_remove_action_widget".}
proc remove_action_widget*(self: Assistant, child: Widget) {.inline.} =
  gtk_assistant_remove_action_widget(self, child.getPointer)
# proc remove_action_widget*(self: Assistant, child: Widget) {.inline.} =

# gtk_assistant_remove_page
# flags: {isMethod} container: Assistant
# need sugar: is method
# page_num 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_assistant_remove_page(self: ptr TAssistant, page_num: int32) {.cdecl, dynlib: lib, importc: "gtk_assistant_remove_page".}
proc remove_page*(self: Assistant, page_num: int32) {.inline.} =
  gtk_assistant_remove_page(self, page_num)
# proc remove_page*(self: Assistant, page_num: int32) {.inline.} =

# gtk_assistant_set_current_page
# flags: {isMethod} container: Assistant
# need sugar: is method
# page_num 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_assistant_set_current_page(self: ptr TAssistant, page_num: int32) {.cdecl, dynlib: lib, importc: "gtk_assistant_set_current_page".}
proc set_current_page*(self: Assistant, page_num: int32) {.inline.} =
  gtk_assistant_set_current_page(self, page_num)
# proc set_current_page*(self: Assistant, page_num: int32) {.inline.} =

# gtk_assistant_set_forward_page_func
# flags: {isMethod} container: Assistant
# need sugar: is method
# page_func 'pointer' 'pointer' IN
# data 'pointer' 'pointer' IN
# destroy 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_assistant_set_forward_page_func(self: ptr TAssistant, page_func: pointer, data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_assistant_set_forward_page_func".}
proc set_forward_page_func*(self: Assistant, page_func: pointer, data: pointer, destroy: pointer) {.inline.} =
  gtk_assistant_set_forward_page_func(self, page_func, data, destroy)
# proc set_forward_page_func*(self: Assistant, page_func: pointer, data: pointer, destroy: pointer) {.inline.} =

# gtk_assistant_set_page_complete
# flags: {isMethod} container: Assistant
# need sugar: is method
# page 'Widget' 'ptr TWidget' IN (diff., need sugar)
# complete 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_assistant_set_page_complete(self: ptr TAssistant, page: ptr TWidget, complete: bool) {.cdecl, dynlib: lib, importc: "gtk_assistant_set_page_complete".}
proc set_page_complete*(self: Assistant, page: Widget, complete: bool) {.inline.} =
  gtk_assistant_set_page_complete(self, page.getPointer, complete)
# proc set_page_complete*(self: Assistant, page: Widget, complete: bool) {.inline.} =

# gtk_assistant_set_page_header_image
# flags: {isMethod} container: Assistant (deprecated)
# gtk_assistant_set_page_side_image
# flags: {isMethod} container: Assistant (deprecated)
# gtk_assistant_set_page_title
# flags: {isMethod} container: Assistant
# need sugar: is method
# page 'Widget' 'ptr TWidget' IN (diff., need sugar)
# title 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_assistant_set_page_title(self: ptr TAssistant, page: ptr TWidget, title: ucstring) {.cdecl, dynlib: lib, importc: "gtk_assistant_set_page_title".}
proc set_page_title*(self: Assistant, page: Widget, title: ustring) {.inline.} =
  gtk_assistant_set_page_title(self, page.getPointer, ucstring(title))
# proc set_page_title*(self: Assistant, page: Widget, title: ustring) {.inline.} =

# gtk_assistant_set_page_type
# flags: {isMethod} container: Assistant
# need sugar: is method
# page 'Widget' 'ptr TWidget' IN (diff., need sugar)
# type 'AssistantPageType' 'AssistantPageType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_assistant_set_page_type(self: ptr TAssistant, page: ptr TWidget, type_x: AssistantPageType) {.cdecl, dynlib: lib, importc: "gtk_assistant_set_page_type".}
proc set_page_type*(self: Assistant, page: Widget, type_x: AssistantPageType) {.inline.} =
  gtk_assistant_set_page_type(self, page.getPointer, type_x)
# proc set_page_type*(self: Assistant, page: Widget, type_x: AssistantPageType) {.inline.} =

# gtk_assistant_update_buttons_state
# flags: {isMethod} container: Assistant
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_assistant_update_buttons_state(self: ptr TAssistant) {.cdecl, dynlib: lib, importc: "gtk_assistant_update_buttons_state".}
proc update_buttons_state*(self: Assistant) {.inline.} =
  gtk_assistant_update_buttons_state(self)
# proc update_buttons_state*(self: Assistant) {.inline.} =

# gtk_bin_get_child
# flags: {isMethod} container: Bin
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_bin_get_child(self: ptr TBin): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_bin_get_child".}
proc get_child*(self: Bin): Widget {.inline.} =
  wrap(gtk_bin_get_child(self))
# proc get_child*(self: Bin): Widget {.inline.} =

# gtk_box_new
# flags: {isConstructor} container: Box
# need sugar: is static method
# orientation 'Orientation' 'Orientation' IN
# spacing 'int32' 'int32' IN
# 'Box' 'TransferNone[TBox]' (diff., need sugar)
proc gtk_box_new(orientation: Orientation, spacing: int32): TransferNone[TBox] {.cdecl, dynlib: lib, importc: "gtk_box_new".}
proc new_box*(orientation: Orientation, spacing: int32): Box {.inline.} =
  wrap(gtk_box_new(orientation, spacing))
# proc new_box*(orientation: Orientation, spacing: int32): Box {.inline.} =

# gtk_box_get_baseline_position
# flags: {isMethod} container: Box
# need sugar: is method
# 'BaselinePosition' 'BaselinePosition'
proc gtk_box_get_baseline_position(self: ptr TBox): BaselinePosition {.cdecl, dynlib: lib, importc: "gtk_box_get_baseline_position".}
proc get_baseline_position*(self: Box): BaselinePosition {.inline.} =
  gtk_box_get_baseline_position(self)
# proc get_baseline_position*(self: Box): BaselinePosition {.inline.} =

# gtk_box_get_center_widget
# flags: {isMethod} container: Box
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_box_get_center_widget(self: ptr TBox): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_box_get_center_widget".}
proc get_center_widget*(self: Box): Widget {.inline.} =
  wrap(gtk_box_get_center_widget(self))
# proc get_center_widget*(self: Box): Widget {.inline.} =

# gtk_box_get_homogeneous
# flags: {isMethod} container: Box
# need sugar: is method
# 'bool' 'bool'
proc gtk_box_get_homogeneous(self: ptr TBox): bool {.cdecl, dynlib: lib, importc: "gtk_box_get_homogeneous".}
proc get_homogeneous*(self: Box): bool {.inline.} =
  gtk_box_get_homogeneous(self)
# proc get_homogeneous*(self: Box): bool {.inline.} =

# gtk_box_get_spacing
# flags: {isMethod} container: Box
# need sugar: is method
# 'int32' 'int32'
proc gtk_box_get_spacing(self: ptr TBox): int32 {.cdecl, dynlib: lib, importc: "gtk_box_get_spacing".}
proc get_spacing*(self: Box): int32 {.inline.} =
  gtk_box_get_spacing(self)
# proc get_spacing*(self: Box): int32 {.inline.} =

# gtk_box_pack_end
# flags: {isMethod} container: Box
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# expand 'bool' 'bool' IN
# fill 'bool' 'bool' IN
# padding 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_box_pack_end(self: ptr TBox, child: ptr TWidget, expand: bool, fill: bool, padding: uint32) {.cdecl, dynlib: lib, importc: "gtk_box_pack_end".}
proc pack_end*(self: Box, child: Widget, expand: bool, fill: bool, padding: uint32) {.inline.} =
  gtk_box_pack_end(self, child.getPointer, expand, fill, padding)
# proc pack_end*(self: Box, child: Widget, expand: bool, fill: bool, padding: uint32) {.inline.} =

# gtk_box_pack_start
# flags: {isMethod} container: Box
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# expand 'bool' 'bool' IN
# fill 'bool' 'bool' IN
# padding 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_box_pack_start(self: ptr TBox, child: ptr TWidget, expand: bool, fill: bool, padding: uint32) {.cdecl, dynlib: lib, importc: "gtk_box_pack_start".}
proc pack_start*(self: Box, child: Widget, expand: bool, fill: bool, padding: uint32) {.inline.} =
  gtk_box_pack_start(self, child.getPointer, expand, fill, padding)
# proc pack_start*(self: Box, child: Widget, expand: bool, fill: bool, padding: uint32) {.inline.} =

# gtk_box_query_child_packing
# flags: {isMethod} container: Box
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# expand 'var bool' 'ptr bool' OUT (diff., need sugar)
# fill 'var bool' 'ptr bool' OUT (diff., need sugar)
# padding 'var uint32' 'ptr uint32' OUT (diff., need sugar)
# pack_type 'PackType' 'PackType' OUT
# 'VOID_TODO' 'VOID_TODO'
proc gtk_box_query_child_packing(self: ptr TBox, child: ptr TWidget, expand: ptr bool, fill: ptr bool, padding: ptr uint32, pack_type: PackType) {.cdecl, dynlib: lib, importc: "gtk_box_query_child_packing".}
proc query_child_packing*(self: Box, child: Widget, expand: var bool, fill: var bool, padding: var uint32, pack_type: PackType) {.inline.} =
  gtk_box_query_child_packing(self, child.getPointer, addr(expand), addr(fill), addr(padding), pack_type)
# tuple-return
# expand: var bool
# fill: var bool
# padding: var uint32
# pack_type: PackType
# proc query_child_packing*(self: Box, child: Widget) {.inline.} =

# gtk_box_reorder_child
# flags: {isMethod} container: Box
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# position 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_box_reorder_child(self: ptr TBox, child: ptr TWidget, position: int32) {.cdecl, dynlib: lib, importc: "gtk_box_reorder_child".}
proc reorder_child*(self: Box, child: Widget, position: int32) {.inline.} =
  gtk_box_reorder_child(self, child.getPointer, position)
# proc reorder_child*(self: Box, child: Widget, position: int32) {.inline.} =

# gtk_box_set_baseline_position
# flags: {isMethod} container: Box
# need sugar: is method
# position 'BaselinePosition' 'BaselinePosition' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_box_set_baseline_position(self: ptr TBox, position: BaselinePosition) {.cdecl, dynlib: lib, importc: "gtk_box_set_baseline_position".}
proc set_baseline_position*(self: Box, position: BaselinePosition) {.inline.} =
  gtk_box_set_baseline_position(self, position)
# proc set_baseline_position*(self: Box, position: BaselinePosition) {.inline.} =

# gtk_box_set_center_widget
# flags: {isMethod} container: Box
# need sugar: is method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_box_set_center_widget(self: ptr TBox, widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_box_set_center_widget".}
proc set_center_widget*(self: Box, widget: Widget) {.inline.} =
  gtk_box_set_center_widget(self, widget.getPointer)
# proc set_center_widget*(self: Box, widget: Widget) {.inline.} =

# gtk_box_set_child_packing
# flags: {isMethod} container: Box
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# expand 'bool' 'bool' IN
# fill 'bool' 'bool' IN
# padding 'uint32' 'uint32' IN
# pack_type 'PackType' 'PackType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_box_set_child_packing(self: ptr TBox, child: ptr TWidget, expand: bool, fill: bool, padding: uint32, pack_type: PackType) {.cdecl, dynlib: lib, importc: "gtk_box_set_child_packing".}
proc set_child_packing*(self: Box, child: Widget, expand: bool, fill: bool, padding: uint32, pack_type: PackType) {.inline.} =
  gtk_box_set_child_packing(self, child.getPointer, expand, fill, padding, pack_type)
# proc set_child_packing*(self: Box, child: Widget, expand: bool, fill: bool, padding: uint32, pack_type: PackType) {.inline.} =

# gtk_box_set_homogeneous
# flags: {isMethod} container: Box
# need sugar: is method
# homogeneous 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_box_set_homogeneous(self: ptr TBox, homogeneous: bool) {.cdecl, dynlib: lib, importc: "gtk_box_set_homogeneous".}
proc set_homogeneous*(self: Box, homogeneous: bool) {.inline.} =
  gtk_box_set_homogeneous(self, homogeneous)
# proc set_homogeneous*(self: Box, homogeneous: bool) {.inline.} =

# gtk_box_set_spacing
# flags: {isMethod} container: Box
# need sugar: is method
# spacing 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_box_set_spacing(self: ptr TBox, spacing: int32) {.cdecl, dynlib: lib, importc: "gtk_box_set_spacing".}
proc set_spacing*(self: Box, spacing: int32) {.inline.} =
  gtk_box_set_spacing(self, spacing)
# proc set_spacing*(self: Box, spacing: int32) {.inline.} =

# gtk_builder_new
# flags: {isConstructor} container: Builder
# need sugar: is static method
# 'Builder' 'TransferFull[TBuilder]' (diff., need sugar)
proc gtk_builder_new(): TransferFull[TBuilder] {.cdecl, dynlib: lib, importc: "gtk_builder_new".}
proc new_builder*(): Builder {.inline.} =
  wrap(gtk_builder_new())
# proc new_builder*(): Builder {.inline.} =

# gtk_builder_new_from_file
# flags: {isConstructor} container: Builder
# need sugar: is static method
# filename 'ustring' 'ucstring' IN (diff., need sugar)
# 'Builder' 'TransferFull[TBuilder]' (diff., need sugar)
proc gtk_builder_new_from_file(filename: ucstring): TransferFull[TBuilder] {.cdecl, dynlib: lib, importc: "gtk_builder_new_from_file".}
proc new_builder_from_file*(filename: ustring): Builder {.inline.} =
  wrap(gtk_builder_new_from_file(ucstring(filename)))
# proc new_builder_from_file*(filename: ustring): Builder {.inline.} =

# gtk_builder_new_from_resource
# flags: {isConstructor} container: Builder
# need sugar: is static method
# resource_path 'ustring' 'ucstring' IN (diff., need sugar)
# 'Builder' 'TransferFull[TBuilder]' (diff., need sugar)
proc gtk_builder_new_from_resource(resource_path: ucstring): TransferFull[TBuilder] {.cdecl, dynlib: lib, importc: "gtk_builder_new_from_resource".}
proc new_builder_from_resource*(resource_path: ustring): Builder {.inline.} =
  wrap(gtk_builder_new_from_resource(ucstring(resource_path)))
# proc new_builder_from_resource*(resource_path: ustring): Builder {.inline.} =

# gtk_builder_new_from_string
# flags: {isConstructor} container: Builder
# need sugar: is static method
# string 'ustring' 'ucstring' IN (diff., need sugar)
# length 'int32' 'int32' IN
# 'Builder' 'TransferFull[TBuilder]' (diff., need sugar)
proc gtk_builder_new_from_string(string: ucstring, length: int32): TransferFull[TBuilder] {.cdecl, dynlib: lib, importc: "gtk_builder_new_from_string".}
proc new_builder_from_string*(string: ustring, length: int32): Builder {.inline.} =
  wrap(gtk_builder_new_from_string(ucstring(string), length))
# proc new_builder_from_string*(string: ustring, length: int32): Builder {.inline.} =

# gtk_builder_add_callback_symbol
# flags: {isMethod} container: Builder
# need sugar: is method
# callback_name 'ustring' 'ucstring' IN (diff., need sugar)
# callback_symbol 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_builder_add_callback_symbol(self: ptr TBuilder, callback_name: ucstring, callback_symbol: pointer) {.cdecl, dynlib: lib, importc: "gtk_builder_add_callback_symbol".}
proc add_callback_symbol*(self: Builder, callback_name: ustring, callback_symbol: pointer) {.inline.} =
  gtk_builder_add_callback_symbol(self, ucstring(callback_name), callback_symbol)
# proc add_callback_symbol*(self: Builder, callback_name: ustring, callback_symbol: pointer) {.inline.} =

# gtk_builder_add_from_file
# flags: {isMethod, throws} container: Builder
# can throw
# need sugar: is method
# filename 'ustring' 'ucstring' IN (diff., need sugar)
# 'uint32' 'uint32'
proc gtk_builder_add_from_file(self: ptr TBuilder, filename: ucstring, error: ptr PGError=nil): uint32 {.cdecl, dynlib: lib, importc: "gtk_builder_add_from_file".}
proc add_from_file*(self: Builder, filename: ustring): uint32 {.inline.} =
  gtk_builder_add_from_file(self, ucstring(filename))
# proc add_from_file*(self: Builder, filename: ustring): uint32 {.inline.} =

# gtk_builder_add_from_resource
# flags: {isMethod, throws} container: Builder
# can throw
# need sugar: is method
# resource_path 'ustring' 'ucstring' IN (diff., need sugar)
# 'uint32' 'uint32'
proc gtk_builder_add_from_resource(self: ptr TBuilder, resource_path: ucstring, error: ptr PGError=nil): uint32 {.cdecl, dynlib: lib, importc: "gtk_builder_add_from_resource".}
proc add_from_resource*(self: Builder, resource_path: ustring): uint32 {.inline.} =
  gtk_builder_add_from_resource(self, ucstring(resource_path))
# proc add_from_resource*(self: Builder, resource_path: ustring): uint32 {.inline.} =

# gtk_builder_add_from_string
# flags: {isMethod, throws} container: Builder
# can throw
# need sugar: is method
# buffer 'ustring' 'ucstring' IN (diff., need sugar)
# length 'uint32' 'uint32' IN
# 'uint32' 'uint32'
proc gtk_builder_add_from_string(self: ptr TBuilder, buffer: ucstring, length: uint32, error: ptr PGError=nil): uint32 {.cdecl, dynlib: lib, importc: "gtk_builder_add_from_string".}
proc add_from_string*(self: Builder, buffer: ustring, length: uint32): uint32 {.inline.} =
  gtk_builder_add_from_string(self, ucstring(buffer), length)
# proc add_from_string*(self: Builder, buffer: ustring, length: uint32): uint32 {.inline.} =

# gtk_builder_add_objects_from_file
# flags: {isMethod, throws} container: Builder
# can throw
# need sugar: is method
# filename 'ustring' 'ucstring' IN (diff., need sugar)
# object_ids 'uncheckedArray[ucstring]' 'uncheckedArray[ucstring]' IN array zero-terminated
# 'uint32' 'uint32'
proc gtk_builder_add_objects_from_file(self: ptr TBuilder, filename: ucstring, object_ids: uncheckedArray[ucstring], error: ptr PGError=nil): uint32 {.cdecl, dynlib: lib, importc: "gtk_builder_add_objects_from_file".}
proc add_objects_from_file*(self: Builder, filename: ustring, object_ids: uncheckedArray[ucstring]): uint32 {.inline.} =
  gtk_builder_add_objects_from_file(self, ucstring(filename), object_ids)
# proc add_objects_from_file*(self: Builder, filename: ustring, object_ids: uncheckedArray[ucstring]): uint32 {.inline.} =

# gtk_builder_add_objects_from_resource
# flags: {isMethod, throws} container: Builder
# can throw
# need sugar: is method
# resource_path 'ustring' 'ucstring' IN (diff., need sugar)
# object_ids 'uncheckedArray[ucstring]' 'uncheckedArray[ucstring]' IN array zero-terminated
# 'uint32' 'uint32'
proc gtk_builder_add_objects_from_resource(self: ptr TBuilder, resource_path: ucstring, object_ids: uncheckedArray[ucstring], error: ptr PGError=nil): uint32 {.cdecl, dynlib: lib, importc: "gtk_builder_add_objects_from_resource".}
proc add_objects_from_resource*(self: Builder, resource_path: ustring, object_ids: uncheckedArray[ucstring]): uint32 {.inline.} =
  gtk_builder_add_objects_from_resource(self, ucstring(resource_path), object_ids)
# proc add_objects_from_resource*(self: Builder, resource_path: ustring, object_ids: uncheckedArray[ucstring]): uint32 {.inline.} =

# gtk_builder_add_objects_from_string
# flags: {isMethod, throws} container: Builder
# can throw
# need sugar: is method
# buffer 'ustring' 'ucstring' IN (diff., need sugar)
# length 'uint32' 'uint32' IN
# object_ids 'uncheckedArray[ucstring]' 'uncheckedArray[ucstring]' IN array zero-terminated
# 'uint32' 'uint32'
proc gtk_builder_add_objects_from_string(self: ptr TBuilder, buffer: ucstring, length: uint32, object_ids: uncheckedArray[ucstring], error: ptr PGError=nil): uint32 {.cdecl, dynlib: lib, importc: "gtk_builder_add_objects_from_string".}
proc add_objects_from_string*(self: Builder, buffer: ustring, length: uint32, object_ids: uncheckedArray[ucstring]): uint32 {.inline.} =
  gtk_builder_add_objects_from_string(self, ucstring(buffer), length, object_ids)
# proc add_objects_from_string*(self: Builder, buffer: ustring, length: uint32, object_ids: uncheckedArray[ucstring]): uint32 {.inline.} =

# gtk_builder_connect_signals
# flags: {isMethod} container: Builder
# need sugar: is method
# user_data 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_builder_connect_signals(self: ptr TBuilder, user_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_builder_connect_signals".}
proc connect_signals*(self: Builder, user_data: pointer) {.inline.} =
  gtk_builder_connect_signals(self, user_data)
# proc connect_signals*(self: Builder, user_data: pointer) {.inline.} =

# gtk_builder_connect_signals_full
# flags: {isMethod} container: Builder
# need sugar: is method
# func 'pointer' 'pointer' IN
# user_data 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_builder_connect_signals_full(self: ptr TBuilder, func_x: pointer, user_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_builder_connect_signals_full".}
proc connect_signals_full*(self: Builder, func_x: pointer, user_data: pointer) {.inline.} =
  gtk_builder_connect_signals_full(self, func_x, user_data)
# proc connect_signals_full*(self: Builder, func_x: pointer, user_data: pointer) {.inline.} =

# gtk_builder_expose_object
# flags: {isMethod} container: Builder
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# object 'GObject2.Object' 'ptr GObject2.TObject' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_builder_expose_object(self: ptr TBuilder, name: ucstring, object_x: ptr GObject2.TObject) {.cdecl, dynlib: lib, importc: "gtk_builder_expose_object".}
proc expose_object*(self: Builder, name: ustring, object_x: GObject2.Object) {.inline.} =
  gtk_builder_expose_object(self, ucstring(name), object_x.getPointer)
# proc expose_object*(self: Builder, name: ustring, object_x: GObject2.Object) {.inline.} =

# gtk_builder_get_application
# flags: {isMethod} container: Builder
# need sugar: is method
# 'Application' 'TransferNone[TApplication]' (diff., need sugar)
proc gtk_builder_get_application(self: ptr TBuilder): TransferNone[TApplication] {.cdecl, dynlib: lib, importc: "gtk_builder_get_application".}
proc get_application*(self: Builder): Application {.inline.} =
  wrap(gtk_builder_get_application(self))
# proc get_application*(self: Builder): Application {.inline.} =

# gtk_builder_get_object
# flags: {isMethod} container: Builder
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# 'GObject2.Object' 'TransferNone[GObject2.TObject]' (diff., need sugar)
proc gtk_builder_get_object(self: ptr TBuilder, name: ucstring): TransferNone[GObject2.TObject] {.cdecl, dynlib: lib, importc: "gtk_builder_get_object".}
proc get_object*(self: Builder, name: ustring): GObject2.Object {.inline.} =
  wrap(gtk_builder_get_object(self, ucstring(name)))
# proc get_object*(self: Builder, name: ustring): GObject2.Object {.inline.} =

# gtk_builder_get_objects
# flags: {isMethod} container: Builder
# need sugar: is method
# 'ptr GSLIST_TODO' 'ptr GSLIST_TODO'
proc gtk_builder_get_objects(self: ptr TBuilder): ptr GSLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_builder_get_objects".}
proc get_objects*(self: Builder): ptr GSLIST_TODO {.inline.} =
  gtk_builder_get_objects(self)
# proc get_objects*(self: Builder): ptr GSLIST_TODO {.inline.} =

# gtk_builder_get_translation_domain
# flags: {isMethod} container: Builder
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_builder_get_translation_domain(self: ptr TBuilder): ucstring {.cdecl, dynlib: lib, importc: "gtk_builder_get_translation_domain".}
proc get_translation_domain*(self: Builder): ustring {.inline.} =
  ustring($(gtk_builder_get_translation_domain(self)))
# proc get_translation_domain*(self: Builder): ustring {.inline.} =

# gtk_builder_get_type_from_name
# flags: {isMethod} container: Builder
# need sugar: is method
# type_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'GType' 'GType'
proc gtk_builder_get_type_from_name(self: ptr TBuilder, type_name: ucstring): GType {.cdecl, dynlib: lib, importc: "gtk_builder_get_type_from_name".}
proc get_type_from_name*(self: Builder, type_name: ustring): GType {.inline.} =
  gtk_builder_get_type_from_name(self, ucstring(type_name))
# proc get_type_from_name*(self: Builder, type_name: ustring): GType {.inline.} =

# gtk_builder_set_application
# flags: {isMethod} container: Builder
# need sugar: is method
# application 'Application' 'ptr TApplication' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_builder_set_application(self: ptr TBuilder, application: ptr TApplication) {.cdecl, dynlib: lib, importc: "gtk_builder_set_application".}
proc set_application*(self: Builder, application: Application) {.inline.} =
  gtk_builder_set_application(self, application.getPointer)
# proc set_application*(self: Builder, application: Application) {.inline.} =

# gtk_builder_set_translation_domain
# flags: {isMethod} container: Builder
# need sugar: is method
# domain 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_builder_set_translation_domain(self: ptr TBuilder, domain: ucstring) {.cdecl, dynlib: lib, importc: "gtk_builder_set_translation_domain".}
proc set_translation_domain*(self: Builder, domain: ustring) {.inline.} =
  gtk_builder_set_translation_domain(self, ucstring(domain))
# proc set_translation_domain*(self: Builder, domain: ustring) {.inline.} =

# gtk_builder_value_from_string
# flags: {isMethod, throws} container: Builder
# can throw
# need sugar: is method
# pspec 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# string 'ustring' 'ucstring' IN (diff., need sugar)
# value 'var GObject2.TValue' 'ptr GObject2.TValue' OUT (diff., need sugar) caller-allocates
# 'bool' 'bool'
proc gtk_builder_value_from_string(self: ptr TBuilder, pspec: ptr GObject2.TParamSpec, string: ucstring, value: ptr GObject2.TValue, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_builder_value_from_string".}
proc value_from_string*(self: Builder, pspec: GObject2.ParamSpec, string: ustring, value: var GObject2.TValue): bool {.inline.} =
  gtk_builder_value_from_string(self, pspec.getPointer, ucstring(string), addr(value))
# tuple-return
# value: var GObject2.TValue
# proc value_from_string*(self: Builder, pspec: GObject2.ParamSpec, string: ustring): bool {.inline.} =

# gtk_builder_value_from_string_type
# flags: {isMethod, throws} container: Builder
# can throw
# need sugar: is method
# type 'GType' 'GType' IN
# string 'ustring' 'ucstring' IN (diff., need sugar)
# value 'var GObject2.TValue' 'ptr GObject2.TValue' OUT (diff., need sugar) caller-allocates
# 'bool' 'bool'
proc gtk_builder_value_from_string_type(self: ptr TBuilder, type_x: GType, string: ucstring, value: ptr GObject2.TValue, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_builder_value_from_string_type".}
proc value_from_string_type*(self: Builder, type_x: GType, string: ustring, value: var GObject2.TValue): bool {.inline.} =
  gtk_builder_value_from_string_type(self, type_x, ucstring(string), addr(value))
# tuple-return
# value: var GObject2.TValue
# proc value_from_string_type*(self: Builder, type_x: GType, string: ustring): bool {.inline.} =

# gtk_button_new
# flags: {isConstructor} container: Button
# need sugar: is static method
# 'Button' 'TransferNone[TButton]' (diff., need sugar)
proc gtk_button_new(): TransferNone[TButton] {.cdecl, dynlib: lib, importc: "gtk_button_new".}
proc new_button*(): Button {.inline.} =
  wrap(gtk_button_new())
# proc new_button*(): Button {.inline.} =

# gtk_button_new_from_icon_name
# flags: {isConstructor} container: Button
# need sugar: is static method
# icon_name 'ustring' 'ucstring' IN (diff., need sugar)
# size 'int32' 'int32' IN
# 'Button' 'TransferNone[TButton]' (diff., need sugar)
proc gtk_button_new_from_icon_name(icon_name: ucstring, size: int32): TransferNone[TButton] {.cdecl, dynlib: lib, importc: "gtk_button_new_from_icon_name".}
proc new_button_from_icon_name*(icon_name: ustring, size: int32): Button {.inline.} =
  wrap(gtk_button_new_from_icon_name(ucstring(icon_name), size))
# proc new_button_from_icon_name*(icon_name: ustring, size: int32): Button {.inline.} =

# gtk_button_new_from_stock
# flags: {isConstructor} container: Button (deprecated)
# gtk_button_new_with_label
# flags: {isConstructor} container: Button
# need sugar: is static method
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'Button' 'TransferNone[TButton]' (diff., need sugar)
proc gtk_button_new_with_label(label: ucstring): TransferNone[TButton] {.cdecl, dynlib: lib, importc: "gtk_button_new_with_label".}
proc new_button_with_label*(label: ustring): Button {.inline.} =
  wrap(gtk_button_new_with_label(ucstring(label)))
# proc new_button_with_label*(label: ustring): Button {.inline.} =

# gtk_button_new_with_mnemonic
# flags: {isConstructor} container: Button
# need sugar: is static method
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'Button' 'TransferNone[TButton]' (diff., need sugar)
proc gtk_button_new_with_mnemonic(label: ucstring): TransferNone[TButton] {.cdecl, dynlib: lib, importc: "gtk_button_new_with_mnemonic".}
proc new_button_with_mnemonic*(label: ustring): Button {.inline.} =
  wrap(gtk_button_new_with_mnemonic(ucstring(label)))
# proc new_button_with_mnemonic*(label: ustring): Button {.inline.} =

# gtk_button_clicked
# flags: {isMethod} container: Button
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_button_clicked(self: ptr TButton) {.cdecl, dynlib: lib, importc: "gtk_button_clicked".}
proc clicked*(self: Button) {.inline.} =
  gtk_button_clicked(self)
# proc clicked*(self: Button) {.inline.} =

# gtk_button_enter
# flags: {isMethod} container: Button (deprecated)
# gtk_button_get_alignment
# flags: {isMethod} container: Button (deprecated)
# gtk_button_get_always_show_image
# flags: {isMethod} container: Button
# need sugar: is method
# 'bool' 'bool'
proc gtk_button_get_always_show_image(self: ptr TButton): bool {.cdecl, dynlib: lib, importc: "gtk_button_get_always_show_image".}
proc get_always_show_image*(self: Button): bool {.inline.} =
  gtk_button_get_always_show_image(self)
# proc get_always_show_image*(self: Button): bool {.inline.} =

# gtk_button_get_event_window
# flags: {isMethod} container: Button
# need sugar: is method
# 'Gdk3.Window' 'TransferNone[Gdk3.TWindow]' (diff., need sugar)
proc gtk_button_get_event_window(self: ptr TButton): TransferNone[Gdk3.TWindow] {.cdecl, dynlib: lib, importc: "gtk_button_get_event_window".}
proc get_event_window*(self: Button): Gdk3.Window {.inline.} =
  wrap(gtk_button_get_event_window(self))
# proc get_event_window*(self: Button): Gdk3.Window {.inline.} =

# gtk_button_get_focus_on_click
# flags: {isMethod} container: Button
# need sugar: is method
# 'bool' 'bool'
proc gtk_button_get_focus_on_click(self: ptr TButton): bool {.cdecl, dynlib: lib, importc: "gtk_button_get_focus_on_click".}
proc get_focus_on_click*(self: Button): bool {.inline.} =
  gtk_button_get_focus_on_click(self)
# proc get_focus_on_click*(self: Button): bool {.inline.} =

# gtk_button_get_image
# flags: {isMethod} container: Button
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_button_get_image(self: ptr TButton): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_button_get_image".}
proc get_image*(self: Button): Widget {.inline.} =
  wrap(gtk_button_get_image(self))
# proc get_image*(self: Button): Widget {.inline.} =

# gtk_button_get_image_position
# flags: {isMethod} container: Button
# need sugar: is method
# 'PositionType' 'PositionType'
proc gtk_button_get_image_position(self: ptr TButton): PositionType {.cdecl, dynlib: lib, importc: "gtk_button_get_image_position".}
proc get_image_position*(self: Button): PositionType {.inline.} =
  gtk_button_get_image_position(self)
# proc get_image_position*(self: Button): PositionType {.inline.} =

# gtk_button_get_label
# flags: {isMethod} container: Button
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_button_get_label(self: ptr TButton): ucstring {.cdecl, dynlib: lib, importc: "gtk_button_get_label".}
proc get_label*(self: Button): ustring {.inline.} =
  ustring($(gtk_button_get_label(self)))
# proc get_label*(self: Button): ustring {.inline.} =

# gtk_button_get_relief
# flags: {isMethod} container: Button
# need sugar: is method
# 'ReliefStyle' 'ReliefStyle'
proc gtk_button_get_relief(self: ptr TButton): ReliefStyle {.cdecl, dynlib: lib, importc: "gtk_button_get_relief".}
proc get_relief*(self: Button): ReliefStyle {.inline.} =
  gtk_button_get_relief(self)
# proc get_relief*(self: Button): ReliefStyle {.inline.} =

# gtk_button_get_use_stock
# flags: {isMethod} container: Button (deprecated)
# gtk_button_get_use_underline
# flags: {isMethod} container: Button
# need sugar: is method
# 'bool' 'bool'
proc gtk_button_get_use_underline(self: ptr TButton): bool {.cdecl, dynlib: lib, importc: "gtk_button_get_use_underline".}
proc get_use_underline*(self: Button): bool {.inline.} =
  gtk_button_get_use_underline(self)
# proc get_use_underline*(self: Button): bool {.inline.} =

# gtk_button_leave
# flags: {isMethod} container: Button (deprecated)
# gtk_button_pressed
# flags: {isMethod} container: Button (deprecated)
# gtk_button_released
# flags: {isMethod} container: Button (deprecated)
# gtk_button_set_alignment
# flags: {isMethod} container: Button (deprecated)
# gtk_button_set_always_show_image
# flags: {isMethod} container: Button
# need sugar: is method
# always_show 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_button_set_always_show_image(self: ptr TButton, always_show: bool) {.cdecl, dynlib: lib, importc: "gtk_button_set_always_show_image".}
proc set_always_show_image*(self: Button, always_show: bool) {.inline.} =
  gtk_button_set_always_show_image(self, always_show)
# proc set_always_show_image*(self: Button, always_show: bool) {.inline.} =

# gtk_button_set_focus_on_click
# flags: {isMethod} container: Button
# need sugar: is method
# focus_on_click 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_button_set_focus_on_click(self: ptr TButton, focus_on_click: bool) {.cdecl, dynlib: lib, importc: "gtk_button_set_focus_on_click".}
proc set_focus_on_click*(self: Button, focus_on_click: bool) {.inline.} =
  gtk_button_set_focus_on_click(self, focus_on_click)
# proc set_focus_on_click*(self: Button, focus_on_click: bool) {.inline.} =

# gtk_button_set_image
# flags: {isMethod} container: Button
# need sugar: is method
# image 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_button_set_image(self: ptr TButton, image: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_button_set_image".}
proc set_image*(self: Button, image: Widget) {.inline.} =
  gtk_button_set_image(self, image.getPointer)
# proc set_image*(self: Button, image: Widget) {.inline.} =

# gtk_button_set_image_position
# flags: {isMethod} container: Button
# need sugar: is method
# position 'PositionType' 'PositionType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_button_set_image_position(self: ptr TButton, position: PositionType) {.cdecl, dynlib: lib, importc: "gtk_button_set_image_position".}
proc set_image_position*(self: Button, position: PositionType) {.inline.} =
  gtk_button_set_image_position(self, position)
# proc set_image_position*(self: Button, position: PositionType) {.inline.} =

# gtk_button_set_label
# flags: {isMethod} container: Button
# need sugar: is method
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_button_set_label(self: ptr TButton, label: ucstring) {.cdecl, dynlib: lib, importc: "gtk_button_set_label".}
proc set_label*(self: Button, label: ustring) {.inline.} =
  gtk_button_set_label(self, ucstring(label))
# proc set_label*(self: Button, label: ustring) {.inline.} =

# gtk_button_set_relief
# flags: {isMethod} container: Button
# need sugar: is method
# relief 'ReliefStyle' 'ReliefStyle' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_button_set_relief(self: ptr TButton, relief: ReliefStyle) {.cdecl, dynlib: lib, importc: "gtk_button_set_relief".}
proc set_relief*(self: Button, relief: ReliefStyle) {.inline.} =
  gtk_button_set_relief(self, relief)
# proc set_relief*(self: Button, relief: ReliefStyle) {.inline.} =

# gtk_button_set_use_stock
# flags: {isMethod} container: Button (deprecated)
# gtk_button_set_use_underline
# flags: {isMethod} container: Button
# need sugar: is method
# use_underline 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_button_set_use_underline(self: ptr TButton, use_underline: bool) {.cdecl, dynlib: lib, importc: "gtk_button_set_use_underline".}
proc set_use_underline*(self: Button, use_underline: bool) {.inline.} =
  gtk_button_set_use_underline(self, use_underline)
# proc set_use_underline*(self: Button, use_underline: bool) {.inline.} =

# gtk_button_box_new
# flags: {isConstructor} container: ButtonBox
# need sugar: is static method
# orientation 'Orientation' 'Orientation' IN
# 'ButtonBox' 'TransferNone[TButtonBox]' (diff., need sugar)
proc gtk_button_box_new(orientation: Orientation): TransferNone[TButtonBox] {.cdecl, dynlib: lib, importc: "gtk_button_box_new".}
proc new_buttonbox*(orientation: Orientation): ButtonBox {.inline.} =
  wrap(gtk_button_box_new(orientation))
# proc new_buttonbox*(orientation: Orientation): ButtonBox {.inline.} =

# gtk_button_box_get_child_non_homogeneous
# flags: {isMethod} container: ButtonBox
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_button_box_get_child_non_homogeneous(self: ptr TButtonBox, child: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_button_box_get_child_non_homogeneous".}
proc get_child_non_homogeneous*(self: ButtonBox, child: Widget): bool {.inline.} =
  gtk_button_box_get_child_non_homogeneous(self, child.getPointer)
# proc get_child_non_homogeneous*(self: ButtonBox, child: Widget): bool {.inline.} =

# gtk_button_box_get_child_secondary
# flags: {isMethod} container: ButtonBox
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_button_box_get_child_secondary(self: ptr TButtonBox, child: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_button_box_get_child_secondary".}
proc get_child_secondary*(self: ButtonBox, child: Widget): bool {.inline.} =
  gtk_button_box_get_child_secondary(self, child.getPointer)
# proc get_child_secondary*(self: ButtonBox, child: Widget): bool {.inline.} =

# gtk_button_box_get_layout
# flags: {isMethod} container: ButtonBox
# need sugar: is method
# 'ButtonBoxStyle' 'ButtonBoxStyle'
proc gtk_button_box_get_layout(self: ptr TButtonBox): ButtonBoxStyle {.cdecl, dynlib: lib, importc: "gtk_button_box_get_layout".}
proc get_layout*(self: ButtonBox): ButtonBoxStyle {.inline.} =
  gtk_button_box_get_layout(self)
# proc get_layout*(self: ButtonBox): ButtonBoxStyle {.inline.} =

# gtk_button_box_set_child_non_homogeneous
# flags: {isMethod} container: ButtonBox
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# non_homogeneous 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_button_box_set_child_non_homogeneous(self: ptr TButtonBox, child: ptr TWidget, non_homogeneous: bool) {.cdecl, dynlib: lib, importc: "gtk_button_box_set_child_non_homogeneous".}
proc set_child_non_homogeneous*(self: ButtonBox, child: Widget, non_homogeneous: bool) {.inline.} =
  gtk_button_box_set_child_non_homogeneous(self, child.getPointer, non_homogeneous)
# proc set_child_non_homogeneous*(self: ButtonBox, child: Widget, non_homogeneous: bool) {.inline.} =

# gtk_button_box_set_child_secondary
# flags: {isMethod} container: ButtonBox
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# is_secondary 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_button_box_set_child_secondary(self: ptr TButtonBox, child: ptr TWidget, is_secondary: bool) {.cdecl, dynlib: lib, importc: "gtk_button_box_set_child_secondary".}
proc set_child_secondary*(self: ButtonBox, child: Widget, is_secondary: bool) {.inline.} =
  gtk_button_box_set_child_secondary(self, child.getPointer, is_secondary)
# proc set_child_secondary*(self: ButtonBox, child: Widget, is_secondary: bool) {.inline.} =

# gtk_button_box_set_layout
# flags: {isMethod} container: ButtonBox
# need sugar: is method
# layout_style 'ButtonBoxStyle' 'ButtonBoxStyle' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_button_box_set_layout(self: ptr TButtonBox, layout_style: ButtonBoxStyle) {.cdecl, dynlib: lib, importc: "gtk_button_box_set_layout".}
proc set_layout*(self: ButtonBox, layout_style: ButtonBoxStyle) {.inline.} =
  gtk_button_box_set_layout(self, layout_style)
# proc set_layout*(self: ButtonBox, layout_style: ButtonBoxStyle) {.inline.} =

# gtk_calendar_new
# flags: {isConstructor} container: Calendar
# need sugar: is static method
# 'Calendar' 'TransferNone[TCalendar]' (diff., need sugar)
proc gtk_calendar_new(): TransferNone[TCalendar] {.cdecl, dynlib: lib, importc: "gtk_calendar_new".}
proc new_calendar*(): Calendar {.inline.} =
  wrap(gtk_calendar_new())
# proc new_calendar*(): Calendar {.inline.} =

# gtk_calendar_clear_marks
# flags: {isMethod} container: Calendar
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_calendar_clear_marks(self: ptr TCalendar) {.cdecl, dynlib: lib, importc: "gtk_calendar_clear_marks".}
proc clear_marks*(self: Calendar) {.inline.} =
  gtk_calendar_clear_marks(self)
# proc clear_marks*(self: Calendar) {.inline.} =

# gtk_calendar_get_date
# flags: {isMethod} container: Calendar
# need sugar: is method
# year 'var uint32' 'ptr uint32' OUT (diff., need sugar) optional
# month 'var uint32' 'ptr uint32' OUT (diff., need sugar) optional
# day 'var uint32' 'ptr uint32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_calendar_get_date(self: ptr TCalendar, year: ptr uint32, month: ptr uint32, day: ptr uint32) {.cdecl, dynlib: lib, importc: "gtk_calendar_get_date".}
proc get_date*(self: Calendar, year: var uint32, month: var uint32, day: var uint32) {.inline.} =
  gtk_calendar_get_date(self, addr(year), addr(month), addr(day))
# tuple-return
# year: var uint32
# month: var uint32
# day: var uint32
# proc get_date*(self: Calendar) {.inline.} =

# gtk_calendar_get_day_is_marked
# flags: {isMethod} container: Calendar
# need sugar: is method
# day 'uint32' 'uint32' IN
# 'bool' 'bool'
proc gtk_calendar_get_day_is_marked(self: ptr TCalendar, day: uint32): bool {.cdecl, dynlib: lib, importc: "gtk_calendar_get_day_is_marked".}
proc get_day_is_marked*(self: Calendar, day: uint32): bool {.inline.} =
  gtk_calendar_get_day_is_marked(self, day)
# proc get_day_is_marked*(self: Calendar, day: uint32): bool {.inline.} =

# gtk_calendar_get_detail_height_rows
# flags: {isMethod} container: Calendar
# need sugar: is method
# 'int32' 'int32'
proc gtk_calendar_get_detail_height_rows(self: ptr TCalendar): int32 {.cdecl, dynlib: lib, importc: "gtk_calendar_get_detail_height_rows".}
proc get_detail_height_rows*(self: Calendar): int32 {.inline.} =
  gtk_calendar_get_detail_height_rows(self)
# proc get_detail_height_rows*(self: Calendar): int32 {.inline.} =

# gtk_calendar_get_detail_width_chars
# flags: {isMethod} container: Calendar
# need sugar: is method
# 'int32' 'int32'
proc gtk_calendar_get_detail_width_chars(self: ptr TCalendar): int32 {.cdecl, dynlib: lib, importc: "gtk_calendar_get_detail_width_chars".}
proc get_detail_width_chars*(self: Calendar): int32 {.inline.} =
  gtk_calendar_get_detail_width_chars(self)
# proc get_detail_width_chars*(self: Calendar): int32 {.inline.} =

# gtk_calendar_get_display_options
# flags: {isMethod} container: Calendar
# need sugar: is method
# 'SCalendarDisplayOptions' 'SCalendarDisplayOptions'
proc gtk_calendar_get_display_options(self: ptr TCalendar): SCalendarDisplayOptions {.cdecl, dynlib: lib, importc: "gtk_calendar_get_display_options".}
proc get_display_options*(self: Calendar): SCalendarDisplayOptions {.inline.} =
  gtk_calendar_get_display_options(self)
# proc get_display_options*(self: Calendar): SCalendarDisplayOptions {.inline.} =

# gtk_calendar_mark_day
# flags: {isMethod} container: Calendar
# need sugar: is method
# day 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_calendar_mark_day(self: ptr TCalendar, day: uint32) {.cdecl, dynlib: lib, importc: "gtk_calendar_mark_day".}
proc mark_day*(self: Calendar, day: uint32) {.inline.} =
  gtk_calendar_mark_day(self, day)
# proc mark_day*(self: Calendar, day: uint32) {.inline.} =

# gtk_calendar_select_day
# flags: {isMethod} container: Calendar
# need sugar: is method
# day 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_calendar_select_day(self: ptr TCalendar, day: uint32) {.cdecl, dynlib: lib, importc: "gtk_calendar_select_day".}
proc select_day*(self: Calendar, day: uint32) {.inline.} =
  gtk_calendar_select_day(self, day)
# proc select_day*(self: Calendar, day: uint32) {.inline.} =

# gtk_calendar_select_month
# flags: {isMethod} container: Calendar
# need sugar: is method
# month 'uint32' 'uint32' IN
# year 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_calendar_select_month(self: ptr TCalendar, month: uint32, year: uint32) {.cdecl, dynlib: lib, importc: "gtk_calendar_select_month".}
proc select_month*(self: Calendar, month: uint32, year: uint32) {.inline.} =
  gtk_calendar_select_month(self, month, year)
# proc select_month*(self: Calendar, month: uint32, year: uint32) {.inline.} =

# gtk_calendar_set_detail_func
# flags: {isMethod} container: Calendar
# need sugar: is method
# func 'pointer' 'pointer' IN
# data 'pointer' 'pointer' IN
# destroy 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_calendar_set_detail_func(self: ptr TCalendar, func_x: pointer, data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_calendar_set_detail_func".}
proc set_detail_func*(self: Calendar, func_x: pointer, data: pointer, destroy: pointer) {.inline.} =
  gtk_calendar_set_detail_func(self, func_x, data, destroy)
# proc set_detail_func*(self: Calendar, func_x: pointer, data: pointer, destroy: pointer) {.inline.} =

# gtk_calendar_set_detail_height_rows
# flags: {isMethod} container: Calendar
# need sugar: is method
# rows 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_calendar_set_detail_height_rows(self: ptr TCalendar, rows: int32) {.cdecl, dynlib: lib, importc: "gtk_calendar_set_detail_height_rows".}
proc set_detail_height_rows*(self: Calendar, rows: int32) {.inline.} =
  gtk_calendar_set_detail_height_rows(self, rows)
# proc set_detail_height_rows*(self: Calendar, rows: int32) {.inline.} =

# gtk_calendar_set_detail_width_chars
# flags: {isMethod} container: Calendar
# need sugar: is method
# chars 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_calendar_set_detail_width_chars(self: ptr TCalendar, chars: int32) {.cdecl, dynlib: lib, importc: "gtk_calendar_set_detail_width_chars".}
proc set_detail_width_chars*(self: Calendar, chars: int32) {.inline.} =
  gtk_calendar_set_detail_width_chars(self, chars)
# proc set_detail_width_chars*(self: Calendar, chars: int32) {.inline.} =

# gtk_calendar_set_display_options
# flags: {isMethod} container: Calendar
# need sugar: is method
# flags 'SCalendarDisplayOptions' 'SCalendarDisplayOptions' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_calendar_set_display_options(self: ptr TCalendar, flags: SCalendarDisplayOptions) {.cdecl, dynlib: lib, importc: "gtk_calendar_set_display_options".}
proc set_display_options*(self: Calendar, flags: SCalendarDisplayOptions) {.inline.} =
  gtk_calendar_set_display_options(self, flags)
# proc set_display_options*(self: Calendar, flags: SCalendarDisplayOptions) {.inline.} =

# gtk_calendar_unmark_day
# flags: {isMethod} container: Calendar
# need sugar: is method
# day 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_calendar_unmark_day(self: ptr TCalendar, day: uint32) {.cdecl, dynlib: lib, importc: "gtk_calendar_unmark_day".}
proc unmark_day*(self: Calendar, day: uint32) {.inline.} =
  gtk_calendar_unmark_day(self, day)
# proc unmark_day*(self: Calendar, day: uint32) {.inline.} =

# gtk_cell_area_activate
# flags: {isMethod} container: CellArea
# need sugar: is method
# context 'CellAreaContext' 'ptr TCellAreaContext' IN (diff., need sugar)
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# cell_area 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# flags 'SCellRendererState' 'SCellRendererState' IN
# edit_only 'bool' 'bool' IN
# 'bool' 'bool'
proc gtk_cell_area_activate(self: ptr TCellArea, context: ptr TCellAreaContext, widget: ptr TWidget, cell_area: ptr cairo1.TRectangleInt, flags: SCellRendererState, edit_only: bool): bool {.cdecl, dynlib: lib, importc: "gtk_cell_area_activate".}
proc activate*(self: CellArea, context: CellAreaContext, widget: Widget, cell_area: cairo1.TRectangleInt, flags: SCellRendererState, edit_only: bool): bool {.inline.} =
  gtk_cell_area_activate(self, context.getPointer, widget.getPointer, myUnsafeAddr(cell_area), flags, edit_only)
# proc activate*(self: CellArea, context: CellAreaContext, widget: Widget, cell_area: cairo1.TRectangleInt, flags: SCellRendererState, edit_only: bool): bool {.inline.} =

# gtk_cell_area_activate_cell
# flags: {isMethod} container: CellArea
# need sugar: is method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# renderer 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# event 'Gdk3.TEvent' 'ptr Gdk3.TEvent' IN (diff., need sugar)
# cell_area 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# flags 'SCellRendererState' 'SCellRendererState' IN
# 'bool' 'bool'
proc gtk_cell_area_activate_cell(self: ptr TCellArea, widget: ptr TWidget, renderer: ptr TCellRenderer, event: ptr Gdk3.TEvent, cell_area: ptr cairo1.TRectangleInt, flags: SCellRendererState): bool {.cdecl, dynlib: lib, importc: "gtk_cell_area_activate_cell".}
proc activate_cell*(self: CellArea, widget: Widget, renderer: CellRenderer, event: Gdk3.TEvent, cell_area: cairo1.TRectangleInt, flags: SCellRendererState): bool {.inline.} =
  gtk_cell_area_activate_cell(self, widget.getPointer, renderer.getPointer, myUnsafeAddr(event), myUnsafeAddr(cell_area), flags)
# proc activate_cell*(self: CellArea, widget: Widget, renderer: CellRenderer, event: Gdk3.TEvent, cell_area: cairo1.TRectangleInt, flags: SCellRendererState): bool {.inline.} =

# gtk_cell_area_add
# flags: {isMethod} container: CellArea
# need sugar: is method
# renderer 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_add(self: ptr TCellArea, renderer: ptr TCellRenderer) {.cdecl, dynlib: lib, importc: "gtk_cell_area_add".}
proc add*(self: CellArea, renderer: CellRenderer) {.inline.} =
  gtk_cell_area_add(self, renderer.getPointer)
# proc add*(self: CellArea, renderer: CellRenderer) {.inline.} =

# gtk_cell_area_add_focus_sibling
# flags: {isMethod} container: CellArea
# need sugar: is method
# renderer 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# sibling 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_add_focus_sibling(self: ptr TCellArea, renderer: ptr TCellRenderer, sibling: ptr TCellRenderer) {.cdecl, dynlib: lib, importc: "gtk_cell_area_add_focus_sibling".}
proc add_focus_sibling*(self: CellArea, renderer: CellRenderer, sibling: CellRenderer) {.inline.} =
  gtk_cell_area_add_focus_sibling(self, renderer.getPointer, sibling.getPointer)
# proc add_focus_sibling*(self: CellArea, renderer: CellRenderer, sibling: CellRenderer) {.inline.} =

# gtk_cell_area_apply_attributes
# flags: {isMethod} container: CellArea
# need sugar: is method
# tree_model 'TreeModel' 'ptr TTreeModel' IN (diff., need sugar)
# iter 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# is_expander 'bool' 'bool' IN
# is_expanded 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_apply_attributes(self: ptr TCellArea, tree_model: ptr TTreeModel, iter: ptr TTreeIter, is_expander: bool, is_expanded: bool) {.cdecl, dynlib: lib, importc: "gtk_cell_area_apply_attributes".}
proc apply_attributes*(self: CellArea, tree_model: TreeModel, iter: TTreeIter, is_expander: bool, is_expanded: bool) {.inline.} =
  gtk_cell_area_apply_attributes(self, unwrap(tree_model), myUnsafeAddr(iter), is_expander, is_expanded)
# proc apply_attributes*(self: CellArea, tree_model: TreeModel, iter: TTreeIter, is_expander: bool, is_expanded: bool) {.inline.} =

# gtk_cell_area_attribute_connect
# flags: {isMethod} container: CellArea
# need sugar: is method
# renderer 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# attribute 'ustring' 'ucstring' IN (diff., need sugar)
# column 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_attribute_connect(self: ptr TCellArea, renderer: ptr TCellRenderer, attribute: ucstring, column: int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_attribute_connect".}
proc attribute_connect*(self: CellArea, renderer: CellRenderer, attribute: ustring, column: int32) {.inline.} =
  gtk_cell_area_attribute_connect(self, renderer.getPointer, ucstring(attribute), column)
# proc attribute_connect*(self: CellArea, renderer: CellRenderer, attribute: ustring, column: int32) {.inline.} =

# gtk_cell_area_attribute_disconnect
# flags: {isMethod} container: CellArea
# need sugar: is method
# renderer 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# attribute 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_attribute_disconnect(self: ptr TCellArea, renderer: ptr TCellRenderer, attribute: ucstring) {.cdecl, dynlib: lib, importc: "gtk_cell_area_attribute_disconnect".}
proc attribute_disconnect*(self: CellArea, renderer: CellRenderer, attribute: ustring) {.inline.} =
  gtk_cell_area_attribute_disconnect(self, renderer.getPointer, ucstring(attribute))
# proc attribute_disconnect*(self: CellArea, renderer: CellRenderer, attribute: ustring) {.inline.} =

# gtk_cell_area_attribute_get_column
# flags: {isMethod} container: CellArea
# need sugar: is method
# renderer 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# attribute 'ustring' 'ucstring' IN (diff., need sugar)
# 'int32' 'int32'
proc gtk_cell_area_attribute_get_column(self: ptr TCellArea, renderer: ptr TCellRenderer, attribute: ucstring): int32 {.cdecl, dynlib: lib, importc: "gtk_cell_area_attribute_get_column".}
proc attribute_get_column*(self: CellArea, renderer: CellRenderer, attribute: ustring): int32 {.inline.} =
  gtk_cell_area_attribute_get_column(self, renderer.getPointer, ucstring(attribute))
# proc attribute_get_column*(self: CellArea, renderer: CellRenderer, attribute: ustring): int32 {.inline.} =

# gtk_cell_area_cell_get_property
# flags: {isMethod} container: CellArea
# need sugar: is method
# renderer 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# property_name 'ustring' 'ucstring' IN (diff., need sugar)
# value 'GObject2.TValue' 'ptr GObject2.TValue' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_cell_get_property(self: ptr TCellArea, renderer: ptr TCellRenderer, property_name: ucstring, value: ptr GObject2.TValue) {.cdecl, dynlib: lib, importc: "gtk_cell_area_cell_get_property".}
proc cell_get_property*(self: CellArea, renderer: CellRenderer, property_name: ustring, value: GObject2.TValue) {.inline.} =
  gtk_cell_area_cell_get_property(self, renderer.getPointer, ucstring(property_name), myUnsafeAddr(value))
# proc cell_get_property*(self: CellArea, renderer: CellRenderer, property_name: ustring, value: GObject2.TValue) {.inline.} =

# gtk_cell_area_cell_set_property
# flags: {isMethod} container: CellArea
# need sugar: is method
# renderer 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# property_name 'ustring' 'ucstring' IN (diff., need sugar)
# value 'GObject2.TValue' 'ptr GObject2.TValue' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_cell_set_property(self: ptr TCellArea, renderer: ptr TCellRenderer, property_name: ucstring, value: ptr GObject2.TValue) {.cdecl, dynlib: lib, importc: "gtk_cell_area_cell_set_property".}
proc cell_set_property*(self: CellArea, renderer: CellRenderer, property_name: ustring, value: GObject2.TValue) {.inline.} =
  gtk_cell_area_cell_set_property(self, renderer.getPointer, ucstring(property_name), myUnsafeAddr(value))
# proc cell_set_property*(self: CellArea, renderer: CellRenderer, property_name: ustring, value: GObject2.TValue) {.inline.} =

# gtk_cell_area_copy_context
# flags: {isMethod} container: CellArea
# need sugar: is method
# context 'CellAreaContext' 'ptr TCellAreaContext' IN (diff., need sugar)
# 'CellAreaContext' 'TransferFull[TCellAreaContext]' (diff., need sugar)
proc gtk_cell_area_copy_context(self: ptr TCellArea, context: ptr TCellAreaContext): TransferFull[TCellAreaContext] {.cdecl, dynlib: lib, importc: "gtk_cell_area_copy_context".}
proc copy_context*(self: CellArea, context: CellAreaContext): CellAreaContext {.inline.} =
  wrap(gtk_cell_area_copy_context(self, context.getPointer))
# proc copy_context*(self: CellArea, context: CellAreaContext): CellAreaContext {.inline.} =

# gtk_cell_area_create_context
# flags: {isMethod} container: CellArea
# need sugar: is method
# 'CellAreaContext' 'TransferFull[TCellAreaContext]' (diff., need sugar)
proc gtk_cell_area_create_context(self: ptr TCellArea): TransferFull[TCellAreaContext] {.cdecl, dynlib: lib, importc: "gtk_cell_area_create_context".}
proc create_context*(self: CellArea): CellAreaContext {.inline.} =
  wrap(gtk_cell_area_create_context(self))
# proc create_context*(self: CellArea): CellAreaContext {.inline.} =

# gtk_cell_area_event
# flags: {isMethod} container: CellArea
# need sugar: is method
# context 'CellAreaContext' 'ptr TCellAreaContext' IN (diff., need sugar)
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# event 'Gdk3.TEvent' 'ptr Gdk3.TEvent' IN (diff., need sugar)
# cell_area 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# flags 'SCellRendererState' 'SCellRendererState' IN
# 'int32' 'int32'
proc gtk_cell_area_event(self: ptr TCellArea, context: ptr TCellAreaContext, widget: ptr TWidget, event: ptr Gdk3.TEvent, cell_area: ptr cairo1.TRectangleInt, flags: SCellRendererState): int32 {.cdecl, dynlib: lib, importc: "gtk_cell_area_event".}
proc event*(self: CellArea, context: CellAreaContext, widget: Widget, event: Gdk3.TEvent, cell_area: cairo1.TRectangleInt, flags: SCellRendererState): int32 {.inline.} =
  gtk_cell_area_event(self, context.getPointer, widget.getPointer, myUnsafeAddr(event), myUnsafeAddr(cell_area), flags)
# proc event*(self: CellArea, context: CellAreaContext, widget: Widget, event: Gdk3.TEvent, cell_area: cairo1.TRectangleInt, flags: SCellRendererState): int32 {.inline.} =

# gtk_cell_area_focus
# flags: {isMethod} container: CellArea
# need sugar: is method
# direction 'DirectionType' 'DirectionType' IN
# 'bool' 'bool'
proc gtk_cell_area_focus(self: ptr TCellArea, direction: DirectionType): bool {.cdecl, dynlib: lib, importc: "gtk_cell_area_focus".}
proc focus*(self: CellArea, direction: DirectionType): bool {.inline.} =
  gtk_cell_area_focus(self, direction)
# proc focus*(self: CellArea, direction: DirectionType): bool {.inline.} =

# gtk_cell_area_foreach
# flags: {isMethod} container: CellArea
# need sugar: is method
# callback 'pointer' 'pointer' IN
# callback_data 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_foreach(self: ptr TCellArea, callback: pointer, callback_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_cell_area_foreach".}
proc foreach*(self: CellArea, callback: pointer, callback_data: pointer) {.inline.} =
  gtk_cell_area_foreach(self, callback, callback_data)
# proc foreach*(self: CellArea, callback: pointer, callback_data: pointer) {.inline.} =

# gtk_cell_area_foreach_alloc
# flags: {isMethod} container: CellArea
# need sugar: is method
# context 'CellAreaContext' 'ptr TCellAreaContext' IN (diff., need sugar)
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# cell_area 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# background_area 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# callback 'pointer' 'pointer' IN
# callback_data 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_foreach_alloc(self: ptr TCellArea, context: ptr TCellAreaContext, widget: ptr TWidget, cell_area: ptr cairo1.TRectangleInt, background_area: ptr cairo1.TRectangleInt, callback: pointer, callback_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_cell_area_foreach_alloc".}
proc foreach_alloc*(self: CellArea, context: CellAreaContext, widget: Widget, cell_area: cairo1.TRectangleInt, background_area: cairo1.TRectangleInt, callback: pointer, callback_data: pointer) {.inline.} =
  gtk_cell_area_foreach_alloc(self, context.getPointer, widget.getPointer, myUnsafeAddr(cell_area), myUnsafeAddr(background_area), callback, callback_data)
# proc foreach_alloc*(self: CellArea, context: CellAreaContext, widget: Widget, cell_area: cairo1.TRectangleInt, background_area: cairo1.TRectangleInt, callback: pointer, callback_data: pointer) {.inline.} =

# gtk_cell_area_get_cell_allocation
# flags: {isMethod} container: CellArea
# need sugar: is method
# context 'CellAreaContext' 'ptr TCellAreaContext' IN (diff., need sugar)
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# renderer 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# cell_area 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# allocation 'var cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_get_cell_allocation(self: ptr TCellArea, context: ptr TCellAreaContext, widget: ptr TWidget, renderer: ptr TCellRenderer, cell_area: ptr cairo1.TRectangleInt, allocation: ptr cairo1.TRectangleInt) {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_cell_allocation".}
proc get_cell_allocation*(self: CellArea, context: CellAreaContext, widget: Widget, renderer: CellRenderer, cell_area: cairo1.TRectangleInt, allocation: var cairo1.TRectangleInt) {.inline.} =
  gtk_cell_area_get_cell_allocation(self, context.getPointer, widget.getPointer, renderer.getPointer, myUnsafeAddr(cell_area), addr(allocation))
# tuple-return
# allocation: var cairo1.TRectangleInt
# proc get_cell_allocation*(self: CellArea, context: CellAreaContext, widget: Widget, renderer: CellRenderer, cell_area: cairo1.TRectangleInt) {.inline.} =

# gtk_cell_area_get_cell_at_position
# flags: {isMethod} container: CellArea
# need sugar: is method
# context 'CellAreaContext' 'ptr TCellAreaContext' IN (diff., need sugar)
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# cell_area 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# x 'int32' 'int32' IN
# y 'int32' 'int32' IN
# alloc_area 'var cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' OUT (diff., need sugar) caller-allocates optional
# 'CellRenderer' 'TransferNone[TCellRenderer]' (diff., need sugar)
proc gtk_cell_area_get_cell_at_position(self: ptr TCellArea, context: ptr TCellAreaContext, widget: ptr TWidget, cell_area: ptr cairo1.TRectangleInt, x: int32, y: int32, alloc_area: ptr cairo1.TRectangleInt): TransferNone[TCellRenderer] {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_cell_at_position".}
proc get_cell_at_position*(self: CellArea, context: CellAreaContext, widget: Widget, cell_area: cairo1.TRectangleInt, x: int32, y: int32, alloc_area: var cairo1.TRectangleInt): CellRenderer {.inline.} =
  wrap(gtk_cell_area_get_cell_at_position(self, context.getPointer, widget.getPointer, myUnsafeAddr(cell_area), x, y, addr(alloc_area)))
# tuple-return
# alloc_area: var cairo1.TRectangleInt
# proc get_cell_at_position*(self: CellArea, context: CellAreaContext, widget: Widget, cell_area: cairo1.TRectangleInt, x: int32, y: int32): CellRenderer {.inline.} =

# gtk_cell_area_get_current_path_string
# flags: {isMethod} container: CellArea
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_cell_area_get_current_path_string(self: ptr TCellArea): ucstring {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_current_path_string".}
proc get_current_path_string*(self: CellArea): ustring {.inline.} =
  ustring($(gtk_cell_area_get_current_path_string(self)))
# proc get_current_path_string*(self: CellArea): ustring {.inline.} =

# gtk_cell_area_get_edit_widget
# flags: {isMethod} container: CellArea
# need sugar: is method
# 'CellEditable' 'TransferNone[TCellEditable]' (diff., need sugar)
proc gtk_cell_area_get_edit_widget(self: ptr TCellArea): TransferNone[TCellEditable] {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_edit_widget".}
proc get_edit_widget*(self: CellArea): CellEditable {.inline.} =
  wrap(gtk_cell_area_get_edit_widget(self))
# proc get_edit_widget*(self: CellArea): CellEditable {.inline.} =

# gtk_cell_area_get_edited_cell
# flags: {isMethod} container: CellArea
# need sugar: is method
# 'CellRenderer' 'TransferNone[TCellRenderer]' (diff., need sugar)
proc gtk_cell_area_get_edited_cell(self: ptr TCellArea): TransferNone[TCellRenderer] {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_edited_cell".}
proc get_edited_cell*(self: CellArea): CellRenderer {.inline.} =
  wrap(gtk_cell_area_get_edited_cell(self))
# proc get_edited_cell*(self: CellArea): CellRenderer {.inline.} =

# gtk_cell_area_get_focus_cell
# flags: {isMethod} container: CellArea
# need sugar: is method
# 'CellRenderer' 'TransferNone[TCellRenderer]' (diff., need sugar)
proc gtk_cell_area_get_focus_cell(self: ptr TCellArea): TransferNone[TCellRenderer] {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_focus_cell".}
proc get_focus_cell*(self: CellArea): CellRenderer {.inline.} =
  wrap(gtk_cell_area_get_focus_cell(self))
# proc get_focus_cell*(self: CellArea): CellRenderer {.inline.} =

# gtk_cell_area_get_focus_from_sibling
# flags: {isMethod} container: CellArea
# need sugar: is method
# renderer 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# 'CellRenderer' 'TransferNone[TCellRenderer]' (diff., need sugar)
proc gtk_cell_area_get_focus_from_sibling(self: ptr TCellArea, renderer: ptr TCellRenderer): TransferNone[TCellRenderer] {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_focus_from_sibling".}
proc get_focus_from_sibling*(self: CellArea, renderer: CellRenderer): CellRenderer {.inline.} =
  wrap(gtk_cell_area_get_focus_from_sibling(self, renderer.getPointer))
# proc get_focus_from_sibling*(self: CellArea, renderer: CellRenderer): CellRenderer {.inline.} =

# gtk_cell_area_get_focus_siblings
# flags: {isMethod} container: CellArea
# need sugar: is method
# renderer 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_cell_area_get_focus_siblings(self: ptr TCellArea, renderer: ptr TCellRenderer): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_focus_siblings".}
proc get_focus_siblings*(self: CellArea, renderer: CellRenderer): ptr GLIST_TODO {.inline.} =
  gtk_cell_area_get_focus_siblings(self, renderer.getPointer)
# proc get_focus_siblings*(self: CellArea, renderer: CellRenderer): ptr GLIST_TODO {.inline.} =

# gtk_cell_area_get_preferred_height
# flags: {isMethod} container: CellArea
# need sugar: is method
# context 'CellAreaContext' 'ptr TCellAreaContext' IN (diff., need sugar)
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# minimum_height 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# natural_height 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_get_preferred_height(self: ptr TCellArea, context: ptr TCellAreaContext, widget: ptr TWidget, minimum_height: ptr int32, natural_height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_preferred_height".}
proc get_preferred_height*(self: CellArea, context: CellAreaContext, widget: Widget, minimum_height: var int32, natural_height: var int32) {.inline.} =
  gtk_cell_area_get_preferred_height(self, context.getPointer, widget.getPointer, addr(minimum_height), addr(natural_height))
# tuple-return
# minimum_height: var int32
# natural_height: var int32
# proc get_preferred_height*(self: CellArea, context: CellAreaContext, widget: Widget) {.inline.} =

# gtk_cell_area_get_preferred_height_for_width
# flags: {isMethod} container: CellArea
# need sugar: is method
# context 'CellAreaContext' 'ptr TCellAreaContext' IN (diff., need sugar)
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# width 'int32' 'int32' IN
# minimum_height 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# natural_height 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_get_preferred_height_for_width(self: ptr TCellArea, context: ptr TCellAreaContext, widget: ptr TWidget, width: int32, minimum_height: ptr int32, natural_height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_preferred_height_for_width".}
proc get_preferred_height_for_width*(self: CellArea, context: CellAreaContext, widget: Widget, width: int32, minimum_height: var int32, natural_height: var int32) {.inline.} =
  gtk_cell_area_get_preferred_height_for_width(self, context.getPointer, widget.getPointer, width, addr(minimum_height), addr(natural_height))
# tuple-return
# minimum_height: var int32
# natural_height: var int32
# proc get_preferred_height_for_width*(self: CellArea, context: CellAreaContext, widget: Widget, width: int32) {.inline.} =

# gtk_cell_area_get_preferred_width
# flags: {isMethod} container: CellArea
# need sugar: is method
# context 'CellAreaContext' 'ptr TCellAreaContext' IN (diff., need sugar)
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# minimum_width 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# natural_width 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_get_preferred_width(self: ptr TCellArea, context: ptr TCellAreaContext, widget: ptr TWidget, minimum_width: ptr int32, natural_width: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_preferred_width".}
proc get_preferred_width*(self: CellArea, context: CellAreaContext, widget: Widget, minimum_width: var int32, natural_width: var int32) {.inline.} =
  gtk_cell_area_get_preferred_width(self, context.getPointer, widget.getPointer, addr(minimum_width), addr(natural_width))
# tuple-return
# minimum_width: var int32
# natural_width: var int32
# proc get_preferred_width*(self: CellArea, context: CellAreaContext, widget: Widget) {.inline.} =

# gtk_cell_area_get_preferred_width_for_height
# flags: {isMethod} container: CellArea
# need sugar: is method
# context 'CellAreaContext' 'ptr TCellAreaContext' IN (diff., need sugar)
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# height 'int32' 'int32' IN
# minimum_width 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# natural_width 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_get_preferred_width_for_height(self: ptr TCellArea, context: ptr TCellAreaContext, widget: ptr TWidget, height: int32, minimum_width: ptr int32, natural_width: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_preferred_width_for_height".}
proc get_preferred_width_for_height*(self: CellArea, context: CellAreaContext, widget: Widget, height: int32, minimum_width: var int32, natural_width: var int32) {.inline.} =
  gtk_cell_area_get_preferred_width_for_height(self, context.getPointer, widget.getPointer, height, addr(minimum_width), addr(natural_width))
# tuple-return
# minimum_width: var int32
# natural_width: var int32
# proc get_preferred_width_for_height*(self: CellArea, context: CellAreaContext, widget: Widget, height: int32) {.inline.} =

# gtk_cell_area_get_request_mode
# flags: {isMethod} container: CellArea
# need sugar: is method
# 'SizeRequestMode' 'SizeRequestMode'
proc gtk_cell_area_get_request_mode(self: ptr TCellArea): SizeRequestMode {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_request_mode".}
proc get_request_mode*(self: CellArea): SizeRequestMode {.inline.} =
  gtk_cell_area_get_request_mode(self)
# proc get_request_mode*(self: CellArea): SizeRequestMode {.inline.} =

# gtk_cell_area_has_renderer
# flags: {isMethod} container: CellArea
# need sugar: is method
# renderer 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_cell_area_has_renderer(self: ptr TCellArea, renderer: ptr TCellRenderer): bool {.cdecl, dynlib: lib, importc: "gtk_cell_area_has_renderer".}
proc has_renderer*(self: CellArea, renderer: CellRenderer): bool {.inline.} =
  gtk_cell_area_has_renderer(self, renderer.getPointer)
# proc has_renderer*(self: CellArea, renderer: CellRenderer): bool {.inline.} =

# gtk_cell_area_inner_cell_area
# flags: {isMethod} container: CellArea
# need sugar: is method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# cell_area 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# inner_area 'var cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_inner_cell_area(self: ptr TCellArea, widget: ptr TWidget, cell_area: ptr cairo1.TRectangleInt, inner_area: ptr cairo1.TRectangleInt) {.cdecl, dynlib: lib, importc: "gtk_cell_area_inner_cell_area".}
proc inner_cell_area*(self: CellArea, widget: Widget, cell_area: cairo1.TRectangleInt, inner_area: var cairo1.TRectangleInt) {.inline.} =
  gtk_cell_area_inner_cell_area(self, widget.getPointer, myUnsafeAddr(cell_area), addr(inner_area))
# tuple-return
# inner_area: var cairo1.TRectangleInt
# proc inner_cell_area*(self: CellArea, widget: Widget, cell_area: cairo1.TRectangleInt) {.inline.} =

# gtk_cell_area_is_activatable
# flags: {isMethod} container: CellArea
# need sugar: is method
# 'bool' 'bool'
proc gtk_cell_area_is_activatable(self: ptr TCellArea): bool {.cdecl, dynlib: lib, importc: "gtk_cell_area_is_activatable".}
proc is_activatable*(self: CellArea): bool {.inline.} =
  gtk_cell_area_is_activatable(self)
# proc is_activatable*(self: CellArea): bool {.inline.} =

# gtk_cell_area_is_focus_sibling
# flags: {isMethod} container: CellArea
# need sugar: is method
# renderer 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# sibling 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_cell_area_is_focus_sibling(self: ptr TCellArea, renderer: ptr TCellRenderer, sibling: ptr TCellRenderer): bool {.cdecl, dynlib: lib, importc: "gtk_cell_area_is_focus_sibling".}
proc is_focus_sibling*(self: CellArea, renderer: CellRenderer, sibling: CellRenderer): bool {.inline.} =
  gtk_cell_area_is_focus_sibling(self, renderer.getPointer, sibling.getPointer)
# proc is_focus_sibling*(self: CellArea, renderer: CellRenderer, sibling: CellRenderer): bool {.inline.} =

# gtk_cell_area_remove
# flags: {isMethod} container: CellArea
# need sugar: is method
# renderer 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_remove(self: ptr TCellArea, renderer: ptr TCellRenderer) {.cdecl, dynlib: lib, importc: "gtk_cell_area_remove".}
proc remove*(self: CellArea, renderer: CellRenderer) {.inline.} =
  gtk_cell_area_remove(self, renderer.getPointer)
# proc remove*(self: CellArea, renderer: CellRenderer) {.inline.} =

# gtk_cell_area_remove_focus_sibling
# flags: {isMethod} container: CellArea
# need sugar: is method
# renderer 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# sibling 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_remove_focus_sibling(self: ptr TCellArea, renderer: ptr TCellRenderer, sibling: ptr TCellRenderer) {.cdecl, dynlib: lib, importc: "gtk_cell_area_remove_focus_sibling".}
proc remove_focus_sibling*(self: CellArea, renderer: CellRenderer, sibling: CellRenderer) {.inline.} =
  gtk_cell_area_remove_focus_sibling(self, renderer.getPointer, sibling.getPointer)
# proc remove_focus_sibling*(self: CellArea, renderer: CellRenderer, sibling: CellRenderer) {.inline.} =

# gtk_cell_area_render
# flags: {isMethod} container: CellArea
# need sugar: is method
# context 'CellAreaContext' 'ptr TCellAreaContext' IN (diff., need sugar)
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# cr 'cairo1.TContext' 'ptr cairo1.TContext' IN (diff., need sugar)
# background_area 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# cell_area 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# flags 'SCellRendererState' 'SCellRendererState' IN
# paint_focus 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_render(self: ptr TCellArea, context: ptr TCellAreaContext, widget: ptr TWidget, cr: ptr cairo1.TContext, background_area: ptr cairo1.TRectangleInt, cell_area: ptr cairo1.TRectangleInt, flags: SCellRendererState, paint_focus: bool) {.cdecl, dynlib: lib, importc: "gtk_cell_area_render".}
proc render*(self: CellArea, context: CellAreaContext, widget: Widget, cr: cairo1.TContext, background_area: cairo1.TRectangleInt, cell_area: cairo1.TRectangleInt, flags: SCellRendererState, paint_focus: bool) {.inline.} =
  gtk_cell_area_render(self, context.getPointer, widget.getPointer, myUnsafeAddr(cr), myUnsafeAddr(background_area), myUnsafeAddr(cell_area), flags, paint_focus)
# proc render*(self: CellArea, context: CellAreaContext, widget: Widget, cr: cairo1.TContext, background_area: cairo1.TRectangleInt, cell_area: cairo1.TRectangleInt, flags: SCellRendererState, paint_focus: bool) {.inline.} =

# gtk_cell_area_request_renderer
# flags: {isMethod} container: CellArea
# need sugar: is method
# renderer 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# orientation 'Orientation' 'Orientation' IN
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# for_size 'int32' 'int32' IN
# minimum_size 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# natural_size 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_request_renderer(self: ptr TCellArea, renderer: ptr TCellRenderer, orientation: Orientation, widget: ptr TWidget, for_size: int32, minimum_size: ptr int32, natural_size: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_request_renderer".}
proc request_renderer*(self: CellArea, renderer: CellRenderer, orientation: Orientation, widget: Widget, for_size: int32, minimum_size: var int32, natural_size: var int32) {.inline.} =
  gtk_cell_area_request_renderer(self, renderer.getPointer, orientation, widget.getPointer, for_size, addr(minimum_size), addr(natural_size))
# tuple-return
# minimum_size: var int32
# natural_size: var int32
# proc request_renderer*(self: CellArea, renderer: CellRenderer, orientation: Orientation, widget: Widget, for_size: int32) {.inline.} =

# gtk_cell_area_set_focus_cell
# flags: {isMethod} container: CellArea
# need sugar: is method
# renderer 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_set_focus_cell(self: ptr TCellArea, renderer: ptr TCellRenderer) {.cdecl, dynlib: lib, importc: "gtk_cell_area_set_focus_cell".}
proc set_focus_cell*(self: CellArea, renderer: CellRenderer) {.inline.} =
  gtk_cell_area_set_focus_cell(self, renderer.getPointer)
# proc set_focus_cell*(self: CellArea, renderer: CellRenderer) {.inline.} =

# gtk_cell_area_stop_editing
# flags: {isMethod} container: CellArea
# need sugar: is method
# canceled 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_stop_editing(self: ptr TCellArea, canceled: bool) {.cdecl, dynlib: lib, importc: "gtk_cell_area_stop_editing".}
proc stop_editing*(self: CellArea, canceled: bool) {.inline.} =
  gtk_cell_area_stop_editing(self, canceled)
# proc stop_editing*(self: CellArea, canceled: bool) {.inline.} =

# gtk_cell_area_box_new
# flags: {isConstructor} container: CellAreaBox
# need sugar: is static method
# 'CellAreaBox' 'TransferNone[TCellAreaBox]' (diff., need sugar)
proc gtk_cell_area_box_new(): TransferNone[TCellAreaBox] {.cdecl, dynlib: lib, importc: "gtk_cell_area_box_new".}
proc new_cellareabox*(): CellAreaBox {.inline.} =
  wrap(gtk_cell_area_box_new())
# proc new_cellareabox*(): CellAreaBox {.inline.} =

# gtk_cell_area_box_get_spacing
# flags: {isMethod} container: CellAreaBox
# need sugar: is method
# 'int32' 'int32'
proc gtk_cell_area_box_get_spacing(self: ptr TCellAreaBox): int32 {.cdecl, dynlib: lib, importc: "gtk_cell_area_box_get_spacing".}
proc get_spacing*(self: CellAreaBox): int32 {.inline.} =
  gtk_cell_area_box_get_spacing(self)
# proc get_spacing*(self: CellAreaBox): int32 {.inline.} =

# gtk_cell_area_box_pack_end
# flags: {isMethod} container: CellAreaBox
# need sugar: is method
# renderer 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# expand 'bool' 'bool' IN
# align 'bool' 'bool' IN
# fixed 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_box_pack_end(self: ptr TCellAreaBox, renderer: ptr TCellRenderer, expand: bool, align: bool, fixed: bool) {.cdecl, dynlib: lib, importc: "gtk_cell_area_box_pack_end".}
proc pack_end*(self: CellAreaBox, renderer: CellRenderer, expand: bool, align: bool, fixed: bool) {.inline.} =
  gtk_cell_area_box_pack_end(self, renderer.getPointer, expand, align, fixed)
# proc pack_end*(self: CellAreaBox, renderer: CellRenderer, expand: bool, align: bool, fixed: bool) {.inline.} =

# gtk_cell_area_box_pack_start
# flags: {isMethod} container: CellAreaBox
# need sugar: is method
# renderer 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# expand 'bool' 'bool' IN
# align 'bool' 'bool' IN
# fixed 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_box_pack_start(self: ptr TCellAreaBox, renderer: ptr TCellRenderer, expand: bool, align: bool, fixed: bool) {.cdecl, dynlib: lib, importc: "gtk_cell_area_box_pack_start".}
proc pack_start*(self: CellAreaBox, renderer: CellRenderer, expand: bool, align: bool, fixed: bool) {.inline.} =
  gtk_cell_area_box_pack_start(self, renderer.getPointer, expand, align, fixed)
# proc pack_start*(self: CellAreaBox, renderer: CellRenderer, expand: bool, align: bool, fixed: bool) {.inline.} =

# gtk_cell_area_box_set_spacing
# flags: {isMethod} container: CellAreaBox
# need sugar: is method
# spacing 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_box_set_spacing(self: ptr TCellAreaBox, spacing: int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_box_set_spacing".}
proc set_spacing*(self: CellAreaBox, spacing: int32) {.inline.} =
  gtk_cell_area_box_set_spacing(self, spacing)
# proc set_spacing*(self: CellAreaBox, spacing: int32) {.inline.} =

# gtk_cell_area_context_allocate
# flags: {isMethod} container: CellAreaContext
# need sugar: is method
# width 'int32' 'int32' IN
# height 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_context_allocate(self: ptr TCellAreaContext, width: int32, height: int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_context_allocate".}
proc allocate*(self: CellAreaContext, width: int32, height: int32) {.inline.} =
  gtk_cell_area_context_allocate(self, width, height)
# proc allocate*(self: CellAreaContext, width: int32, height: int32) {.inline.} =

# gtk_cell_area_context_get_allocation
# flags: {isMethod} container: CellAreaContext
# need sugar: is method
# width 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# height 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_context_get_allocation(self: ptr TCellAreaContext, width: ptr int32, height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_context_get_allocation".}
proc get_allocation*(self: CellAreaContext, width: var int32, height: var int32) {.inline.} =
  gtk_cell_area_context_get_allocation(self, addr(width), addr(height))
# tuple-return
# width: var int32
# height: var int32
# proc get_allocation*(self: CellAreaContext) {.inline.} =

# gtk_cell_area_context_get_area
# flags: {isMethod} container: CellAreaContext
# need sugar: is method
# 'CellArea' 'TransferNone[TCellArea]' (diff., need sugar)
proc gtk_cell_area_context_get_area(self: ptr TCellAreaContext): TransferNone[TCellArea] {.cdecl, dynlib: lib, importc: "gtk_cell_area_context_get_area".}
proc get_area*(self: CellAreaContext): CellArea {.inline.} =
  wrap(gtk_cell_area_context_get_area(self))
# proc get_area*(self: CellAreaContext): CellArea {.inline.} =

# gtk_cell_area_context_get_preferred_height
# flags: {isMethod} container: CellAreaContext
# need sugar: is method
# minimum_height 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# natural_height 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_context_get_preferred_height(self: ptr TCellAreaContext, minimum_height: ptr int32, natural_height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_context_get_preferred_height".}
proc get_preferred_height*(self: CellAreaContext, minimum_height: var int32, natural_height: var int32) {.inline.} =
  gtk_cell_area_context_get_preferred_height(self, addr(minimum_height), addr(natural_height))
# tuple-return
# minimum_height: var int32
# natural_height: var int32
# proc get_preferred_height*(self: CellAreaContext) {.inline.} =

# gtk_cell_area_context_get_preferred_height_for_width
# flags: {isMethod} container: CellAreaContext
# need sugar: is method
# width 'int32' 'int32' IN
# minimum_height 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# natural_height 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_context_get_preferred_height_for_width(self: ptr TCellAreaContext, width: int32, minimum_height: ptr int32, natural_height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_context_get_preferred_height_for_width".}
proc get_preferred_height_for_width*(self: CellAreaContext, width: int32, minimum_height: var int32, natural_height: var int32) {.inline.} =
  gtk_cell_area_context_get_preferred_height_for_width(self, width, addr(minimum_height), addr(natural_height))
# tuple-return
# minimum_height: var int32
# natural_height: var int32
# proc get_preferred_height_for_width*(self: CellAreaContext, width: int32) {.inline.} =

# gtk_cell_area_context_get_preferred_width
# flags: {isMethod} container: CellAreaContext
# need sugar: is method
# minimum_width 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# natural_width 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_context_get_preferred_width(self: ptr TCellAreaContext, minimum_width: ptr int32, natural_width: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_context_get_preferred_width".}
proc get_preferred_width*(self: CellAreaContext, minimum_width: var int32, natural_width: var int32) {.inline.} =
  gtk_cell_area_context_get_preferred_width(self, addr(minimum_width), addr(natural_width))
# tuple-return
# minimum_width: var int32
# natural_width: var int32
# proc get_preferred_width*(self: CellAreaContext) {.inline.} =

# gtk_cell_area_context_get_preferred_width_for_height
# flags: {isMethod} container: CellAreaContext
# need sugar: is method
# height 'int32' 'int32' IN
# minimum_width 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# natural_width 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_context_get_preferred_width_for_height(self: ptr TCellAreaContext, height: int32, minimum_width: ptr int32, natural_width: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_context_get_preferred_width_for_height".}
proc get_preferred_width_for_height*(self: CellAreaContext, height: int32, minimum_width: var int32, natural_width: var int32) {.inline.} =
  gtk_cell_area_context_get_preferred_width_for_height(self, height, addr(minimum_width), addr(natural_width))
# tuple-return
# minimum_width: var int32
# natural_width: var int32
# proc get_preferred_width_for_height*(self: CellAreaContext, height: int32) {.inline.} =

# gtk_cell_area_context_push_preferred_height
# flags: {isMethod} container: CellAreaContext
# need sugar: is method
# minimum_height 'int32' 'int32' IN
# natural_height 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_context_push_preferred_height(self: ptr TCellAreaContext, minimum_height: int32, natural_height: int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_context_push_preferred_height".}
proc push_preferred_height*(self: CellAreaContext, minimum_height: int32, natural_height: int32) {.inline.} =
  gtk_cell_area_context_push_preferred_height(self, minimum_height, natural_height)
# proc push_preferred_height*(self: CellAreaContext, minimum_height: int32, natural_height: int32) {.inline.} =

# gtk_cell_area_context_push_preferred_width
# flags: {isMethod} container: CellAreaContext
# need sugar: is method
# minimum_width 'int32' 'int32' IN
# natural_width 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_context_push_preferred_width(self: ptr TCellAreaContext, minimum_width: int32, natural_width: int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_context_push_preferred_width".}
proc push_preferred_width*(self: CellAreaContext, minimum_width: int32, natural_width: int32) {.inline.} =
  gtk_cell_area_context_push_preferred_width(self, minimum_width, natural_width)
# proc push_preferred_width*(self: CellAreaContext, minimum_width: int32, natural_width: int32) {.inline.} =

# gtk_cell_area_context_reset
# flags: {isMethod} container: CellAreaContext
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_context_reset(self: ptr TCellAreaContext) {.cdecl, dynlib: lib, importc: "gtk_cell_area_context_reset".}
proc reset*(self: CellAreaContext) {.inline.} =
  gtk_cell_area_context_reset(self)
# proc reset*(self: CellAreaContext) {.inline.} =

# gtk_cell_renderer_activate
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# event 'Gdk3.TEvent' 'ptr Gdk3.TEvent' IN (diff., need sugar)
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# path 'ustring' 'ucstring' IN (diff., need sugar)
# background_area 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# cell_area 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# flags 'SCellRendererState' 'SCellRendererState' IN
# 'bool' 'bool'
proc gtk_cell_renderer_activate(self: ptr TCellRenderer, event: ptr Gdk3.TEvent, widget: ptr TWidget, path: ucstring, background_area: ptr cairo1.TRectangleInt, cell_area: ptr cairo1.TRectangleInt, flags: SCellRendererState): bool {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_activate".}
proc activate*(self: CellRenderer, event: Gdk3.TEvent, widget: Widget, path: ustring, background_area: cairo1.TRectangleInt, cell_area: cairo1.TRectangleInt, flags: SCellRendererState): bool {.inline.} =
  gtk_cell_renderer_activate(self, myUnsafeAddr(event), widget.getPointer, ucstring(path), myUnsafeAddr(background_area), myUnsafeAddr(cell_area), flags)
# proc activate*(self: CellRenderer, event: Gdk3.TEvent, widget: Widget, path: ustring, background_area: cairo1.TRectangleInt, cell_area: cairo1.TRectangleInt, flags: SCellRendererState): bool {.inline.} =

# gtk_cell_renderer_get_aligned_area
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# flags 'SCellRendererState' 'SCellRendererState' IN
# cell_area 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# aligned_area 'var cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_get_aligned_area(self: ptr TCellRenderer, widget: ptr TWidget, flags: SCellRendererState, cell_area: ptr cairo1.TRectangleInt, aligned_area: ptr cairo1.TRectangleInt) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_aligned_area".}
proc get_aligned_area*(self: CellRenderer, widget: Widget, flags: SCellRendererState, cell_area: cairo1.TRectangleInt, aligned_area: var cairo1.TRectangleInt) {.inline.} =
  gtk_cell_renderer_get_aligned_area(self, widget.getPointer, flags, myUnsafeAddr(cell_area), addr(aligned_area))
# tuple-return
# aligned_area: var cairo1.TRectangleInt
# proc get_aligned_area*(self: CellRenderer, widget: Widget, flags: SCellRendererState, cell_area: cairo1.TRectangleInt) {.inline.} =

# gtk_cell_renderer_get_alignment
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# xalign 'var float32' 'ptr float32' OUT (diff., need sugar) optional
# yalign 'var float32' 'ptr float32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_get_alignment(self: ptr TCellRenderer, xalign: ptr float32, yalign: ptr float32) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_alignment".}
proc get_alignment*(self: CellRenderer, xalign: var float32, yalign: var float32) {.inline.} =
  gtk_cell_renderer_get_alignment(self, addr(xalign), addr(yalign))
# tuple-return
# xalign: var float32
# yalign: var float32
# proc get_alignment*(self: CellRenderer) {.inline.} =

# gtk_cell_renderer_get_fixed_size
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# width 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# height 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_get_fixed_size(self: ptr TCellRenderer, width: ptr int32, height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_fixed_size".}
proc get_fixed_size*(self: CellRenderer, width: var int32, height: var int32) {.inline.} =
  gtk_cell_renderer_get_fixed_size(self, addr(width), addr(height))
# tuple-return
# width: var int32
# height: var int32
# proc get_fixed_size*(self: CellRenderer) {.inline.} =

# gtk_cell_renderer_get_padding
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# xpad 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# ypad 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_get_padding(self: ptr TCellRenderer, xpad: ptr int32, ypad: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_padding".}
proc get_padding*(self: CellRenderer, xpad: var int32, ypad: var int32) {.inline.} =
  gtk_cell_renderer_get_padding(self, addr(xpad), addr(ypad))
# tuple-return
# xpad: var int32
# ypad: var int32
# proc get_padding*(self: CellRenderer) {.inline.} =

# gtk_cell_renderer_get_preferred_height
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# minimum_size 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# natural_size 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_get_preferred_height(self: ptr TCellRenderer, widget: ptr TWidget, minimum_size: ptr int32, natural_size: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_preferred_height".}
proc get_preferred_height*(self: CellRenderer, widget: Widget, minimum_size: var int32, natural_size: var int32) {.inline.} =
  gtk_cell_renderer_get_preferred_height(self, widget.getPointer, addr(minimum_size), addr(natural_size))
# tuple-return
# minimum_size: var int32
# natural_size: var int32
# proc get_preferred_height*(self: CellRenderer, widget: Widget) {.inline.} =

# gtk_cell_renderer_get_preferred_height_for_width
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# width 'int32' 'int32' IN
# minimum_height 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# natural_height 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_get_preferred_height_for_width(self: ptr TCellRenderer, widget: ptr TWidget, width: int32, minimum_height: ptr int32, natural_height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_preferred_height_for_width".}
proc get_preferred_height_for_width*(self: CellRenderer, widget: Widget, width: int32, minimum_height: var int32, natural_height: var int32) {.inline.} =
  gtk_cell_renderer_get_preferred_height_for_width(self, widget.getPointer, width, addr(minimum_height), addr(natural_height))
# tuple-return
# minimum_height: var int32
# natural_height: var int32
# proc get_preferred_height_for_width*(self: CellRenderer, widget: Widget, width: int32) {.inline.} =

# gtk_cell_renderer_get_preferred_size
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# minimum_size 'var TRequisition' 'ptr TRequisition' OUT (diff., need sugar) caller-allocates optional
# natural_size 'var TRequisition' 'ptr TRequisition' OUT (diff., need sugar) caller-allocates optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_get_preferred_size(self: ptr TCellRenderer, widget: ptr TWidget, minimum_size: ptr TRequisition, natural_size: ptr TRequisition) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_preferred_size".}
proc get_preferred_size*(self: CellRenderer, widget: Widget, minimum_size: var TRequisition, natural_size: var TRequisition) {.inline.} =
  gtk_cell_renderer_get_preferred_size(self, widget.getPointer, addr(minimum_size), addr(natural_size))
# tuple-return
# minimum_size: var TRequisition
# natural_size: var TRequisition
# proc get_preferred_size*(self: CellRenderer, widget: Widget) {.inline.} =

# gtk_cell_renderer_get_preferred_width
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# minimum_size 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# natural_size 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_get_preferred_width(self: ptr TCellRenderer, widget: ptr TWidget, minimum_size: ptr int32, natural_size: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_preferred_width".}
proc get_preferred_width*(self: CellRenderer, widget: Widget, minimum_size: var int32, natural_size: var int32) {.inline.} =
  gtk_cell_renderer_get_preferred_width(self, widget.getPointer, addr(minimum_size), addr(natural_size))
# tuple-return
# minimum_size: var int32
# natural_size: var int32
# proc get_preferred_width*(self: CellRenderer, widget: Widget) {.inline.} =

# gtk_cell_renderer_get_preferred_width_for_height
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# height 'int32' 'int32' IN
# minimum_width 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# natural_width 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_get_preferred_width_for_height(self: ptr TCellRenderer, widget: ptr TWidget, height: int32, minimum_width: ptr int32, natural_width: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_preferred_width_for_height".}
proc get_preferred_width_for_height*(self: CellRenderer, widget: Widget, height: int32, minimum_width: var int32, natural_width: var int32) {.inline.} =
  gtk_cell_renderer_get_preferred_width_for_height(self, widget.getPointer, height, addr(minimum_width), addr(natural_width))
# tuple-return
# minimum_width: var int32
# natural_width: var int32
# proc get_preferred_width_for_height*(self: CellRenderer, widget: Widget, height: int32) {.inline.} =

# gtk_cell_renderer_get_request_mode
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# 'SizeRequestMode' 'SizeRequestMode'
proc gtk_cell_renderer_get_request_mode(self: ptr TCellRenderer): SizeRequestMode {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_request_mode".}
proc get_request_mode*(self: CellRenderer): SizeRequestMode {.inline.} =
  gtk_cell_renderer_get_request_mode(self)
# proc get_request_mode*(self: CellRenderer): SizeRequestMode {.inline.} =

# gtk_cell_renderer_get_sensitive
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# 'bool' 'bool'
proc gtk_cell_renderer_get_sensitive(self: ptr TCellRenderer): bool {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_sensitive".}
proc get_sensitive*(self: CellRenderer): bool {.inline.} =
  gtk_cell_renderer_get_sensitive(self)
# proc get_sensitive*(self: CellRenderer): bool {.inline.} =

# gtk_cell_renderer_get_size
# flags: {isMethod} container: CellRenderer (deprecated)
# gtk_cell_renderer_get_state
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# cell_state 'SCellRendererState' 'SCellRendererState' IN
# 'SStateFlags' 'SStateFlags'
proc gtk_cell_renderer_get_state(self: ptr TCellRenderer, widget: ptr TWidget, cell_state: SCellRendererState): SStateFlags {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_state".}
proc get_state*(self: CellRenderer, widget: Widget, cell_state: SCellRendererState): SStateFlags {.inline.} =
  gtk_cell_renderer_get_state(self, widget.getPointer, cell_state)
# proc get_state*(self: CellRenderer, widget: Widget, cell_state: SCellRendererState): SStateFlags {.inline.} =

# gtk_cell_renderer_get_visible
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# 'bool' 'bool'
proc gtk_cell_renderer_get_visible(self: ptr TCellRenderer): bool {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_visible".}
proc get_visible*(self: CellRenderer): bool {.inline.} =
  gtk_cell_renderer_get_visible(self)
# proc get_visible*(self: CellRenderer): bool {.inline.} =

# gtk_cell_renderer_is_activatable
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# 'bool' 'bool'
proc gtk_cell_renderer_is_activatable(self: ptr TCellRenderer): bool {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_is_activatable".}
proc is_activatable*(self: CellRenderer): bool {.inline.} =
  gtk_cell_renderer_is_activatable(self)
# proc is_activatable*(self: CellRenderer): bool {.inline.} =

# gtk_cell_renderer_render
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# cr 'cairo1.TContext' 'ptr cairo1.TContext' IN (diff., need sugar)
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# background_area 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# cell_area 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# flags 'SCellRendererState' 'SCellRendererState' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_render(self: ptr TCellRenderer, cr: ptr cairo1.TContext, widget: ptr TWidget, background_area: ptr cairo1.TRectangleInt, cell_area: ptr cairo1.TRectangleInt, flags: SCellRendererState) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_render".}
proc render*(self: CellRenderer, cr: cairo1.TContext, widget: Widget, background_area: cairo1.TRectangleInt, cell_area: cairo1.TRectangleInt, flags: SCellRendererState) {.inline.} =
  gtk_cell_renderer_render(self, myUnsafeAddr(cr), widget.getPointer, myUnsafeAddr(background_area), myUnsafeAddr(cell_area), flags)
# proc render*(self: CellRenderer, cr: cairo1.TContext, widget: Widget, background_area: cairo1.TRectangleInt, cell_area: cairo1.TRectangleInt, flags: SCellRendererState) {.inline.} =

# gtk_cell_renderer_set_alignment
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# xalign 'float32' 'float32' IN
# yalign 'float32' 'float32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_set_alignment(self: ptr TCellRenderer, xalign: float32, yalign: float32) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_set_alignment".}
proc set_alignment*(self: CellRenderer, xalign: float32, yalign: float32) {.inline.} =
  gtk_cell_renderer_set_alignment(self, xalign, yalign)
# proc set_alignment*(self: CellRenderer, xalign: float32, yalign: float32) {.inline.} =

# gtk_cell_renderer_set_fixed_size
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# width 'int32' 'int32' IN
# height 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_set_fixed_size(self: ptr TCellRenderer, width: int32, height: int32) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_set_fixed_size".}
proc set_fixed_size*(self: CellRenderer, width: int32, height: int32) {.inline.} =
  gtk_cell_renderer_set_fixed_size(self, width, height)
# proc set_fixed_size*(self: CellRenderer, width: int32, height: int32) {.inline.} =

# gtk_cell_renderer_set_padding
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# xpad 'int32' 'int32' IN
# ypad 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_set_padding(self: ptr TCellRenderer, xpad: int32, ypad: int32) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_set_padding".}
proc set_padding*(self: CellRenderer, xpad: int32, ypad: int32) {.inline.} =
  gtk_cell_renderer_set_padding(self, xpad, ypad)
# proc set_padding*(self: CellRenderer, xpad: int32, ypad: int32) {.inline.} =

# gtk_cell_renderer_set_sensitive
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# sensitive 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_set_sensitive(self: ptr TCellRenderer, sensitive: bool) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_set_sensitive".}
proc set_sensitive*(self: CellRenderer, sensitive: bool) {.inline.} =
  gtk_cell_renderer_set_sensitive(self, sensitive)
# proc set_sensitive*(self: CellRenderer, sensitive: bool) {.inline.} =

# gtk_cell_renderer_set_visible
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# visible 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_set_visible(self: ptr TCellRenderer, visible: bool) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_set_visible".}
proc set_visible*(self: CellRenderer, visible: bool) {.inline.} =
  gtk_cell_renderer_set_visible(self, visible)
# proc set_visible*(self: CellRenderer, visible: bool) {.inline.} =

# gtk_cell_renderer_start_editing
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# event 'Gdk3.TEvent' 'ptr Gdk3.TEvent' IN (diff., need sugar)
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# path 'ustring' 'ucstring' IN (diff., need sugar)
# background_area 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# cell_area 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# flags 'SCellRendererState' 'SCellRendererState' IN
# 'CellEditable' 'TransferNone[TCellEditable]' (diff., need sugar)
proc gtk_cell_renderer_start_editing(self: ptr TCellRenderer, event: ptr Gdk3.TEvent, widget: ptr TWidget, path: ucstring, background_area: ptr cairo1.TRectangleInt, cell_area: ptr cairo1.TRectangleInt, flags: SCellRendererState): TransferNone[TCellEditable] {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_start_editing".}
proc start_editing*(self: CellRenderer, event: Gdk3.TEvent, widget: Widget, path: ustring, background_area: cairo1.TRectangleInt, cell_area: cairo1.TRectangleInt, flags: SCellRendererState): CellEditable {.inline.} =
  wrap(gtk_cell_renderer_start_editing(self, myUnsafeAddr(event), widget.getPointer, ucstring(path), myUnsafeAddr(background_area), myUnsafeAddr(cell_area), flags))
# proc start_editing*(self: CellRenderer, event: Gdk3.TEvent, widget: Widget, path: ustring, background_area: cairo1.TRectangleInt, cell_area: cairo1.TRectangleInt, flags: SCellRendererState): CellEditable {.inline.} =

# gtk_cell_renderer_stop_editing
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# canceled 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_stop_editing(self: ptr TCellRenderer, canceled: bool) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_stop_editing".}
proc stop_editing*(self: CellRenderer, canceled: bool) {.inline.} =
  gtk_cell_renderer_stop_editing(self, canceled)
# proc stop_editing*(self: CellRenderer, canceled: bool) {.inline.} =

# gtk_cell_renderer_accel_new
# flags: {isConstructor} container: CellRendererAccel
# need sugar: is static method
# 'CellRendererAccel' 'TransferNone[TCellRendererAccel]' (diff., need sugar)
proc gtk_cell_renderer_accel_new(): TransferNone[TCellRendererAccel] {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_accel_new".}
proc new_cellrendereraccel*(): CellRendererAccel {.inline.} =
  wrap(gtk_cell_renderer_accel_new())
# proc new_cellrendereraccel*(): CellRendererAccel {.inline.} =

# gtk_cell_renderer_combo_new
# flags: {isConstructor} container: CellRendererCombo
# need sugar: is static method
# 'CellRendererCombo' 'TransferNone[TCellRendererCombo]' (diff., need sugar)
proc gtk_cell_renderer_combo_new(): TransferNone[TCellRendererCombo] {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_combo_new".}
proc new_cellrenderercombo*(): CellRendererCombo {.inline.} =
  wrap(gtk_cell_renderer_combo_new())
# proc new_cellrenderercombo*(): CellRendererCombo {.inline.} =

# gtk_cell_renderer_pixbuf_new
# flags: {isConstructor} container: CellRendererPixbuf
# need sugar: is static method
# 'CellRendererPixbuf' 'TransferNone[TCellRendererPixbuf]' (diff., need sugar)
proc gtk_cell_renderer_pixbuf_new(): TransferNone[TCellRendererPixbuf] {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_pixbuf_new".}
proc new_cellrendererpixbuf*(): CellRendererPixbuf {.inline.} =
  wrap(gtk_cell_renderer_pixbuf_new())
# proc new_cellrendererpixbuf*(): CellRendererPixbuf {.inline.} =

# gtk_cell_renderer_progress_new
# flags: {isConstructor} container: CellRendererProgress
# need sugar: is static method
# 'CellRendererProgress' 'TransferNone[TCellRendererProgress]' (diff., need sugar)
proc gtk_cell_renderer_progress_new(): TransferNone[TCellRendererProgress] {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_progress_new".}
proc new_cellrendererprogress*(): CellRendererProgress {.inline.} =
  wrap(gtk_cell_renderer_progress_new())
# proc new_cellrendererprogress*(): CellRendererProgress {.inline.} =

# gtk_cell_renderer_spin_new
# flags: {isConstructor} container: CellRendererSpin
# need sugar: is static method
# 'CellRendererSpin' 'TransferNone[TCellRendererSpin]' (diff., need sugar)
proc gtk_cell_renderer_spin_new(): TransferNone[TCellRendererSpin] {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_spin_new".}
proc new_cellrendererspin*(): CellRendererSpin {.inline.} =
  wrap(gtk_cell_renderer_spin_new())
# proc new_cellrendererspin*(): CellRendererSpin {.inline.} =

# gtk_cell_renderer_spinner_new
# flags: {isConstructor} container: CellRendererSpinner
# need sugar: is static method
# 'CellRendererSpinner' 'TransferNone[TCellRendererSpinner]' (diff., need sugar)
proc gtk_cell_renderer_spinner_new(): TransferNone[TCellRendererSpinner] {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_spinner_new".}
proc new_cellrendererspinner*(): CellRendererSpinner {.inline.} =
  wrap(gtk_cell_renderer_spinner_new())
# proc new_cellrendererspinner*(): CellRendererSpinner {.inline.} =

# gtk_cell_renderer_text_new
# flags: {isConstructor} container: CellRendererText
# need sugar: is static method
# 'CellRendererText' 'TransferNone[TCellRendererText]' (diff., need sugar)
proc gtk_cell_renderer_text_new(): TransferNone[TCellRendererText] {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_text_new".}
proc new_cellrenderertext*(): CellRendererText {.inline.} =
  wrap(gtk_cell_renderer_text_new())
# proc new_cellrenderertext*(): CellRendererText {.inline.} =

# gtk_cell_renderer_text_set_fixed_height_from_font
# flags: {isMethod} container: CellRendererText
# need sugar: is method
# number_of_rows 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_text_set_fixed_height_from_font(self: ptr TCellRendererText, number_of_rows: int32) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_text_set_fixed_height_from_font".}
proc set_fixed_height_from_font*(self: CellRendererText, number_of_rows: int32) {.inline.} =
  gtk_cell_renderer_text_set_fixed_height_from_font(self, number_of_rows)
# proc set_fixed_height_from_font*(self: CellRendererText, number_of_rows: int32) {.inline.} =

# gtk_cell_renderer_toggle_new
# flags: {isConstructor} container: CellRendererToggle
# need sugar: is static method
# 'CellRendererToggle' 'TransferNone[TCellRendererToggle]' (diff., need sugar)
proc gtk_cell_renderer_toggle_new(): TransferNone[TCellRendererToggle] {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_toggle_new".}
proc new_cellrenderertoggle*(): CellRendererToggle {.inline.} =
  wrap(gtk_cell_renderer_toggle_new())
# proc new_cellrenderertoggle*(): CellRendererToggle {.inline.} =

# gtk_cell_renderer_toggle_get_activatable
# flags: {isMethod} container: CellRendererToggle
# need sugar: is method
# 'bool' 'bool'
proc gtk_cell_renderer_toggle_get_activatable(self: ptr TCellRendererToggle): bool {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_toggle_get_activatable".}
proc get_activatable*(self: CellRendererToggle): bool {.inline.} =
  gtk_cell_renderer_toggle_get_activatable(self)
# proc get_activatable*(self: CellRendererToggle): bool {.inline.} =

# gtk_cell_renderer_toggle_get_active
# flags: {isMethod} container: CellRendererToggle
# need sugar: is method
# 'bool' 'bool'
proc gtk_cell_renderer_toggle_get_active(self: ptr TCellRendererToggle): bool {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_toggle_get_active".}
proc get_active*(self: CellRendererToggle): bool {.inline.} =
  gtk_cell_renderer_toggle_get_active(self)
# proc get_active*(self: CellRendererToggle): bool {.inline.} =

# gtk_cell_renderer_toggle_get_radio
# flags: {isMethod} container: CellRendererToggle
# need sugar: is method
# 'bool' 'bool'
proc gtk_cell_renderer_toggle_get_radio(self: ptr TCellRendererToggle): bool {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_toggle_get_radio".}
proc get_radio*(self: CellRendererToggle): bool {.inline.} =
  gtk_cell_renderer_toggle_get_radio(self)
# proc get_radio*(self: CellRendererToggle): bool {.inline.} =

# gtk_cell_renderer_toggle_set_activatable
# flags: {isMethod} container: CellRendererToggle
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_toggle_set_activatable(self: ptr TCellRendererToggle, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_toggle_set_activatable".}
proc set_activatable*(self: CellRendererToggle, setting: bool) {.inline.} =
  gtk_cell_renderer_toggle_set_activatable(self, setting)
# proc set_activatable*(self: CellRendererToggle, setting: bool) {.inline.} =

# gtk_cell_renderer_toggle_set_active
# flags: {isMethod} container: CellRendererToggle
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_toggle_set_active(self: ptr TCellRendererToggle, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_toggle_set_active".}
proc set_active*(self: CellRendererToggle, setting: bool) {.inline.} =
  gtk_cell_renderer_toggle_set_active(self, setting)
# proc set_active*(self: CellRendererToggle, setting: bool) {.inline.} =

# gtk_cell_renderer_toggle_set_radio
# flags: {isMethod} container: CellRendererToggle
# need sugar: is method
# radio 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_toggle_set_radio(self: ptr TCellRendererToggle, radio: bool) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_toggle_set_radio".}
proc set_radio*(self: CellRendererToggle, radio: bool) {.inline.} =
  gtk_cell_renderer_toggle_set_radio(self, radio)
# proc set_radio*(self: CellRendererToggle, radio: bool) {.inline.} =

# gtk_cell_view_new
# flags: {isConstructor} container: CellView
# need sugar: is static method
# 'CellView' 'TransferNone[TCellView]' (diff., need sugar)
proc gtk_cell_view_new(): TransferNone[TCellView] {.cdecl, dynlib: lib, importc: "gtk_cell_view_new".}
proc new_cellview*(): CellView {.inline.} =
  wrap(gtk_cell_view_new())
# proc new_cellview*(): CellView {.inline.} =

# gtk_cell_view_new_with_context
# flags: {isConstructor} container: CellView
# need sugar: is static method
# area 'CellArea' 'ptr TCellArea' IN (diff., need sugar)
# context 'CellAreaContext' 'ptr TCellAreaContext' IN (diff., need sugar)
# 'CellView' 'TransferNone[TCellView]' (diff., need sugar)
proc gtk_cell_view_new_with_context(area: ptr TCellArea, context: ptr TCellAreaContext): TransferNone[TCellView] {.cdecl, dynlib: lib, importc: "gtk_cell_view_new_with_context".}
proc new_cellview_with_context*(area: CellArea, context: CellAreaContext): CellView {.inline.} =
  wrap(gtk_cell_view_new_with_context(area.getPointer, context.getPointer))
# proc new_cellview_with_context*(area: CellArea, context: CellAreaContext): CellView {.inline.} =

# gtk_cell_view_new_with_markup
# flags: {isConstructor} container: CellView
# need sugar: is static method
# markup 'ustring' 'ucstring' IN (diff., need sugar)
# 'CellView' 'TransferNone[TCellView]' (diff., need sugar)
proc gtk_cell_view_new_with_markup(markup: ucstring): TransferNone[TCellView] {.cdecl, dynlib: lib, importc: "gtk_cell_view_new_with_markup".}
proc new_cellview_with_markup*(markup: ustring): CellView {.inline.} =
  wrap(gtk_cell_view_new_with_markup(ucstring(markup)))
# proc new_cellview_with_markup*(markup: ustring): CellView {.inline.} =

# gtk_cell_view_new_with_pixbuf
# flags: {isConstructor} container: CellView
# need sugar: is static method
# pixbuf 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# 'CellView' 'TransferNone[TCellView]' (diff., need sugar)
proc gtk_cell_view_new_with_pixbuf(pixbuf: ptr GdkPixbuf2.TPixbuf): TransferNone[TCellView] {.cdecl, dynlib: lib, importc: "gtk_cell_view_new_with_pixbuf".}
proc new_cellview_with_pixbuf*(pixbuf: GdkPixbuf2.Pixbuf): CellView {.inline.} =
  wrap(gtk_cell_view_new_with_pixbuf(pixbuf.getPointer))
# proc new_cellview_with_pixbuf*(pixbuf: GdkPixbuf2.Pixbuf): CellView {.inline.} =

# gtk_cell_view_new_with_text
# flags: {isConstructor} container: CellView
# need sugar: is static method
# text 'ustring' 'ucstring' IN (diff., need sugar)
# 'CellView' 'TransferNone[TCellView]' (diff., need sugar)
proc gtk_cell_view_new_with_text(text: ucstring): TransferNone[TCellView] {.cdecl, dynlib: lib, importc: "gtk_cell_view_new_with_text".}
proc new_cellview_with_text*(text: ustring): CellView {.inline.} =
  wrap(gtk_cell_view_new_with_text(ucstring(text)))
# proc new_cellview_with_text*(text: ustring): CellView {.inline.} =

# gtk_cell_view_get_displayed_row
# flags: {isMethod} container: CellView
# need sugar: is method
# 'TTreePath' 'ptr TTreePath' (diff., need sugar)
proc gtk_cell_view_get_displayed_row(self: ptr TCellView): ptr TTreePath {.cdecl, dynlib: lib, importc: "gtk_cell_view_get_displayed_row".}
proc get_displayed_row*(self: CellView): TTreePath {.inline.} =
  (gtk_cell_view_get_displayed_row(self))[]
# proc get_displayed_row*(self: CellView): TTreePath {.inline.} =

# gtk_cell_view_get_draw_sensitive
# flags: {isMethod} container: CellView
# need sugar: is method
# 'bool' 'bool'
proc gtk_cell_view_get_draw_sensitive(self: ptr TCellView): bool {.cdecl, dynlib: lib, importc: "gtk_cell_view_get_draw_sensitive".}
proc get_draw_sensitive*(self: CellView): bool {.inline.} =
  gtk_cell_view_get_draw_sensitive(self)
# proc get_draw_sensitive*(self: CellView): bool {.inline.} =

# gtk_cell_view_get_fit_model
# flags: {isMethod} container: CellView
# need sugar: is method
# 'bool' 'bool'
proc gtk_cell_view_get_fit_model(self: ptr TCellView): bool {.cdecl, dynlib: lib, importc: "gtk_cell_view_get_fit_model".}
proc get_fit_model*(self: CellView): bool {.inline.} =
  gtk_cell_view_get_fit_model(self)
# proc get_fit_model*(self: CellView): bool {.inline.} =

# gtk_cell_view_get_model
# flags: {isMethod} container: CellView
# need sugar: is method
# 'TreeModel' 'TransferNone[TTreeModel]' (diff., need sugar)
proc gtk_cell_view_get_model(self: ptr TCellView): TransferNone[TTreeModel] {.cdecl, dynlib: lib, importc: "gtk_cell_view_get_model".}
proc get_model*(self: CellView): TreeModel {.inline.} =
  wrap(gtk_cell_view_get_model(self))
# proc get_model*(self: CellView): TreeModel {.inline.} =

# gtk_cell_view_get_size_of_row
# flags: {isMethod} container: CellView (deprecated)
# gtk_cell_view_set_background_color
# flags: {isMethod} container: CellView (deprecated)
# gtk_cell_view_set_background_rgba
# flags: {isMethod} container: CellView
# need sugar: is method
# rgba 'Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_view_set_background_rgba(self: ptr TCellView, rgba: ptr Gdk3.TRGBA) {.cdecl, dynlib: lib, importc: "gtk_cell_view_set_background_rgba".}
proc set_background_rgba*(self: CellView, rgba: Gdk3.TRGBA) {.inline.} =
  gtk_cell_view_set_background_rgba(self, myUnsafeAddr(rgba))
# proc set_background_rgba*(self: CellView, rgba: Gdk3.TRGBA) {.inline.} =

# gtk_cell_view_set_displayed_row
# flags: {isMethod} container: CellView
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_view_set_displayed_row(self: ptr TCellView, path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_cell_view_set_displayed_row".}
proc set_displayed_row*(self: CellView, path: TTreePath) {.inline.} =
  gtk_cell_view_set_displayed_row(self, myUnsafeAddr(path))
# proc set_displayed_row*(self: CellView, path: TTreePath) {.inline.} =

# gtk_cell_view_set_draw_sensitive
# flags: {isMethod} container: CellView
# need sugar: is method
# draw_sensitive 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_view_set_draw_sensitive(self: ptr TCellView, draw_sensitive: bool) {.cdecl, dynlib: lib, importc: "gtk_cell_view_set_draw_sensitive".}
proc set_draw_sensitive*(self: CellView, draw_sensitive: bool) {.inline.} =
  gtk_cell_view_set_draw_sensitive(self, draw_sensitive)
# proc set_draw_sensitive*(self: CellView, draw_sensitive: bool) {.inline.} =

# gtk_cell_view_set_fit_model
# flags: {isMethod} container: CellView
# need sugar: is method
# fit_model 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_view_set_fit_model(self: ptr TCellView, fit_model: bool) {.cdecl, dynlib: lib, importc: "gtk_cell_view_set_fit_model".}
proc set_fit_model*(self: CellView, fit_model: bool) {.inline.} =
  gtk_cell_view_set_fit_model(self, fit_model)
# proc set_fit_model*(self: CellView, fit_model: bool) {.inline.} =

# gtk_cell_view_set_model
# flags: {isMethod} container: CellView
# need sugar: is method
# model 'TreeModel' 'ptr TTreeModel' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_view_set_model(self: ptr TCellView, model: ptr TTreeModel) {.cdecl, dynlib: lib, importc: "gtk_cell_view_set_model".}
proc set_model*(self: CellView, model: TreeModel) {.inline.} =
  gtk_cell_view_set_model(self, unwrap(model))
# proc set_model*(self: CellView, model: TreeModel) {.inline.} =

# gtk_check_button_new
# flags: {isConstructor} container: CheckButton
# need sugar: is static method
# 'CheckButton' 'TransferNone[TCheckButton]' (diff., need sugar)
proc gtk_check_button_new(): TransferNone[TCheckButton] {.cdecl, dynlib: lib, importc: "gtk_check_button_new".}
proc new_checkbutton*(): CheckButton {.inline.} =
  wrap(gtk_check_button_new())
# proc new_checkbutton*(): CheckButton {.inline.} =

# gtk_check_button_new_with_label
# flags: {isConstructor} container: CheckButton
# need sugar: is static method
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'CheckButton' 'TransferNone[TCheckButton]' (diff., need sugar)
proc gtk_check_button_new_with_label(label: ucstring): TransferNone[TCheckButton] {.cdecl, dynlib: lib, importc: "gtk_check_button_new_with_label".}
proc new_checkbutton_with_label*(label: ustring): CheckButton {.inline.} =
  wrap(gtk_check_button_new_with_label(ucstring(label)))
# proc new_checkbutton_with_label*(label: ustring): CheckButton {.inline.} =

# gtk_check_button_new_with_mnemonic
# flags: {isConstructor} container: CheckButton
# need sugar: is static method
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'CheckButton' 'TransferNone[TCheckButton]' (diff., need sugar)
proc gtk_check_button_new_with_mnemonic(label: ucstring): TransferNone[TCheckButton] {.cdecl, dynlib: lib, importc: "gtk_check_button_new_with_mnemonic".}
proc new_checkbutton_with_mnemonic*(label: ustring): CheckButton {.inline.} =
  wrap(gtk_check_button_new_with_mnemonic(ucstring(label)))
# proc new_checkbutton_with_mnemonic*(label: ustring): CheckButton {.inline.} =

# gtk_check_menu_item_new
# flags: {isConstructor} container: CheckMenuItem
# need sugar: is static method
# 'CheckMenuItem' 'TransferNone[TCheckMenuItem]' (diff., need sugar)
proc gtk_check_menu_item_new(): TransferNone[TCheckMenuItem] {.cdecl, dynlib: lib, importc: "gtk_check_menu_item_new".}
proc new_checkmenuitem*(): CheckMenuItem {.inline.} =
  wrap(gtk_check_menu_item_new())
# proc new_checkmenuitem*(): CheckMenuItem {.inline.} =

# gtk_check_menu_item_new_with_label
# flags: {isConstructor} container: CheckMenuItem
# need sugar: is static method
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'CheckMenuItem' 'TransferNone[TCheckMenuItem]' (diff., need sugar)
proc gtk_check_menu_item_new_with_label(label: ucstring): TransferNone[TCheckMenuItem] {.cdecl, dynlib: lib, importc: "gtk_check_menu_item_new_with_label".}
proc new_checkmenuitem_with_label*(label: ustring): CheckMenuItem {.inline.} =
  wrap(gtk_check_menu_item_new_with_label(ucstring(label)))
# proc new_checkmenuitem_with_label*(label: ustring): CheckMenuItem {.inline.} =

# gtk_check_menu_item_new_with_mnemonic
# flags: {isConstructor} container: CheckMenuItem
# need sugar: is static method
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'CheckMenuItem' 'TransferNone[TCheckMenuItem]' (diff., need sugar)
proc gtk_check_menu_item_new_with_mnemonic(label: ucstring): TransferNone[TCheckMenuItem] {.cdecl, dynlib: lib, importc: "gtk_check_menu_item_new_with_mnemonic".}
proc new_checkmenuitem_with_mnemonic*(label: ustring): CheckMenuItem {.inline.} =
  wrap(gtk_check_menu_item_new_with_mnemonic(ucstring(label)))
# proc new_checkmenuitem_with_mnemonic*(label: ustring): CheckMenuItem {.inline.} =

# gtk_check_menu_item_get_active
# flags: {isMethod} container: CheckMenuItem
# need sugar: is method
# 'bool' 'bool'
proc gtk_check_menu_item_get_active(self: ptr TCheckMenuItem): bool {.cdecl, dynlib: lib, importc: "gtk_check_menu_item_get_active".}
proc get_active*(self: CheckMenuItem): bool {.inline.} =
  gtk_check_menu_item_get_active(self)
# proc get_active*(self: CheckMenuItem): bool {.inline.} =

# gtk_check_menu_item_get_draw_as_radio
# flags: {isMethod} container: CheckMenuItem
# need sugar: is method
# 'bool' 'bool'
proc gtk_check_menu_item_get_draw_as_radio(self: ptr TCheckMenuItem): bool {.cdecl, dynlib: lib, importc: "gtk_check_menu_item_get_draw_as_radio".}
proc get_draw_as_radio*(self: CheckMenuItem): bool {.inline.} =
  gtk_check_menu_item_get_draw_as_radio(self)
# proc get_draw_as_radio*(self: CheckMenuItem): bool {.inline.} =

# gtk_check_menu_item_get_inconsistent
# flags: {isMethod} container: CheckMenuItem
# need sugar: is method
# 'bool' 'bool'
proc gtk_check_menu_item_get_inconsistent(self: ptr TCheckMenuItem): bool {.cdecl, dynlib: lib, importc: "gtk_check_menu_item_get_inconsistent".}
proc get_inconsistent*(self: CheckMenuItem): bool {.inline.} =
  gtk_check_menu_item_get_inconsistent(self)
# proc get_inconsistent*(self: CheckMenuItem): bool {.inline.} =

# gtk_check_menu_item_set_active
# flags: {isMethod} container: CheckMenuItem
# need sugar: is method
# is_active 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_check_menu_item_set_active(self: ptr TCheckMenuItem, is_active: bool) {.cdecl, dynlib: lib, importc: "gtk_check_menu_item_set_active".}
proc set_active*(self: CheckMenuItem, is_active: bool) {.inline.} =
  gtk_check_menu_item_set_active(self, is_active)
# proc set_active*(self: CheckMenuItem, is_active: bool) {.inline.} =

# gtk_check_menu_item_set_draw_as_radio
# flags: {isMethod} container: CheckMenuItem
# need sugar: is method
# draw_as_radio 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_check_menu_item_set_draw_as_radio(self: ptr TCheckMenuItem, draw_as_radio: bool) {.cdecl, dynlib: lib, importc: "gtk_check_menu_item_set_draw_as_radio".}
proc set_draw_as_radio*(self: CheckMenuItem, draw_as_radio: bool) {.inline.} =
  gtk_check_menu_item_set_draw_as_radio(self, draw_as_radio)
# proc set_draw_as_radio*(self: CheckMenuItem, draw_as_radio: bool) {.inline.} =

# gtk_check_menu_item_set_inconsistent
# flags: {isMethod} container: CheckMenuItem
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_check_menu_item_set_inconsistent(self: ptr TCheckMenuItem, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_check_menu_item_set_inconsistent".}
proc set_inconsistent*(self: CheckMenuItem, setting: bool) {.inline.} =
  gtk_check_menu_item_set_inconsistent(self, setting)
# proc set_inconsistent*(self: CheckMenuItem, setting: bool) {.inline.} =

# gtk_check_menu_item_toggled
# flags: {isMethod} container: CheckMenuItem
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_check_menu_item_toggled(self: ptr TCheckMenuItem) {.cdecl, dynlib: lib, importc: "gtk_check_menu_item_toggled".}
proc toggled*(self: CheckMenuItem) {.inline.} =
  gtk_check_menu_item_toggled(self)
# proc toggled*(self: CheckMenuItem) {.inline.} =

# gtk_clipboard_get
# flags: {} container: Clipboard
# need sugar: is static method
# selection 'Gdk3.TAtom' 'ptr Gdk3.TAtom' IN (diff., need sugar)
# 'Clipboard' 'TransferNone[TClipboard]' (diff., need sugar)
proc gtk_clipboard_get(selection: ptr Gdk3.TAtom): TransferNone[TClipboard] {.cdecl, dynlib: lib, importc: "gtk_clipboard_get".}
template get*(klass_parameter: typedesc[Clipboard], selection: Gdk3.TAtom): Clipboard =
  wrap(gtk_clipboard_get(myUnsafeAddr(selection)))
# template get*(klass_parameter: typedesc[Clipboard], selection: Gdk3.TAtom): Clipboard =

# gtk_clipboard_get_for_display
# flags: {} container: Clipboard
# need sugar: is static method
# display 'Gdk3.Display' 'ptr Gdk3.TDisplay' IN (diff., need sugar)
# selection 'Gdk3.TAtom' 'ptr Gdk3.TAtom' IN (diff., need sugar)
# 'Clipboard' 'TransferNone[TClipboard]' (diff., need sugar)
proc gtk_clipboard_get_for_display(display: ptr Gdk3.TDisplay, selection: ptr Gdk3.TAtom): TransferNone[TClipboard] {.cdecl, dynlib: lib, importc: "gtk_clipboard_get_for_display".}
template get_for_display*(klass_parameter: typedesc[Clipboard], display: Gdk3.Display, selection: Gdk3.TAtom): Clipboard =
  wrap(gtk_clipboard_get_for_display(display.getPointer, myUnsafeAddr(selection)))
# template get_for_display*(klass_parameter: typedesc[Clipboard], display: Gdk3.Display, selection: Gdk3.TAtom): Clipboard =

# gtk_clipboard_clear
# flags: {isMethod} container: Clipboard
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_clipboard_clear(self: ptr TClipboard) {.cdecl, dynlib: lib, importc: "gtk_clipboard_clear".}
proc clear*(self: Clipboard) {.inline.} =
  gtk_clipboard_clear(self)
# proc clear*(self: Clipboard) {.inline.} =

# gtk_clipboard_get_display
# flags: {isMethod} container: Clipboard
# need sugar: is method
# 'Gdk3.Display' 'TransferNone[Gdk3.TDisplay]' (diff., need sugar)
proc gtk_clipboard_get_display(self: ptr TClipboard): TransferNone[Gdk3.TDisplay] {.cdecl, dynlib: lib, importc: "gtk_clipboard_get_display".}
proc get_display*(self: Clipboard): Gdk3.Display {.inline.} =
  wrap(gtk_clipboard_get_display(self))
# proc get_display*(self: Clipboard): Gdk3.Display {.inline.} =

# gtk_clipboard_get_owner
# flags: {isMethod} container: Clipboard
# need sugar: is method
# 'GObject2.Object' 'TransferNone[GObject2.TObject]' (diff., need sugar)
proc gtk_clipboard_get_owner(self: ptr TClipboard): TransferNone[GObject2.TObject] {.cdecl, dynlib: lib, importc: "gtk_clipboard_get_owner".}
proc get_owner*(self: Clipboard): GObject2.Object {.inline.} =
  wrap(gtk_clipboard_get_owner(self))
# proc get_owner*(self: Clipboard): GObject2.Object {.inline.} =

# gtk_clipboard_request_contents
# flags: {isMethod} container: Clipboard
# need sugar: is method
# target 'Gdk3.TAtom' 'ptr Gdk3.TAtom' IN (diff., need sugar)
# callback 'pointer' 'pointer' IN
# user_data 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_clipboard_request_contents(self: ptr TClipboard, target: ptr Gdk3.TAtom, callback: pointer, user_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_clipboard_request_contents".}
proc request_contents*(self: Clipboard, target: Gdk3.TAtom, callback: pointer, user_data: pointer) {.inline.} =
  gtk_clipboard_request_contents(self, myUnsafeAddr(target), callback, user_data)
# proc request_contents*(self: Clipboard, target: Gdk3.TAtom, callback: pointer, user_data: pointer) {.inline.} =

# gtk_clipboard_request_image
# flags: {isMethod} container: Clipboard
# need sugar: is method
# callback 'pointer' 'pointer' IN
# user_data 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_clipboard_request_image(self: ptr TClipboard, callback: pointer, user_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_clipboard_request_image".}
proc request_image*(self: Clipboard, callback: pointer, user_data: pointer) {.inline.} =
  gtk_clipboard_request_image(self, callback, user_data)
# proc request_image*(self: Clipboard, callback: pointer, user_data: pointer) {.inline.} =

# gtk_clipboard_request_rich_text
# flags: {isMethod} container: Clipboard
# need sugar: is method
# buffer 'TextBuffer' 'ptr TTextBuffer' IN (diff., need sugar)
# callback 'pointer' 'pointer' IN
# user_data 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_clipboard_request_rich_text(self: ptr TClipboard, buffer: ptr TTextBuffer, callback: pointer, user_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_clipboard_request_rich_text".}
proc request_rich_text*(self: Clipboard, buffer: TextBuffer, callback: pointer, user_data: pointer) {.inline.} =
  gtk_clipboard_request_rich_text(self, buffer.getPointer, callback, user_data)
# proc request_rich_text*(self: Clipboard, buffer: TextBuffer, callback: pointer, user_data: pointer) {.inline.} =

# gtk_clipboard_request_targets
# flags: {isMethod} container: Clipboard
# need sugar: is method
# callback 'pointer' 'pointer' IN
# user_data 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_clipboard_request_targets(self: ptr TClipboard, callback: pointer, user_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_clipboard_request_targets".}
proc request_targets*(self: Clipboard, callback: pointer, user_data: pointer) {.inline.} =
  gtk_clipboard_request_targets(self, callback, user_data)
# proc request_targets*(self: Clipboard, callback: pointer, user_data: pointer) {.inline.} =

# gtk_clipboard_request_text
# flags: {isMethod} container: Clipboard
# need sugar: is method
# callback 'pointer' 'pointer' IN
# user_data 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_clipboard_request_text(self: ptr TClipboard, callback: pointer, user_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_clipboard_request_text".}
proc request_text*(self: Clipboard, callback: pointer, user_data: pointer) {.inline.} =
  gtk_clipboard_request_text(self, callback, user_data)
# proc request_text*(self: Clipboard, callback: pointer, user_data: pointer) {.inline.} =

# gtk_clipboard_request_uris
# flags: {isMethod} container: Clipboard
# need sugar: is method
# callback 'pointer' 'pointer' IN
# user_data 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_clipboard_request_uris(self: ptr TClipboard, callback: pointer, user_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_clipboard_request_uris".}
proc request_uris*(self: Clipboard, callback: pointer, user_data: pointer) {.inline.} =
  gtk_clipboard_request_uris(self, callback, user_data)
# proc request_uris*(self: Clipboard, callback: pointer, user_data: pointer) {.inline.} =

# gtk_clipboard_set_can_store
# flags: {isMethod} container: Clipboard
# need sugar: is method
# targets 'var openarray[TTargetEntry]' 'openarray[TTargetEntry]' IN (diff., need sugar) array lengthArg: 1
# n_targets 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_clipboard_set_can_store(self: ptr TClipboard, targets: openarray[TTargetEntry], n_targets: int32) {.cdecl, dynlib: lib, importc: "gtk_clipboard_set_can_store".}
proc set_can_store*(self: Clipboard, targets: var openarray[TTargetEntry]) {.inline.} =
  gtk_clipboard_set_can_store(self, targets, targets.len.int32)
# proc set_can_store*(self: Clipboard, targets: var openarray[TTargetEntry]) {.inline.} =

# gtk_clipboard_set_image
# flags: {isMethod} container: Clipboard
# need sugar: is method
# pixbuf 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_clipboard_set_image(self: ptr TClipboard, pixbuf: ptr GdkPixbuf2.TPixbuf) {.cdecl, dynlib: lib, importc: "gtk_clipboard_set_image".}
proc set_image*(self: Clipboard, pixbuf: GdkPixbuf2.Pixbuf) {.inline.} =
  gtk_clipboard_set_image(self, pixbuf.getPointer)
# proc set_image*(self: Clipboard, pixbuf: GdkPixbuf2.Pixbuf) {.inline.} =

# gtk_clipboard_set_text
# flags: {isMethod} container: Clipboard
# need sugar: is method
# text 'ustring' 'ucstring' IN (diff., need sugar)
# len 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_clipboard_set_text(self: ptr TClipboard, text: ucstring, len: int32) {.cdecl, dynlib: lib, importc: "gtk_clipboard_set_text".}
proc set_text*(self: Clipboard, text: ustring, len: int32) {.inline.} =
  gtk_clipboard_set_text(self, ucstring(text), len)
# proc set_text*(self: Clipboard, text: ustring, len: int32) {.inline.} =

# gtk_clipboard_store
# flags: {isMethod} container: Clipboard
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_clipboard_store(self: ptr TClipboard) {.cdecl, dynlib: lib, importc: "gtk_clipboard_store".}
proc store*(self: Clipboard) {.inline.} =
  gtk_clipboard_store(self)
# proc store*(self: Clipboard) {.inline.} =

# gtk_clipboard_wait_for_contents
# flags: {isMethod} container: Clipboard
# need sugar: is method
# target 'Gdk3.TAtom' 'ptr Gdk3.TAtom' IN (diff., need sugar)
# 'TSelectionData' 'ptr TSelectionData' (diff., need sugar)
proc gtk_clipboard_wait_for_contents(self: ptr TClipboard, target: ptr Gdk3.TAtom): ptr TSelectionData {.cdecl, dynlib: lib, importc: "gtk_clipboard_wait_for_contents".}
proc wait_for_contents*(self: Clipboard, target: Gdk3.TAtom): TSelectionData {.inline.} =
  (gtk_clipboard_wait_for_contents(self, myUnsafeAddr(target)))[]
# proc wait_for_contents*(self: Clipboard, target: Gdk3.TAtom): TSelectionData {.inline.} =

# gtk_clipboard_wait_for_image
# flags: {isMethod} container: Clipboard
# need sugar: is method
# 'GdkPixbuf2.Pixbuf' 'TransferFull[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_clipboard_wait_for_image(self: ptr TClipboard): TransferFull[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_clipboard_wait_for_image".}
proc wait_for_image*(self: Clipboard): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_clipboard_wait_for_image(self))
# proc wait_for_image*(self: Clipboard): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_clipboard_wait_for_rich_text
# flags: {isMethod} container: Clipboard
# need sugar: is method
# buffer 'TextBuffer' 'ptr TTextBuffer' IN (diff., need sugar)
# format 'var Gdk3.TAtom' 'ptr Gdk3.TAtom' OUT (diff., need sugar) caller-allocates
# length 'var uint32' 'ptr uint32' OUT (diff., need sugar)
# 'string' 'cstring' (diff., need sugar)
proc gtk_clipboard_wait_for_rich_text(self: ptr TClipboard, buffer: ptr TTextBuffer, format: ptr Gdk3.TAtom, length: ptr uint32): cstring {.cdecl, dynlib: lib, importc: "gtk_clipboard_wait_for_rich_text".}
proc wait_for_rich_text*(self: Clipboard, buffer: TextBuffer, format: var Gdk3.TAtom, length: var uint32): string {.inline.} =
  $(gtk_clipboard_wait_for_rich_text(self, buffer.getPointer, addr(format), addr(length)))
# tuple-return
# format: var Gdk3.TAtom
# length: var uint32
# proc wait_for_rich_text*(self: Clipboard, buffer: TextBuffer): string {.inline.} =

# gtk_clipboard_wait_for_targets
# flags: {isMethod} container: Clipboard
# need sugar: is method
# targets 'var openarray[ptr Gdk3.TAtom]' 'openarray[ptr Gdk3.TAtom]' OUT (diff., need sugar) array lengthArg: 1
# n_targets 'var int32' 'ptr int32' OUT (diff., need sugar)
# 'bool' 'bool'
proc gtk_clipboard_wait_for_targets(self: ptr TClipboard, targets: openarray[ptr Gdk3.TAtom], n_targets: ptr int32): bool {.cdecl, dynlib: lib, importc: "gtk_clipboard_wait_for_targets".}
proc wait_for_targets*(self: Clipboard, targets: var openarray[ptr Gdk3.TAtom], n_targets: var int32): bool {.inline.} =
  gtk_clipboard_wait_for_targets(self, targets, addr(n_targets))
# tuple-return
# targets: var openarray[ptr Gdk3.TAtom]
# n_targets: var int32
# proc wait_for_targets*(self: Clipboard): bool {.inline.} =

# gtk_clipboard_wait_for_text
# flags: {isMethod} container: Clipboard
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_clipboard_wait_for_text(self: ptr TClipboard): ucstring {.cdecl, dynlib: lib, importc: "gtk_clipboard_wait_for_text".}
proc wait_for_text*(self: Clipboard): ustring {.inline.} =
  ustring($(gtk_clipboard_wait_for_text(self)))
# proc wait_for_text*(self: Clipboard): ustring {.inline.} =

# gtk_clipboard_wait_for_uris
# flags: {isMethod} container: Clipboard
# need sugar: is method
# 'zeroTerminatedArray[ucstring]' 'zeroTerminatedArray[ucstring]'
proc gtk_clipboard_wait_for_uris(self: ptr TClipboard): zeroTerminatedArray[ucstring] {.cdecl, dynlib: lib, importc: "gtk_clipboard_wait_for_uris".}
proc wait_for_uris*(self: Clipboard): zeroTerminatedArray[ucstring] {.inline.} =
  gtk_clipboard_wait_for_uris(self)
# proc wait_for_uris*(self: Clipboard): zeroTerminatedArray[ucstring] {.inline.} =

# gtk_clipboard_wait_is_image_available
# flags: {isMethod} container: Clipboard
# need sugar: is method
# 'bool' 'bool'
proc gtk_clipboard_wait_is_image_available(self: ptr TClipboard): bool {.cdecl, dynlib: lib, importc: "gtk_clipboard_wait_is_image_available".}
proc wait_is_image_available*(self: Clipboard): bool {.inline.} =
  gtk_clipboard_wait_is_image_available(self)
# proc wait_is_image_available*(self: Clipboard): bool {.inline.} =

# gtk_clipboard_wait_is_rich_text_available
# flags: {isMethod} container: Clipboard
# need sugar: is method
# buffer 'TextBuffer' 'ptr TTextBuffer' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_clipboard_wait_is_rich_text_available(self: ptr TClipboard, buffer: ptr TTextBuffer): bool {.cdecl, dynlib: lib, importc: "gtk_clipboard_wait_is_rich_text_available".}
proc wait_is_rich_text_available*(self: Clipboard, buffer: TextBuffer): bool {.inline.} =
  gtk_clipboard_wait_is_rich_text_available(self, buffer.getPointer)
# proc wait_is_rich_text_available*(self: Clipboard, buffer: TextBuffer): bool {.inline.} =

# gtk_clipboard_wait_is_target_available
# flags: {isMethod} container: Clipboard
# need sugar: is method
# target 'Gdk3.TAtom' 'ptr Gdk3.TAtom' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_clipboard_wait_is_target_available(self: ptr TClipboard, target: ptr Gdk3.TAtom): bool {.cdecl, dynlib: lib, importc: "gtk_clipboard_wait_is_target_available".}
proc wait_is_target_available*(self: Clipboard, target: Gdk3.TAtom): bool {.inline.} =
  gtk_clipboard_wait_is_target_available(self, myUnsafeAddr(target))
# proc wait_is_target_available*(self: Clipboard, target: Gdk3.TAtom): bool {.inline.} =

# gtk_clipboard_wait_is_text_available
# flags: {isMethod} container: Clipboard
# need sugar: is method
# 'bool' 'bool'
proc gtk_clipboard_wait_is_text_available(self: ptr TClipboard): bool {.cdecl, dynlib: lib, importc: "gtk_clipboard_wait_is_text_available".}
proc wait_is_text_available*(self: Clipboard): bool {.inline.} =
  gtk_clipboard_wait_is_text_available(self)
# proc wait_is_text_available*(self: Clipboard): bool {.inline.} =

# gtk_clipboard_wait_is_uris_available
# flags: {isMethod} container: Clipboard
# need sugar: is method
# 'bool' 'bool'
proc gtk_clipboard_wait_is_uris_available(self: ptr TClipboard): bool {.cdecl, dynlib: lib, importc: "gtk_clipboard_wait_is_uris_available".}
proc wait_is_uris_available*(self: Clipboard): bool {.inline.} =
  gtk_clipboard_wait_is_uris_available(self)
# proc wait_is_uris_available*(self: Clipboard): bool {.inline.} =

# gtk_color_button_new
# flags: {isConstructor} container: ColorButton
# need sugar: is static method
# 'ColorButton' 'TransferNone[TColorButton]' (diff., need sugar)
proc gtk_color_button_new(): TransferNone[TColorButton] {.cdecl, dynlib: lib, importc: "gtk_color_button_new".}
proc new_colorbutton*(): ColorButton {.inline.} =
  wrap(gtk_color_button_new())
# proc new_colorbutton*(): ColorButton {.inline.} =

# gtk_color_button_new_with_color
# flags: {isConstructor} container: ColorButton (deprecated)
# gtk_color_button_new_with_rgba
# flags: {isConstructor} container: ColorButton
# need sugar: is static method
# rgba 'Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN (diff., need sugar)
# 'ColorButton' 'TransferNone[TColorButton]' (diff., need sugar)
proc gtk_color_button_new_with_rgba(rgba: ptr Gdk3.TRGBA): TransferNone[TColorButton] {.cdecl, dynlib: lib, importc: "gtk_color_button_new_with_rgba".}
proc new_colorbutton_with_rgba*(rgba: Gdk3.TRGBA): ColorButton {.inline.} =
  wrap(gtk_color_button_new_with_rgba(myUnsafeAddr(rgba)))
# proc new_colorbutton_with_rgba*(rgba: Gdk3.TRGBA): ColorButton {.inline.} =

# gtk_color_button_get_alpha
# flags: {isMethod} container: ColorButton (deprecated)
# gtk_color_button_get_color
# flags: {isMethod} container: ColorButton (deprecated)
# gtk_color_button_get_title
# flags: {isMethod} container: ColorButton
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_color_button_get_title(self: ptr TColorButton): ucstring {.cdecl, dynlib: lib, importc: "gtk_color_button_get_title".}
proc get_title*(self: ColorButton): ustring {.inline.} =
  ustring($(gtk_color_button_get_title(self)))
# proc get_title*(self: ColorButton): ustring {.inline.} =

# gtk_color_button_get_use_alpha
# flags: {isMethod} container: ColorButton (deprecated)
# gtk_color_button_set_alpha
# flags: {isMethod} container: ColorButton (deprecated)
# gtk_color_button_set_color
# flags: {isMethod} container: ColorButton (deprecated)
# gtk_color_button_set_title
# flags: {isMethod} container: ColorButton
# need sugar: is method
# title 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_color_button_set_title(self: ptr TColorButton, title: ucstring) {.cdecl, dynlib: lib, importc: "gtk_color_button_set_title".}
proc set_title*(self: ColorButton, title: ustring) {.inline.} =
  gtk_color_button_set_title(self, ucstring(title))
# proc set_title*(self: ColorButton, title: ustring) {.inline.} =

# gtk_color_button_set_use_alpha
# flags: {isMethod} container: ColorButton (deprecated)
# gtk_color_chooser_dialog_new
# flags: {isConstructor} container: ColorChooserDialog
# need sugar: is static method
# title 'ustring' 'ucstring' IN (diff., need sugar)
# parent 'Window' 'ptr TWindow' IN (diff., need sugar)
# 'ColorChooserDialog' 'TransferNone[TColorChooserDialog]' (diff., need sugar)
proc gtk_color_chooser_dialog_new(title: ucstring, parent: ptr TWindow): TransferNone[TColorChooserDialog] {.cdecl, dynlib: lib, importc: "gtk_color_chooser_dialog_new".}
proc new_colorchooserdialog*(title: ustring, parent: Window): ColorChooserDialog {.inline.} =
  wrap(gtk_color_chooser_dialog_new(ucstring(title), parent.getPointer))
# proc new_colorchooserdialog*(title: ustring, parent: Window): ColorChooserDialog {.inline.} =

# gtk_color_chooser_widget_new
# flags: {isConstructor} container: ColorChooserWidget
# need sugar: is static method
# 'ColorChooserWidget' 'TransferNone[TColorChooserWidget]' (diff., need sugar)
proc gtk_color_chooser_widget_new(): TransferNone[TColorChooserWidget] {.cdecl, dynlib: lib, importc: "gtk_color_chooser_widget_new".}
proc new_colorchooserwidget*(): ColorChooserWidget {.inline.} =
  wrap(gtk_color_chooser_widget_new())
# proc new_colorchooserwidget*(): ColorChooserWidget {.inline.} =

# gtk_color_selection_new
# flags: {isConstructor} container: ColorSelection
# need sugar: is static method
# 'ColorSelection' 'TransferNone[TColorSelection]' (diff., need sugar)
proc gtk_color_selection_new(): TransferNone[TColorSelection] {.cdecl, dynlib: lib, importc: "gtk_color_selection_new".}
proc new_colorselection*(): ColorSelection {.inline.} =
  wrap(gtk_color_selection_new())
# proc new_colorselection*(): ColorSelection {.inline.} =

# gtk_color_selection_palette_from_string
# flags: {} container: ColorSelection
# need sugar: is static method
# str 'ustring' 'ucstring' IN (diff., need sugar)
# colors 'var openarray[Gdk3.TColor]' 'openarray[Gdk3.TColor]' OUT (diff., need sugar) array lengthArg: 2
# n_colors 'var int32' 'ptr int32' OUT (diff., need sugar)
# 'bool' 'bool'
proc gtk_color_selection_palette_from_string(str: ucstring, colors: openarray[Gdk3.TColor], n_colors: ptr int32): bool {.cdecl, dynlib: lib, importc: "gtk_color_selection_palette_from_string".}
template palette_from_string*(klass_parameter: typedesc[ColorSelection], str: ustring, colors: var openarray[Gdk3.TColor], n_colors: var int32): bool =
  gtk_color_selection_palette_from_string(ucstring(str), colors, addr(n_colors))
# tuple-return
# colors: var openarray[Gdk3.TColor]
# n_colors: var int32
# template palette_from_string*(klass_parameter: typedesc[ColorSelection], str: ustring): bool =

# gtk_color_selection_palette_to_string
# flags: {} container: ColorSelection
# need sugar: is static method
# colors 'var openarray[Gdk3.TColor]' 'openarray[Gdk3.TColor]' IN (diff., need sugar) array lengthArg: 1
# n_colors 'int32' 'int32' IN
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_color_selection_palette_to_string(colors: openarray[Gdk3.TColor], n_colors: int32): ucstring {.cdecl, dynlib: lib, importc: "gtk_color_selection_palette_to_string".}
template palette_to_string*(klass_parameter: typedesc[ColorSelection], colors: var openarray[Gdk3.TColor]): ustring =
  ustring($(gtk_color_selection_palette_to_string(colors, colors.len.int32)))
# template palette_to_string*(klass_parameter: typedesc[ColorSelection], colors: var openarray[Gdk3.TColor]): ustring =

# gtk_color_selection_get_current_alpha
# flags: {isMethod} container: ColorSelection
# need sugar: is method
# 'uint16' 'uint16'
proc gtk_color_selection_get_current_alpha(self: ptr TColorSelection): uint16 {.cdecl, dynlib: lib, importc: "gtk_color_selection_get_current_alpha".}
proc get_current_alpha*(self: ColorSelection): uint16 {.inline.} =
  gtk_color_selection_get_current_alpha(self)
# proc get_current_alpha*(self: ColorSelection): uint16 {.inline.} =

# gtk_color_selection_get_current_color
# flags: {isMethod} container: ColorSelection (deprecated)
# gtk_color_selection_get_current_rgba
# flags: {isMethod} container: ColorSelection
# need sugar: is method
# rgba 'var Gdk3.TRGBA' 'ptr Gdk3.TRGBA' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_color_selection_get_current_rgba(self: ptr TColorSelection, rgba: ptr Gdk3.TRGBA) {.cdecl, dynlib: lib, importc: "gtk_color_selection_get_current_rgba".}
proc get_current_rgba*(self: ColorSelection, rgba: var Gdk3.TRGBA) {.inline.} =
  gtk_color_selection_get_current_rgba(self, addr(rgba))
# tuple-return
# rgba: var Gdk3.TRGBA
# proc get_current_rgba*(self: ColorSelection) {.inline.} =

# gtk_color_selection_get_has_opacity_control
# flags: {isMethod} container: ColorSelection
# need sugar: is method
# 'bool' 'bool'
proc gtk_color_selection_get_has_opacity_control(self: ptr TColorSelection): bool {.cdecl, dynlib: lib, importc: "gtk_color_selection_get_has_opacity_control".}
proc get_has_opacity_control*(self: ColorSelection): bool {.inline.} =
  gtk_color_selection_get_has_opacity_control(self)
# proc get_has_opacity_control*(self: ColorSelection): bool {.inline.} =

# gtk_color_selection_get_has_palette
# flags: {isMethod} container: ColorSelection
# need sugar: is method
# 'bool' 'bool'
proc gtk_color_selection_get_has_palette(self: ptr TColorSelection): bool {.cdecl, dynlib: lib, importc: "gtk_color_selection_get_has_palette".}
proc get_has_palette*(self: ColorSelection): bool {.inline.} =
  gtk_color_selection_get_has_palette(self)
# proc get_has_palette*(self: ColorSelection): bool {.inline.} =

# gtk_color_selection_get_previous_alpha
# flags: {isMethod} container: ColorSelection
# need sugar: is method
# 'uint16' 'uint16'
proc gtk_color_selection_get_previous_alpha(self: ptr TColorSelection): uint16 {.cdecl, dynlib: lib, importc: "gtk_color_selection_get_previous_alpha".}
proc get_previous_alpha*(self: ColorSelection): uint16 {.inline.} =
  gtk_color_selection_get_previous_alpha(self)
# proc get_previous_alpha*(self: ColorSelection): uint16 {.inline.} =

# gtk_color_selection_get_previous_color
# flags: {isMethod} container: ColorSelection (deprecated)
# gtk_color_selection_get_previous_rgba
# flags: {isMethod} container: ColorSelection
# need sugar: is method
# rgba 'var Gdk3.TRGBA' 'ptr Gdk3.TRGBA' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_color_selection_get_previous_rgba(self: ptr TColorSelection, rgba: ptr Gdk3.TRGBA) {.cdecl, dynlib: lib, importc: "gtk_color_selection_get_previous_rgba".}
proc get_previous_rgba*(self: ColorSelection, rgba: var Gdk3.TRGBA) {.inline.} =
  gtk_color_selection_get_previous_rgba(self, addr(rgba))
# tuple-return
# rgba: var Gdk3.TRGBA
# proc get_previous_rgba*(self: ColorSelection) {.inline.} =

# gtk_color_selection_is_adjusting
# flags: {isMethod} container: ColorSelection
# need sugar: is method
# 'bool' 'bool'
proc gtk_color_selection_is_adjusting(self: ptr TColorSelection): bool {.cdecl, dynlib: lib, importc: "gtk_color_selection_is_adjusting".}
proc is_adjusting*(self: ColorSelection): bool {.inline.} =
  gtk_color_selection_is_adjusting(self)
# proc is_adjusting*(self: ColorSelection): bool {.inline.} =

# gtk_color_selection_set_current_alpha
# flags: {isMethod} container: ColorSelection
# need sugar: is method
# alpha 'uint16' 'uint16' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_color_selection_set_current_alpha(self: ptr TColorSelection, alpha: uint16) {.cdecl, dynlib: lib, importc: "gtk_color_selection_set_current_alpha".}
proc set_current_alpha*(self: ColorSelection, alpha: uint16) {.inline.} =
  gtk_color_selection_set_current_alpha(self, alpha)
# proc set_current_alpha*(self: ColorSelection, alpha: uint16) {.inline.} =

# gtk_color_selection_set_current_color
# flags: {isMethod} container: ColorSelection (deprecated)
# gtk_color_selection_set_current_rgba
# flags: {isMethod} container: ColorSelection
# need sugar: is method
# rgba 'Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_color_selection_set_current_rgba(self: ptr TColorSelection, rgba: ptr Gdk3.TRGBA) {.cdecl, dynlib: lib, importc: "gtk_color_selection_set_current_rgba".}
proc set_current_rgba*(self: ColorSelection, rgba: Gdk3.TRGBA) {.inline.} =
  gtk_color_selection_set_current_rgba(self, myUnsafeAddr(rgba))
# proc set_current_rgba*(self: ColorSelection, rgba: Gdk3.TRGBA) {.inline.} =

# gtk_color_selection_set_has_opacity_control
# flags: {isMethod} container: ColorSelection
# need sugar: is method
# has_opacity 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_color_selection_set_has_opacity_control(self: ptr TColorSelection, has_opacity: bool) {.cdecl, dynlib: lib, importc: "gtk_color_selection_set_has_opacity_control".}
proc set_has_opacity_control*(self: ColorSelection, has_opacity: bool) {.inline.} =
  gtk_color_selection_set_has_opacity_control(self, has_opacity)
# proc set_has_opacity_control*(self: ColorSelection, has_opacity: bool) {.inline.} =

# gtk_color_selection_set_has_palette
# flags: {isMethod} container: ColorSelection
# need sugar: is method
# has_palette 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_color_selection_set_has_palette(self: ptr TColorSelection, has_palette: bool) {.cdecl, dynlib: lib, importc: "gtk_color_selection_set_has_palette".}
proc set_has_palette*(self: ColorSelection, has_palette: bool) {.inline.} =
  gtk_color_selection_set_has_palette(self, has_palette)
# proc set_has_palette*(self: ColorSelection, has_palette: bool) {.inline.} =

# gtk_color_selection_set_previous_alpha
# flags: {isMethod} container: ColorSelection
# need sugar: is method
# alpha 'uint16' 'uint16' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_color_selection_set_previous_alpha(self: ptr TColorSelection, alpha: uint16) {.cdecl, dynlib: lib, importc: "gtk_color_selection_set_previous_alpha".}
proc set_previous_alpha*(self: ColorSelection, alpha: uint16) {.inline.} =
  gtk_color_selection_set_previous_alpha(self, alpha)
# proc set_previous_alpha*(self: ColorSelection, alpha: uint16) {.inline.} =

# gtk_color_selection_set_previous_color
# flags: {isMethod} container: ColorSelection (deprecated)
# gtk_color_selection_set_previous_rgba
# flags: {isMethod} container: ColorSelection
# need sugar: is method
# rgba 'Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_color_selection_set_previous_rgba(self: ptr TColorSelection, rgba: ptr Gdk3.TRGBA) {.cdecl, dynlib: lib, importc: "gtk_color_selection_set_previous_rgba".}
proc set_previous_rgba*(self: ColorSelection, rgba: Gdk3.TRGBA) {.inline.} =
  gtk_color_selection_set_previous_rgba(self, myUnsafeAddr(rgba))
# proc set_previous_rgba*(self: ColorSelection, rgba: Gdk3.TRGBA) {.inline.} =

# gtk_color_selection_dialog_new
# flags: {isConstructor} container: ColorSelectionDialog
# need sugar: is static method
# title 'ustring' 'ucstring' IN (diff., need sugar)
# 'ColorSelectionDialog' 'TransferNone[TColorSelectionDialog]' (diff., need sugar)
proc gtk_color_selection_dialog_new(title: ucstring): TransferNone[TColorSelectionDialog] {.cdecl, dynlib: lib, importc: "gtk_color_selection_dialog_new".}
proc new_colorselectiondialog*(title: ustring): ColorSelectionDialog {.inline.} =
  wrap(gtk_color_selection_dialog_new(ucstring(title)))
# proc new_colorselectiondialog*(title: ustring): ColorSelectionDialog {.inline.} =

# gtk_color_selection_dialog_get_color_selection
# flags: {isMethod} container: ColorSelectionDialog
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_color_selection_dialog_get_color_selection(self: ptr TColorSelectionDialog): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_color_selection_dialog_get_color_selection".}
proc get_color_selection*(self: ColorSelectionDialog): Widget {.inline.} =
  wrap(gtk_color_selection_dialog_get_color_selection(self))
# proc get_color_selection*(self: ColorSelectionDialog): Widget {.inline.} =

# gtk_combo_box_new
# flags: {isConstructor} container: ComboBox
# need sugar: is static method
# 'ComboBox' 'TransferNone[TComboBox]' (diff., need sugar)
proc gtk_combo_box_new(): TransferNone[TComboBox] {.cdecl, dynlib: lib, importc: "gtk_combo_box_new".}
proc new_combobox*(): ComboBox {.inline.} =
  wrap(gtk_combo_box_new())
# proc new_combobox*(): ComboBox {.inline.} =

# gtk_combo_box_new_with_area
# flags: {isConstructor} container: ComboBox
# need sugar: is static method
# area 'CellArea' 'ptr TCellArea' IN (diff., need sugar)
# 'ComboBox' 'TransferNone[TComboBox]' (diff., need sugar)
proc gtk_combo_box_new_with_area(area: ptr TCellArea): TransferNone[TComboBox] {.cdecl, dynlib: lib, importc: "gtk_combo_box_new_with_area".}
proc new_combobox_with_area*(area: CellArea): ComboBox {.inline.} =
  wrap(gtk_combo_box_new_with_area(area.getPointer))
# proc new_combobox_with_area*(area: CellArea): ComboBox {.inline.} =

# gtk_combo_box_new_with_area_and_entry
# flags: {isConstructor} container: ComboBox
# need sugar: is static method
# area 'CellArea' 'ptr TCellArea' IN (diff., need sugar)
# 'ComboBox' 'TransferNone[TComboBox]' (diff., need sugar)
proc gtk_combo_box_new_with_area_and_entry(area: ptr TCellArea): TransferNone[TComboBox] {.cdecl, dynlib: lib, importc: "gtk_combo_box_new_with_area_and_entry".}
proc new_combobox_with_area_and_entry*(area: CellArea): ComboBox {.inline.} =
  wrap(gtk_combo_box_new_with_area_and_entry(area.getPointer))
# proc new_combobox_with_area_and_entry*(area: CellArea): ComboBox {.inline.} =

# gtk_combo_box_new_with_entry
# flags: {isConstructor} container: ComboBox
# need sugar: is static method
# 'ComboBox' 'TransferNone[TComboBox]' (diff., need sugar)
proc gtk_combo_box_new_with_entry(): TransferNone[TComboBox] {.cdecl, dynlib: lib, importc: "gtk_combo_box_new_with_entry".}
proc new_combobox_with_entry*(): ComboBox {.inline.} =
  wrap(gtk_combo_box_new_with_entry())
# proc new_combobox_with_entry*(): ComboBox {.inline.} =

# gtk_combo_box_new_with_model
# flags: {isConstructor} container: ComboBox
# need sugar: is static method
# model 'TreeModel' 'ptr TTreeModel' IN (diff., need sugar)
# 'ComboBox' 'TransferNone[TComboBox]' (diff., need sugar)
proc gtk_combo_box_new_with_model(model: ptr TTreeModel): TransferNone[TComboBox] {.cdecl, dynlib: lib, importc: "gtk_combo_box_new_with_model".}
proc new_combobox_with_model*(model: TreeModel): ComboBox {.inline.} =
  wrap(gtk_combo_box_new_with_model(unwrap(model)))
# proc new_combobox_with_model*(model: TreeModel): ComboBox {.inline.} =

# gtk_combo_box_new_with_model_and_entry
# flags: {isConstructor} container: ComboBox
# need sugar: is static method
# model 'TreeModel' 'ptr TTreeModel' IN (diff., need sugar)
# 'ComboBox' 'TransferNone[TComboBox]' (diff., need sugar)
proc gtk_combo_box_new_with_model_and_entry(model: ptr TTreeModel): TransferNone[TComboBox] {.cdecl, dynlib: lib, importc: "gtk_combo_box_new_with_model_and_entry".}
proc new_combobox_with_model_and_entry*(model: TreeModel): ComboBox {.inline.} =
  wrap(gtk_combo_box_new_with_model_and_entry(unwrap(model)))
# proc new_combobox_with_model_and_entry*(model: TreeModel): ComboBox {.inline.} =

# gtk_combo_box_get_active
# flags: {isMethod} container: ComboBox
# need sugar: is method
# 'int32' 'int32'
proc gtk_combo_box_get_active(self: ptr TComboBox): int32 {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_active".}
proc get_active*(self: ComboBox): int32 {.inline.} =
  gtk_combo_box_get_active(self)
# proc get_active*(self: ComboBox): int32 {.inline.} =

# gtk_combo_box_get_active_id
# flags: {isMethod} container: ComboBox
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_combo_box_get_active_id(self: ptr TComboBox): ucstring {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_active_id".}
proc get_active_id*(self: ComboBox): ustring {.inline.} =
  ustring($(gtk_combo_box_get_active_id(self)))
# proc get_active_id*(self: ComboBox): ustring {.inline.} =

# gtk_combo_box_get_active_iter
# flags: {isMethod} container: ComboBox
# need sugar: is method
# iter 'var TTreeIter' 'ptr TTreeIter' OUT (diff., need sugar) caller-allocates
# 'bool' 'bool'
proc gtk_combo_box_get_active_iter(self: ptr TComboBox, iter: ptr TTreeIter): bool {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_active_iter".}
proc get_active_iter*(self: ComboBox, iter: var TTreeIter): bool {.inline.} =
  gtk_combo_box_get_active_iter(self, addr(iter))
# tuple-return
# iter: var TTreeIter
# proc get_active_iter*(self: ComboBox): bool {.inline.} =

# gtk_combo_box_get_add_tearoffs
# flags: {isMethod} container: ComboBox (deprecated)
# gtk_combo_box_get_button_sensitivity
# flags: {isMethod} container: ComboBox
# need sugar: is method
# 'SensitivityType' 'SensitivityType'
proc gtk_combo_box_get_button_sensitivity(self: ptr TComboBox): SensitivityType {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_button_sensitivity".}
proc get_button_sensitivity*(self: ComboBox): SensitivityType {.inline.} =
  gtk_combo_box_get_button_sensitivity(self)
# proc get_button_sensitivity*(self: ComboBox): SensitivityType {.inline.} =

# gtk_combo_box_get_column_span_column
# flags: {isMethod} container: ComboBox
# need sugar: is method
# 'int32' 'int32'
proc gtk_combo_box_get_column_span_column(self: ptr TComboBox): int32 {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_column_span_column".}
proc get_column_span_column*(self: ComboBox): int32 {.inline.} =
  gtk_combo_box_get_column_span_column(self)
# proc get_column_span_column*(self: ComboBox): int32 {.inline.} =

# gtk_combo_box_get_entry_text_column
# flags: {isMethod} container: ComboBox
# need sugar: is method
# 'int32' 'int32'
proc gtk_combo_box_get_entry_text_column(self: ptr TComboBox): int32 {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_entry_text_column".}
proc get_entry_text_column*(self: ComboBox): int32 {.inline.} =
  gtk_combo_box_get_entry_text_column(self)
# proc get_entry_text_column*(self: ComboBox): int32 {.inline.} =

# gtk_combo_box_get_focus_on_click
# flags: {isMethod} container: ComboBox
# need sugar: is method
# 'bool' 'bool'
proc gtk_combo_box_get_focus_on_click(self: ptr TComboBox): bool {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_focus_on_click".}
proc get_focus_on_click*(self: ComboBox): bool {.inline.} =
  gtk_combo_box_get_focus_on_click(self)
# proc get_focus_on_click*(self: ComboBox): bool {.inline.} =

# gtk_combo_box_get_has_entry
# flags: {isMethod} container: ComboBox
# need sugar: is method
# 'bool' 'bool'
proc gtk_combo_box_get_has_entry(self: ptr TComboBox): bool {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_has_entry".}
proc get_has_entry*(self: ComboBox): bool {.inline.} =
  gtk_combo_box_get_has_entry(self)
# proc get_has_entry*(self: ComboBox): bool {.inline.} =

# gtk_combo_box_get_id_column
# flags: {isMethod} container: ComboBox
# need sugar: is method
# 'int32' 'int32'
proc gtk_combo_box_get_id_column(self: ptr TComboBox): int32 {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_id_column".}
proc get_id_column*(self: ComboBox): int32 {.inline.} =
  gtk_combo_box_get_id_column(self)
# proc get_id_column*(self: ComboBox): int32 {.inline.} =

# gtk_combo_box_get_model
# flags: {isMethod} container: ComboBox
# need sugar: is method
# 'TreeModel' 'TransferNone[TTreeModel]' (diff., need sugar)
proc gtk_combo_box_get_model(self: ptr TComboBox): TransferNone[TTreeModel] {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_model".}
proc get_model*(self: ComboBox): TreeModel {.inline.} =
  wrap(gtk_combo_box_get_model(self))
# proc get_model*(self: ComboBox): TreeModel {.inline.} =

# gtk_combo_box_get_popup_accessible
# flags: {isMethod} container: ComboBox
# need sugar: is method
# 'Atk1.Object' 'TransferNone[Atk1.TObject]' (diff., need sugar)
proc gtk_combo_box_get_popup_accessible(self: ptr TComboBox): TransferNone[Atk1.TObject] {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_popup_accessible".}
proc get_popup_accessible*(self: ComboBox): Atk1.Object {.inline.} =
  wrap(gtk_combo_box_get_popup_accessible(self))
# proc get_popup_accessible*(self: ComboBox): Atk1.Object {.inline.} =

# gtk_combo_box_get_popup_fixed_width
# flags: {isMethod} container: ComboBox
# need sugar: is method
# 'bool' 'bool'
proc gtk_combo_box_get_popup_fixed_width(self: ptr TComboBox): bool {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_popup_fixed_width".}
proc get_popup_fixed_width*(self: ComboBox): bool {.inline.} =
  gtk_combo_box_get_popup_fixed_width(self)
# proc get_popup_fixed_width*(self: ComboBox): bool {.inline.} =

# gtk_combo_box_get_row_span_column
# flags: {isMethod} container: ComboBox
# need sugar: is method
# 'int32' 'int32'
proc gtk_combo_box_get_row_span_column(self: ptr TComboBox): int32 {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_row_span_column".}
proc get_row_span_column*(self: ComboBox): int32 {.inline.} =
  gtk_combo_box_get_row_span_column(self)
# proc get_row_span_column*(self: ComboBox): int32 {.inline.} =

# gtk_combo_box_get_title
# flags: {isMethod} container: ComboBox (deprecated)
# gtk_combo_box_get_wrap_width
# flags: {isMethod} container: ComboBox
# need sugar: is method
# 'int32' 'int32'
proc gtk_combo_box_get_wrap_width(self: ptr TComboBox): int32 {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_wrap_width".}
proc get_wrap_width*(self: ComboBox): int32 {.inline.} =
  gtk_combo_box_get_wrap_width(self)
# proc get_wrap_width*(self: ComboBox): int32 {.inline.} =

# gtk_combo_box_popdown
# flags: {isMethod} container: ComboBox
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_popdown(self: ptr TComboBox) {.cdecl, dynlib: lib, importc: "gtk_combo_box_popdown".}
proc popdown*(self: ComboBox) {.inline.} =
  gtk_combo_box_popdown(self)
# proc popdown*(self: ComboBox) {.inline.} =

# gtk_combo_box_popup
# flags: {isMethod} container: ComboBox
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_popup(self: ptr TComboBox) {.cdecl, dynlib: lib, importc: "gtk_combo_box_popup".}
proc popup*(self: ComboBox) {.inline.} =
  gtk_combo_box_popup(self)
# proc popup*(self: ComboBox) {.inline.} =

# gtk_combo_box_popup_for_device
# flags: {isMethod} container: ComboBox
# need sugar: is method
# device 'Gdk3.Device' 'ptr Gdk3.TDevice' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_popup_for_device(self: ptr TComboBox, device: ptr Gdk3.TDevice) {.cdecl, dynlib: lib, importc: "gtk_combo_box_popup_for_device".}
proc popup_for_device*(self: ComboBox, device: Gdk3.Device) {.inline.} =
  gtk_combo_box_popup_for_device(self, device.getPointer)
# proc popup_for_device*(self: ComboBox, device: Gdk3.Device) {.inline.} =

# gtk_combo_box_set_active
# flags: {isMethod} container: ComboBox
# need sugar: is method
# index_ 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_set_active(self: ptr TComboBox, index_x: int32) {.cdecl, dynlib: lib, importc: "gtk_combo_box_set_active".}
proc set_active*(self: ComboBox, index_x: int32) {.inline.} =
  gtk_combo_box_set_active(self, index_x)
# proc set_active*(self: ComboBox, index_x: int32) {.inline.} =

# gtk_combo_box_set_active_id
# flags: {isMethod} container: ComboBox
# need sugar: is method
# active_id 'ustring' 'ucstring' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_combo_box_set_active_id(self: ptr TComboBox, active_id: ucstring): bool {.cdecl, dynlib: lib, importc: "gtk_combo_box_set_active_id".}
proc set_active_id*(self: ComboBox, active_id: ustring): bool {.inline.} =
  gtk_combo_box_set_active_id(self, ucstring(active_id))
# proc set_active_id*(self: ComboBox, active_id: ustring): bool {.inline.} =

# gtk_combo_box_set_active_iter
# flags: {isMethod} container: ComboBox
# need sugar: is method
# iter 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_set_active_iter(self: ptr TComboBox, iter: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_combo_box_set_active_iter".}
proc set_active_iter*(self: ComboBox, iter: TTreeIter) {.inline.} =
  gtk_combo_box_set_active_iter(self, myUnsafeAddr(iter))
# proc set_active_iter*(self: ComboBox, iter: TTreeIter) {.inline.} =

# gtk_combo_box_set_add_tearoffs
# flags: {isMethod} container: ComboBox (deprecated)
# gtk_combo_box_set_button_sensitivity
# flags: {isMethod} container: ComboBox
# need sugar: is method
# sensitivity 'SensitivityType' 'SensitivityType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_set_button_sensitivity(self: ptr TComboBox, sensitivity: SensitivityType) {.cdecl, dynlib: lib, importc: "gtk_combo_box_set_button_sensitivity".}
proc set_button_sensitivity*(self: ComboBox, sensitivity: SensitivityType) {.inline.} =
  gtk_combo_box_set_button_sensitivity(self, sensitivity)
# proc set_button_sensitivity*(self: ComboBox, sensitivity: SensitivityType) {.inline.} =

# gtk_combo_box_set_column_span_column
# flags: {isMethod} container: ComboBox
# need sugar: is method
# column_span 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_set_column_span_column(self: ptr TComboBox, column_span: int32) {.cdecl, dynlib: lib, importc: "gtk_combo_box_set_column_span_column".}
proc set_column_span_column*(self: ComboBox, column_span: int32) {.inline.} =
  gtk_combo_box_set_column_span_column(self, column_span)
# proc set_column_span_column*(self: ComboBox, column_span: int32) {.inline.} =

# gtk_combo_box_set_entry_text_column
# flags: {isMethod} container: ComboBox
# need sugar: is method
# text_column 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_set_entry_text_column(self: ptr TComboBox, text_column: int32) {.cdecl, dynlib: lib, importc: "gtk_combo_box_set_entry_text_column".}
proc set_entry_text_column*(self: ComboBox, text_column: int32) {.inline.} =
  gtk_combo_box_set_entry_text_column(self, text_column)
# proc set_entry_text_column*(self: ComboBox, text_column: int32) {.inline.} =

# gtk_combo_box_set_focus_on_click
# flags: {isMethod} container: ComboBox
# need sugar: is method
# focus_on_click 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_set_focus_on_click(self: ptr TComboBox, focus_on_click: bool) {.cdecl, dynlib: lib, importc: "gtk_combo_box_set_focus_on_click".}
proc set_focus_on_click*(self: ComboBox, focus_on_click: bool) {.inline.} =
  gtk_combo_box_set_focus_on_click(self, focus_on_click)
# proc set_focus_on_click*(self: ComboBox, focus_on_click: bool) {.inline.} =

# gtk_combo_box_set_id_column
# flags: {isMethod} container: ComboBox
# need sugar: is method
# id_column 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_set_id_column(self: ptr TComboBox, id_column: int32) {.cdecl, dynlib: lib, importc: "gtk_combo_box_set_id_column".}
proc set_id_column*(self: ComboBox, id_column: int32) {.inline.} =
  gtk_combo_box_set_id_column(self, id_column)
# proc set_id_column*(self: ComboBox, id_column: int32) {.inline.} =

# gtk_combo_box_set_model
# flags: {isMethod} container: ComboBox
# need sugar: is method
# model 'TreeModel' 'ptr TTreeModel' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_set_model(self: ptr TComboBox, model: ptr TTreeModel) {.cdecl, dynlib: lib, importc: "gtk_combo_box_set_model".}
proc set_model*(self: ComboBox, model: TreeModel) {.inline.} =
  gtk_combo_box_set_model(self, unwrap(model))
# proc set_model*(self: ComboBox, model: TreeModel) {.inline.} =

# gtk_combo_box_set_popup_fixed_width
# flags: {isMethod} container: ComboBox
# need sugar: is method
# fixed 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_set_popup_fixed_width(self: ptr TComboBox, fixed: bool) {.cdecl, dynlib: lib, importc: "gtk_combo_box_set_popup_fixed_width".}
proc set_popup_fixed_width*(self: ComboBox, fixed: bool) {.inline.} =
  gtk_combo_box_set_popup_fixed_width(self, fixed)
# proc set_popup_fixed_width*(self: ComboBox, fixed: bool) {.inline.} =

# gtk_combo_box_set_row_separator_func
# flags: {isMethod} container: ComboBox
# need sugar: is method
# func 'pointer' 'pointer' IN
# data 'pointer' 'pointer' IN
# destroy 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_set_row_separator_func(self: ptr TComboBox, func_x: pointer, data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_combo_box_set_row_separator_func".}
proc set_row_separator_func*(self: ComboBox, func_x: pointer, data: pointer, destroy: pointer) {.inline.} =
  gtk_combo_box_set_row_separator_func(self, func_x, data, destroy)
# proc set_row_separator_func*(self: ComboBox, func_x: pointer, data: pointer, destroy: pointer) {.inline.} =

# gtk_combo_box_set_row_span_column
# flags: {isMethod} container: ComboBox
# need sugar: is method
# row_span 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_set_row_span_column(self: ptr TComboBox, row_span: int32) {.cdecl, dynlib: lib, importc: "gtk_combo_box_set_row_span_column".}
proc set_row_span_column*(self: ComboBox, row_span: int32) {.inline.} =
  gtk_combo_box_set_row_span_column(self, row_span)
# proc set_row_span_column*(self: ComboBox, row_span: int32) {.inline.} =

# gtk_combo_box_set_title
# flags: {isMethod} container: ComboBox (deprecated)
# gtk_combo_box_set_wrap_width
# flags: {isMethod} container: ComboBox
# need sugar: is method
# width 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_set_wrap_width(self: ptr TComboBox, width: int32) {.cdecl, dynlib: lib, importc: "gtk_combo_box_set_wrap_width".}
proc set_wrap_width*(self: ComboBox, width: int32) {.inline.} =
  gtk_combo_box_set_wrap_width(self, width)
# proc set_wrap_width*(self: ComboBox, width: int32) {.inline.} =

# gtk_combo_box_text_new
# flags: {isConstructor} container: ComboBoxText
# need sugar: is static method
# 'ComboBoxText' 'TransferNone[TComboBoxText]' (diff., need sugar)
proc gtk_combo_box_text_new(): TransferNone[TComboBoxText] {.cdecl, dynlib: lib, importc: "gtk_combo_box_text_new".}
proc new_comboboxtext*(): ComboBoxText {.inline.} =
  wrap(gtk_combo_box_text_new())
# proc new_comboboxtext*(): ComboBoxText {.inline.} =

# gtk_combo_box_text_new_with_entry
# flags: {isConstructor} container: ComboBoxText
# need sugar: is static method
# 'ComboBoxText' 'TransferNone[TComboBoxText]' (diff., need sugar)
proc gtk_combo_box_text_new_with_entry(): TransferNone[TComboBoxText] {.cdecl, dynlib: lib, importc: "gtk_combo_box_text_new_with_entry".}
proc new_comboboxtext_with_entry*(): ComboBoxText {.inline.} =
  wrap(gtk_combo_box_text_new_with_entry())
# proc new_comboboxtext_with_entry*(): ComboBoxText {.inline.} =

# gtk_combo_box_text_append
# flags: {isMethod} container: ComboBoxText
# need sugar: is method
# id 'ustring' 'ucstring' IN (diff., need sugar)
# text 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_text_append(self: ptr TComboBoxText, id: ucstring, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_combo_box_text_append".}
proc append*(self: ComboBoxText, id: ustring, text: ustring) {.inline.} =
  gtk_combo_box_text_append(self, ucstring(id), ucstring(text))
# proc append*(self: ComboBoxText, id: ustring, text: ustring) {.inline.} =

# gtk_combo_box_text_append_text
# flags: {isMethod} container: ComboBoxText
# need sugar: is method
# text 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_text_append_text(self: ptr TComboBoxText, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_combo_box_text_append_text".}
proc append_text*(self: ComboBoxText, text: ustring) {.inline.} =
  gtk_combo_box_text_append_text(self, ucstring(text))
# proc append_text*(self: ComboBoxText, text: ustring) {.inline.} =

# gtk_combo_box_text_get_active_text
# flags: {isMethod} container: ComboBoxText
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_combo_box_text_get_active_text(self: ptr TComboBoxText): ucstring {.cdecl, dynlib: lib, importc: "gtk_combo_box_text_get_active_text".}
proc get_active_text*(self: ComboBoxText): ustring {.inline.} =
  ustring($(gtk_combo_box_text_get_active_text(self)))
# proc get_active_text*(self: ComboBoxText): ustring {.inline.} =

# gtk_combo_box_text_insert
# flags: {isMethod} container: ComboBoxText
# need sugar: is method
# position 'int32' 'int32' IN
# id 'ustring' 'ucstring' IN (diff., need sugar)
# text 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_text_insert(self: ptr TComboBoxText, position: int32, id: ucstring, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_combo_box_text_insert".}
proc insert*(self: ComboBoxText, position: int32, id: ustring, text: ustring) {.inline.} =
  gtk_combo_box_text_insert(self, position, ucstring(id), ucstring(text))
# proc insert*(self: ComboBoxText, position: int32, id: ustring, text: ustring) {.inline.} =

# gtk_combo_box_text_insert_text
# flags: {isMethod} container: ComboBoxText
# need sugar: is method
# position 'int32' 'int32' IN
# text 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_text_insert_text(self: ptr TComboBoxText, position: int32, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_combo_box_text_insert_text".}
proc insert_text*(self: ComboBoxText, position: int32, text: ustring) {.inline.} =
  gtk_combo_box_text_insert_text(self, position, ucstring(text))
# proc insert_text*(self: ComboBoxText, position: int32, text: ustring) {.inline.} =

# gtk_combo_box_text_prepend
# flags: {isMethod} container: ComboBoxText
# need sugar: is method
# id 'ustring' 'ucstring' IN (diff., need sugar)
# text 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_text_prepend(self: ptr TComboBoxText, id: ucstring, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_combo_box_text_prepend".}
proc prepend*(self: ComboBoxText, id: ustring, text: ustring) {.inline.} =
  gtk_combo_box_text_prepend(self, ucstring(id), ucstring(text))
# proc prepend*(self: ComboBoxText, id: ustring, text: ustring) {.inline.} =

# gtk_combo_box_text_prepend_text
# flags: {isMethod} container: ComboBoxText
# need sugar: is method
# text 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_text_prepend_text(self: ptr TComboBoxText, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_combo_box_text_prepend_text".}
proc prepend_text*(self: ComboBoxText, text: ustring) {.inline.} =
  gtk_combo_box_text_prepend_text(self, ucstring(text))
# proc prepend_text*(self: ComboBoxText, text: ustring) {.inline.} =

# gtk_combo_box_text_remove
# flags: {isMethod} container: ComboBoxText
# need sugar: is method
# position 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_text_remove(self: ptr TComboBoxText, position: int32) {.cdecl, dynlib: lib, importc: "gtk_combo_box_text_remove".}
proc remove*(self: ComboBoxText, position: int32) {.inline.} =
  gtk_combo_box_text_remove(self, position)
# proc remove*(self: ComboBoxText, position: int32) {.inline.} =

# gtk_combo_box_text_remove_all
# flags: {isMethod} container: ComboBoxText
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_text_remove_all(self: ptr TComboBoxText) {.cdecl, dynlib: lib, importc: "gtk_combo_box_text_remove_all".}
proc remove_all*(self: ComboBoxText) {.inline.} =
  gtk_combo_box_text_remove_all(self)
# proc remove_all*(self: ComboBoxText) {.inline.} =

# gtk_container_add
# flags: {isMethod} container: Container
# need sugar: is method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_container_add(self: ptr TContainer, widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_container_add".}
proc add*(self: Container, widget: Widget) {.inline.} =
  gtk_container_add(self, widget.getPointer)
# proc add*(self: Container, widget: Widget) {.inline.} =

# gtk_container_check_resize
# flags: {isMethod} container: Container
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_container_check_resize(self: ptr TContainer) {.cdecl, dynlib: lib, importc: "gtk_container_check_resize".}
proc check_resize*(self: Container) {.inline.} =
  gtk_container_check_resize(self)
# proc check_resize*(self: Container) {.inline.} =

# gtk_container_child_get_property
# flags: {isMethod} container: Container
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# property_name 'ustring' 'ucstring' IN (diff., need sugar)
# value 'GObject2.TValue' 'ptr GObject2.TValue' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_container_child_get_property(self: ptr TContainer, child: ptr TWidget, property_name: ucstring, value: ptr GObject2.TValue) {.cdecl, dynlib: lib, importc: "gtk_container_child_get_property".}
proc child_get_property*(self: Container, child: Widget, property_name: ustring, value: GObject2.TValue) {.inline.} =
  gtk_container_child_get_property(self, child.getPointer, ucstring(property_name), myUnsafeAddr(value))
# proc child_get_property*(self: Container, child: Widget, property_name: ustring, value: GObject2.TValue) {.inline.} =

# gtk_container_child_notify
# flags: {isMethod} container: Container
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# child_property 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_container_child_notify(self: ptr TContainer, child: ptr TWidget, child_property: ucstring) {.cdecl, dynlib: lib, importc: "gtk_container_child_notify".}
proc child_notify*(self: Container, child: Widget, child_property: ustring) {.inline.} =
  gtk_container_child_notify(self, child.getPointer, ucstring(child_property))
# proc child_notify*(self: Container, child: Widget, child_property: ustring) {.inline.} =

# gtk_container_child_set_property
# flags: {isMethod} container: Container
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# property_name 'ustring' 'ucstring' IN (diff., need sugar)
# value 'GObject2.TValue' 'ptr GObject2.TValue' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_container_child_set_property(self: ptr TContainer, child: ptr TWidget, property_name: ucstring, value: ptr GObject2.TValue) {.cdecl, dynlib: lib, importc: "gtk_container_child_set_property".}
proc child_set_property*(self: Container, child: Widget, property_name: ustring, value: GObject2.TValue) {.inline.} =
  gtk_container_child_set_property(self, child.getPointer, ucstring(property_name), myUnsafeAddr(value))
# proc child_set_property*(self: Container, child: Widget, property_name: ustring, value: GObject2.TValue) {.inline.} =

# gtk_container_child_type
# flags: {isMethod} container: Container
# need sugar: is method
# 'GType' 'GType'
proc gtk_container_child_type(self: ptr TContainer): GType {.cdecl, dynlib: lib, importc: "gtk_container_child_type".}
proc child_type*(self: Container): GType {.inline.} =
  gtk_container_child_type(self)
# proc child_type*(self: Container): GType {.inline.} =

# gtk_container_forall
# flags: {isMethod} container: Container
# need sugar: is method
# callback 'pointer' 'pointer' IN
# callback_data 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_container_forall(self: ptr TContainer, callback: pointer, callback_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_container_forall".}
proc forall*(self: Container, callback: pointer, callback_data: pointer) {.inline.} =
  gtk_container_forall(self, callback, callback_data)
# proc forall*(self: Container, callback: pointer, callback_data: pointer) {.inline.} =

# gtk_container_foreach
# flags: {isMethod} container: Container
# need sugar: is method
# callback 'pointer' 'pointer' IN
# callback_data 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_container_foreach(self: ptr TContainer, callback: pointer, callback_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_container_foreach".}
proc foreach*(self: Container, callback: pointer, callback_data: pointer) {.inline.} =
  gtk_container_foreach(self, callback, callback_data)
# proc foreach*(self: Container, callback: pointer, callback_data: pointer) {.inline.} =

# gtk_container_get_border_width
# flags: {isMethod} container: Container
# need sugar: is method
# 'uint32' 'uint32'
proc gtk_container_get_border_width(self: ptr TContainer): uint32 {.cdecl, dynlib: lib, importc: "gtk_container_get_border_width".}
proc get_border_width*(self: Container): uint32 {.inline.} =
  gtk_container_get_border_width(self)
# proc get_border_width*(self: Container): uint32 {.inline.} =

# gtk_container_get_children
# flags: {isMethod} container: Container
# need sugar: is method
# 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_container_get_children(self: ptr TContainer): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_container_get_children".}
proc get_children*(self: Container): ptr GLIST_TODO {.inline.} =
  gtk_container_get_children(self)
# proc get_children*(self: Container): ptr GLIST_TODO {.inline.} =

# gtk_container_get_focus_chain
# flags: {isMethod} container: Container
# need sugar: is method
# focusable_widgets 'ptr GLIST_TODO' 'ptr GLIST_TODO' OUT
# 'bool' 'bool'
proc gtk_container_get_focus_chain(self: ptr TContainer, focusable_widgets: ptr GLIST_TODO): bool {.cdecl, dynlib: lib, importc: "gtk_container_get_focus_chain".}
proc get_focus_chain*(self: Container, focusable_widgets: ptr GLIST_TODO): bool {.inline.} =
  gtk_container_get_focus_chain(self, focusable_widgets)
# tuple-return
# focusable_widgets: ptr GLIST_TODO
# proc get_focus_chain*(self: Container): bool {.inline.} =

# gtk_container_get_focus_child
# flags: {isMethod} container: Container
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_container_get_focus_child(self: ptr TContainer): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_container_get_focus_child".}
proc get_focus_child*(self: Container): Widget {.inline.} =
  wrap(gtk_container_get_focus_child(self))
# proc get_focus_child*(self: Container): Widget {.inline.} =

# gtk_container_get_focus_hadjustment
# flags: {isMethod} container: Container
# need sugar: is method
# 'Adjustment' 'TransferNone[TAdjustment]' (diff., need sugar)
proc gtk_container_get_focus_hadjustment(self: ptr TContainer): TransferNone[TAdjustment] {.cdecl, dynlib: lib, importc: "gtk_container_get_focus_hadjustment".}
proc get_focus_hadjustment*(self: Container): Adjustment {.inline.} =
  wrap(gtk_container_get_focus_hadjustment(self))
# proc get_focus_hadjustment*(self: Container): Adjustment {.inline.} =

# gtk_container_get_focus_vadjustment
# flags: {isMethod} container: Container
# need sugar: is method
# 'Adjustment' 'TransferNone[TAdjustment]' (diff., need sugar)
proc gtk_container_get_focus_vadjustment(self: ptr TContainer): TransferNone[TAdjustment] {.cdecl, dynlib: lib, importc: "gtk_container_get_focus_vadjustment".}
proc get_focus_vadjustment*(self: Container): Adjustment {.inline.} =
  wrap(gtk_container_get_focus_vadjustment(self))
# proc get_focus_vadjustment*(self: Container): Adjustment {.inline.} =

# gtk_container_get_path_for_child
# flags: {isMethod} container: Container
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'TWidgetPath' 'ptr TWidgetPath' (diff., need sugar)
proc gtk_container_get_path_for_child(self: ptr TContainer, child: ptr TWidget): ptr TWidgetPath {.cdecl, dynlib: lib, importc: "gtk_container_get_path_for_child".}
proc get_path_for_child*(self: Container, child: Widget): TWidgetPath {.inline.} =
  (gtk_container_get_path_for_child(self, child.getPointer))[]
# proc get_path_for_child*(self: Container, child: Widget): TWidgetPath {.inline.} =

# gtk_container_get_resize_mode
# flags: {isMethod} container: Container (deprecated)
# gtk_container_propagate_draw
# flags: {isMethod} container: Container
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# cr 'cairo1.TContext' 'ptr cairo1.TContext' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_container_propagate_draw(self: ptr TContainer, child: ptr TWidget, cr: ptr cairo1.TContext) {.cdecl, dynlib: lib, importc: "gtk_container_propagate_draw".}
proc propagate_draw*(self: Container, child: Widget, cr: cairo1.TContext) {.inline.} =
  gtk_container_propagate_draw(self, child.getPointer, myUnsafeAddr(cr))
# proc propagate_draw*(self: Container, child: Widget, cr: cairo1.TContext) {.inline.} =

# gtk_container_remove
# flags: {isMethod} container: Container
# need sugar: is method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_container_remove(self: ptr TContainer, widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_container_remove".}
proc remove*(self: Container, widget: Widget) {.inline.} =
  gtk_container_remove(self, widget.getPointer)
# proc remove*(self: Container, widget: Widget) {.inline.} =

# gtk_container_resize_children
# flags: {isMethod} container: Container (deprecated)
# gtk_container_set_border_width
# flags: {isMethod} container: Container
# need sugar: is method
# border_width 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_container_set_border_width(self: ptr TContainer, border_width: uint32) {.cdecl, dynlib: lib, importc: "gtk_container_set_border_width".}
proc set_border_width*(self: Container, border_width: uint32) {.inline.} =
  gtk_container_set_border_width(self, border_width)
# proc set_border_width*(self: Container, border_width: uint32) {.inline.} =

# gtk_container_set_focus_chain
# flags: {isMethod} container: Container
# need sugar: is method
# focusable_widgets 'ptr GLIST_TODO' 'ptr GLIST_TODO' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_container_set_focus_chain(self: ptr TContainer, focusable_widgets: ptr GLIST_TODO) {.cdecl, dynlib: lib, importc: "gtk_container_set_focus_chain".}
proc set_focus_chain*(self: Container, focusable_widgets: ptr GLIST_TODO) {.inline.} =
  gtk_container_set_focus_chain(self, focusable_widgets)
# proc set_focus_chain*(self: Container, focusable_widgets: ptr GLIST_TODO) {.inline.} =

# gtk_container_set_focus_child
# flags: {isMethod} container: Container
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_container_set_focus_child(self: ptr TContainer, child: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_container_set_focus_child".}
proc set_focus_child*(self: Container, child: Widget) {.inline.} =
  gtk_container_set_focus_child(self, child.getPointer)
# proc set_focus_child*(self: Container, child: Widget) {.inline.} =

# gtk_container_set_focus_hadjustment
# flags: {isMethod} container: Container
# need sugar: is method
# adjustment 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_container_set_focus_hadjustment(self: ptr TContainer, adjustment: ptr TAdjustment) {.cdecl, dynlib: lib, importc: "gtk_container_set_focus_hadjustment".}
proc set_focus_hadjustment*(self: Container, adjustment: Adjustment) {.inline.} =
  gtk_container_set_focus_hadjustment(self, adjustment.getPointer)
# proc set_focus_hadjustment*(self: Container, adjustment: Adjustment) {.inline.} =

# gtk_container_set_focus_vadjustment
# flags: {isMethod} container: Container
# need sugar: is method
# adjustment 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_container_set_focus_vadjustment(self: ptr TContainer, adjustment: ptr TAdjustment) {.cdecl, dynlib: lib, importc: "gtk_container_set_focus_vadjustment".}
proc set_focus_vadjustment*(self: Container, adjustment: Adjustment) {.inline.} =
  gtk_container_set_focus_vadjustment(self, adjustment.getPointer)
# proc set_focus_vadjustment*(self: Container, adjustment: Adjustment) {.inline.} =

# gtk_container_set_reallocate_redraws
# flags: {isMethod} container: Container (deprecated)
# gtk_container_set_resize_mode
# flags: {isMethod} container: Container (deprecated)
# gtk_container_unset_focus_chain
# flags: {isMethod} container: Container
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_container_unset_focus_chain(self: ptr TContainer) {.cdecl, dynlib: lib, importc: "gtk_container_unset_focus_chain".}
proc unset_focus_chain*(self: Container) {.inline.} =
  gtk_container_unset_focus_chain(self)
# proc unset_focus_chain*(self: Container) {.inline.} =

# gtk_container_cell_accessible_new
# flags: {isConstructor} container: ContainerCellAccessible
# need sugar: is static method
# 'ContainerCellAccessible' 'TransferFull[TContainerCellAccessible]' (diff., need sugar)
proc gtk_container_cell_accessible_new(): TransferFull[TContainerCellAccessible] {.cdecl, dynlib: lib, importc: "gtk_container_cell_accessible_new".}
proc new_containercellaccessible*(): ContainerCellAccessible {.inline.} =
  wrap(gtk_container_cell_accessible_new())
# proc new_containercellaccessible*(): ContainerCellAccessible {.inline.} =

# gtk_container_cell_accessible_add_child
# flags: {isMethod} container: ContainerCellAccessible
# need sugar: is method
# child 'CellAccessible' 'ptr TCellAccessible' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_container_cell_accessible_add_child(self: ptr TContainerCellAccessible, child: ptr TCellAccessible) {.cdecl, dynlib: lib, importc: "gtk_container_cell_accessible_add_child".}
proc add_child*(self: ContainerCellAccessible, child: CellAccessible) {.inline.} =
  gtk_container_cell_accessible_add_child(self, child.getPointer)
# proc add_child*(self: ContainerCellAccessible, child: CellAccessible) {.inline.} =

# gtk_container_cell_accessible_get_children
# flags: {isMethod} container: ContainerCellAccessible
# need sugar: is method
# 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_container_cell_accessible_get_children(self: ptr TContainerCellAccessible): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_container_cell_accessible_get_children".}
proc get_children*(self: ContainerCellAccessible): ptr GLIST_TODO {.inline.} =
  gtk_container_cell_accessible_get_children(self)
# proc get_children*(self: ContainerCellAccessible): ptr GLIST_TODO {.inline.} =

# gtk_container_cell_accessible_remove_child
# flags: {isMethod} container: ContainerCellAccessible
# need sugar: is method
# child 'CellAccessible' 'ptr TCellAccessible' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_container_cell_accessible_remove_child(self: ptr TContainerCellAccessible, child: ptr TCellAccessible) {.cdecl, dynlib: lib, importc: "gtk_container_cell_accessible_remove_child".}
proc remove_child*(self: ContainerCellAccessible, child: CellAccessible) {.inline.} =
  gtk_container_cell_accessible_remove_child(self, child.getPointer)
# proc remove_child*(self: ContainerCellAccessible, child: CellAccessible) {.inline.} =

# gtk_css_provider_new
# flags: {isConstructor} container: CssProvider
# need sugar: is static method
# 'CssProvider' 'TransferFull[TCssProvider]' (diff., need sugar)
proc gtk_css_provider_new(): TransferFull[TCssProvider] {.cdecl, dynlib: lib, importc: "gtk_css_provider_new".}
proc new_cssprovider*(): CssProvider {.inline.} =
  wrap(gtk_css_provider_new())
# proc new_cssprovider*(): CssProvider {.inline.} =

# gtk_css_provider_get_default
# flags: {} container: CssProvider
# need sugar: is static method
# 'CssProvider' 'TransferNone[TCssProvider]' (diff., need sugar)
proc gtk_css_provider_get_default(): TransferNone[TCssProvider] {.cdecl, dynlib: lib, importc: "gtk_css_provider_get_default".}
template get_default*(klass_parameter: typedesc[CssProvider]): CssProvider =
  wrap(gtk_css_provider_get_default())
# template get_default*(klass_parameter: typedesc[CssProvider]): CssProvider =

# gtk_css_provider_get_named
# flags: {} container: CssProvider
# need sugar: is static method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# variant 'ustring' 'ucstring' IN (diff., need sugar)
# 'CssProvider' 'TransferNone[TCssProvider]' (diff., need sugar)
proc gtk_css_provider_get_named(name: ucstring, variant: ucstring): TransferNone[TCssProvider] {.cdecl, dynlib: lib, importc: "gtk_css_provider_get_named".}
template get_named*(klass_parameter: typedesc[CssProvider], name: ustring, variant: ustring): CssProvider =
  wrap(gtk_css_provider_get_named(ucstring(name), ucstring(variant)))
# template get_named*(klass_parameter: typedesc[CssProvider], name: ustring, variant: ustring): CssProvider =

# gtk_css_provider_load_from_data
# flags: {isMethod, throws} container: CssProvider
# can throw
# need sugar: is method
# data 'string' 'cstring' IN (diff., need sugar) array lengthArg: 1
# length 'int32' 'int32' IN
# 'bool' 'bool'
proc gtk_css_provider_load_from_data(self: ptr TCssProvider, data: cstring, length: int32, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_css_provider_load_from_data".}
proc load_from_data*(self: CssProvider, data: string): bool {.inline.} =
  gtk_css_provider_load_from_data(self, cstring(data), data.len.int32)
# proc load_from_data*(self: CssProvider, data: string): bool {.inline.} =

# gtk_css_provider_load_from_file
# flags: {isMethod, throws} container: CssProvider
# can throw
# need sugar: is method
# file 'Gio2.File' 'ptr Gio2.TFile' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_css_provider_load_from_file(self: ptr TCssProvider, file: ptr Gio2.TFile, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_css_provider_load_from_file".}
proc load_from_file*(self: CssProvider, file: Gio2.File): bool {.inline.} =
  gtk_css_provider_load_from_file(self, unwrap(file))
# proc load_from_file*(self: CssProvider, file: Gio2.File): bool {.inline.} =

# gtk_css_provider_load_from_path
# flags: {isMethod, throws} container: CssProvider
# can throw
# need sugar: is method
# path 'ustring' 'ucstring' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_css_provider_load_from_path(self: ptr TCssProvider, path: ucstring, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_css_provider_load_from_path".}
proc load_from_path*(self: CssProvider, path: ustring): bool {.inline.} =
  gtk_css_provider_load_from_path(self, ucstring(path))
# proc load_from_path*(self: CssProvider, path: ustring): bool {.inline.} =

# gtk_css_provider_to_string
# flags: {isMethod} container: CssProvider
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_css_provider_to_string(self: ptr TCssProvider): ucstring {.cdecl, dynlib: lib, importc: "gtk_css_provider_to_string".}
proc to_string*(self: CssProvider): ustring {.inline.} =
  ustring($(gtk_css_provider_to_string(self)))
# proc to_string*(self: CssProvider): ustring {.inline.} =

# gtk_dialog_new
# flags: {isConstructor} container: Dialog
# need sugar: is static method
# 'Dialog' 'TransferNone[TDialog]' (diff., need sugar)
proc gtk_dialog_new(): TransferNone[TDialog] {.cdecl, dynlib: lib, importc: "gtk_dialog_new".}
proc new_dialog*(): Dialog {.inline.} =
  wrap(gtk_dialog_new())
# proc new_dialog*(): Dialog {.inline.} =

# gtk_dialog_add_action_widget
# flags: {isMethod} container: Dialog
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# response_id 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_dialog_add_action_widget(self: ptr TDialog, child: ptr TWidget, response_id: int32) {.cdecl, dynlib: lib, importc: "gtk_dialog_add_action_widget".}
proc add_action_widget*(self: Dialog, child: Widget, response_id: int32) {.inline.} =
  gtk_dialog_add_action_widget(self, child.getPointer, response_id)
# proc add_action_widget*(self: Dialog, child: Widget, response_id: int32) {.inline.} =

# gtk_dialog_add_button
# flags: {isMethod} container: Dialog
# need sugar: is method
# button_text 'ustring' 'ucstring' IN (diff., need sugar)
# response_id 'int32' 'int32' IN
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_dialog_add_button(self: ptr TDialog, button_text: ucstring, response_id: int32): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_dialog_add_button".}
proc add_button*(self: Dialog, button_text: ustring, response_id: int32): Widget {.inline.} =
  wrap(gtk_dialog_add_button(self, ucstring(button_text), response_id))
# proc add_button*(self: Dialog, button_text: ustring, response_id: int32): Widget {.inline.} =

# gtk_dialog_get_action_area
# flags: {isMethod} container: Dialog (deprecated)
# gtk_dialog_get_content_area
# flags: {isMethod} container: Dialog
# need sugar: is method
# 'Box' 'TransferNone[TBox]' (diff., need sugar)
proc gtk_dialog_get_content_area(self: ptr TDialog): TransferNone[TBox] {.cdecl, dynlib: lib, importc: "gtk_dialog_get_content_area".}
proc get_content_area*(self: Dialog): Box {.inline.} =
  wrap(gtk_dialog_get_content_area(self))
# proc get_content_area*(self: Dialog): Box {.inline.} =

# gtk_dialog_get_header_bar
# flags: {isMethod} container: Dialog
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_dialog_get_header_bar(self: ptr TDialog): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_dialog_get_header_bar".}
proc get_header_bar*(self: Dialog): Widget {.inline.} =
  wrap(gtk_dialog_get_header_bar(self))
# proc get_header_bar*(self: Dialog): Widget {.inline.} =

# gtk_dialog_get_response_for_widget
# flags: {isMethod} container: Dialog
# need sugar: is method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'int32' 'int32'
proc gtk_dialog_get_response_for_widget(self: ptr TDialog, widget: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_dialog_get_response_for_widget".}
proc get_response_for_widget*(self: Dialog, widget: Widget): int32 {.inline.} =
  gtk_dialog_get_response_for_widget(self, widget.getPointer)
# proc get_response_for_widget*(self: Dialog, widget: Widget): int32 {.inline.} =

# gtk_dialog_get_widget_for_response
# flags: {isMethod} container: Dialog
# need sugar: is method
# response_id 'int32' 'int32' IN
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_dialog_get_widget_for_response(self: ptr TDialog, response_id: int32): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_dialog_get_widget_for_response".}
proc get_widget_for_response*(self: Dialog, response_id: int32): Widget {.inline.} =
  wrap(gtk_dialog_get_widget_for_response(self, response_id))
# proc get_widget_for_response*(self: Dialog, response_id: int32): Widget {.inline.} =

# gtk_dialog_response
# flags: {isMethod} container: Dialog
# need sugar: is method
# response_id 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_dialog_response(self: ptr TDialog, response_id: int32) {.cdecl, dynlib: lib, importc: "gtk_dialog_response".}
proc response*(self: Dialog, response_id: int32) {.inline.} =
  gtk_dialog_response(self, response_id)
# proc response*(self: Dialog, response_id: int32) {.inline.} =

# gtk_dialog_run
# flags: {isMethod} container: Dialog
# need sugar: is method
# 'int32' 'int32'
proc gtk_dialog_run(self: ptr TDialog): int32 {.cdecl, dynlib: lib, importc: "gtk_dialog_run".}
proc run*(self: Dialog): int32 {.inline.} =
  gtk_dialog_run(self)
# proc run*(self: Dialog): int32 {.inline.} =

# gtk_dialog_set_alternative_button_order_from_array
# flags: {isMethod} container: Dialog (deprecated)
# gtk_dialog_set_default_response
# flags: {isMethod} container: Dialog
# need sugar: is method
# response_id 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_dialog_set_default_response(self: ptr TDialog, response_id: int32) {.cdecl, dynlib: lib, importc: "gtk_dialog_set_default_response".}
proc set_default_response*(self: Dialog, response_id: int32) {.inline.} =
  gtk_dialog_set_default_response(self, response_id)
# proc set_default_response*(self: Dialog, response_id: int32) {.inline.} =

# gtk_dialog_set_response_sensitive
# flags: {isMethod} container: Dialog
# need sugar: is method
# response_id 'int32' 'int32' IN
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_dialog_set_response_sensitive(self: ptr TDialog, response_id: int32, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_dialog_set_response_sensitive".}
proc set_response_sensitive*(self: Dialog, response_id: int32, setting: bool) {.inline.} =
  gtk_dialog_set_response_sensitive(self, response_id, setting)
# proc set_response_sensitive*(self: Dialog, response_id: int32, setting: bool) {.inline.} =

# gtk_drawing_area_new
# flags: {isConstructor} container: DrawingArea
# need sugar: is static method
# 'DrawingArea' 'TransferNone[TDrawingArea]' (diff., need sugar)
proc gtk_drawing_area_new(): TransferNone[TDrawingArea] {.cdecl, dynlib: lib, importc: "gtk_drawing_area_new".}
proc new_drawingarea*(): DrawingArea {.inline.} =
  wrap(gtk_drawing_area_new())
# proc new_drawingarea*(): DrawingArea {.inline.} =

# gtk_entry_new
# flags: {isConstructor} container: Entry
# need sugar: is static method
# 'Entry' 'TransferNone[TEntry]' (diff., need sugar)
proc gtk_entry_new(): TransferNone[TEntry] {.cdecl, dynlib: lib, importc: "gtk_entry_new".}
proc new_entry*(): Entry {.inline.} =
  wrap(gtk_entry_new())
# proc new_entry*(): Entry {.inline.} =

# gtk_entry_new_with_buffer
# flags: {isConstructor} container: Entry
# need sugar: is static method
# buffer 'EntryBuffer' 'ptr TEntryBuffer' IN (diff., need sugar)
# 'Entry' 'TransferNone[TEntry]' (diff., need sugar)
proc gtk_entry_new_with_buffer(buffer: ptr TEntryBuffer): TransferNone[TEntry] {.cdecl, dynlib: lib, importc: "gtk_entry_new_with_buffer".}
proc new_entry_with_buffer*(buffer: EntryBuffer): Entry {.inline.} =
  wrap(gtk_entry_new_with_buffer(buffer.getPointer))
# proc new_entry_with_buffer*(buffer: EntryBuffer): Entry {.inline.} =

# gtk_entry_get_activates_default
# flags: {isMethod} container: Entry
# need sugar: is method
# 'bool' 'bool'
proc gtk_entry_get_activates_default(self: ptr TEntry): bool {.cdecl, dynlib: lib, importc: "gtk_entry_get_activates_default".}
proc get_activates_default*(self: Entry): bool {.inline.} =
  gtk_entry_get_activates_default(self)
# proc get_activates_default*(self: Entry): bool {.inline.} =

# gtk_entry_get_alignment
# flags: {isMethod} container: Entry
# need sugar: is method
# 'float32' 'float32'
proc gtk_entry_get_alignment(self: ptr TEntry): float32 {.cdecl, dynlib: lib, importc: "gtk_entry_get_alignment".}
proc get_alignment*(self: Entry): float32 {.inline.} =
  gtk_entry_get_alignment(self)
# proc get_alignment*(self: Entry): float32 {.inline.} =

# gtk_entry_get_attributes
# flags: {isMethod} container: Entry
# need sugar: is method
# 'Pango1.TAttrList' 'ptr Pango1.TAttrList' (diff., need sugar)
proc gtk_entry_get_attributes(self: ptr TEntry): ptr Pango1.TAttrList {.cdecl, dynlib: lib, importc: "gtk_entry_get_attributes".}
proc get_attributes*(self: Entry): Pango1.TAttrList {.inline.} =
  (gtk_entry_get_attributes(self))[]
# proc get_attributes*(self: Entry): Pango1.TAttrList {.inline.} =

# gtk_entry_get_buffer
# flags: {isMethod} container: Entry
# need sugar: is method
# 'EntryBuffer' 'TransferNone[TEntryBuffer]' (diff., need sugar)
proc gtk_entry_get_buffer(self: ptr TEntry): TransferNone[TEntryBuffer] {.cdecl, dynlib: lib, importc: "gtk_entry_get_buffer".}
proc get_buffer*(self: Entry): EntryBuffer {.inline.} =
  wrap(gtk_entry_get_buffer(self))
# proc get_buffer*(self: Entry): EntryBuffer {.inline.} =

# gtk_entry_get_completion
# flags: {isMethod} container: Entry
# need sugar: is method
# 'EntryCompletion' 'TransferNone[TEntryCompletion]' (diff., need sugar)
proc gtk_entry_get_completion(self: ptr TEntry): TransferNone[TEntryCompletion] {.cdecl, dynlib: lib, importc: "gtk_entry_get_completion".}
proc get_completion*(self: Entry): EntryCompletion {.inline.} =
  wrap(gtk_entry_get_completion(self))
# proc get_completion*(self: Entry): EntryCompletion {.inline.} =

# gtk_entry_get_current_icon_drag_source
# flags: {isMethod} container: Entry
# need sugar: is method
# 'int32' 'int32'
proc gtk_entry_get_current_icon_drag_source(self: ptr TEntry): int32 {.cdecl, dynlib: lib, importc: "gtk_entry_get_current_icon_drag_source".}
proc get_current_icon_drag_source*(self: Entry): int32 {.inline.} =
  gtk_entry_get_current_icon_drag_source(self)
# proc get_current_icon_drag_source*(self: Entry): int32 {.inline.} =

# gtk_entry_get_cursor_hadjustment
# flags: {isMethod} container: Entry
# need sugar: is method
# 'Adjustment' 'TransferNone[TAdjustment]' (diff., need sugar)
proc gtk_entry_get_cursor_hadjustment(self: ptr TEntry): TransferNone[TAdjustment] {.cdecl, dynlib: lib, importc: "gtk_entry_get_cursor_hadjustment".}
proc get_cursor_hadjustment*(self: Entry): Adjustment {.inline.} =
  wrap(gtk_entry_get_cursor_hadjustment(self))
# proc get_cursor_hadjustment*(self: Entry): Adjustment {.inline.} =

# gtk_entry_get_has_frame
# flags: {isMethod} container: Entry
# need sugar: is method
# 'bool' 'bool'
proc gtk_entry_get_has_frame(self: ptr TEntry): bool {.cdecl, dynlib: lib, importc: "gtk_entry_get_has_frame".}
proc get_has_frame*(self: Entry): bool {.inline.} =
  gtk_entry_get_has_frame(self)
# proc get_has_frame*(self: Entry): bool {.inline.} =

# gtk_entry_get_icon_activatable
# flags: {isMethod} container: Entry
# need sugar: is method
# icon_pos 'EntryIconPosition' 'EntryIconPosition' IN
# 'bool' 'bool'
proc gtk_entry_get_icon_activatable(self: ptr TEntry, icon_pos: EntryIconPosition): bool {.cdecl, dynlib: lib, importc: "gtk_entry_get_icon_activatable".}
proc get_icon_activatable*(self: Entry, icon_pos: EntryIconPosition): bool {.inline.} =
  gtk_entry_get_icon_activatable(self, icon_pos)
# proc get_icon_activatable*(self: Entry, icon_pos: EntryIconPosition): bool {.inline.} =

# gtk_entry_get_icon_area
# flags: {isMethod} container: Entry
# need sugar: is method
# icon_pos 'EntryIconPosition' 'EntryIconPosition' IN
# icon_area 'var cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_get_icon_area(self: ptr TEntry, icon_pos: EntryIconPosition, icon_area: ptr cairo1.TRectangleInt) {.cdecl, dynlib: lib, importc: "gtk_entry_get_icon_area".}
proc get_icon_area*(self: Entry, icon_pos: EntryIconPosition, icon_area: var cairo1.TRectangleInt) {.inline.} =
  gtk_entry_get_icon_area(self, icon_pos, addr(icon_area))
# tuple-return
# icon_area: var cairo1.TRectangleInt
# proc get_icon_area*(self: Entry, icon_pos: EntryIconPosition) {.inline.} =

# gtk_entry_get_icon_at_pos
# flags: {isMethod} container: Entry
# need sugar: is method
# x 'int32' 'int32' IN
# y 'int32' 'int32' IN
# 'int32' 'int32'
proc gtk_entry_get_icon_at_pos(self: ptr TEntry, x: int32, y: int32): int32 {.cdecl, dynlib: lib, importc: "gtk_entry_get_icon_at_pos".}
proc get_icon_at_pos*(self: Entry, x: int32, y: int32): int32 {.inline.} =
  gtk_entry_get_icon_at_pos(self, x, y)
# proc get_icon_at_pos*(self: Entry, x: int32, y: int32): int32 {.inline.} =

# gtk_entry_get_icon_gicon
# flags: {isMethod} container: Entry
# need sugar: is method
# icon_pos 'EntryIconPosition' 'EntryIconPosition' IN
# 'Gio2.Icon' 'TransferNone[Gio2.TIcon]' (diff., need sugar)
proc gtk_entry_get_icon_gicon(self: ptr TEntry, icon_pos: EntryIconPosition): TransferNone[Gio2.TIcon] {.cdecl, dynlib: lib, importc: "gtk_entry_get_icon_gicon".}
proc get_icon_gicon*(self: Entry, icon_pos: EntryIconPosition): Gio2.Icon {.inline.} =
  wrap(gtk_entry_get_icon_gicon(self, icon_pos))
# proc get_icon_gicon*(self: Entry, icon_pos: EntryIconPosition): Gio2.Icon {.inline.} =

# gtk_entry_get_icon_name
# flags: {isMethod} container: Entry
# need sugar: is method
# icon_pos 'EntryIconPosition' 'EntryIconPosition' IN
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_entry_get_icon_name(self: ptr TEntry, icon_pos: EntryIconPosition): ucstring {.cdecl, dynlib: lib, importc: "gtk_entry_get_icon_name".}
proc get_icon_name*(self: Entry, icon_pos: EntryIconPosition): ustring {.inline.} =
  ustring($(gtk_entry_get_icon_name(self, icon_pos)))
# proc get_icon_name*(self: Entry, icon_pos: EntryIconPosition): ustring {.inline.} =

# gtk_entry_get_icon_pixbuf
# flags: {isMethod} container: Entry
# need sugar: is method
# icon_pos 'EntryIconPosition' 'EntryIconPosition' IN
# 'GdkPixbuf2.Pixbuf' 'TransferNone[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_entry_get_icon_pixbuf(self: ptr TEntry, icon_pos: EntryIconPosition): TransferNone[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_entry_get_icon_pixbuf".}
proc get_icon_pixbuf*(self: Entry, icon_pos: EntryIconPosition): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_entry_get_icon_pixbuf(self, icon_pos))
# proc get_icon_pixbuf*(self: Entry, icon_pos: EntryIconPosition): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_entry_get_icon_sensitive
# flags: {isMethod} container: Entry
# need sugar: is method
# icon_pos 'EntryIconPosition' 'EntryIconPosition' IN
# 'bool' 'bool'
proc gtk_entry_get_icon_sensitive(self: ptr TEntry, icon_pos: EntryIconPosition): bool {.cdecl, dynlib: lib, importc: "gtk_entry_get_icon_sensitive".}
proc get_icon_sensitive*(self: Entry, icon_pos: EntryIconPosition): bool {.inline.} =
  gtk_entry_get_icon_sensitive(self, icon_pos)
# proc get_icon_sensitive*(self: Entry, icon_pos: EntryIconPosition): bool {.inline.} =

# gtk_entry_get_icon_stock
# flags: {isMethod} container: Entry (deprecated)
# gtk_entry_get_icon_storage_type
# flags: {isMethod} container: Entry
# need sugar: is method
# icon_pos 'EntryIconPosition' 'EntryIconPosition' IN
# 'ImageType' 'ImageType'
proc gtk_entry_get_icon_storage_type(self: ptr TEntry, icon_pos: EntryIconPosition): ImageType {.cdecl, dynlib: lib, importc: "gtk_entry_get_icon_storage_type".}
proc get_icon_storage_type*(self: Entry, icon_pos: EntryIconPosition): ImageType {.inline.} =
  gtk_entry_get_icon_storage_type(self, icon_pos)
# proc get_icon_storage_type*(self: Entry, icon_pos: EntryIconPosition): ImageType {.inline.} =

# gtk_entry_get_icon_tooltip_markup
# flags: {isMethod} container: Entry
# need sugar: is method
# icon_pos 'EntryIconPosition' 'EntryIconPosition' IN
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_entry_get_icon_tooltip_markup(self: ptr TEntry, icon_pos: EntryIconPosition): ucstring {.cdecl, dynlib: lib, importc: "gtk_entry_get_icon_tooltip_markup".}
proc get_icon_tooltip_markup*(self: Entry, icon_pos: EntryIconPosition): ustring {.inline.} =
  ustring($(gtk_entry_get_icon_tooltip_markup(self, icon_pos)))
# proc get_icon_tooltip_markup*(self: Entry, icon_pos: EntryIconPosition): ustring {.inline.} =

# gtk_entry_get_icon_tooltip_text
# flags: {isMethod} container: Entry
# need sugar: is method
# icon_pos 'EntryIconPosition' 'EntryIconPosition' IN
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_entry_get_icon_tooltip_text(self: ptr TEntry, icon_pos: EntryIconPosition): ucstring {.cdecl, dynlib: lib, importc: "gtk_entry_get_icon_tooltip_text".}
proc get_icon_tooltip_text*(self: Entry, icon_pos: EntryIconPosition): ustring {.inline.} =
  ustring($(gtk_entry_get_icon_tooltip_text(self, icon_pos)))
# proc get_icon_tooltip_text*(self: Entry, icon_pos: EntryIconPosition): ustring {.inline.} =

# gtk_entry_get_inner_border
# flags: {isMethod} container: Entry (deprecated)
# gtk_entry_get_input_hints
# flags: {isMethod} container: Entry
# need sugar: is method
# 'SInputHints' 'SInputHints'
proc gtk_entry_get_input_hints(self: ptr TEntry): SInputHints {.cdecl, dynlib: lib, importc: "gtk_entry_get_input_hints".}
proc get_input_hints*(self: Entry): SInputHints {.inline.} =
  gtk_entry_get_input_hints(self)
# proc get_input_hints*(self: Entry): SInputHints {.inline.} =

# gtk_entry_get_input_purpose
# flags: {isMethod} container: Entry
# need sugar: is method
# 'InputPurpose' 'InputPurpose'
proc gtk_entry_get_input_purpose(self: ptr TEntry): InputPurpose {.cdecl, dynlib: lib, importc: "gtk_entry_get_input_purpose".}
proc get_input_purpose*(self: Entry): InputPurpose {.inline.} =
  gtk_entry_get_input_purpose(self)
# proc get_input_purpose*(self: Entry): InputPurpose {.inline.} =

# gtk_entry_get_invisible_char
# flags: {isMethod} container: Entry
# need sugar: is method
# 'unichar' 'unichar'
proc gtk_entry_get_invisible_char(self: ptr TEntry): unichar {.cdecl, dynlib: lib, importc: "gtk_entry_get_invisible_char".}
proc get_invisible_char*(self: Entry): unichar {.inline.} =
  gtk_entry_get_invisible_char(self)
# proc get_invisible_char*(self: Entry): unichar {.inline.} =

# gtk_entry_get_layout
# flags: {isMethod} container: Entry
# need sugar: is method
# 'Pango1.Layout' 'TransferNone[Pango1.TLayout]' (diff., need sugar)
proc gtk_entry_get_layout(self: ptr TEntry): TransferNone[Pango1.TLayout] {.cdecl, dynlib: lib, importc: "gtk_entry_get_layout".}
proc get_layout*(self: Entry): Pango1.Layout {.inline.} =
  wrap(gtk_entry_get_layout(self))
# proc get_layout*(self: Entry): Pango1.Layout {.inline.} =

# gtk_entry_get_layout_offsets
# flags: {isMethod} container: Entry
# need sugar: is method
# x 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# y 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_get_layout_offsets(self: ptr TEntry, x: ptr int32, y: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_entry_get_layout_offsets".}
proc get_layout_offsets*(self: Entry, x: var int32, y: var int32) {.inline.} =
  gtk_entry_get_layout_offsets(self, addr(x), addr(y))
# tuple-return
# x: var int32
# y: var int32
# proc get_layout_offsets*(self: Entry) {.inline.} =

# gtk_entry_get_max_length
# flags: {isMethod} container: Entry
# need sugar: is method
# 'int32' 'int32'
proc gtk_entry_get_max_length(self: ptr TEntry): int32 {.cdecl, dynlib: lib, importc: "gtk_entry_get_max_length".}
proc get_max_length*(self: Entry): int32 {.inline.} =
  gtk_entry_get_max_length(self)
# proc get_max_length*(self: Entry): int32 {.inline.} =

# gtk_entry_get_max_width_chars
# flags: {isMethod} container: Entry
# need sugar: is method
# 'int32' 'int32'
proc gtk_entry_get_max_width_chars(self: ptr TEntry): int32 {.cdecl, dynlib: lib, importc: "gtk_entry_get_max_width_chars".}
proc get_max_width_chars*(self: Entry): int32 {.inline.} =
  gtk_entry_get_max_width_chars(self)
# proc get_max_width_chars*(self: Entry): int32 {.inline.} =

# gtk_entry_get_overwrite_mode
# flags: {isMethod} container: Entry
# need sugar: is method
# 'bool' 'bool'
proc gtk_entry_get_overwrite_mode(self: ptr TEntry): bool {.cdecl, dynlib: lib, importc: "gtk_entry_get_overwrite_mode".}
proc get_overwrite_mode*(self: Entry): bool {.inline.} =
  gtk_entry_get_overwrite_mode(self)
# proc get_overwrite_mode*(self: Entry): bool {.inline.} =

# gtk_entry_get_placeholder_text
# flags: {isMethod} container: Entry
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_entry_get_placeholder_text(self: ptr TEntry): ucstring {.cdecl, dynlib: lib, importc: "gtk_entry_get_placeholder_text".}
proc get_placeholder_text*(self: Entry): ustring {.inline.} =
  ustring($(gtk_entry_get_placeholder_text(self)))
# proc get_placeholder_text*(self: Entry): ustring {.inline.} =

# gtk_entry_get_progress_fraction
# flags: {isMethod} container: Entry
# need sugar: is method
# 'float64' 'float64'
proc gtk_entry_get_progress_fraction(self: ptr TEntry): float64 {.cdecl, dynlib: lib, importc: "gtk_entry_get_progress_fraction".}
proc get_progress_fraction*(self: Entry): float64 {.inline.} =
  gtk_entry_get_progress_fraction(self)
# proc get_progress_fraction*(self: Entry): float64 {.inline.} =

# gtk_entry_get_progress_pulse_step
# flags: {isMethod} container: Entry
# need sugar: is method
# 'float64' 'float64'
proc gtk_entry_get_progress_pulse_step(self: ptr TEntry): float64 {.cdecl, dynlib: lib, importc: "gtk_entry_get_progress_pulse_step".}
proc get_progress_pulse_step*(self: Entry): float64 {.inline.} =
  gtk_entry_get_progress_pulse_step(self)
# proc get_progress_pulse_step*(self: Entry): float64 {.inline.} =

# gtk_entry_get_tabs
# flags: {isMethod} container: Entry
# need sugar: is method
# 'Pango1.TTabArray' 'ptr Pango1.TTabArray' (diff., need sugar)
proc gtk_entry_get_tabs(self: ptr TEntry): ptr Pango1.TTabArray {.cdecl, dynlib: lib, importc: "gtk_entry_get_tabs".}
proc get_tabs*(self: Entry): Pango1.TTabArray {.inline.} =
  (gtk_entry_get_tabs(self))[]
# proc get_tabs*(self: Entry): Pango1.TTabArray {.inline.} =

# gtk_entry_get_text
# flags: {isMethod} container: Entry
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_entry_get_text(self: ptr TEntry): ucstring {.cdecl, dynlib: lib, importc: "gtk_entry_get_text".}
proc get_text*(self: Entry): ustring {.inline.} =
  ustring($(gtk_entry_get_text(self)))
# proc get_text*(self: Entry): ustring {.inline.} =

# gtk_entry_get_text_area
# flags: {isMethod} container: Entry
# need sugar: is method
# text_area 'var cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_get_text_area(self: ptr TEntry, text_area: ptr cairo1.TRectangleInt) {.cdecl, dynlib: lib, importc: "gtk_entry_get_text_area".}
proc get_text_area*(self: Entry, text_area: var cairo1.TRectangleInt) {.inline.} =
  gtk_entry_get_text_area(self, addr(text_area))
# tuple-return
# text_area: var cairo1.TRectangleInt
# proc get_text_area*(self: Entry) {.inline.} =

# gtk_entry_get_text_length
# flags: {isMethod} container: Entry
# need sugar: is method
# 'uint16' 'uint16'
proc gtk_entry_get_text_length(self: ptr TEntry): uint16 {.cdecl, dynlib: lib, importc: "gtk_entry_get_text_length".}
proc get_text_length*(self: Entry): uint16 {.inline.} =
  gtk_entry_get_text_length(self)
# proc get_text_length*(self: Entry): uint16 {.inline.} =

# gtk_entry_get_visibility
# flags: {isMethod} container: Entry
# need sugar: is method
# 'bool' 'bool'
proc gtk_entry_get_visibility(self: ptr TEntry): bool {.cdecl, dynlib: lib, importc: "gtk_entry_get_visibility".}
proc get_visibility*(self: Entry): bool {.inline.} =
  gtk_entry_get_visibility(self)
# proc get_visibility*(self: Entry): bool {.inline.} =

# gtk_entry_get_width_chars
# flags: {isMethod} container: Entry
# need sugar: is method
# 'int32' 'int32'
proc gtk_entry_get_width_chars(self: ptr TEntry): int32 {.cdecl, dynlib: lib, importc: "gtk_entry_get_width_chars".}
proc get_width_chars*(self: Entry): int32 {.inline.} =
  gtk_entry_get_width_chars(self)
# proc get_width_chars*(self: Entry): int32 {.inline.} =

# gtk_entry_im_context_filter_keypress
# flags: {isMethod} container: Entry
# need sugar: is method
# event 'Gdk3.TEventKey' 'ptr Gdk3.TEventKey' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_entry_im_context_filter_keypress(self: ptr TEntry, event: ptr Gdk3.TEventKey): bool {.cdecl, dynlib: lib, importc: "gtk_entry_im_context_filter_keypress".}
proc im_context_filter_keypress*(self: Entry, event: Gdk3.TEventKey): bool {.inline.} =
  gtk_entry_im_context_filter_keypress(self, myUnsafeAddr(event))
# proc im_context_filter_keypress*(self: Entry, event: Gdk3.TEventKey): bool {.inline.} =

# gtk_entry_layout_index_to_text_index
# flags: {isMethod} container: Entry
# need sugar: is method
# layout_index 'int32' 'int32' IN
# 'int32' 'int32'
proc gtk_entry_layout_index_to_text_index(self: ptr TEntry, layout_index: int32): int32 {.cdecl, dynlib: lib, importc: "gtk_entry_layout_index_to_text_index".}
proc layout_index_to_text_index*(self: Entry, layout_index: int32): int32 {.inline.} =
  gtk_entry_layout_index_to_text_index(self, layout_index)
# proc layout_index_to_text_index*(self: Entry, layout_index: int32): int32 {.inline.} =

# gtk_entry_progress_pulse
# flags: {isMethod} container: Entry
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_progress_pulse(self: ptr TEntry) {.cdecl, dynlib: lib, importc: "gtk_entry_progress_pulse".}
proc progress_pulse*(self: Entry) {.inline.} =
  gtk_entry_progress_pulse(self)
# proc progress_pulse*(self: Entry) {.inline.} =

# gtk_entry_reset_im_context
# flags: {isMethod} container: Entry
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_reset_im_context(self: ptr TEntry) {.cdecl, dynlib: lib, importc: "gtk_entry_reset_im_context".}
proc reset_im_context*(self: Entry) {.inline.} =
  gtk_entry_reset_im_context(self)
# proc reset_im_context*(self: Entry) {.inline.} =

# gtk_entry_set_activates_default
# flags: {isMethod} container: Entry
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_activates_default(self: ptr TEntry, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_entry_set_activates_default".}
proc set_activates_default*(self: Entry, setting: bool) {.inline.} =
  gtk_entry_set_activates_default(self, setting)
# proc set_activates_default*(self: Entry, setting: bool) {.inline.} =

# gtk_entry_set_alignment
# flags: {isMethod} container: Entry
# need sugar: is method
# xalign 'float32' 'float32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_alignment(self: ptr TEntry, xalign: float32) {.cdecl, dynlib: lib, importc: "gtk_entry_set_alignment".}
proc set_alignment*(self: Entry, xalign: float32) {.inline.} =
  gtk_entry_set_alignment(self, xalign)
# proc set_alignment*(self: Entry, xalign: float32) {.inline.} =

# gtk_entry_set_attributes
# flags: {isMethod} container: Entry
# need sugar: is method
# attrs 'Pango1.TAttrList' 'ptr Pango1.TAttrList' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_attributes(self: ptr TEntry, attrs: ptr Pango1.TAttrList) {.cdecl, dynlib: lib, importc: "gtk_entry_set_attributes".}
proc set_attributes*(self: Entry, attrs: Pango1.TAttrList) {.inline.} =
  gtk_entry_set_attributes(self, myUnsafeAddr(attrs))
# proc set_attributes*(self: Entry, attrs: Pango1.TAttrList) {.inline.} =

# gtk_entry_set_buffer
# flags: {isMethod} container: Entry
# need sugar: is method
# buffer 'EntryBuffer' 'ptr TEntryBuffer' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_buffer(self: ptr TEntry, buffer: ptr TEntryBuffer) {.cdecl, dynlib: lib, importc: "gtk_entry_set_buffer".}
proc set_buffer*(self: Entry, buffer: EntryBuffer) {.inline.} =
  gtk_entry_set_buffer(self, buffer.getPointer)
# proc set_buffer*(self: Entry, buffer: EntryBuffer) {.inline.} =

# gtk_entry_set_completion
# flags: {isMethod} container: Entry
# need sugar: is method
# completion 'EntryCompletion' 'ptr TEntryCompletion' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_completion(self: ptr TEntry, completion: ptr TEntryCompletion) {.cdecl, dynlib: lib, importc: "gtk_entry_set_completion".}
proc set_completion*(self: Entry, completion: EntryCompletion) {.inline.} =
  gtk_entry_set_completion(self, completion.getPointer)
# proc set_completion*(self: Entry, completion: EntryCompletion) {.inline.} =

# gtk_entry_set_cursor_hadjustment
# flags: {isMethod} container: Entry
# need sugar: is method
# adjustment 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_cursor_hadjustment(self: ptr TEntry, adjustment: ptr TAdjustment) {.cdecl, dynlib: lib, importc: "gtk_entry_set_cursor_hadjustment".}
proc set_cursor_hadjustment*(self: Entry, adjustment: Adjustment) {.inline.} =
  gtk_entry_set_cursor_hadjustment(self, adjustment.getPointer)
# proc set_cursor_hadjustment*(self: Entry, adjustment: Adjustment) {.inline.} =

# gtk_entry_set_has_frame
# flags: {isMethod} container: Entry
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_has_frame(self: ptr TEntry, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_entry_set_has_frame".}
proc set_has_frame*(self: Entry, setting: bool) {.inline.} =
  gtk_entry_set_has_frame(self, setting)
# proc set_has_frame*(self: Entry, setting: bool) {.inline.} =

# gtk_entry_set_icon_activatable
# flags: {isMethod} container: Entry
# need sugar: is method
# icon_pos 'EntryIconPosition' 'EntryIconPosition' IN
# activatable 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_icon_activatable(self: ptr TEntry, icon_pos: EntryIconPosition, activatable: bool) {.cdecl, dynlib: lib, importc: "gtk_entry_set_icon_activatable".}
proc set_icon_activatable*(self: Entry, icon_pos: EntryIconPosition, activatable: bool) {.inline.} =
  gtk_entry_set_icon_activatable(self, icon_pos, activatable)
# proc set_icon_activatable*(self: Entry, icon_pos: EntryIconPosition, activatable: bool) {.inline.} =

# gtk_entry_set_icon_drag_source
# flags: {isMethod} container: Entry
# need sugar: is method
# icon_pos 'EntryIconPosition' 'EntryIconPosition' IN
# target_list 'TTargetList' 'ptr TTargetList' IN (diff., need sugar)
# actions 'Gdk3.SDragAction' 'Gdk3.SDragAction' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_icon_drag_source(self: ptr TEntry, icon_pos: EntryIconPosition, target_list: ptr TTargetList, actions: Gdk3.SDragAction) {.cdecl, dynlib: lib, importc: "gtk_entry_set_icon_drag_source".}
proc set_icon_drag_source*(self: Entry, icon_pos: EntryIconPosition, target_list: TTargetList, actions: Gdk3.SDragAction) {.inline.} =
  gtk_entry_set_icon_drag_source(self, icon_pos, myUnsafeAddr(target_list), actions)
# proc set_icon_drag_source*(self: Entry, icon_pos: EntryIconPosition, target_list: TTargetList, actions: Gdk3.SDragAction) {.inline.} =

# gtk_entry_set_icon_from_gicon
# flags: {isMethod} container: Entry
# need sugar: is method
# icon_pos 'EntryIconPosition' 'EntryIconPosition' IN
# icon 'Gio2.Icon' 'ptr Gio2.TIcon' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_icon_from_gicon(self: ptr TEntry, icon_pos: EntryIconPosition, icon: ptr Gio2.TIcon) {.cdecl, dynlib: lib, importc: "gtk_entry_set_icon_from_gicon".}
proc set_icon_from_gicon*(self: Entry, icon_pos: EntryIconPosition, icon: Gio2.Icon) {.inline.} =
  gtk_entry_set_icon_from_gicon(self, icon_pos, unwrap(icon))
# proc set_icon_from_gicon*(self: Entry, icon_pos: EntryIconPosition, icon: Gio2.Icon) {.inline.} =

# gtk_entry_set_icon_from_icon_name
# flags: {isMethod} container: Entry
# need sugar: is method
# icon_pos 'EntryIconPosition' 'EntryIconPosition' IN
# icon_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_icon_from_icon_name(self: ptr TEntry, icon_pos: EntryIconPosition, icon_name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_entry_set_icon_from_icon_name".}
proc set_icon_from_icon_name*(self: Entry, icon_pos: EntryIconPosition, icon_name: ustring) {.inline.} =
  gtk_entry_set_icon_from_icon_name(self, icon_pos, ucstring(icon_name))
# proc set_icon_from_icon_name*(self: Entry, icon_pos: EntryIconPosition, icon_name: ustring) {.inline.} =

# gtk_entry_set_icon_from_pixbuf
# flags: {isMethod} container: Entry
# need sugar: is method
# icon_pos 'EntryIconPosition' 'EntryIconPosition' IN
# pixbuf 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_icon_from_pixbuf(self: ptr TEntry, icon_pos: EntryIconPosition, pixbuf: ptr GdkPixbuf2.TPixbuf) {.cdecl, dynlib: lib, importc: "gtk_entry_set_icon_from_pixbuf".}
proc set_icon_from_pixbuf*(self: Entry, icon_pos: EntryIconPosition, pixbuf: GdkPixbuf2.Pixbuf) {.inline.} =
  gtk_entry_set_icon_from_pixbuf(self, icon_pos, pixbuf.getPointer)
# proc set_icon_from_pixbuf*(self: Entry, icon_pos: EntryIconPosition, pixbuf: GdkPixbuf2.Pixbuf) {.inline.} =

# gtk_entry_set_icon_from_stock
# flags: {isMethod} container: Entry (deprecated)
# gtk_entry_set_icon_sensitive
# flags: {isMethod} container: Entry
# need sugar: is method
# icon_pos 'EntryIconPosition' 'EntryIconPosition' IN
# sensitive 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_icon_sensitive(self: ptr TEntry, icon_pos: EntryIconPosition, sensitive: bool) {.cdecl, dynlib: lib, importc: "gtk_entry_set_icon_sensitive".}
proc set_icon_sensitive*(self: Entry, icon_pos: EntryIconPosition, sensitive: bool) {.inline.} =
  gtk_entry_set_icon_sensitive(self, icon_pos, sensitive)
# proc set_icon_sensitive*(self: Entry, icon_pos: EntryIconPosition, sensitive: bool) {.inline.} =

# gtk_entry_set_icon_tooltip_markup
# flags: {isMethod} container: Entry
# need sugar: is method
# icon_pos 'EntryIconPosition' 'EntryIconPosition' IN
# tooltip 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_icon_tooltip_markup(self: ptr TEntry, icon_pos: EntryIconPosition, tooltip: ucstring) {.cdecl, dynlib: lib, importc: "gtk_entry_set_icon_tooltip_markup".}
proc set_icon_tooltip_markup*(self: Entry, icon_pos: EntryIconPosition, tooltip: ustring) {.inline.} =
  gtk_entry_set_icon_tooltip_markup(self, icon_pos, ucstring(tooltip))
# proc set_icon_tooltip_markup*(self: Entry, icon_pos: EntryIconPosition, tooltip: ustring) {.inline.} =

# gtk_entry_set_icon_tooltip_text
# flags: {isMethod} container: Entry
# need sugar: is method
# icon_pos 'EntryIconPosition' 'EntryIconPosition' IN
# tooltip 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_icon_tooltip_text(self: ptr TEntry, icon_pos: EntryIconPosition, tooltip: ucstring) {.cdecl, dynlib: lib, importc: "gtk_entry_set_icon_tooltip_text".}
proc set_icon_tooltip_text*(self: Entry, icon_pos: EntryIconPosition, tooltip: ustring) {.inline.} =
  gtk_entry_set_icon_tooltip_text(self, icon_pos, ucstring(tooltip))
# proc set_icon_tooltip_text*(self: Entry, icon_pos: EntryIconPosition, tooltip: ustring) {.inline.} =

# gtk_entry_set_inner_border
# flags: {isMethod} container: Entry (deprecated)
# gtk_entry_set_input_hints
# flags: {isMethod} container: Entry
# need sugar: is method
# hints 'SInputHints' 'SInputHints' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_input_hints(self: ptr TEntry, hints: SInputHints) {.cdecl, dynlib: lib, importc: "gtk_entry_set_input_hints".}
proc set_input_hints*(self: Entry, hints: SInputHints) {.inline.} =
  gtk_entry_set_input_hints(self, hints)
# proc set_input_hints*(self: Entry, hints: SInputHints) {.inline.} =

# gtk_entry_set_input_purpose
# flags: {isMethod} container: Entry
# need sugar: is method
# purpose 'InputPurpose' 'InputPurpose' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_input_purpose(self: ptr TEntry, purpose: InputPurpose) {.cdecl, dynlib: lib, importc: "gtk_entry_set_input_purpose".}
proc set_input_purpose*(self: Entry, purpose: InputPurpose) {.inline.} =
  gtk_entry_set_input_purpose(self, purpose)
# proc set_input_purpose*(self: Entry, purpose: InputPurpose) {.inline.} =

# gtk_entry_set_invisible_char
# flags: {isMethod} container: Entry
# need sugar: is method
# ch 'unichar' 'unichar' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_invisible_char(self: ptr TEntry, ch: unichar) {.cdecl, dynlib: lib, importc: "gtk_entry_set_invisible_char".}
proc set_invisible_char*(self: Entry, ch: unichar) {.inline.} =
  gtk_entry_set_invisible_char(self, ch)
# proc set_invisible_char*(self: Entry, ch: unichar) {.inline.} =

# gtk_entry_set_max_length
# flags: {isMethod} container: Entry
# need sugar: is method
# max 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_max_length(self: ptr TEntry, max: int32) {.cdecl, dynlib: lib, importc: "gtk_entry_set_max_length".}
proc set_max_length*(self: Entry, max: int32) {.inline.} =
  gtk_entry_set_max_length(self, max)
# proc set_max_length*(self: Entry, max: int32) {.inline.} =

# gtk_entry_set_max_width_chars
# flags: {isMethod} container: Entry
# need sugar: is method
# n_chars 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_max_width_chars(self: ptr TEntry, n_chars: int32) {.cdecl, dynlib: lib, importc: "gtk_entry_set_max_width_chars".}
proc set_max_width_chars*(self: Entry, n_chars: int32) {.inline.} =
  gtk_entry_set_max_width_chars(self, n_chars)
# proc set_max_width_chars*(self: Entry, n_chars: int32) {.inline.} =

# gtk_entry_set_overwrite_mode
# flags: {isMethod} container: Entry
# need sugar: is method
# overwrite 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_overwrite_mode(self: ptr TEntry, overwrite: bool) {.cdecl, dynlib: lib, importc: "gtk_entry_set_overwrite_mode".}
proc set_overwrite_mode*(self: Entry, overwrite: bool) {.inline.} =
  gtk_entry_set_overwrite_mode(self, overwrite)
# proc set_overwrite_mode*(self: Entry, overwrite: bool) {.inline.} =

# gtk_entry_set_placeholder_text
# flags: {isMethod} container: Entry
# need sugar: is method
# text 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_placeholder_text(self: ptr TEntry, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_entry_set_placeholder_text".}
proc set_placeholder_text*(self: Entry, text: ustring) {.inline.} =
  gtk_entry_set_placeholder_text(self, ucstring(text))
# proc set_placeholder_text*(self: Entry, text: ustring) {.inline.} =

# gtk_entry_set_progress_fraction
# flags: {isMethod} container: Entry
# need sugar: is method
# fraction 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_progress_fraction(self: ptr TEntry, fraction: float64) {.cdecl, dynlib: lib, importc: "gtk_entry_set_progress_fraction".}
proc set_progress_fraction*(self: Entry, fraction: float64) {.inline.} =
  gtk_entry_set_progress_fraction(self, fraction)
# proc set_progress_fraction*(self: Entry, fraction: float64) {.inline.} =

# gtk_entry_set_progress_pulse_step
# flags: {isMethod} container: Entry
# need sugar: is method
# fraction 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_progress_pulse_step(self: ptr TEntry, fraction: float64) {.cdecl, dynlib: lib, importc: "gtk_entry_set_progress_pulse_step".}
proc set_progress_pulse_step*(self: Entry, fraction: float64) {.inline.} =
  gtk_entry_set_progress_pulse_step(self, fraction)
# proc set_progress_pulse_step*(self: Entry, fraction: float64) {.inline.} =

# gtk_entry_set_tabs
# flags: {isMethod} container: Entry
# need sugar: is method
# tabs 'Pango1.TTabArray' 'ptr Pango1.TTabArray' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_tabs(self: ptr TEntry, tabs: ptr Pango1.TTabArray) {.cdecl, dynlib: lib, importc: "gtk_entry_set_tabs".}
proc set_tabs*(self: Entry, tabs: Pango1.TTabArray) {.inline.} =
  gtk_entry_set_tabs(self, myUnsafeAddr(tabs))
# proc set_tabs*(self: Entry, tabs: Pango1.TTabArray) {.inline.} =

# gtk_entry_set_text
# flags: {isMethod} container: Entry
# need sugar: is method
# text 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_text(self: ptr TEntry, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_entry_set_text".}
proc set_text*(self: Entry, text: ustring) {.inline.} =
  gtk_entry_set_text(self, ucstring(text))
# proc set_text*(self: Entry, text: ustring) {.inline.} =

# gtk_entry_set_visibility
# flags: {isMethod} container: Entry
# need sugar: is method
# visible 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_visibility(self: ptr TEntry, visible: bool) {.cdecl, dynlib: lib, importc: "gtk_entry_set_visibility".}
proc set_visibility*(self: Entry, visible: bool) {.inline.} =
  gtk_entry_set_visibility(self, visible)
# proc set_visibility*(self: Entry, visible: bool) {.inline.} =

# gtk_entry_set_width_chars
# flags: {isMethod} container: Entry
# need sugar: is method
# n_chars 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_width_chars(self: ptr TEntry, n_chars: int32) {.cdecl, dynlib: lib, importc: "gtk_entry_set_width_chars".}
proc set_width_chars*(self: Entry, n_chars: int32) {.inline.} =
  gtk_entry_set_width_chars(self, n_chars)
# proc set_width_chars*(self: Entry, n_chars: int32) {.inline.} =

# gtk_entry_text_index_to_layout_index
# flags: {isMethod} container: Entry
# need sugar: is method
# text_index 'int32' 'int32' IN
# 'int32' 'int32'
proc gtk_entry_text_index_to_layout_index(self: ptr TEntry, text_index: int32): int32 {.cdecl, dynlib: lib, importc: "gtk_entry_text_index_to_layout_index".}
proc text_index_to_layout_index*(self: Entry, text_index: int32): int32 {.inline.} =
  gtk_entry_text_index_to_layout_index(self, text_index)
# proc text_index_to_layout_index*(self: Entry, text_index: int32): int32 {.inline.} =

# gtk_entry_unset_invisible_char
# flags: {isMethod} container: Entry
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_unset_invisible_char(self: ptr TEntry) {.cdecl, dynlib: lib, importc: "gtk_entry_unset_invisible_char".}
proc unset_invisible_char*(self: Entry) {.inline.} =
  gtk_entry_unset_invisible_char(self)
# proc unset_invisible_char*(self: Entry) {.inline.} =

# gtk_entry_buffer_new
# flags: {isConstructor} container: EntryBuffer
# need sugar: is static method
# initial_chars 'ustring' 'ucstring' IN (diff., need sugar)
# n_initial_chars 'int32' 'int32' IN
# 'EntryBuffer' 'TransferFull[TEntryBuffer]' (diff., need sugar)
proc gtk_entry_buffer_new(initial_chars: ucstring, n_initial_chars: int32): TransferFull[TEntryBuffer] {.cdecl, dynlib: lib, importc: "gtk_entry_buffer_new".}
proc new_entrybuffer*(initial_chars: ustring, n_initial_chars: int32): EntryBuffer {.inline.} =
  wrap(gtk_entry_buffer_new(ucstring(initial_chars), n_initial_chars))
# proc new_entrybuffer*(initial_chars: ustring, n_initial_chars: int32): EntryBuffer {.inline.} =

# gtk_entry_buffer_delete_text
# flags: {isMethod} container: EntryBuffer
# need sugar: is method
# position 'uint32' 'uint32' IN
# n_chars 'int32' 'int32' IN
# 'uint32' 'uint32'
proc gtk_entry_buffer_delete_text(self: ptr TEntryBuffer, position: uint32, n_chars: int32): uint32 {.cdecl, dynlib: lib, importc: "gtk_entry_buffer_delete_text".}
proc delete_text*(self: EntryBuffer, position: uint32, n_chars: int32): uint32 {.inline.} =
  gtk_entry_buffer_delete_text(self, position, n_chars)
# proc delete_text*(self: EntryBuffer, position: uint32, n_chars: int32): uint32 {.inline.} =

# gtk_entry_buffer_emit_deleted_text
# flags: {isMethod} container: EntryBuffer
# need sugar: is method
# position 'uint32' 'uint32' IN
# n_chars 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_buffer_emit_deleted_text(self: ptr TEntryBuffer, position: uint32, n_chars: uint32) {.cdecl, dynlib: lib, importc: "gtk_entry_buffer_emit_deleted_text".}
proc emit_deleted_text*(self: EntryBuffer, position: uint32, n_chars: uint32) {.inline.} =
  gtk_entry_buffer_emit_deleted_text(self, position, n_chars)
# proc emit_deleted_text*(self: EntryBuffer, position: uint32, n_chars: uint32) {.inline.} =

# gtk_entry_buffer_emit_inserted_text
# flags: {isMethod} container: EntryBuffer
# need sugar: is method
# position 'uint32' 'uint32' IN
# chars 'ustring' 'ucstring' IN (diff., need sugar)
# n_chars 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_buffer_emit_inserted_text(self: ptr TEntryBuffer, position: uint32, chars: ucstring, n_chars: uint32) {.cdecl, dynlib: lib, importc: "gtk_entry_buffer_emit_inserted_text".}
proc emit_inserted_text*(self: EntryBuffer, position: uint32, chars: ustring, n_chars: uint32) {.inline.} =
  gtk_entry_buffer_emit_inserted_text(self, position, ucstring(chars), n_chars)
# proc emit_inserted_text*(self: EntryBuffer, position: uint32, chars: ustring, n_chars: uint32) {.inline.} =

# gtk_entry_buffer_get_bytes
# flags: {isMethod} container: EntryBuffer
# need sugar: is method
# 'uint32' 'uint32'
proc gtk_entry_buffer_get_bytes(self: ptr TEntryBuffer): uint32 {.cdecl, dynlib: lib, importc: "gtk_entry_buffer_get_bytes".}
proc get_bytes*(self: EntryBuffer): uint32 {.inline.} =
  gtk_entry_buffer_get_bytes(self)
# proc get_bytes*(self: EntryBuffer): uint32 {.inline.} =

# gtk_entry_buffer_get_length
# flags: {isMethod} container: EntryBuffer
# need sugar: is method
# 'uint32' 'uint32'
proc gtk_entry_buffer_get_length(self: ptr TEntryBuffer): uint32 {.cdecl, dynlib: lib, importc: "gtk_entry_buffer_get_length".}
proc get_length*(self: EntryBuffer): uint32 {.inline.} =
  gtk_entry_buffer_get_length(self)
# proc get_length*(self: EntryBuffer): uint32 {.inline.} =

# gtk_entry_buffer_get_max_length
# flags: {isMethod} container: EntryBuffer
# need sugar: is method
# 'int32' 'int32'
proc gtk_entry_buffer_get_max_length(self: ptr TEntryBuffer): int32 {.cdecl, dynlib: lib, importc: "gtk_entry_buffer_get_max_length".}
proc get_max_length*(self: EntryBuffer): int32 {.inline.} =
  gtk_entry_buffer_get_max_length(self)
# proc get_max_length*(self: EntryBuffer): int32 {.inline.} =

# gtk_entry_buffer_get_text
# flags: {isMethod} container: EntryBuffer
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_entry_buffer_get_text(self: ptr TEntryBuffer): ucstring {.cdecl, dynlib: lib, importc: "gtk_entry_buffer_get_text".}
proc get_text*(self: EntryBuffer): ustring {.inline.} =
  ustring($(gtk_entry_buffer_get_text(self)))
# proc get_text*(self: EntryBuffer): ustring {.inline.} =

# gtk_entry_buffer_insert_text
# flags: {isMethod} container: EntryBuffer
# need sugar: is method
# position 'uint32' 'uint32' IN
# chars 'ustring' 'ucstring' IN (diff., need sugar)
# n_chars 'int32' 'int32' IN
# 'uint32' 'uint32'
proc gtk_entry_buffer_insert_text(self: ptr TEntryBuffer, position: uint32, chars: ucstring, n_chars: int32): uint32 {.cdecl, dynlib: lib, importc: "gtk_entry_buffer_insert_text".}
proc insert_text*(self: EntryBuffer, position: uint32, chars: ustring, n_chars: int32): uint32 {.inline.} =
  gtk_entry_buffer_insert_text(self, position, ucstring(chars), n_chars)
# proc insert_text*(self: EntryBuffer, position: uint32, chars: ustring, n_chars: int32): uint32 {.inline.} =

# gtk_entry_buffer_set_max_length
# flags: {isMethod} container: EntryBuffer
# need sugar: is method
# max_length 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_buffer_set_max_length(self: ptr TEntryBuffer, max_length: int32) {.cdecl, dynlib: lib, importc: "gtk_entry_buffer_set_max_length".}
proc set_max_length*(self: EntryBuffer, max_length: int32) {.inline.} =
  gtk_entry_buffer_set_max_length(self, max_length)
# proc set_max_length*(self: EntryBuffer, max_length: int32) {.inline.} =

# gtk_entry_buffer_set_text
# flags: {isMethod} container: EntryBuffer
# need sugar: is method
# chars 'ustring' 'ucstring' IN (diff., need sugar)
# n_chars 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_buffer_set_text(self: ptr TEntryBuffer, chars: ucstring, n_chars: int32) {.cdecl, dynlib: lib, importc: "gtk_entry_buffer_set_text".}
proc set_text*(self: EntryBuffer, chars: ustring, n_chars: int32) {.inline.} =
  gtk_entry_buffer_set_text(self, ucstring(chars), n_chars)
# proc set_text*(self: EntryBuffer, chars: ustring, n_chars: int32) {.inline.} =

# gtk_entry_completion_new
# flags: {isConstructor} container: EntryCompletion
# need sugar: is static method
# 'EntryCompletion' 'TransferFull[TEntryCompletion]' (diff., need sugar)
proc gtk_entry_completion_new(): TransferFull[TEntryCompletion] {.cdecl, dynlib: lib, importc: "gtk_entry_completion_new".}
proc new_entrycompletion*(): EntryCompletion {.inline.} =
  wrap(gtk_entry_completion_new())
# proc new_entrycompletion*(): EntryCompletion {.inline.} =

# gtk_entry_completion_new_with_area
# flags: {isConstructor} container: EntryCompletion
# need sugar: is static method
# area 'CellArea' 'ptr TCellArea' IN (diff., need sugar)
# 'EntryCompletion' 'TransferFull[TEntryCompletion]' (diff., need sugar)
proc gtk_entry_completion_new_with_area(area: ptr TCellArea): TransferFull[TEntryCompletion] {.cdecl, dynlib: lib, importc: "gtk_entry_completion_new_with_area".}
proc new_entrycompletion_with_area*(area: CellArea): EntryCompletion {.inline.} =
  wrap(gtk_entry_completion_new_with_area(area.getPointer))
# proc new_entrycompletion_with_area*(area: CellArea): EntryCompletion {.inline.} =

# gtk_entry_completion_complete
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_complete(self: ptr TEntryCompletion) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_complete".}
proc complete*(self: EntryCompletion) {.inline.} =
  gtk_entry_completion_complete(self)
# proc complete*(self: EntryCompletion) {.inline.} =

# gtk_entry_completion_compute_prefix
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# key 'ustring' 'ucstring' IN (diff., need sugar)
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_entry_completion_compute_prefix(self: ptr TEntryCompletion, key: ucstring): ucstring {.cdecl, dynlib: lib, importc: "gtk_entry_completion_compute_prefix".}
proc compute_prefix*(self: EntryCompletion, key: ustring): ustring {.inline.} =
  ustring($(gtk_entry_completion_compute_prefix(self, ucstring(key))))
# proc compute_prefix*(self: EntryCompletion, key: ustring): ustring {.inline.} =

# gtk_entry_completion_delete_action
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# index_ 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_delete_action(self: ptr TEntryCompletion, index_x: int32) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_delete_action".}
proc delete_action*(self: EntryCompletion, index_x: int32) {.inline.} =
  gtk_entry_completion_delete_action(self, index_x)
# proc delete_action*(self: EntryCompletion, index_x: int32) {.inline.} =

# gtk_entry_completion_get_completion_prefix
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_entry_completion_get_completion_prefix(self: ptr TEntryCompletion): ucstring {.cdecl, dynlib: lib, importc: "gtk_entry_completion_get_completion_prefix".}
proc get_completion_prefix*(self: EntryCompletion): ustring {.inline.} =
  ustring($(gtk_entry_completion_get_completion_prefix(self)))
# proc get_completion_prefix*(self: EntryCompletion): ustring {.inline.} =

# gtk_entry_completion_get_entry
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_entry_completion_get_entry(self: ptr TEntryCompletion): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_entry_completion_get_entry".}
proc get_entry*(self: EntryCompletion): Widget {.inline.} =
  wrap(gtk_entry_completion_get_entry(self))
# proc get_entry*(self: EntryCompletion): Widget {.inline.} =

# gtk_entry_completion_get_inline_completion
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# 'bool' 'bool'
proc gtk_entry_completion_get_inline_completion(self: ptr TEntryCompletion): bool {.cdecl, dynlib: lib, importc: "gtk_entry_completion_get_inline_completion".}
proc get_inline_completion*(self: EntryCompletion): bool {.inline.} =
  gtk_entry_completion_get_inline_completion(self)
# proc get_inline_completion*(self: EntryCompletion): bool {.inline.} =

# gtk_entry_completion_get_inline_selection
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# 'bool' 'bool'
proc gtk_entry_completion_get_inline_selection(self: ptr TEntryCompletion): bool {.cdecl, dynlib: lib, importc: "gtk_entry_completion_get_inline_selection".}
proc get_inline_selection*(self: EntryCompletion): bool {.inline.} =
  gtk_entry_completion_get_inline_selection(self)
# proc get_inline_selection*(self: EntryCompletion): bool {.inline.} =

# gtk_entry_completion_get_minimum_key_length
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# 'int32' 'int32'
proc gtk_entry_completion_get_minimum_key_length(self: ptr TEntryCompletion): int32 {.cdecl, dynlib: lib, importc: "gtk_entry_completion_get_minimum_key_length".}
proc get_minimum_key_length*(self: EntryCompletion): int32 {.inline.} =
  gtk_entry_completion_get_minimum_key_length(self)
# proc get_minimum_key_length*(self: EntryCompletion): int32 {.inline.} =

# gtk_entry_completion_get_model
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# 'TreeModel' 'TransferNone[TTreeModel]' (diff., need sugar)
proc gtk_entry_completion_get_model(self: ptr TEntryCompletion): TransferNone[TTreeModel] {.cdecl, dynlib: lib, importc: "gtk_entry_completion_get_model".}
proc get_model*(self: EntryCompletion): TreeModel {.inline.} =
  wrap(gtk_entry_completion_get_model(self))
# proc get_model*(self: EntryCompletion): TreeModel {.inline.} =

# gtk_entry_completion_get_popup_completion
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# 'bool' 'bool'
proc gtk_entry_completion_get_popup_completion(self: ptr TEntryCompletion): bool {.cdecl, dynlib: lib, importc: "gtk_entry_completion_get_popup_completion".}
proc get_popup_completion*(self: EntryCompletion): bool {.inline.} =
  gtk_entry_completion_get_popup_completion(self)
# proc get_popup_completion*(self: EntryCompletion): bool {.inline.} =

# gtk_entry_completion_get_popup_set_width
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# 'bool' 'bool'
proc gtk_entry_completion_get_popup_set_width(self: ptr TEntryCompletion): bool {.cdecl, dynlib: lib, importc: "gtk_entry_completion_get_popup_set_width".}
proc get_popup_set_width*(self: EntryCompletion): bool {.inline.} =
  gtk_entry_completion_get_popup_set_width(self)
# proc get_popup_set_width*(self: EntryCompletion): bool {.inline.} =

# gtk_entry_completion_get_popup_single_match
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# 'bool' 'bool'
proc gtk_entry_completion_get_popup_single_match(self: ptr TEntryCompletion): bool {.cdecl, dynlib: lib, importc: "gtk_entry_completion_get_popup_single_match".}
proc get_popup_single_match*(self: EntryCompletion): bool {.inline.} =
  gtk_entry_completion_get_popup_single_match(self)
# proc get_popup_single_match*(self: EntryCompletion): bool {.inline.} =

# gtk_entry_completion_get_text_column
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# 'int32' 'int32'
proc gtk_entry_completion_get_text_column(self: ptr TEntryCompletion): int32 {.cdecl, dynlib: lib, importc: "gtk_entry_completion_get_text_column".}
proc get_text_column*(self: EntryCompletion): int32 {.inline.} =
  gtk_entry_completion_get_text_column(self)
# proc get_text_column*(self: EntryCompletion): int32 {.inline.} =

# gtk_entry_completion_insert_action_markup
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# index_ 'int32' 'int32' IN
# markup 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_insert_action_markup(self: ptr TEntryCompletion, index_x: int32, markup: ucstring) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_insert_action_markup".}
proc insert_action_markup*(self: EntryCompletion, index_x: int32, markup: ustring) {.inline.} =
  gtk_entry_completion_insert_action_markup(self, index_x, ucstring(markup))
# proc insert_action_markup*(self: EntryCompletion, index_x: int32, markup: ustring) {.inline.} =

# gtk_entry_completion_insert_action_text
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# index_ 'int32' 'int32' IN
# text 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_insert_action_text(self: ptr TEntryCompletion, index_x: int32, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_insert_action_text".}
proc insert_action_text*(self: EntryCompletion, index_x: int32, text: ustring) {.inline.} =
  gtk_entry_completion_insert_action_text(self, index_x, ucstring(text))
# proc insert_action_text*(self: EntryCompletion, index_x: int32, text: ustring) {.inline.} =

# gtk_entry_completion_insert_prefix
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_insert_prefix(self: ptr TEntryCompletion) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_insert_prefix".}
proc insert_prefix*(self: EntryCompletion) {.inline.} =
  gtk_entry_completion_insert_prefix(self)
# proc insert_prefix*(self: EntryCompletion) {.inline.} =

# gtk_entry_completion_set_inline_completion
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# inline_completion 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_set_inline_completion(self: ptr TEntryCompletion, inline_completion: bool) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_set_inline_completion".}
proc set_inline_completion*(self: EntryCompletion, inline_completion: bool) {.inline.} =
  gtk_entry_completion_set_inline_completion(self, inline_completion)
# proc set_inline_completion*(self: EntryCompletion, inline_completion: bool) {.inline.} =

# gtk_entry_completion_set_inline_selection
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# inline_selection 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_set_inline_selection(self: ptr TEntryCompletion, inline_selection: bool) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_set_inline_selection".}
proc set_inline_selection*(self: EntryCompletion, inline_selection: bool) {.inline.} =
  gtk_entry_completion_set_inline_selection(self, inline_selection)
# proc set_inline_selection*(self: EntryCompletion, inline_selection: bool) {.inline.} =

# gtk_entry_completion_set_match_func
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# func 'pointer' 'pointer' IN
# func_data 'pointer' 'pointer' IN
# func_notify 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_set_match_func(self: ptr TEntryCompletion, func_x: pointer, func_data: pointer, func_notify: pointer) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_set_match_func".}
proc set_match_func*(self: EntryCompletion, func_x: pointer, func_data: pointer, func_notify: pointer) {.inline.} =
  gtk_entry_completion_set_match_func(self, func_x, func_data, func_notify)
# proc set_match_func*(self: EntryCompletion, func_x: pointer, func_data: pointer, func_notify: pointer) {.inline.} =

# gtk_entry_completion_set_minimum_key_length
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# length 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_set_minimum_key_length(self: ptr TEntryCompletion, length: int32) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_set_minimum_key_length".}
proc set_minimum_key_length*(self: EntryCompletion, length: int32) {.inline.} =
  gtk_entry_completion_set_minimum_key_length(self, length)
# proc set_minimum_key_length*(self: EntryCompletion, length: int32) {.inline.} =

# gtk_entry_completion_set_model
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# model 'TreeModel' 'ptr TTreeModel' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_set_model(self: ptr TEntryCompletion, model: ptr TTreeModel) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_set_model".}
proc set_model*(self: EntryCompletion, model: TreeModel) {.inline.} =
  gtk_entry_completion_set_model(self, unwrap(model))
# proc set_model*(self: EntryCompletion, model: TreeModel) {.inline.} =

# gtk_entry_completion_set_popup_completion
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# popup_completion 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_set_popup_completion(self: ptr TEntryCompletion, popup_completion: bool) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_set_popup_completion".}
proc set_popup_completion*(self: EntryCompletion, popup_completion: bool) {.inline.} =
  gtk_entry_completion_set_popup_completion(self, popup_completion)
# proc set_popup_completion*(self: EntryCompletion, popup_completion: bool) {.inline.} =

# gtk_entry_completion_set_popup_set_width
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# popup_set_width 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_set_popup_set_width(self: ptr TEntryCompletion, popup_set_width: bool) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_set_popup_set_width".}
proc set_popup_set_width*(self: EntryCompletion, popup_set_width: bool) {.inline.} =
  gtk_entry_completion_set_popup_set_width(self, popup_set_width)
# proc set_popup_set_width*(self: EntryCompletion, popup_set_width: bool) {.inline.} =

# gtk_entry_completion_set_popup_single_match
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# popup_single_match 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_set_popup_single_match(self: ptr TEntryCompletion, popup_single_match: bool) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_set_popup_single_match".}
proc set_popup_single_match*(self: EntryCompletion, popup_single_match: bool) {.inline.} =
  gtk_entry_completion_set_popup_single_match(self, popup_single_match)
# proc set_popup_single_match*(self: EntryCompletion, popup_single_match: bool) {.inline.} =

# gtk_entry_completion_set_text_column
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# column 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_set_text_column(self: ptr TEntryCompletion, column: int32) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_set_text_column".}
proc set_text_column*(self: EntryCompletion, column: int32) {.inline.} =
  gtk_entry_completion_set_text_column(self, column)
# proc set_text_column*(self: EntryCompletion, column: int32) {.inline.} =

# gtk_event_box_new
# flags: {isConstructor} container: EventBox
# need sugar: is static method
# 'EventBox' 'TransferNone[TEventBox]' (diff., need sugar)
proc gtk_event_box_new(): TransferNone[TEventBox] {.cdecl, dynlib: lib, importc: "gtk_event_box_new".}
proc new_eventbox*(): EventBox {.inline.} =
  wrap(gtk_event_box_new())
# proc new_eventbox*(): EventBox {.inline.} =

# gtk_event_box_get_above_child
# flags: {isMethod} container: EventBox
# need sugar: is method
# 'bool' 'bool'
proc gtk_event_box_get_above_child(self: ptr TEventBox): bool {.cdecl, dynlib: lib, importc: "gtk_event_box_get_above_child".}
proc get_above_child*(self: EventBox): bool {.inline.} =
  gtk_event_box_get_above_child(self)
# proc get_above_child*(self: EventBox): bool {.inline.} =

# gtk_event_box_get_visible_window
# flags: {isMethod} container: EventBox
# need sugar: is method
# 'bool' 'bool'
proc gtk_event_box_get_visible_window(self: ptr TEventBox): bool {.cdecl, dynlib: lib, importc: "gtk_event_box_get_visible_window".}
proc get_visible_window*(self: EventBox): bool {.inline.} =
  gtk_event_box_get_visible_window(self)
# proc get_visible_window*(self: EventBox): bool {.inline.} =

# gtk_event_box_set_above_child
# flags: {isMethod} container: EventBox
# need sugar: is method
# above_child 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_event_box_set_above_child(self: ptr TEventBox, above_child: bool) {.cdecl, dynlib: lib, importc: "gtk_event_box_set_above_child".}
proc set_above_child*(self: EventBox, above_child: bool) {.inline.} =
  gtk_event_box_set_above_child(self, above_child)
# proc set_above_child*(self: EventBox, above_child: bool) {.inline.} =

# gtk_event_box_set_visible_window
# flags: {isMethod} container: EventBox
# need sugar: is method
# visible_window 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_event_box_set_visible_window(self: ptr TEventBox, visible_window: bool) {.cdecl, dynlib: lib, importc: "gtk_event_box_set_visible_window".}
proc set_visible_window*(self: EventBox, visible_window: bool) {.inline.} =
  gtk_event_box_set_visible_window(self, visible_window)
# proc set_visible_window*(self: EventBox, visible_window: bool) {.inline.} =

# gtk_event_controller_get_propagation_phase
# flags: {isMethod} container: EventController
# need sugar: is method
# 'PropagationPhase' 'PropagationPhase'
proc gtk_event_controller_get_propagation_phase(self: ptr TEventController): PropagationPhase {.cdecl, dynlib: lib, importc: "gtk_event_controller_get_propagation_phase".}
proc get_propagation_phase*(self: EventController): PropagationPhase {.inline.} =
  gtk_event_controller_get_propagation_phase(self)
# proc get_propagation_phase*(self: EventController): PropagationPhase {.inline.} =

# gtk_event_controller_get_widget
# flags: {isMethod} container: EventController
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_event_controller_get_widget(self: ptr TEventController): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_event_controller_get_widget".}
proc get_widget*(self: EventController): Widget {.inline.} =
  wrap(gtk_event_controller_get_widget(self))
# proc get_widget*(self: EventController): Widget {.inline.} =

# gtk_event_controller_handle_event
# flags: {isMethod} container: EventController
# need sugar: is method
# event 'Gdk3.TEvent' 'ptr Gdk3.TEvent' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_event_controller_handle_event(self: ptr TEventController, event: ptr Gdk3.TEvent): bool {.cdecl, dynlib: lib, importc: "gtk_event_controller_handle_event".}
proc handle_event*(self: EventController, event: Gdk3.TEvent): bool {.inline.} =
  gtk_event_controller_handle_event(self, myUnsafeAddr(event))
# proc handle_event*(self: EventController, event: Gdk3.TEvent): bool {.inline.} =

# gtk_event_controller_reset
# flags: {isMethod} container: EventController
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_event_controller_reset(self: ptr TEventController) {.cdecl, dynlib: lib, importc: "gtk_event_controller_reset".}
proc reset*(self: EventController) {.inline.} =
  gtk_event_controller_reset(self)
# proc reset*(self: EventController) {.inline.} =

# gtk_event_controller_set_propagation_phase
# flags: {isMethod} container: EventController
# need sugar: is method
# phase 'PropagationPhase' 'PropagationPhase' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_event_controller_set_propagation_phase(self: ptr TEventController, phase: PropagationPhase) {.cdecl, dynlib: lib, importc: "gtk_event_controller_set_propagation_phase".}
proc set_propagation_phase*(self: EventController, phase: PropagationPhase) {.inline.} =
  gtk_event_controller_set_propagation_phase(self, phase)
# proc set_propagation_phase*(self: EventController, phase: PropagationPhase) {.inline.} =

# gtk_expander_new
# flags: {isConstructor} container: Expander
# need sugar: is static method
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'Expander' 'TransferNone[TExpander]' (diff., need sugar)
proc gtk_expander_new(label: ucstring): TransferNone[TExpander] {.cdecl, dynlib: lib, importc: "gtk_expander_new".}
proc new_expander*(label: ustring): Expander {.inline.} =
  wrap(gtk_expander_new(ucstring(label)))
# proc new_expander*(label: ustring): Expander {.inline.} =

# gtk_expander_new_with_mnemonic
# flags: {isConstructor} container: Expander
# need sugar: is static method
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'Expander' 'TransferNone[TExpander]' (diff., need sugar)
proc gtk_expander_new_with_mnemonic(label: ucstring): TransferNone[TExpander] {.cdecl, dynlib: lib, importc: "gtk_expander_new_with_mnemonic".}
proc new_expander_with_mnemonic*(label: ustring): Expander {.inline.} =
  wrap(gtk_expander_new_with_mnemonic(ucstring(label)))
# proc new_expander_with_mnemonic*(label: ustring): Expander {.inline.} =

# gtk_expander_get_expanded
# flags: {isMethod} container: Expander
# need sugar: is method
# 'bool' 'bool'
proc gtk_expander_get_expanded(self: ptr TExpander): bool {.cdecl, dynlib: lib, importc: "gtk_expander_get_expanded".}
proc get_expanded*(self: Expander): bool {.inline.} =
  gtk_expander_get_expanded(self)
# proc get_expanded*(self: Expander): bool {.inline.} =

# gtk_expander_get_label
# flags: {isMethod} container: Expander
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_expander_get_label(self: ptr TExpander): ucstring {.cdecl, dynlib: lib, importc: "gtk_expander_get_label".}
proc get_label*(self: Expander): ustring {.inline.} =
  ustring($(gtk_expander_get_label(self)))
# proc get_label*(self: Expander): ustring {.inline.} =

# gtk_expander_get_label_fill
# flags: {isMethod} container: Expander
# need sugar: is method
# 'bool' 'bool'
proc gtk_expander_get_label_fill(self: ptr TExpander): bool {.cdecl, dynlib: lib, importc: "gtk_expander_get_label_fill".}
proc get_label_fill*(self: Expander): bool {.inline.} =
  gtk_expander_get_label_fill(self)
# proc get_label_fill*(self: Expander): bool {.inline.} =

# gtk_expander_get_label_widget
# flags: {isMethod} container: Expander
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_expander_get_label_widget(self: ptr TExpander): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_expander_get_label_widget".}
proc get_label_widget*(self: Expander): Widget {.inline.} =
  wrap(gtk_expander_get_label_widget(self))
# proc get_label_widget*(self: Expander): Widget {.inline.} =

# gtk_expander_get_resize_toplevel
# flags: {isMethod} container: Expander
# need sugar: is method
# 'bool' 'bool'
proc gtk_expander_get_resize_toplevel(self: ptr TExpander): bool {.cdecl, dynlib: lib, importc: "gtk_expander_get_resize_toplevel".}
proc get_resize_toplevel*(self: Expander): bool {.inline.} =
  gtk_expander_get_resize_toplevel(self)
# proc get_resize_toplevel*(self: Expander): bool {.inline.} =

# gtk_expander_get_spacing
# flags: {isMethod} container: Expander
# need sugar: is method
# 'int32' 'int32'
proc gtk_expander_get_spacing(self: ptr TExpander): int32 {.cdecl, dynlib: lib, importc: "gtk_expander_get_spacing".}
proc get_spacing*(self: Expander): int32 {.inline.} =
  gtk_expander_get_spacing(self)
# proc get_spacing*(self: Expander): int32 {.inline.} =

# gtk_expander_get_use_markup
# flags: {isMethod} container: Expander
# need sugar: is method
# 'bool' 'bool'
proc gtk_expander_get_use_markup(self: ptr TExpander): bool {.cdecl, dynlib: lib, importc: "gtk_expander_get_use_markup".}
proc get_use_markup*(self: Expander): bool {.inline.} =
  gtk_expander_get_use_markup(self)
# proc get_use_markup*(self: Expander): bool {.inline.} =

# gtk_expander_get_use_underline
# flags: {isMethod} container: Expander
# need sugar: is method
# 'bool' 'bool'
proc gtk_expander_get_use_underline(self: ptr TExpander): bool {.cdecl, dynlib: lib, importc: "gtk_expander_get_use_underline".}
proc get_use_underline*(self: Expander): bool {.inline.} =
  gtk_expander_get_use_underline(self)
# proc get_use_underline*(self: Expander): bool {.inline.} =

# gtk_expander_set_expanded
# flags: {isMethod} container: Expander
# need sugar: is method
# expanded 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_expander_set_expanded(self: ptr TExpander, expanded: bool) {.cdecl, dynlib: lib, importc: "gtk_expander_set_expanded".}
proc set_expanded*(self: Expander, expanded: bool) {.inline.} =
  gtk_expander_set_expanded(self, expanded)
# proc set_expanded*(self: Expander, expanded: bool) {.inline.} =

# gtk_expander_set_label
# flags: {isMethod} container: Expander
# need sugar: is method
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_expander_set_label(self: ptr TExpander, label: ucstring) {.cdecl, dynlib: lib, importc: "gtk_expander_set_label".}
proc set_label*(self: Expander, label: ustring) {.inline.} =
  gtk_expander_set_label(self, ucstring(label))
# proc set_label*(self: Expander, label: ustring) {.inline.} =

# gtk_expander_set_label_fill
# flags: {isMethod} container: Expander
# need sugar: is method
# label_fill 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_expander_set_label_fill(self: ptr TExpander, label_fill: bool) {.cdecl, dynlib: lib, importc: "gtk_expander_set_label_fill".}
proc set_label_fill*(self: Expander, label_fill: bool) {.inline.} =
  gtk_expander_set_label_fill(self, label_fill)
# proc set_label_fill*(self: Expander, label_fill: bool) {.inline.} =

# gtk_expander_set_label_widget
# flags: {isMethod} container: Expander
# need sugar: is method
# label_widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_expander_set_label_widget(self: ptr TExpander, label_widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_expander_set_label_widget".}
proc set_label_widget*(self: Expander, label_widget: Widget) {.inline.} =
  gtk_expander_set_label_widget(self, label_widget.getPointer)
# proc set_label_widget*(self: Expander, label_widget: Widget) {.inline.} =

# gtk_expander_set_resize_toplevel
# flags: {isMethod} container: Expander
# need sugar: is method
# resize_toplevel 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_expander_set_resize_toplevel(self: ptr TExpander, resize_toplevel: bool) {.cdecl, dynlib: lib, importc: "gtk_expander_set_resize_toplevel".}
proc set_resize_toplevel*(self: Expander, resize_toplevel: bool) {.inline.} =
  gtk_expander_set_resize_toplevel(self, resize_toplevel)
# proc set_resize_toplevel*(self: Expander, resize_toplevel: bool) {.inline.} =

# gtk_expander_set_spacing
# flags: {isMethod} container: Expander
# need sugar: is method
# spacing 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_expander_set_spacing(self: ptr TExpander, spacing: int32) {.cdecl, dynlib: lib, importc: "gtk_expander_set_spacing".}
proc set_spacing*(self: Expander, spacing: int32) {.inline.} =
  gtk_expander_set_spacing(self, spacing)
# proc set_spacing*(self: Expander, spacing: int32) {.inline.} =

# gtk_expander_set_use_markup
# flags: {isMethod} container: Expander
# need sugar: is method
# use_markup 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_expander_set_use_markup(self: ptr TExpander, use_markup: bool) {.cdecl, dynlib: lib, importc: "gtk_expander_set_use_markup".}
proc set_use_markup*(self: Expander, use_markup: bool) {.inline.} =
  gtk_expander_set_use_markup(self, use_markup)
# proc set_use_markup*(self: Expander, use_markup: bool) {.inline.} =

# gtk_expander_set_use_underline
# flags: {isMethod} container: Expander
# need sugar: is method
# use_underline 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_expander_set_use_underline(self: ptr TExpander, use_underline: bool) {.cdecl, dynlib: lib, importc: "gtk_expander_set_use_underline".}
proc set_use_underline*(self: Expander, use_underline: bool) {.inline.} =
  gtk_expander_set_use_underline(self, use_underline)
# proc set_use_underline*(self: Expander, use_underline: bool) {.inline.} =

# gtk_file_chooser_button_new
# flags: {isConstructor} container: FileChooserButton
# need sugar: is static method
# title 'ustring' 'ucstring' IN (diff., need sugar)
# action 'FileChooserAction' 'FileChooserAction' IN
# 'FileChooserButton' 'TransferNone[TFileChooserButton]' (diff., need sugar)
proc gtk_file_chooser_button_new(title: ucstring, action: FileChooserAction): TransferNone[TFileChooserButton] {.cdecl, dynlib: lib, importc: "gtk_file_chooser_button_new".}
proc new_filechooserbutton*(title: ustring, action: FileChooserAction): FileChooserButton {.inline.} =
  wrap(gtk_file_chooser_button_new(ucstring(title), action))
# proc new_filechooserbutton*(title: ustring, action: FileChooserAction): FileChooserButton {.inline.} =

# gtk_file_chooser_button_new_with_dialog
# flags: {isConstructor} container: FileChooserButton
# need sugar: is static method
# dialog 'Dialog' 'ptr TDialog' IN (diff., need sugar)
# 'FileChooserButton' 'TransferNone[TFileChooserButton]' (diff., need sugar)
proc gtk_file_chooser_button_new_with_dialog(dialog: ptr TDialog): TransferNone[TFileChooserButton] {.cdecl, dynlib: lib, importc: "gtk_file_chooser_button_new_with_dialog".}
proc new_filechooserbutton_with_dialog*(dialog: Dialog): FileChooserButton {.inline.} =
  wrap(gtk_file_chooser_button_new_with_dialog(dialog.getPointer))
# proc new_filechooserbutton_with_dialog*(dialog: Dialog): FileChooserButton {.inline.} =

# gtk_file_chooser_button_get_focus_on_click
# flags: {isMethod} container: FileChooserButton
# need sugar: is method
# 'bool' 'bool'
proc gtk_file_chooser_button_get_focus_on_click(self: ptr TFileChooserButton): bool {.cdecl, dynlib: lib, importc: "gtk_file_chooser_button_get_focus_on_click".}
proc get_focus_on_click*(self: FileChooserButton): bool {.inline.} =
  gtk_file_chooser_button_get_focus_on_click(self)
# proc get_focus_on_click*(self: FileChooserButton): bool {.inline.} =

# gtk_file_chooser_button_get_title
# flags: {isMethod} container: FileChooserButton
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_file_chooser_button_get_title(self: ptr TFileChooserButton): ucstring {.cdecl, dynlib: lib, importc: "gtk_file_chooser_button_get_title".}
proc get_title*(self: FileChooserButton): ustring {.inline.} =
  ustring($(gtk_file_chooser_button_get_title(self)))
# proc get_title*(self: FileChooserButton): ustring {.inline.} =

# gtk_file_chooser_button_get_width_chars
# flags: {isMethod} container: FileChooserButton
# need sugar: is method
# 'int32' 'int32'
proc gtk_file_chooser_button_get_width_chars(self: ptr TFileChooserButton): int32 {.cdecl, dynlib: lib, importc: "gtk_file_chooser_button_get_width_chars".}
proc get_width_chars*(self: FileChooserButton): int32 {.inline.} =
  gtk_file_chooser_button_get_width_chars(self)
# proc get_width_chars*(self: FileChooserButton): int32 {.inline.} =

# gtk_file_chooser_button_set_focus_on_click
# flags: {isMethod} container: FileChooserButton
# need sugar: is method
# focus_on_click 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_file_chooser_button_set_focus_on_click(self: ptr TFileChooserButton, focus_on_click: bool) {.cdecl, dynlib: lib, importc: "gtk_file_chooser_button_set_focus_on_click".}
proc set_focus_on_click*(self: FileChooserButton, focus_on_click: bool) {.inline.} =
  gtk_file_chooser_button_set_focus_on_click(self, focus_on_click)
# proc set_focus_on_click*(self: FileChooserButton, focus_on_click: bool) {.inline.} =

# gtk_file_chooser_button_set_title
# flags: {isMethod} container: FileChooserButton
# need sugar: is method
# title 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_file_chooser_button_set_title(self: ptr TFileChooserButton, title: ucstring) {.cdecl, dynlib: lib, importc: "gtk_file_chooser_button_set_title".}
proc set_title*(self: FileChooserButton, title: ustring) {.inline.} =
  gtk_file_chooser_button_set_title(self, ucstring(title))
# proc set_title*(self: FileChooserButton, title: ustring) {.inline.} =

# gtk_file_chooser_button_set_width_chars
# flags: {isMethod} container: FileChooserButton
# need sugar: is method
# n_chars 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_file_chooser_button_set_width_chars(self: ptr TFileChooserButton, n_chars: int32) {.cdecl, dynlib: lib, importc: "gtk_file_chooser_button_set_width_chars".}
proc set_width_chars*(self: FileChooserButton, n_chars: int32) {.inline.} =
  gtk_file_chooser_button_set_width_chars(self, n_chars)
# proc set_width_chars*(self: FileChooserButton, n_chars: int32) {.inline.} =

# gtk_file_chooser_widget_new
# flags: {isConstructor} container: FileChooserWidget
# need sugar: is static method
# action 'FileChooserAction' 'FileChooserAction' IN
# 'FileChooserWidget' 'TransferNone[TFileChooserWidget]' (diff., need sugar)
proc gtk_file_chooser_widget_new(action: FileChooserAction): TransferNone[TFileChooserWidget] {.cdecl, dynlib: lib, importc: "gtk_file_chooser_widget_new".}
proc new_filechooserwidget*(action: FileChooserAction): FileChooserWidget {.inline.} =
  wrap(gtk_file_chooser_widget_new(action))
# proc new_filechooserwidget*(action: FileChooserAction): FileChooserWidget {.inline.} =

# gtk_file_filter_new
# flags: {isConstructor} container: FileFilter
# need sugar: is static method
# 'FileFilter' 'TransferNone[TFileFilter]' (diff., need sugar)
proc gtk_file_filter_new(): TransferNone[TFileFilter] {.cdecl, dynlib: lib, importc: "gtk_file_filter_new".}
proc new_filefilter*(): FileFilter {.inline.} =
  wrap(gtk_file_filter_new())
# proc new_filefilter*(): FileFilter {.inline.} =

# gtk_file_filter_add_custom
# flags: {isMethod} container: FileFilter
# need sugar: is method
# needed 'SFileFilterFlags' 'SFileFilterFlags' IN
# func 'pointer' 'pointer' IN
# data 'pointer' 'pointer' IN
# notify 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_file_filter_add_custom(self: ptr TFileFilter, needed: SFileFilterFlags, func_x: pointer, data: pointer, notify: pointer) {.cdecl, dynlib: lib, importc: "gtk_file_filter_add_custom".}
proc add_custom*(self: FileFilter, needed: SFileFilterFlags, func_x: pointer, data: pointer, notify: pointer) {.inline.} =
  gtk_file_filter_add_custom(self, needed, func_x, data, notify)
# proc add_custom*(self: FileFilter, needed: SFileFilterFlags, func_x: pointer, data: pointer, notify: pointer) {.inline.} =

# gtk_file_filter_add_mime_type
# flags: {isMethod} container: FileFilter
# need sugar: is method
# mime_type 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_file_filter_add_mime_type(self: ptr TFileFilter, mime_type: ucstring) {.cdecl, dynlib: lib, importc: "gtk_file_filter_add_mime_type".}
proc add_mime_type*(self: FileFilter, mime_type: ustring) {.inline.} =
  gtk_file_filter_add_mime_type(self, ucstring(mime_type))
# proc add_mime_type*(self: FileFilter, mime_type: ustring) {.inline.} =

# gtk_file_filter_add_pattern
# flags: {isMethod} container: FileFilter
# need sugar: is method
# pattern 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_file_filter_add_pattern(self: ptr TFileFilter, pattern: ucstring) {.cdecl, dynlib: lib, importc: "gtk_file_filter_add_pattern".}
proc add_pattern*(self: FileFilter, pattern: ustring) {.inline.} =
  gtk_file_filter_add_pattern(self, ucstring(pattern))
# proc add_pattern*(self: FileFilter, pattern: ustring) {.inline.} =

# gtk_file_filter_add_pixbuf_formats
# flags: {isMethod} container: FileFilter
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_file_filter_add_pixbuf_formats(self: ptr TFileFilter) {.cdecl, dynlib: lib, importc: "gtk_file_filter_add_pixbuf_formats".}
proc add_pixbuf_formats*(self: FileFilter) {.inline.} =
  gtk_file_filter_add_pixbuf_formats(self)
# proc add_pixbuf_formats*(self: FileFilter) {.inline.} =

# gtk_file_filter_filter
# flags: {isMethod} container: FileFilter
# need sugar: is method
# filter_info 'TFileFilterInfo' 'ptr TFileFilterInfo' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_file_filter_filter(self: ptr TFileFilter, filter_info: ptr TFileFilterInfo): bool {.cdecl, dynlib: lib, importc: "gtk_file_filter_filter".}
proc filter*(self: FileFilter, filter_info: TFileFilterInfo): bool {.inline.} =
  gtk_file_filter_filter(self, myUnsafeAddr(filter_info))
# proc filter*(self: FileFilter, filter_info: TFileFilterInfo): bool {.inline.} =

# gtk_file_filter_get_name
# flags: {isMethod} container: FileFilter
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_file_filter_get_name(self: ptr TFileFilter): ucstring {.cdecl, dynlib: lib, importc: "gtk_file_filter_get_name".}
proc get_name*(self: FileFilter): ustring {.inline.} =
  ustring($(gtk_file_filter_get_name(self)))
# proc get_name*(self: FileFilter): ustring {.inline.} =

# gtk_file_filter_get_needed
# flags: {isMethod} container: FileFilter
# need sugar: is method
# 'SFileFilterFlags' 'SFileFilterFlags'
proc gtk_file_filter_get_needed(self: ptr TFileFilter): SFileFilterFlags {.cdecl, dynlib: lib, importc: "gtk_file_filter_get_needed".}
proc get_needed*(self: FileFilter): SFileFilterFlags {.inline.} =
  gtk_file_filter_get_needed(self)
# proc get_needed*(self: FileFilter): SFileFilterFlags {.inline.} =

# gtk_file_filter_set_name
# flags: {isMethod} container: FileFilter
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_file_filter_set_name(self: ptr TFileFilter, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_file_filter_set_name".}
proc set_name*(self: FileFilter, name: ustring) {.inline.} =
  gtk_file_filter_set_name(self, ucstring(name))
# proc set_name*(self: FileFilter, name: ustring) {.inline.} =

# gtk_fixed_new
# flags: {isConstructor} container: Fixed
# need sugar: is static method
# 'Fixed' 'TransferNone[TFixed]' (diff., need sugar)
proc gtk_fixed_new(): TransferNone[TFixed] {.cdecl, dynlib: lib, importc: "gtk_fixed_new".}
proc new_fixed*(): Fixed {.inline.} =
  wrap(gtk_fixed_new())
# proc new_fixed*(): Fixed {.inline.} =

# gtk_fixed_move
# flags: {isMethod} container: Fixed
# need sugar: is method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# x 'int32' 'int32' IN
# y 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_fixed_move(self: ptr TFixed, widget: ptr TWidget, x: int32, y: int32) {.cdecl, dynlib: lib, importc: "gtk_fixed_move".}
proc move*(self: Fixed, widget: Widget, x: int32, y: int32) {.inline.} =
  gtk_fixed_move(self, widget.getPointer, x, y)
# proc move*(self: Fixed, widget: Widget, x: int32, y: int32) {.inline.} =

# gtk_fixed_put
# flags: {isMethod} container: Fixed
# need sugar: is method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# x 'int32' 'int32' IN
# y 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_fixed_put(self: ptr TFixed, widget: ptr TWidget, x: int32, y: int32) {.cdecl, dynlib: lib, importc: "gtk_fixed_put".}
proc put*(self: Fixed, widget: Widget, x: int32, y: int32) {.inline.} =
  gtk_fixed_put(self, widget.getPointer, x, y)
# proc put*(self: Fixed, widget: Widget, x: int32, y: int32) {.inline.} =

# gtk_flow_box_new
# flags: {isConstructor} container: FlowBox
# need sugar: is static method
# 'FlowBox' 'TransferNone[TFlowBox]' (diff., need sugar)
proc gtk_flow_box_new(): TransferNone[TFlowBox] {.cdecl, dynlib: lib, importc: "gtk_flow_box_new".}
proc new_flowbox*(): FlowBox {.inline.} =
  wrap(gtk_flow_box_new())
# proc new_flowbox*(): FlowBox {.inline.} =

# gtk_flow_box_get_activate_on_single_click
# flags: {isMethod} container: FlowBox
# need sugar: is method
# 'bool' 'bool'
proc gtk_flow_box_get_activate_on_single_click(self: ptr TFlowBox): bool {.cdecl, dynlib: lib, importc: "gtk_flow_box_get_activate_on_single_click".}
proc get_activate_on_single_click*(self: FlowBox): bool {.inline.} =
  gtk_flow_box_get_activate_on_single_click(self)
# proc get_activate_on_single_click*(self: FlowBox): bool {.inline.} =

# gtk_flow_box_get_child_at_index
# flags: {isMethod} container: FlowBox
# need sugar: is method
# idx 'int32' 'int32' IN
# 'FlowBoxChild' 'TransferNone[TFlowBoxChild]' (diff., need sugar)
proc gtk_flow_box_get_child_at_index(self: ptr TFlowBox, idx: int32): TransferNone[TFlowBoxChild] {.cdecl, dynlib: lib, importc: "gtk_flow_box_get_child_at_index".}
proc get_child_at_index*(self: FlowBox, idx: int32): FlowBoxChild {.inline.} =
  wrap(gtk_flow_box_get_child_at_index(self, idx))
# proc get_child_at_index*(self: FlowBox, idx: int32): FlowBoxChild {.inline.} =

# gtk_flow_box_get_column_spacing
# flags: {isMethod} container: FlowBox
# need sugar: is method
# 'uint32' 'uint32'
proc gtk_flow_box_get_column_spacing(self: ptr TFlowBox): uint32 {.cdecl, dynlib: lib, importc: "gtk_flow_box_get_column_spacing".}
proc get_column_spacing*(self: FlowBox): uint32 {.inline.} =
  gtk_flow_box_get_column_spacing(self)
# proc get_column_spacing*(self: FlowBox): uint32 {.inline.} =

# gtk_flow_box_get_homogeneous
# flags: {isMethod} container: FlowBox
# need sugar: is method
# 'bool' 'bool'
proc gtk_flow_box_get_homogeneous(self: ptr TFlowBox): bool {.cdecl, dynlib: lib, importc: "gtk_flow_box_get_homogeneous".}
proc get_homogeneous*(self: FlowBox): bool {.inline.} =
  gtk_flow_box_get_homogeneous(self)
# proc get_homogeneous*(self: FlowBox): bool {.inline.} =

# gtk_flow_box_get_max_children_per_line
# flags: {isMethod} container: FlowBox
# need sugar: is method
# 'uint32' 'uint32'
proc gtk_flow_box_get_max_children_per_line(self: ptr TFlowBox): uint32 {.cdecl, dynlib: lib, importc: "gtk_flow_box_get_max_children_per_line".}
proc get_max_children_per_line*(self: FlowBox): uint32 {.inline.} =
  gtk_flow_box_get_max_children_per_line(self)
# proc get_max_children_per_line*(self: FlowBox): uint32 {.inline.} =

# gtk_flow_box_get_min_children_per_line
# flags: {isMethod} container: FlowBox
# need sugar: is method
# 'uint32' 'uint32'
proc gtk_flow_box_get_min_children_per_line(self: ptr TFlowBox): uint32 {.cdecl, dynlib: lib, importc: "gtk_flow_box_get_min_children_per_line".}
proc get_min_children_per_line*(self: FlowBox): uint32 {.inline.} =
  gtk_flow_box_get_min_children_per_line(self)
# proc get_min_children_per_line*(self: FlowBox): uint32 {.inline.} =

# gtk_flow_box_get_row_spacing
# flags: {isMethod} container: FlowBox
# need sugar: is method
# 'uint32' 'uint32'
proc gtk_flow_box_get_row_spacing(self: ptr TFlowBox): uint32 {.cdecl, dynlib: lib, importc: "gtk_flow_box_get_row_spacing".}
proc get_row_spacing*(self: FlowBox): uint32 {.inline.} =
  gtk_flow_box_get_row_spacing(self)
# proc get_row_spacing*(self: FlowBox): uint32 {.inline.} =

# gtk_flow_box_get_selected_children
# flags: {isMethod} container: FlowBox
# need sugar: is method
# 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_flow_box_get_selected_children(self: ptr TFlowBox): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_flow_box_get_selected_children".}
proc get_selected_children*(self: FlowBox): ptr GLIST_TODO {.inline.} =
  gtk_flow_box_get_selected_children(self)
# proc get_selected_children*(self: FlowBox): ptr GLIST_TODO {.inline.} =

# gtk_flow_box_get_selection_mode
# flags: {isMethod} container: FlowBox
# need sugar: is method
# 'SelectionMode' 'SelectionMode'
proc gtk_flow_box_get_selection_mode(self: ptr TFlowBox): SelectionMode {.cdecl, dynlib: lib, importc: "gtk_flow_box_get_selection_mode".}
proc get_selection_mode*(self: FlowBox): SelectionMode {.inline.} =
  gtk_flow_box_get_selection_mode(self)
# proc get_selection_mode*(self: FlowBox): SelectionMode {.inline.} =

# gtk_flow_box_insert
# flags: {isMethod} container: FlowBox
# need sugar: is method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# position 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_insert(self: ptr TFlowBox, widget: ptr TWidget, position: int32) {.cdecl, dynlib: lib, importc: "gtk_flow_box_insert".}
proc insert*(self: FlowBox, widget: Widget, position: int32) {.inline.} =
  gtk_flow_box_insert(self, widget.getPointer, position)
# proc insert*(self: FlowBox, widget: Widget, position: int32) {.inline.} =

# gtk_flow_box_invalidate_filter
# flags: {isMethod} container: FlowBox
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_invalidate_filter(self: ptr TFlowBox) {.cdecl, dynlib: lib, importc: "gtk_flow_box_invalidate_filter".}
proc invalidate_filter*(self: FlowBox) {.inline.} =
  gtk_flow_box_invalidate_filter(self)
# proc invalidate_filter*(self: FlowBox) {.inline.} =

# gtk_flow_box_invalidate_sort
# flags: {isMethod} container: FlowBox
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_invalidate_sort(self: ptr TFlowBox) {.cdecl, dynlib: lib, importc: "gtk_flow_box_invalidate_sort".}
proc invalidate_sort*(self: FlowBox) {.inline.} =
  gtk_flow_box_invalidate_sort(self)
# proc invalidate_sort*(self: FlowBox) {.inline.} =

# gtk_flow_box_select_all
# flags: {isMethod} container: FlowBox
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_select_all(self: ptr TFlowBox) {.cdecl, dynlib: lib, importc: "gtk_flow_box_select_all".}
proc select_all*(self: FlowBox) {.inline.} =
  gtk_flow_box_select_all(self)
# proc select_all*(self: FlowBox) {.inline.} =

# gtk_flow_box_select_child
# flags: {isMethod} container: FlowBox
# need sugar: is method
# child 'FlowBoxChild' 'ptr TFlowBoxChild' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_select_child(self: ptr TFlowBox, child: ptr TFlowBoxChild) {.cdecl, dynlib: lib, importc: "gtk_flow_box_select_child".}
proc select_child*(self: FlowBox, child: FlowBoxChild) {.inline.} =
  gtk_flow_box_select_child(self, child.getPointer)
# proc select_child*(self: FlowBox, child: FlowBoxChild) {.inline.} =

# gtk_flow_box_selected_foreach
# flags: {isMethod} container: FlowBox
# need sugar: is method
# func 'pointer' 'pointer' IN
# data 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_selected_foreach(self: ptr TFlowBox, func_x: pointer, data: pointer) {.cdecl, dynlib: lib, importc: "gtk_flow_box_selected_foreach".}
proc selected_foreach*(self: FlowBox, func_x: pointer, data: pointer) {.inline.} =
  gtk_flow_box_selected_foreach(self, func_x, data)
# proc selected_foreach*(self: FlowBox, func_x: pointer, data: pointer) {.inline.} =

# gtk_flow_box_set_activate_on_single_click
# flags: {isMethod} container: FlowBox
# need sugar: is method
# single 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_set_activate_on_single_click(self: ptr TFlowBox, single: bool) {.cdecl, dynlib: lib, importc: "gtk_flow_box_set_activate_on_single_click".}
proc set_activate_on_single_click*(self: FlowBox, single: bool) {.inline.} =
  gtk_flow_box_set_activate_on_single_click(self, single)
# proc set_activate_on_single_click*(self: FlowBox, single: bool) {.inline.} =

# gtk_flow_box_set_column_spacing
# flags: {isMethod} container: FlowBox
# need sugar: is method
# spacing 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_set_column_spacing(self: ptr TFlowBox, spacing: uint32) {.cdecl, dynlib: lib, importc: "gtk_flow_box_set_column_spacing".}
proc set_column_spacing*(self: FlowBox, spacing: uint32) {.inline.} =
  gtk_flow_box_set_column_spacing(self, spacing)
# proc set_column_spacing*(self: FlowBox, spacing: uint32) {.inline.} =

# gtk_flow_box_set_filter_func
# flags: {isMethod} container: FlowBox
# need sugar: is method
# filter_func 'pointer' 'pointer' IN
# user_data 'pointer' 'pointer' IN
# destroy 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_set_filter_func(self: ptr TFlowBox, filter_func: pointer, user_data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_flow_box_set_filter_func".}
proc set_filter_func*(self: FlowBox, filter_func: pointer, user_data: pointer, destroy: pointer) {.inline.} =
  gtk_flow_box_set_filter_func(self, filter_func, user_data, destroy)
# proc set_filter_func*(self: FlowBox, filter_func: pointer, user_data: pointer, destroy: pointer) {.inline.} =

# gtk_flow_box_set_hadjustment
# flags: {isMethod} container: FlowBox
# need sugar: is method
# adjustment 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_set_hadjustment(self: ptr TFlowBox, adjustment: ptr TAdjustment) {.cdecl, dynlib: lib, importc: "gtk_flow_box_set_hadjustment".}
proc set_hadjustment*(self: FlowBox, adjustment: Adjustment) {.inline.} =
  gtk_flow_box_set_hadjustment(self, adjustment.getPointer)
# proc set_hadjustment*(self: FlowBox, adjustment: Adjustment) {.inline.} =

# gtk_flow_box_set_homogeneous
# flags: {isMethod} container: FlowBox
# need sugar: is method
# homogeneous 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_set_homogeneous(self: ptr TFlowBox, homogeneous: bool) {.cdecl, dynlib: lib, importc: "gtk_flow_box_set_homogeneous".}
proc set_homogeneous*(self: FlowBox, homogeneous: bool) {.inline.} =
  gtk_flow_box_set_homogeneous(self, homogeneous)
# proc set_homogeneous*(self: FlowBox, homogeneous: bool) {.inline.} =

# gtk_flow_box_set_max_children_per_line
# flags: {isMethod} container: FlowBox
# need sugar: is method
# n_children 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_set_max_children_per_line(self: ptr TFlowBox, n_children: uint32) {.cdecl, dynlib: lib, importc: "gtk_flow_box_set_max_children_per_line".}
proc set_max_children_per_line*(self: FlowBox, n_children: uint32) {.inline.} =
  gtk_flow_box_set_max_children_per_line(self, n_children)
# proc set_max_children_per_line*(self: FlowBox, n_children: uint32) {.inline.} =

# gtk_flow_box_set_min_children_per_line
# flags: {isMethod} container: FlowBox
# need sugar: is method
# n_children 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_set_min_children_per_line(self: ptr TFlowBox, n_children: uint32) {.cdecl, dynlib: lib, importc: "gtk_flow_box_set_min_children_per_line".}
proc set_min_children_per_line*(self: FlowBox, n_children: uint32) {.inline.} =
  gtk_flow_box_set_min_children_per_line(self, n_children)
# proc set_min_children_per_line*(self: FlowBox, n_children: uint32) {.inline.} =

# gtk_flow_box_set_row_spacing
# flags: {isMethod} container: FlowBox
# need sugar: is method
# spacing 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_set_row_spacing(self: ptr TFlowBox, spacing: uint32) {.cdecl, dynlib: lib, importc: "gtk_flow_box_set_row_spacing".}
proc set_row_spacing*(self: FlowBox, spacing: uint32) {.inline.} =
  gtk_flow_box_set_row_spacing(self, spacing)
# proc set_row_spacing*(self: FlowBox, spacing: uint32) {.inline.} =

# gtk_flow_box_set_selection_mode
# flags: {isMethod} container: FlowBox
# need sugar: is method
# mode 'SelectionMode' 'SelectionMode' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_set_selection_mode(self: ptr TFlowBox, mode: SelectionMode) {.cdecl, dynlib: lib, importc: "gtk_flow_box_set_selection_mode".}
proc set_selection_mode*(self: FlowBox, mode: SelectionMode) {.inline.} =
  gtk_flow_box_set_selection_mode(self, mode)
# proc set_selection_mode*(self: FlowBox, mode: SelectionMode) {.inline.} =

# gtk_flow_box_set_sort_func
# flags: {isMethod} container: FlowBox
# need sugar: is method
# sort_func 'pointer' 'pointer' IN
# user_data 'pointer' 'pointer' IN
# destroy 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_set_sort_func(self: ptr TFlowBox, sort_func: pointer, user_data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_flow_box_set_sort_func".}
proc set_sort_func*(self: FlowBox, sort_func: pointer, user_data: pointer, destroy: pointer) {.inline.} =
  gtk_flow_box_set_sort_func(self, sort_func, user_data, destroy)
# proc set_sort_func*(self: FlowBox, sort_func: pointer, user_data: pointer, destroy: pointer) {.inline.} =

# gtk_flow_box_set_vadjustment
# flags: {isMethod} container: FlowBox
# need sugar: is method
# adjustment 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_set_vadjustment(self: ptr TFlowBox, adjustment: ptr TAdjustment) {.cdecl, dynlib: lib, importc: "gtk_flow_box_set_vadjustment".}
proc set_vadjustment*(self: FlowBox, adjustment: Adjustment) {.inline.} =
  gtk_flow_box_set_vadjustment(self, adjustment.getPointer)
# proc set_vadjustment*(self: FlowBox, adjustment: Adjustment) {.inline.} =

# gtk_flow_box_unselect_all
# flags: {isMethod} container: FlowBox
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_unselect_all(self: ptr TFlowBox) {.cdecl, dynlib: lib, importc: "gtk_flow_box_unselect_all".}
proc unselect_all*(self: FlowBox) {.inline.} =
  gtk_flow_box_unselect_all(self)
# proc unselect_all*(self: FlowBox) {.inline.} =

# gtk_flow_box_unselect_child
# flags: {isMethod} container: FlowBox
# need sugar: is method
# child 'FlowBoxChild' 'ptr TFlowBoxChild' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_unselect_child(self: ptr TFlowBox, child: ptr TFlowBoxChild) {.cdecl, dynlib: lib, importc: "gtk_flow_box_unselect_child".}
proc unselect_child*(self: FlowBox, child: FlowBoxChild) {.inline.} =
  gtk_flow_box_unselect_child(self, child.getPointer)
# proc unselect_child*(self: FlowBox, child: FlowBoxChild) {.inline.} =

# gtk_flow_box_child_new
# flags: {isConstructor} container: FlowBoxChild
# need sugar: is static method
# 'FlowBoxChild' 'TransferNone[TFlowBoxChild]' (diff., need sugar)
proc gtk_flow_box_child_new(): TransferNone[TFlowBoxChild] {.cdecl, dynlib: lib, importc: "gtk_flow_box_child_new".}
proc new_flowboxchild*(): FlowBoxChild {.inline.} =
  wrap(gtk_flow_box_child_new())
# proc new_flowboxchild*(): FlowBoxChild {.inline.} =

# gtk_flow_box_child_changed
# flags: {isMethod} container: FlowBoxChild
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_child_changed(self: ptr TFlowBoxChild) {.cdecl, dynlib: lib, importc: "gtk_flow_box_child_changed".}
proc changed*(self: FlowBoxChild) {.inline.} =
  gtk_flow_box_child_changed(self)
# proc changed*(self: FlowBoxChild) {.inline.} =

# gtk_flow_box_child_get_index
# flags: {isMethod} container: FlowBoxChild
# need sugar: is method
# 'int32' 'int32'
proc gtk_flow_box_child_get_index(self: ptr TFlowBoxChild): int32 {.cdecl, dynlib: lib, importc: "gtk_flow_box_child_get_index".}
proc get_index*(self: FlowBoxChild): int32 {.inline.} =
  gtk_flow_box_child_get_index(self)
# proc get_index*(self: FlowBoxChild): int32 {.inline.} =

# gtk_flow_box_child_is_selected
# flags: {isMethod} container: FlowBoxChild
# need sugar: is method
# 'bool' 'bool'
proc gtk_flow_box_child_is_selected(self: ptr TFlowBoxChild): bool {.cdecl, dynlib: lib, importc: "gtk_flow_box_child_is_selected".}
proc is_selected*(self: FlowBoxChild): bool {.inline.} =
  gtk_flow_box_child_is_selected(self)
# proc is_selected*(self: FlowBoxChild): bool {.inline.} =

# gtk_font_button_new
# flags: {isConstructor} container: FontButton
# need sugar: is static method
# 'FontButton' 'TransferNone[TFontButton]' (diff., need sugar)
proc gtk_font_button_new(): TransferNone[TFontButton] {.cdecl, dynlib: lib, importc: "gtk_font_button_new".}
proc new_fontbutton*(): FontButton {.inline.} =
  wrap(gtk_font_button_new())
# proc new_fontbutton*(): FontButton {.inline.} =

# gtk_font_button_new_with_font
# flags: {isConstructor} container: FontButton
# need sugar: is static method
# fontname 'ustring' 'ucstring' IN (diff., need sugar)
# 'FontButton' 'TransferNone[TFontButton]' (diff., need sugar)
proc gtk_font_button_new_with_font(fontname: ucstring): TransferNone[TFontButton] {.cdecl, dynlib: lib, importc: "gtk_font_button_new_with_font".}
proc new_fontbutton_with_font*(fontname: ustring): FontButton {.inline.} =
  wrap(gtk_font_button_new_with_font(ucstring(fontname)))
# proc new_fontbutton_with_font*(fontname: ustring): FontButton {.inline.} =

# gtk_font_button_get_font_name
# flags: {isMethod} container: FontButton
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_font_button_get_font_name(self: ptr TFontButton): ucstring {.cdecl, dynlib: lib, importc: "gtk_font_button_get_font_name".}
proc get_font_name*(self: FontButton): ustring {.inline.} =
  ustring($(gtk_font_button_get_font_name(self)))
# proc get_font_name*(self: FontButton): ustring {.inline.} =

# gtk_font_button_get_show_size
# flags: {isMethod} container: FontButton
# need sugar: is method
# 'bool' 'bool'
proc gtk_font_button_get_show_size(self: ptr TFontButton): bool {.cdecl, dynlib: lib, importc: "gtk_font_button_get_show_size".}
proc get_show_size*(self: FontButton): bool {.inline.} =
  gtk_font_button_get_show_size(self)
# proc get_show_size*(self: FontButton): bool {.inline.} =

# gtk_font_button_get_show_style
# flags: {isMethod} container: FontButton
# need sugar: is method
# 'bool' 'bool'
proc gtk_font_button_get_show_style(self: ptr TFontButton): bool {.cdecl, dynlib: lib, importc: "gtk_font_button_get_show_style".}
proc get_show_style*(self: FontButton): bool {.inline.} =
  gtk_font_button_get_show_style(self)
# proc get_show_style*(self: FontButton): bool {.inline.} =

# gtk_font_button_get_title
# flags: {isMethod} container: FontButton
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_font_button_get_title(self: ptr TFontButton): ucstring {.cdecl, dynlib: lib, importc: "gtk_font_button_get_title".}
proc get_title*(self: FontButton): ustring {.inline.} =
  ustring($(gtk_font_button_get_title(self)))
# proc get_title*(self: FontButton): ustring {.inline.} =

# gtk_font_button_get_use_font
# flags: {isMethod} container: FontButton
# need sugar: is method
# 'bool' 'bool'
proc gtk_font_button_get_use_font(self: ptr TFontButton): bool {.cdecl, dynlib: lib, importc: "gtk_font_button_get_use_font".}
proc get_use_font*(self: FontButton): bool {.inline.} =
  gtk_font_button_get_use_font(self)
# proc get_use_font*(self: FontButton): bool {.inline.} =

# gtk_font_button_get_use_size
# flags: {isMethod} container: FontButton
# need sugar: is method
# 'bool' 'bool'
proc gtk_font_button_get_use_size(self: ptr TFontButton): bool {.cdecl, dynlib: lib, importc: "gtk_font_button_get_use_size".}
proc get_use_size*(self: FontButton): bool {.inline.} =
  gtk_font_button_get_use_size(self)
# proc get_use_size*(self: FontButton): bool {.inline.} =

# gtk_font_button_set_font_name
# flags: {isMethod} container: FontButton
# need sugar: is method
# fontname 'ustring' 'ucstring' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_font_button_set_font_name(self: ptr TFontButton, fontname: ucstring): bool {.cdecl, dynlib: lib, importc: "gtk_font_button_set_font_name".}
proc set_font_name*(self: FontButton, fontname: ustring): bool {.inline.} =
  gtk_font_button_set_font_name(self, ucstring(fontname))
# proc set_font_name*(self: FontButton, fontname: ustring): bool {.inline.} =

# gtk_font_button_set_show_size
# flags: {isMethod} container: FontButton
# need sugar: is method
# show_size 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_font_button_set_show_size(self: ptr TFontButton, show_size: bool) {.cdecl, dynlib: lib, importc: "gtk_font_button_set_show_size".}
proc set_show_size*(self: FontButton, show_size: bool) {.inline.} =
  gtk_font_button_set_show_size(self, show_size)
# proc set_show_size*(self: FontButton, show_size: bool) {.inline.} =

# gtk_font_button_set_show_style
# flags: {isMethod} container: FontButton
# need sugar: is method
# show_style 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_font_button_set_show_style(self: ptr TFontButton, show_style: bool) {.cdecl, dynlib: lib, importc: "gtk_font_button_set_show_style".}
proc set_show_style*(self: FontButton, show_style: bool) {.inline.} =
  gtk_font_button_set_show_style(self, show_style)
# proc set_show_style*(self: FontButton, show_style: bool) {.inline.} =

# gtk_font_button_set_title
# flags: {isMethod} container: FontButton
# need sugar: is method
# title 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_font_button_set_title(self: ptr TFontButton, title: ucstring) {.cdecl, dynlib: lib, importc: "gtk_font_button_set_title".}
proc set_title*(self: FontButton, title: ustring) {.inline.} =
  gtk_font_button_set_title(self, ucstring(title))
# proc set_title*(self: FontButton, title: ustring) {.inline.} =

# gtk_font_button_set_use_font
# flags: {isMethod} container: FontButton
# need sugar: is method
# use_font 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_font_button_set_use_font(self: ptr TFontButton, use_font: bool) {.cdecl, dynlib: lib, importc: "gtk_font_button_set_use_font".}
proc set_use_font*(self: FontButton, use_font: bool) {.inline.} =
  gtk_font_button_set_use_font(self, use_font)
# proc set_use_font*(self: FontButton, use_font: bool) {.inline.} =

# gtk_font_button_set_use_size
# flags: {isMethod} container: FontButton
# need sugar: is method
# use_size 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_font_button_set_use_size(self: ptr TFontButton, use_size: bool) {.cdecl, dynlib: lib, importc: "gtk_font_button_set_use_size".}
proc set_use_size*(self: FontButton, use_size: bool) {.inline.} =
  gtk_font_button_set_use_size(self, use_size)
# proc set_use_size*(self: FontButton, use_size: bool) {.inline.} =

# gtk_font_chooser_dialog_new
# flags: {isConstructor} container: FontChooserDialog
# need sugar: is static method
# title 'ustring' 'ucstring' IN (diff., need sugar)
# parent 'Window' 'ptr TWindow' IN (diff., need sugar)
# 'FontChooserDialog' 'TransferNone[TFontChooserDialog]' (diff., need sugar)
proc gtk_font_chooser_dialog_new(title: ucstring, parent: ptr TWindow): TransferNone[TFontChooserDialog] {.cdecl, dynlib: lib, importc: "gtk_font_chooser_dialog_new".}
proc new_fontchooserdialog*(title: ustring, parent: Window): FontChooserDialog {.inline.} =
  wrap(gtk_font_chooser_dialog_new(ucstring(title), parent.getPointer))
# proc new_fontchooserdialog*(title: ustring, parent: Window): FontChooserDialog {.inline.} =

# gtk_font_chooser_widget_new
# flags: {isConstructor} container: FontChooserWidget
# need sugar: is static method
# 'FontChooserWidget' 'TransferNone[TFontChooserWidget]' (diff., need sugar)
proc gtk_font_chooser_widget_new(): TransferNone[TFontChooserWidget] {.cdecl, dynlib: lib, importc: "gtk_font_chooser_widget_new".}
proc new_fontchooserwidget*(): FontChooserWidget {.inline.} =
  wrap(gtk_font_chooser_widget_new())
# proc new_fontchooserwidget*(): FontChooserWidget {.inline.} =

# gtk_font_selection_new
# flags: {isConstructor} container: FontSelection (deprecated)
# gtk_font_selection_get_face
# flags: {isMethod} container: FontSelection (deprecated)
# gtk_font_selection_get_face_list
# flags: {isMethod} container: FontSelection (deprecated)
# gtk_font_selection_get_family
# flags: {isMethod} container: FontSelection (deprecated)
# gtk_font_selection_get_family_list
# flags: {isMethod} container: FontSelection (deprecated)
# gtk_font_selection_get_font_name
# flags: {isMethod} container: FontSelection (deprecated)
# gtk_font_selection_get_preview_entry
# flags: {isMethod} container: FontSelection (deprecated)
# gtk_font_selection_get_preview_text
# flags: {isMethod} container: FontSelection (deprecated)
# gtk_font_selection_get_size
# flags: {isMethod} container: FontSelection (deprecated)
# gtk_font_selection_get_size_entry
# flags: {isMethod} container: FontSelection (deprecated)
# gtk_font_selection_get_size_list
# flags: {isMethod} container: FontSelection (deprecated)
# gtk_font_selection_set_font_name
# flags: {isMethod} container: FontSelection (deprecated)
# gtk_font_selection_set_preview_text
# flags: {isMethod} container: FontSelection (deprecated)
# gtk_font_selection_dialog_new
# flags: {isConstructor} container: FontSelectionDialog (deprecated)
# gtk_font_selection_dialog_get_cancel_button
# flags: {isMethod} container: FontSelectionDialog (deprecated)
# gtk_font_selection_dialog_get_font_name
# flags: {isMethod} container: FontSelectionDialog (deprecated)
# gtk_font_selection_dialog_get_font_selection
# flags: {isMethod} container: FontSelectionDialog (deprecated)
# gtk_font_selection_dialog_get_ok_button
# flags: {isMethod} container: FontSelectionDialog (deprecated)
# gtk_font_selection_dialog_get_preview_text
# flags: {isMethod} container: FontSelectionDialog (deprecated)
# gtk_font_selection_dialog_set_font_name
# flags: {isMethod} container: FontSelectionDialog (deprecated)
# gtk_font_selection_dialog_set_preview_text
# flags: {isMethod} container: FontSelectionDialog (deprecated)
# gtk_frame_new
# flags: {isConstructor} container: Frame
# need sugar: is static method
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'Frame' 'TransferNone[TFrame]' (diff., need sugar)
proc gtk_frame_new(label: ucstring): TransferNone[TFrame] {.cdecl, dynlib: lib, importc: "gtk_frame_new".}
proc new_frame*(label: ustring): Frame {.inline.} =
  wrap(gtk_frame_new(ucstring(label)))
# proc new_frame*(label: ustring): Frame {.inline.} =

# gtk_frame_get_label
# flags: {isMethod} container: Frame
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_frame_get_label(self: ptr TFrame): ucstring {.cdecl, dynlib: lib, importc: "gtk_frame_get_label".}
proc get_label*(self: Frame): ustring {.inline.} =
  ustring($(gtk_frame_get_label(self)))
# proc get_label*(self: Frame): ustring {.inline.} =

# gtk_frame_get_label_align
# flags: {isMethod} container: Frame
# need sugar: is method
# xalign 'var float32' 'ptr float32' OUT (diff., need sugar) optional
# yalign 'var float32' 'ptr float32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_frame_get_label_align(self: ptr TFrame, xalign: ptr float32, yalign: ptr float32) {.cdecl, dynlib: lib, importc: "gtk_frame_get_label_align".}
proc get_label_align*(self: Frame, xalign: var float32, yalign: var float32) {.inline.} =
  gtk_frame_get_label_align(self, addr(xalign), addr(yalign))
# tuple-return
# xalign: var float32
# yalign: var float32
# proc get_label_align*(self: Frame) {.inline.} =

# gtk_frame_get_label_widget
# flags: {isMethod} container: Frame
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_frame_get_label_widget(self: ptr TFrame): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_frame_get_label_widget".}
proc get_label_widget*(self: Frame): Widget {.inline.} =
  wrap(gtk_frame_get_label_widget(self))
# proc get_label_widget*(self: Frame): Widget {.inline.} =

# gtk_frame_get_shadow_type
# flags: {isMethod} container: Frame
# need sugar: is method
# 'ShadowType' 'ShadowType'
proc gtk_frame_get_shadow_type(self: ptr TFrame): ShadowType {.cdecl, dynlib: lib, importc: "gtk_frame_get_shadow_type".}
proc get_shadow_type*(self: Frame): ShadowType {.inline.} =
  gtk_frame_get_shadow_type(self)
# proc get_shadow_type*(self: Frame): ShadowType {.inline.} =

# gtk_frame_set_label
# flags: {isMethod} container: Frame
# need sugar: is method
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_frame_set_label(self: ptr TFrame, label: ucstring) {.cdecl, dynlib: lib, importc: "gtk_frame_set_label".}
proc set_label*(self: Frame, label: ustring) {.inline.} =
  gtk_frame_set_label(self, ucstring(label))
# proc set_label*(self: Frame, label: ustring) {.inline.} =

# gtk_frame_set_label_align
# flags: {isMethod} container: Frame
# need sugar: is method
# xalign 'float32' 'float32' IN
# yalign 'float32' 'float32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_frame_set_label_align(self: ptr TFrame, xalign: float32, yalign: float32) {.cdecl, dynlib: lib, importc: "gtk_frame_set_label_align".}
proc set_label_align*(self: Frame, xalign: float32, yalign: float32) {.inline.} =
  gtk_frame_set_label_align(self, xalign, yalign)
# proc set_label_align*(self: Frame, xalign: float32, yalign: float32) {.inline.} =

# gtk_frame_set_label_widget
# flags: {isMethod} container: Frame
# need sugar: is method
# label_widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_frame_set_label_widget(self: ptr TFrame, label_widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_frame_set_label_widget".}
proc set_label_widget*(self: Frame, label_widget: Widget) {.inline.} =
  gtk_frame_set_label_widget(self, label_widget.getPointer)
# proc set_label_widget*(self: Frame, label_widget: Widget) {.inline.} =

# gtk_frame_set_shadow_type
# flags: {isMethod} container: Frame
# need sugar: is method
# type 'ShadowType' 'ShadowType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_frame_set_shadow_type(self: ptr TFrame, type_x: ShadowType) {.cdecl, dynlib: lib, importc: "gtk_frame_set_shadow_type".}
proc set_shadow_type*(self: Frame, type_x: ShadowType) {.inline.} =
  gtk_frame_set_shadow_type(self, type_x)
# proc set_shadow_type*(self: Frame, type_x: ShadowType) {.inline.} =

# gtk_gesture_get_bounding_box
# flags: {isMethod} container: Gesture
# need sugar: is method
# rect 'var cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' OUT (diff., need sugar) caller-allocates
# 'bool' 'bool'
proc gtk_gesture_get_bounding_box(self: ptr TGesture, rect: ptr cairo1.TRectangleInt): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_get_bounding_box".}
proc get_bounding_box*(self: Gesture, rect: var cairo1.TRectangleInt): bool {.inline.} =
  gtk_gesture_get_bounding_box(self, addr(rect))
# tuple-return
# rect: var cairo1.TRectangleInt
# proc get_bounding_box*(self: Gesture): bool {.inline.} =

# gtk_gesture_get_bounding_box_center
# flags: {isMethod} container: Gesture
# need sugar: is method
# x 'var float64' 'ptr float64' OUT (diff., need sugar)
# y 'var float64' 'ptr float64' OUT (diff., need sugar)
# 'bool' 'bool'
proc gtk_gesture_get_bounding_box_center(self: ptr TGesture, x: ptr float64, y: ptr float64): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_get_bounding_box_center".}
proc get_bounding_box_center*(self: Gesture, x: var float64, y: var float64): bool {.inline.} =
  gtk_gesture_get_bounding_box_center(self, addr(x), addr(y))
# tuple-return
# x: var float64
# y: var float64
# proc get_bounding_box_center*(self: Gesture): bool {.inline.} =

# gtk_gesture_get_device
# flags: {isMethod} container: Gesture
# need sugar: is method
# 'Gdk3.Device' 'TransferNone[Gdk3.TDevice]' (diff., need sugar)
proc gtk_gesture_get_device(self: ptr TGesture): TransferNone[Gdk3.TDevice] {.cdecl, dynlib: lib, importc: "gtk_gesture_get_device".}
proc get_device*(self: Gesture): Gdk3.Device {.inline.} =
  wrap(gtk_gesture_get_device(self))
# proc get_device*(self: Gesture): Gdk3.Device {.inline.} =

# gtk_gesture_get_group
# flags: {isMethod} container: Gesture
# need sugar: is method
# 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_gesture_get_group(self: ptr TGesture): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_gesture_get_group".}
proc get_group*(self: Gesture): ptr GLIST_TODO {.inline.} =
  gtk_gesture_get_group(self)
# proc get_group*(self: Gesture): ptr GLIST_TODO {.inline.} =

# gtk_gesture_get_last_event
# flags: {isMethod} container: Gesture
# need sugar: is method
# sequence 'Gdk3.TEventSequence' 'ptr Gdk3.TEventSequence' IN (diff., need sugar)
# 'Gdk3.TEvent' 'ptr Gdk3.TEvent' (diff., need sugar)
proc gtk_gesture_get_last_event(self: ptr TGesture, sequence: ptr Gdk3.TEventSequence): ptr Gdk3.TEvent {.cdecl, dynlib: lib, importc: "gtk_gesture_get_last_event".}
proc get_last_event*(self: Gesture, sequence: Gdk3.TEventSequence): Gdk3.TEvent {.inline.} =
  (gtk_gesture_get_last_event(self, myUnsafeAddr(sequence)))[]
# proc get_last_event*(self: Gesture, sequence: Gdk3.TEventSequence): Gdk3.TEvent {.inline.} =

# gtk_gesture_get_last_updated_sequence
# flags: {isMethod} container: Gesture
# need sugar: is method
# 'Gdk3.TEventSequence' 'ptr Gdk3.TEventSequence' (diff., need sugar)
proc gtk_gesture_get_last_updated_sequence(self: ptr TGesture): ptr Gdk3.TEventSequence {.cdecl, dynlib: lib, importc: "gtk_gesture_get_last_updated_sequence".}
proc get_last_updated_sequence*(self: Gesture): Gdk3.TEventSequence {.inline.} =
  (gtk_gesture_get_last_updated_sequence(self))[]
# proc get_last_updated_sequence*(self: Gesture): Gdk3.TEventSequence {.inline.} =

# gtk_gesture_get_point
# flags: {isMethod} container: Gesture
# need sugar: is method
# sequence 'Gdk3.TEventSequence' 'ptr Gdk3.TEventSequence' IN (diff., need sugar)
# x 'var float64' 'ptr float64' OUT (diff., need sugar) optional
# y 'var float64' 'ptr float64' OUT (diff., need sugar) optional
# 'bool' 'bool'
proc gtk_gesture_get_point(self: ptr TGesture, sequence: ptr Gdk3.TEventSequence, x: ptr float64, y: ptr float64): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_get_point".}
proc get_point*(self: Gesture, sequence: Gdk3.TEventSequence, x: var float64, y: var float64): bool {.inline.} =
  gtk_gesture_get_point(self, myUnsafeAddr(sequence), addr(x), addr(y))
# tuple-return
# x: var float64
# y: var float64
# proc get_point*(self: Gesture, sequence: Gdk3.TEventSequence): bool {.inline.} =

# gtk_gesture_get_sequence_state
# flags: {isMethod} container: Gesture
# need sugar: is method
# sequence 'Gdk3.TEventSequence' 'ptr Gdk3.TEventSequence' IN (diff., need sugar)
# 'EventSequenceState' 'EventSequenceState'
proc gtk_gesture_get_sequence_state(self: ptr TGesture, sequence: ptr Gdk3.TEventSequence): EventSequenceState {.cdecl, dynlib: lib, importc: "gtk_gesture_get_sequence_state".}
proc get_sequence_state*(self: Gesture, sequence: Gdk3.TEventSequence): EventSequenceState {.inline.} =
  gtk_gesture_get_sequence_state(self, myUnsafeAddr(sequence))
# proc get_sequence_state*(self: Gesture, sequence: Gdk3.TEventSequence): EventSequenceState {.inline.} =

# gtk_gesture_get_sequences
# flags: {isMethod} container: Gesture
# need sugar: is method
# 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_gesture_get_sequences(self: ptr TGesture): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_gesture_get_sequences".}
proc get_sequences*(self: Gesture): ptr GLIST_TODO {.inline.} =
  gtk_gesture_get_sequences(self)
# proc get_sequences*(self: Gesture): ptr GLIST_TODO {.inline.} =

# gtk_gesture_get_window
# flags: {isMethod} container: Gesture
# need sugar: is method
# 'Gdk3.Window' 'TransferNone[Gdk3.TWindow]' (diff., need sugar)
proc gtk_gesture_get_window(self: ptr TGesture): TransferNone[Gdk3.TWindow] {.cdecl, dynlib: lib, importc: "gtk_gesture_get_window".}
proc get_window*(self: Gesture): Gdk3.Window {.inline.} =
  wrap(gtk_gesture_get_window(self))
# proc get_window*(self: Gesture): Gdk3.Window {.inline.} =

# gtk_gesture_group
# flags: {isMethod} container: Gesture
# need sugar: is method
# gesture 'Gesture' 'ptr TGesture' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_gesture_group(self: ptr TGesture, gesture: ptr TGesture) {.cdecl, dynlib: lib, importc: "gtk_gesture_group".}
proc group*(self: Gesture, gesture: Gesture) {.inline.} =
  gtk_gesture_group(self, gesture.getPointer)
# proc group*(self: Gesture, gesture: Gesture) {.inline.} =

# gtk_gesture_handles_sequence
# flags: {isMethod} container: Gesture
# need sugar: is method
# sequence 'Gdk3.TEventSequence' 'ptr Gdk3.TEventSequence' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_gesture_handles_sequence(self: ptr TGesture, sequence: ptr Gdk3.TEventSequence): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_handles_sequence".}
proc handles_sequence*(self: Gesture, sequence: Gdk3.TEventSequence): bool {.inline.} =
  gtk_gesture_handles_sequence(self, myUnsafeAddr(sequence))
# proc handles_sequence*(self: Gesture, sequence: Gdk3.TEventSequence): bool {.inline.} =

# gtk_gesture_is_active
# flags: {isMethod} container: Gesture
# need sugar: is method
# 'bool' 'bool'
proc gtk_gesture_is_active(self: ptr TGesture): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_is_active".}
proc is_active*(self: Gesture): bool {.inline.} =
  gtk_gesture_is_active(self)
# proc is_active*(self: Gesture): bool {.inline.} =

# gtk_gesture_is_grouped_with
# flags: {isMethod} container: Gesture
# need sugar: is method
# other 'Gesture' 'ptr TGesture' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_gesture_is_grouped_with(self: ptr TGesture, other: ptr TGesture): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_is_grouped_with".}
proc is_grouped_with*(self: Gesture, other: Gesture): bool {.inline.} =
  gtk_gesture_is_grouped_with(self, other.getPointer)
# proc is_grouped_with*(self: Gesture, other: Gesture): bool {.inline.} =

# gtk_gesture_is_recognized
# flags: {isMethod} container: Gesture
# need sugar: is method
# 'bool' 'bool'
proc gtk_gesture_is_recognized(self: ptr TGesture): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_is_recognized".}
proc is_recognized*(self: Gesture): bool {.inline.} =
  gtk_gesture_is_recognized(self)
# proc is_recognized*(self: Gesture): bool {.inline.} =

# gtk_gesture_set_sequence_state
# flags: {isMethod} container: Gesture
# need sugar: is method
# sequence 'Gdk3.TEventSequence' 'ptr Gdk3.TEventSequence' IN (diff., need sugar)
# state 'EventSequenceState' 'EventSequenceState' IN
# 'bool' 'bool'
proc gtk_gesture_set_sequence_state(self: ptr TGesture, sequence: ptr Gdk3.TEventSequence, state: EventSequenceState): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_set_sequence_state".}
proc set_sequence_state*(self: Gesture, sequence: Gdk3.TEventSequence, state: EventSequenceState): bool {.inline.} =
  gtk_gesture_set_sequence_state(self, myUnsafeAddr(sequence), state)
# proc set_sequence_state*(self: Gesture, sequence: Gdk3.TEventSequence, state: EventSequenceState): bool {.inline.} =

# gtk_gesture_set_state
# flags: {isMethod} container: Gesture
# need sugar: is method
# state 'EventSequenceState' 'EventSequenceState' IN
# 'bool' 'bool'
proc gtk_gesture_set_state(self: ptr TGesture, state: EventSequenceState): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_set_state".}
proc set_state*(self: Gesture, state: EventSequenceState): bool {.inline.} =
  gtk_gesture_set_state(self, state)
# proc set_state*(self: Gesture, state: EventSequenceState): bool {.inline.} =

# gtk_gesture_set_window
# flags: {isMethod} container: Gesture
# need sugar: is method
# window 'Gdk3.Window' 'ptr Gdk3.TWindow' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_gesture_set_window(self: ptr TGesture, window: ptr Gdk3.TWindow) {.cdecl, dynlib: lib, importc: "gtk_gesture_set_window".}
proc set_window*(self: Gesture, window: Gdk3.Window) {.inline.} =
  gtk_gesture_set_window(self, window.getPointer)
# proc set_window*(self: Gesture, window: Gdk3.Window) {.inline.} =

# gtk_gesture_ungroup
# flags: {isMethod} container: Gesture
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_gesture_ungroup(self: ptr TGesture) {.cdecl, dynlib: lib, importc: "gtk_gesture_ungroup".}
proc ungroup*(self: Gesture) {.inline.} =
  gtk_gesture_ungroup(self)
# proc ungroup*(self: Gesture) {.inline.} =

# gtk_gesture_drag_new
# flags: {isConstructor} container: GestureDrag
# need sugar: is static method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'GestureDrag' 'TransferFull[TGestureDrag]' (diff., need sugar)
proc gtk_gesture_drag_new(widget: ptr TWidget): TransferFull[TGestureDrag] {.cdecl, dynlib: lib, importc: "gtk_gesture_drag_new".}
proc new_gesturedrag*(widget: Widget): GestureDrag {.inline.} =
  wrap(gtk_gesture_drag_new(widget.getPointer))
# proc new_gesturedrag*(widget: Widget): GestureDrag {.inline.} =

# gtk_gesture_drag_get_offset
# flags: {isMethod} container: GestureDrag
# need sugar: is method
# x 'var float64' 'ptr float64' OUT (diff., need sugar)
# y 'var float64' 'ptr float64' OUT (diff., need sugar)
# 'bool' 'bool'
proc gtk_gesture_drag_get_offset(self: ptr TGestureDrag, x: ptr float64, y: ptr float64): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_drag_get_offset".}
proc get_offset*(self: GestureDrag, x: var float64, y: var float64): bool {.inline.} =
  gtk_gesture_drag_get_offset(self, addr(x), addr(y))
# tuple-return
# x: var float64
# y: var float64
# proc get_offset*(self: GestureDrag): bool {.inline.} =

# gtk_gesture_drag_get_start_point
# flags: {isMethod} container: GestureDrag
# need sugar: is method
# x 'var float64' 'ptr float64' OUT (diff., need sugar)
# y 'var float64' 'ptr float64' OUT (diff., need sugar)
# 'bool' 'bool'
proc gtk_gesture_drag_get_start_point(self: ptr TGestureDrag, x: ptr float64, y: ptr float64): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_drag_get_start_point".}
proc get_start_point*(self: GestureDrag, x: var float64, y: var float64): bool {.inline.} =
  gtk_gesture_drag_get_start_point(self, addr(x), addr(y))
# tuple-return
# x: var float64
# y: var float64
# proc get_start_point*(self: GestureDrag): bool {.inline.} =

# gtk_gesture_long_press_new
# flags: {isConstructor} container: GestureLongPress
# need sugar: is static method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'GestureLongPress' 'TransferFull[TGestureLongPress]' (diff., need sugar)
proc gtk_gesture_long_press_new(widget: ptr TWidget): TransferFull[TGestureLongPress] {.cdecl, dynlib: lib, importc: "gtk_gesture_long_press_new".}
proc new_gesturelongpress*(widget: Widget): GestureLongPress {.inline.} =
  wrap(gtk_gesture_long_press_new(widget.getPointer))
# proc new_gesturelongpress*(widget: Widget): GestureLongPress {.inline.} =

# gtk_gesture_multi_press_new
# flags: {isConstructor} container: GestureMultiPress
# need sugar: is static method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'GestureMultiPress' 'TransferFull[TGestureMultiPress]' (diff., need sugar)
proc gtk_gesture_multi_press_new(widget: ptr TWidget): TransferFull[TGestureMultiPress] {.cdecl, dynlib: lib, importc: "gtk_gesture_multi_press_new".}
proc new_gesturemultipress*(widget: Widget): GestureMultiPress {.inline.} =
  wrap(gtk_gesture_multi_press_new(widget.getPointer))
# proc new_gesturemultipress*(widget: Widget): GestureMultiPress {.inline.} =

# gtk_gesture_multi_press_get_area
# flags: {isMethod} container: GestureMultiPress
# need sugar: is method
# rect 'var cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' OUT (diff., need sugar) caller-allocates
# 'bool' 'bool'
proc gtk_gesture_multi_press_get_area(self: ptr TGestureMultiPress, rect: ptr cairo1.TRectangleInt): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_multi_press_get_area".}
proc get_area*(self: GestureMultiPress, rect: var cairo1.TRectangleInt): bool {.inline.} =
  gtk_gesture_multi_press_get_area(self, addr(rect))
# tuple-return
# rect: var cairo1.TRectangleInt
# proc get_area*(self: GestureMultiPress): bool {.inline.} =

# gtk_gesture_multi_press_set_area
# flags: {isMethod} container: GestureMultiPress
# need sugar: is method
# rect 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_gesture_multi_press_set_area(self: ptr TGestureMultiPress, rect: ptr cairo1.TRectangleInt) {.cdecl, dynlib: lib, importc: "gtk_gesture_multi_press_set_area".}
proc set_area*(self: GestureMultiPress, rect: cairo1.TRectangleInt) {.inline.} =
  gtk_gesture_multi_press_set_area(self, myUnsafeAddr(rect))
# proc set_area*(self: GestureMultiPress, rect: cairo1.TRectangleInt) {.inline.} =

# gtk_gesture_pan_new
# flags: {isConstructor} container: GesturePan
# need sugar: is static method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# orientation 'Orientation' 'Orientation' IN
# 'GesturePan' 'TransferFull[TGesturePan]' (diff., need sugar)
proc gtk_gesture_pan_new(widget: ptr TWidget, orientation: Orientation): TransferFull[TGesturePan] {.cdecl, dynlib: lib, importc: "gtk_gesture_pan_new".}
proc new_gesturepan*(widget: Widget, orientation: Orientation): GesturePan {.inline.} =
  wrap(gtk_gesture_pan_new(widget.getPointer, orientation))
# proc new_gesturepan*(widget: Widget, orientation: Orientation): GesturePan {.inline.} =

# gtk_gesture_pan_get_orientation
# flags: {isMethod} container: GesturePan
# need sugar: is method
# 'Orientation' 'Orientation'
proc gtk_gesture_pan_get_orientation(self: ptr TGesturePan): Orientation {.cdecl, dynlib: lib, importc: "gtk_gesture_pan_get_orientation".}
proc get_orientation*(self: GesturePan): Orientation {.inline.} =
  gtk_gesture_pan_get_orientation(self)
# proc get_orientation*(self: GesturePan): Orientation {.inline.} =

# gtk_gesture_pan_set_orientation
# flags: {isMethod} container: GesturePan
# need sugar: is method
# orientation 'Orientation' 'Orientation' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_gesture_pan_set_orientation(self: ptr TGesturePan, orientation: Orientation) {.cdecl, dynlib: lib, importc: "gtk_gesture_pan_set_orientation".}
proc set_orientation*(self: GesturePan, orientation: Orientation) {.inline.} =
  gtk_gesture_pan_set_orientation(self, orientation)
# proc set_orientation*(self: GesturePan, orientation: Orientation) {.inline.} =

# gtk_gesture_rotate_new
# flags: {isConstructor} container: GestureRotate
# need sugar: is static method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'GestureRotate' 'TransferFull[TGestureRotate]' (diff., need sugar)
proc gtk_gesture_rotate_new(widget: ptr TWidget): TransferFull[TGestureRotate] {.cdecl, dynlib: lib, importc: "gtk_gesture_rotate_new".}
proc new_gesturerotate*(widget: Widget): GestureRotate {.inline.} =
  wrap(gtk_gesture_rotate_new(widget.getPointer))
# proc new_gesturerotate*(widget: Widget): GestureRotate {.inline.} =

# gtk_gesture_rotate_get_angle_delta
# flags: {isMethod} container: GestureRotate
# need sugar: is method
# 'float64' 'float64'
proc gtk_gesture_rotate_get_angle_delta(self: ptr TGestureRotate): float64 {.cdecl, dynlib: lib, importc: "gtk_gesture_rotate_get_angle_delta".}
proc get_angle_delta*(self: GestureRotate): float64 {.inline.} =
  gtk_gesture_rotate_get_angle_delta(self)
# proc get_angle_delta*(self: GestureRotate): float64 {.inline.} =

# gtk_gesture_single_get_button
# flags: {isMethod} container: GestureSingle
# need sugar: is method
# 'uint32' 'uint32'
proc gtk_gesture_single_get_button(self: ptr TGestureSingle): uint32 {.cdecl, dynlib: lib, importc: "gtk_gesture_single_get_button".}
proc get_button*(self: GestureSingle): uint32 {.inline.} =
  gtk_gesture_single_get_button(self)
# proc get_button*(self: GestureSingle): uint32 {.inline.} =

# gtk_gesture_single_get_current_button
# flags: {isMethod} container: GestureSingle
# need sugar: is method
# 'uint32' 'uint32'
proc gtk_gesture_single_get_current_button(self: ptr TGestureSingle): uint32 {.cdecl, dynlib: lib, importc: "gtk_gesture_single_get_current_button".}
proc get_current_button*(self: GestureSingle): uint32 {.inline.} =
  gtk_gesture_single_get_current_button(self)
# proc get_current_button*(self: GestureSingle): uint32 {.inline.} =

# gtk_gesture_single_get_current_sequence
# flags: {isMethod} container: GestureSingle
# need sugar: is method
# 'Gdk3.TEventSequence' 'ptr Gdk3.TEventSequence' (diff., need sugar)
proc gtk_gesture_single_get_current_sequence(self: ptr TGestureSingle): ptr Gdk3.TEventSequence {.cdecl, dynlib: lib, importc: "gtk_gesture_single_get_current_sequence".}
proc get_current_sequence*(self: GestureSingle): Gdk3.TEventSequence {.inline.} =
  (gtk_gesture_single_get_current_sequence(self))[]
# proc get_current_sequence*(self: GestureSingle): Gdk3.TEventSequence {.inline.} =

# gtk_gesture_single_get_exclusive
# flags: {isMethod} container: GestureSingle
# need sugar: is method
# 'bool' 'bool'
proc gtk_gesture_single_get_exclusive(self: ptr TGestureSingle): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_single_get_exclusive".}
proc get_exclusive*(self: GestureSingle): bool {.inline.} =
  gtk_gesture_single_get_exclusive(self)
# proc get_exclusive*(self: GestureSingle): bool {.inline.} =

# gtk_gesture_single_get_touch_only
# flags: {isMethod} container: GestureSingle
# need sugar: is method
# 'bool' 'bool'
proc gtk_gesture_single_get_touch_only(self: ptr TGestureSingle): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_single_get_touch_only".}
proc get_touch_only*(self: GestureSingle): bool {.inline.} =
  gtk_gesture_single_get_touch_only(self)
# proc get_touch_only*(self: GestureSingle): bool {.inline.} =

# gtk_gesture_single_set_button
# flags: {isMethod} container: GestureSingle
# need sugar: is method
# button 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_gesture_single_set_button(self: ptr TGestureSingle, button: uint32) {.cdecl, dynlib: lib, importc: "gtk_gesture_single_set_button".}
proc set_button*(self: GestureSingle, button: uint32) {.inline.} =
  gtk_gesture_single_set_button(self, button)
# proc set_button*(self: GestureSingle, button: uint32) {.inline.} =

# gtk_gesture_single_set_exclusive
# flags: {isMethod} container: GestureSingle
# need sugar: is method
# exclusive 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_gesture_single_set_exclusive(self: ptr TGestureSingle, exclusive: bool) {.cdecl, dynlib: lib, importc: "gtk_gesture_single_set_exclusive".}
proc set_exclusive*(self: GestureSingle, exclusive: bool) {.inline.} =
  gtk_gesture_single_set_exclusive(self, exclusive)
# proc set_exclusive*(self: GestureSingle, exclusive: bool) {.inline.} =

# gtk_gesture_single_set_touch_only
# flags: {isMethod} container: GestureSingle
# need sugar: is method
# touch_only 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_gesture_single_set_touch_only(self: ptr TGestureSingle, touch_only: bool) {.cdecl, dynlib: lib, importc: "gtk_gesture_single_set_touch_only".}
proc set_touch_only*(self: GestureSingle, touch_only: bool) {.inline.} =
  gtk_gesture_single_set_touch_only(self, touch_only)
# proc set_touch_only*(self: GestureSingle, touch_only: bool) {.inline.} =

# gtk_gesture_swipe_new
# flags: {isConstructor} container: GestureSwipe
# need sugar: is static method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'GestureSwipe' 'TransferFull[TGestureSwipe]' (diff., need sugar)
proc gtk_gesture_swipe_new(widget: ptr TWidget): TransferFull[TGestureSwipe] {.cdecl, dynlib: lib, importc: "gtk_gesture_swipe_new".}
proc new_gestureswipe*(widget: Widget): GestureSwipe {.inline.} =
  wrap(gtk_gesture_swipe_new(widget.getPointer))
# proc new_gestureswipe*(widget: Widget): GestureSwipe {.inline.} =

# gtk_gesture_swipe_get_velocity
# flags: {isMethod} container: GestureSwipe
# need sugar: is method
# velocity_x 'var float64' 'ptr float64' OUT (diff., need sugar)
# velocity_y 'var float64' 'ptr float64' OUT (diff., need sugar)
# 'bool' 'bool'
proc gtk_gesture_swipe_get_velocity(self: ptr TGestureSwipe, velocity_x: ptr float64, velocity_y: ptr float64): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_swipe_get_velocity".}
proc get_velocity*(self: GestureSwipe, velocity_x: var float64, velocity_y: var float64): bool {.inline.} =
  gtk_gesture_swipe_get_velocity(self, addr(velocity_x), addr(velocity_y))
# tuple-return
# velocity_x: var float64
# velocity_y: var float64
# proc get_velocity*(self: GestureSwipe): bool {.inline.} =

# gtk_gesture_zoom_new
# flags: {isConstructor} container: GestureZoom
# need sugar: is static method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'GestureZoom' 'TransferFull[TGestureZoom]' (diff., need sugar)
proc gtk_gesture_zoom_new(widget: ptr TWidget): TransferFull[TGestureZoom] {.cdecl, dynlib: lib, importc: "gtk_gesture_zoom_new".}
proc new_gesturezoom*(widget: Widget): GestureZoom {.inline.} =
  wrap(gtk_gesture_zoom_new(widget.getPointer))
# proc new_gesturezoom*(widget: Widget): GestureZoom {.inline.} =

# gtk_gesture_zoom_get_scale_delta
# flags: {isMethod} container: GestureZoom
# need sugar: is method
# 'float64' 'float64'
proc gtk_gesture_zoom_get_scale_delta(self: ptr TGestureZoom): float64 {.cdecl, dynlib: lib, importc: "gtk_gesture_zoom_get_scale_delta".}
proc get_scale_delta*(self: GestureZoom): float64 {.inline.} =
  gtk_gesture_zoom_get_scale_delta(self)
# proc get_scale_delta*(self: GestureZoom): float64 {.inline.} =

# gtk_grid_new
# flags: {isConstructor} container: Grid
# need sugar: is static method
# 'Grid' 'TransferNone[TGrid]' (diff., need sugar)
proc gtk_grid_new(): TransferNone[TGrid] {.cdecl, dynlib: lib, importc: "gtk_grid_new".}
proc new_grid*(): Grid {.inline.} =
  wrap(gtk_grid_new())
# proc new_grid*(): Grid {.inline.} =

# gtk_grid_attach
# flags: {isMethod} container: Grid
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# left 'int32' 'int32' IN
# top 'int32' 'int32' IN
# width 'int32' 'int32' IN
# height 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_grid_attach(self: ptr TGrid, child: ptr TWidget, left: int32, top: int32, width: int32, height: int32) {.cdecl, dynlib: lib, importc: "gtk_grid_attach".}
proc attach*(self: Grid, child: Widget, left: int32, top: int32, width: int32, height: int32) {.inline.} =
  gtk_grid_attach(self, child.getPointer, left, top, width, height)
# proc attach*(self: Grid, child: Widget, left: int32, top: int32, width: int32, height: int32) {.inline.} =

# gtk_grid_attach_next_to
# flags: {isMethod} container: Grid
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# sibling 'Widget' 'ptr TWidget' IN (diff., need sugar)
# side 'PositionType' 'PositionType' IN
# width 'int32' 'int32' IN
# height 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_grid_attach_next_to(self: ptr TGrid, child: ptr TWidget, sibling: ptr TWidget, side: PositionType, width: int32, height: int32) {.cdecl, dynlib: lib, importc: "gtk_grid_attach_next_to".}
proc attach_next_to*(self: Grid, child: Widget, sibling: Widget, side: PositionType, width: int32, height: int32) {.inline.} =
  gtk_grid_attach_next_to(self, child.getPointer, sibling.getPointer, side, width, height)
# proc attach_next_to*(self: Grid, child: Widget, sibling: Widget, side: PositionType, width: int32, height: int32) {.inline.} =

# gtk_grid_get_baseline_row
# flags: {isMethod} container: Grid
# need sugar: is method
# 'int32' 'int32'
proc gtk_grid_get_baseline_row(self: ptr TGrid): int32 {.cdecl, dynlib: lib, importc: "gtk_grid_get_baseline_row".}
proc get_baseline_row*(self: Grid): int32 {.inline.} =
  gtk_grid_get_baseline_row(self)
# proc get_baseline_row*(self: Grid): int32 {.inline.} =

# gtk_grid_get_child_at
# flags: {isMethod} container: Grid
# need sugar: is method
# left 'int32' 'int32' IN
# top 'int32' 'int32' IN
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_grid_get_child_at(self: ptr TGrid, left: int32, top: int32): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_grid_get_child_at".}
proc get_child_at*(self: Grid, left: int32, top: int32): Widget {.inline.} =
  wrap(gtk_grid_get_child_at(self, left, top))
# proc get_child_at*(self: Grid, left: int32, top: int32): Widget {.inline.} =

# gtk_grid_get_column_homogeneous
# flags: {isMethod} container: Grid
# need sugar: is method
# 'bool' 'bool'
proc gtk_grid_get_column_homogeneous(self: ptr TGrid): bool {.cdecl, dynlib: lib, importc: "gtk_grid_get_column_homogeneous".}
proc get_column_homogeneous*(self: Grid): bool {.inline.} =
  gtk_grid_get_column_homogeneous(self)
# proc get_column_homogeneous*(self: Grid): bool {.inline.} =

# gtk_grid_get_column_spacing
# flags: {isMethod} container: Grid
# need sugar: is method
# 'uint32' 'uint32'
proc gtk_grid_get_column_spacing(self: ptr TGrid): uint32 {.cdecl, dynlib: lib, importc: "gtk_grid_get_column_spacing".}
proc get_column_spacing*(self: Grid): uint32 {.inline.} =
  gtk_grid_get_column_spacing(self)
# proc get_column_spacing*(self: Grid): uint32 {.inline.} =

# gtk_grid_get_row_baseline_position
# flags: {isMethod} container: Grid
# need sugar: is method
# row 'int32' 'int32' IN
# 'BaselinePosition' 'BaselinePosition'
proc gtk_grid_get_row_baseline_position(self: ptr TGrid, row: int32): BaselinePosition {.cdecl, dynlib: lib, importc: "gtk_grid_get_row_baseline_position".}
proc get_row_baseline_position*(self: Grid, row: int32): BaselinePosition {.inline.} =
  gtk_grid_get_row_baseline_position(self, row)
# proc get_row_baseline_position*(self: Grid, row: int32): BaselinePosition {.inline.} =

# gtk_grid_get_row_homogeneous
# flags: {isMethod} container: Grid
# need sugar: is method
# 'bool' 'bool'
proc gtk_grid_get_row_homogeneous(self: ptr TGrid): bool {.cdecl, dynlib: lib, importc: "gtk_grid_get_row_homogeneous".}
proc get_row_homogeneous*(self: Grid): bool {.inline.} =
  gtk_grid_get_row_homogeneous(self)
# proc get_row_homogeneous*(self: Grid): bool {.inline.} =

# gtk_grid_get_row_spacing
# flags: {isMethod} container: Grid
# need sugar: is method
# 'uint32' 'uint32'
proc gtk_grid_get_row_spacing(self: ptr TGrid): uint32 {.cdecl, dynlib: lib, importc: "gtk_grid_get_row_spacing".}
proc get_row_spacing*(self: Grid): uint32 {.inline.} =
  gtk_grid_get_row_spacing(self)
# proc get_row_spacing*(self: Grid): uint32 {.inline.} =

# gtk_grid_insert_column
# flags: {isMethod} container: Grid
# need sugar: is method
# position 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_grid_insert_column(self: ptr TGrid, position: int32) {.cdecl, dynlib: lib, importc: "gtk_grid_insert_column".}
proc insert_column*(self: Grid, position: int32) {.inline.} =
  gtk_grid_insert_column(self, position)
# proc insert_column*(self: Grid, position: int32) {.inline.} =

# gtk_grid_insert_next_to
# flags: {isMethod} container: Grid
# need sugar: is method
# sibling 'Widget' 'ptr TWidget' IN (diff., need sugar)
# side 'PositionType' 'PositionType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_grid_insert_next_to(self: ptr TGrid, sibling: ptr TWidget, side: PositionType) {.cdecl, dynlib: lib, importc: "gtk_grid_insert_next_to".}
proc insert_next_to*(self: Grid, sibling: Widget, side: PositionType) {.inline.} =
  gtk_grid_insert_next_to(self, sibling.getPointer, side)
# proc insert_next_to*(self: Grid, sibling: Widget, side: PositionType) {.inline.} =

# gtk_grid_insert_row
# flags: {isMethod} container: Grid
# need sugar: is method
# position 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_grid_insert_row(self: ptr TGrid, position: int32) {.cdecl, dynlib: lib, importc: "gtk_grid_insert_row".}
proc insert_row*(self: Grid, position: int32) {.inline.} =
  gtk_grid_insert_row(self, position)
# proc insert_row*(self: Grid, position: int32) {.inline.} =

# gtk_grid_remove_column
# flags: {isMethod} container: Grid
# need sugar: is method
# position 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_grid_remove_column(self: ptr TGrid, position: int32) {.cdecl, dynlib: lib, importc: "gtk_grid_remove_column".}
proc remove_column*(self: Grid, position: int32) {.inline.} =
  gtk_grid_remove_column(self, position)
# proc remove_column*(self: Grid, position: int32) {.inline.} =

# gtk_grid_remove_row
# flags: {isMethod} container: Grid
# need sugar: is method
# position 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_grid_remove_row(self: ptr TGrid, position: int32) {.cdecl, dynlib: lib, importc: "gtk_grid_remove_row".}
proc remove_row*(self: Grid, position: int32) {.inline.} =
  gtk_grid_remove_row(self, position)
# proc remove_row*(self: Grid, position: int32) {.inline.} =

# gtk_grid_set_baseline_row
# flags: {isMethod} container: Grid
# need sugar: is method
# row 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_grid_set_baseline_row(self: ptr TGrid, row: int32) {.cdecl, dynlib: lib, importc: "gtk_grid_set_baseline_row".}
proc set_baseline_row*(self: Grid, row: int32) {.inline.} =
  gtk_grid_set_baseline_row(self, row)
# proc set_baseline_row*(self: Grid, row: int32) {.inline.} =

# gtk_grid_set_column_homogeneous
# flags: {isMethod} container: Grid
# need sugar: is method
# homogeneous 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_grid_set_column_homogeneous(self: ptr TGrid, homogeneous: bool) {.cdecl, dynlib: lib, importc: "gtk_grid_set_column_homogeneous".}
proc set_column_homogeneous*(self: Grid, homogeneous: bool) {.inline.} =
  gtk_grid_set_column_homogeneous(self, homogeneous)
# proc set_column_homogeneous*(self: Grid, homogeneous: bool) {.inline.} =

# gtk_grid_set_column_spacing
# flags: {isMethod} container: Grid
# need sugar: is method
# spacing 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_grid_set_column_spacing(self: ptr TGrid, spacing: uint32) {.cdecl, dynlib: lib, importc: "gtk_grid_set_column_spacing".}
proc set_column_spacing*(self: Grid, spacing: uint32) {.inline.} =
  gtk_grid_set_column_spacing(self, spacing)
# proc set_column_spacing*(self: Grid, spacing: uint32) {.inline.} =

# gtk_grid_set_row_baseline_position
# flags: {isMethod} container: Grid
# need sugar: is method
# row 'int32' 'int32' IN
# pos 'BaselinePosition' 'BaselinePosition' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_grid_set_row_baseline_position(self: ptr TGrid, row: int32, pos: BaselinePosition) {.cdecl, dynlib: lib, importc: "gtk_grid_set_row_baseline_position".}
proc set_row_baseline_position*(self: Grid, row: int32, pos: BaselinePosition) {.inline.} =
  gtk_grid_set_row_baseline_position(self, row, pos)
# proc set_row_baseline_position*(self: Grid, row: int32, pos: BaselinePosition) {.inline.} =

# gtk_grid_set_row_homogeneous
# flags: {isMethod} container: Grid
# need sugar: is method
# homogeneous 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_grid_set_row_homogeneous(self: ptr TGrid, homogeneous: bool) {.cdecl, dynlib: lib, importc: "gtk_grid_set_row_homogeneous".}
proc set_row_homogeneous*(self: Grid, homogeneous: bool) {.inline.} =
  gtk_grid_set_row_homogeneous(self, homogeneous)
# proc set_row_homogeneous*(self: Grid, homogeneous: bool) {.inline.} =

# gtk_grid_set_row_spacing
# flags: {isMethod} container: Grid
# need sugar: is method
# spacing 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_grid_set_row_spacing(self: ptr TGrid, spacing: uint32) {.cdecl, dynlib: lib, importc: "gtk_grid_set_row_spacing".}
proc set_row_spacing*(self: Grid, spacing: uint32) {.inline.} =
  gtk_grid_set_row_spacing(self, spacing)
# proc set_row_spacing*(self: Grid, spacing: uint32) {.inline.} =

# gtk_hbox_new
# flags: {isConstructor} container: HBox (deprecated)
# gtk_hbutton_box_new
# flags: {isConstructor} container: HButtonBox (deprecated)
# gtk_hpaned_new
# flags: {isConstructor} container: HPaned (deprecated)
# gtk_hsv_new
# flags: {isConstructor} container: HSV
# need sugar: is static method
# 'HSV' 'TransferNone[THSV]' (diff., need sugar)
proc gtk_hsv_new(): TransferNone[THSV] {.cdecl, dynlib: lib, importc: "gtk_hsv_new".}
proc new_hsv*(): HSV {.inline.} =
  wrap(gtk_hsv_new())
# proc new_hsv*(): HSV {.inline.} =

# gtk_hsv_to_rgb
# flags: {} container: HSV
# need sugar: is static method
# h 'float64' 'float64' IN
# s 'float64' 'float64' IN
# v 'float64' 'float64' IN
# r 'var float64' 'ptr float64' OUT (diff., need sugar)
# g 'var float64' 'ptr float64' OUT (diff., need sugar)
# b 'var float64' 'ptr float64' OUT (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_hsv_to_rgb(h: float64, s: float64, v: float64, r: ptr float64, g: ptr float64, b: ptr float64) {.cdecl, dynlib: lib, importc: "gtk_hsv_to_rgb".}
template to_rgb*(klass_parameter: typedesc[HSV], h: float64, s: float64, v: float64, r: var float64, g: var float64, b: var float64) =
  gtk_hsv_to_rgb(h, s, v, addr(r), addr(g), addr(b))
# tuple-return
# r: var float64
# g: var float64
# b: var float64
# template to_rgb*(klass_parameter: typedesc[HSV], h: float64, s: float64, v: float64) =

# gtk_hsv_get_color
# flags: {isMethod} container: HSV
# need sugar: is method
# h 'var float64' 'ptr float64' OUT (diff., need sugar)
# s 'var float64' 'ptr float64' OUT (diff., need sugar)
# v 'var float64' 'ptr float64' OUT (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_hsv_get_color(self: ptr THSV, h: ptr float64, s: ptr float64, v: ptr float64) {.cdecl, dynlib: lib, importc: "gtk_hsv_get_color".}
proc get_color*(self: HSV, h: var float64, s: var float64, v: var float64) {.inline.} =
  gtk_hsv_get_color(self, addr(h), addr(s), addr(v))
# tuple-return
# h: var float64
# s: var float64
# v: var float64
# proc get_color*(self: HSV) {.inline.} =

# gtk_hsv_get_metrics
# flags: {isMethod} container: HSV
# need sugar: is method
# size 'var int32' 'ptr int32' OUT (diff., need sugar)
# ring_width 'var int32' 'ptr int32' OUT (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_hsv_get_metrics(self: ptr THSV, size: ptr int32, ring_width: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_hsv_get_metrics".}
proc get_metrics*(self: HSV, size: var int32, ring_width: var int32) {.inline.} =
  gtk_hsv_get_metrics(self, addr(size), addr(ring_width))
# tuple-return
# size: var int32
# ring_width: var int32
# proc get_metrics*(self: HSV) {.inline.} =

# gtk_hsv_is_adjusting
# flags: {isMethod} container: HSV
# need sugar: is method
# 'bool' 'bool'
proc gtk_hsv_is_adjusting(self: ptr THSV): bool {.cdecl, dynlib: lib, importc: "gtk_hsv_is_adjusting".}
proc is_adjusting*(self: HSV): bool {.inline.} =
  gtk_hsv_is_adjusting(self)
# proc is_adjusting*(self: HSV): bool {.inline.} =

# gtk_hsv_set_color
# flags: {isMethod} container: HSV
# need sugar: is method
# h 'float64' 'float64' IN
# s 'float64' 'float64' IN
# v 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_hsv_set_color(self: ptr THSV, h: float64, s: float64, v: float64) {.cdecl, dynlib: lib, importc: "gtk_hsv_set_color".}
proc set_color*(self: HSV, h: float64, s: float64, v: float64) {.inline.} =
  gtk_hsv_set_color(self, h, s, v)
# proc set_color*(self: HSV, h: float64, s: float64, v: float64) {.inline.} =

# gtk_hsv_set_metrics
# flags: {isMethod} container: HSV
# need sugar: is method
# size 'int32' 'int32' IN
# ring_width 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_hsv_set_metrics(self: ptr THSV, size: int32, ring_width: int32) {.cdecl, dynlib: lib, importc: "gtk_hsv_set_metrics".}
proc set_metrics*(self: HSV, size: int32, ring_width: int32) {.inline.} =
  gtk_hsv_set_metrics(self, size, ring_width)
# proc set_metrics*(self: HSV, size: int32, ring_width: int32) {.inline.} =

# gtk_hscale_new
# flags: {isConstructor} container: HScale (deprecated)
# gtk_hscale_new_with_range
# flags: {isConstructor} container: HScale (deprecated)
# gtk_hscrollbar_new
# flags: {isConstructor} container: HScrollbar (deprecated)
# gtk_hseparator_new
# flags: {isConstructor} container: HSeparator (deprecated)
# gtk_handle_box_new
# flags: {isConstructor} container: HandleBox (deprecated)
# gtk_handle_box_get_child_detached
# flags: {isMethod} container: HandleBox (deprecated)
# gtk_handle_box_get_handle_position
# flags: {isMethod} container: HandleBox (deprecated)
# gtk_handle_box_get_shadow_type
# flags: {isMethod} container: HandleBox (deprecated)
# gtk_handle_box_get_snap_edge
# flags: {isMethod} container: HandleBox (deprecated)
# gtk_handle_box_set_handle_position
# flags: {isMethod} container: HandleBox (deprecated)
# gtk_handle_box_set_shadow_type
# flags: {isMethod} container: HandleBox (deprecated)
# gtk_handle_box_set_snap_edge
# flags: {isMethod} container: HandleBox (deprecated)
# gtk_header_bar_new
# flags: {isConstructor} container: HeaderBar
# need sugar: is static method
# 'HeaderBar' 'TransferNone[THeaderBar]' (diff., need sugar)
proc gtk_header_bar_new(): TransferNone[THeaderBar] {.cdecl, dynlib: lib, importc: "gtk_header_bar_new".}
proc new_headerbar*(): HeaderBar {.inline.} =
  wrap(gtk_header_bar_new())
# proc new_headerbar*(): HeaderBar {.inline.} =

# gtk_header_bar_get_custom_title
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_header_bar_get_custom_title(self: ptr THeaderBar): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_header_bar_get_custom_title".}
proc get_custom_title*(self: HeaderBar): Widget {.inline.} =
  wrap(gtk_header_bar_get_custom_title(self))
# proc get_custom_title*(self: HeaderBar): Widget {.inline.} =

# gtk_header_bar_get_decoration_layout
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_header_bar_get_decoration_layout(self: ptr THeaderBar): ucstring {.cdecl, dynlib: lib, importc: "gtk_header_bar_get_decoration_layout".}
proc get_decoration_layout*(self: HeaderBar): ustring {.inline.} =
  ustring($(gtk_header_bar_get_decoration_layout(self)))
# proc get_decoration_layout*(self: HeaderBar): ustring {.inline.} =

# gtk_header_bar_get_has_subtitle
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# 'bool' 'bool'
proc gtk_header_bar_get_has_subtitle(self: ptr THeaderBar): bool {.cdecl, dynlib: lib, importc: "gtk_header_bar_get_has_subtitle".}
proc get_has_subtitle*(self: HeaderBar): bool {.inline.} =
  gtk_header_bar_get_has_subtitle(self)
# proc get_has_subtitle*(self: HeaderBar): bool {.inline.} =

# gtk_header_bar_get_show_close_button
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# 'bool' 'bool'
proc gtk_header_bar_get_show_close_button(self: ptr THeaderBar): bool {.cdecl, dynlib: lib, importc: "gtk_header_bar_get_show_close_button".}
proc get_show_close_button*(self: HeaderBar): bool {.inline.} =
  gtk_header_bar_get_show_close_button(self)
# proc get_show_close_button*(self: HeaderBar): bool {.inline.} =

# gtk_header_bar_get_subtitle
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_header_bar_get_subtitle(self: ptr THeaderBar): ucstring {.cdecl, dynlib: lib, importc: "gtk_header_bar_get_subtitle".}
proc get_subtitle*(self: HeaderBar): ustring {.inline.} =
  ustring($(gtk_header_bar_get_subtitle(self)))
# proc get_subtitle*(self: HeaderBar): ustring {.inline.} =

# gtk_header_bar_get_title
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_header_bar_get_title(self: ptr THeaderBar): ucstring {.cdecl, dynlib: lib, importc: "gtk_header_bar_get_title".}
proc get_title*(self: HeaderBar): ustring {.inline.} =
  ustring($(gtk_header_bar_get_title(self)))
# proc get_title*(self: HeaderBar): ustring {.inline.} =

# gtk_header_bar_pack_end
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_header_bar_pack_end(self: ptr THeaderBar, child: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_header_bar_pack_end".}
proc pack_end*(self: HeaderBar, child: Widget) {.inline.} =
  gtk_header_bar_pack_end(self, child.getPointer)
# proc pack_end*(self: HeaderBar, child: Widget) {.inline.} =

# gtk_header_bar_pack_start
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_header_bar_pack_start(self: ptr THeaderBar, child: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_header_bar_pack_start".}
proc pack_start*(self: HeaderBar, child: Widget) {.inline.} =
  gtk_header_bar_pack_start(self, child.getPointer)
# proc pack_start*(self: HeaderBar, child: Widget) {.inline.} =

# gtk_header_bar_set_custom_title
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# title_widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_header_bar_set_custom_title(self: ptr THeaderBar, title_widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_header_bar_set_custom_title".}
proc set_custom_title*(self: HeaderBar, title_widget: Widget) {.inline.} =
  gtk_header_bar_set_custom_title(self, title_widget.getPointer)
# proc set_custom_title*(self: HeaderBar, title_widget: Widget) {.inline.} =

# gtk_header_bar_set_decoration_layout
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# layout 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_header_bar_set_decoration_layout(self: ptr THeaderBar, layout: ucstring) {.cdecl, dynlib: lib, importc: "gtk_header_bar_set_decoration_layout".}
proc set_decoration_layout*(self: HeaderBar, layout: ustring) {.inline.} =
  gtk_header_bar_set_decoration_layout(self, ucstring(layout))
# proc set_decoration_layout*(self: HeaderBar, layout: ustring) {.inline.} =

# gtk_header_bar_set_has_subtitle
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_header_bar_set_has_subtitle(self: ptr THeaderBar, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_header_bar_set_has_subtitle".}
proc set_has_subtitle*(self: HeaderBar, setting: bool) {.inline.} =
  gtk_header_bar_set_has_subtitle(self, setting)
# proc set_has_subtitle*(self: HeaderBar, setting: bool) {.inline.} =

# gtk_header_bar_set_show_close_button
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_header_bar_set_show_close_button(self: ptr THeaderBar, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_header_bar_set_show_close_button".}
proc set_show_close_button*(self: HeaderBar, setting: bool) {.inline.} =
  gtk_header_bar_set_show_close_button(self, setting)
# proc set_show_close_button*(self: HeaderBar, setting: bool) {.inline.} =

# gtk_header_bar_set_subtitle
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# subtitle 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_header_bar_set_subtitle(self: ptr THeaderBar, subtitle: ucstring) {.cdecl, dynlib: lib, importc: "gtk_header_bar_set_subtitle".}
proc set_subtitle*(self: HeaderBar, subtitle: ustring) {.inline.} =
  gtk_header_bar_set_subtitle(self, ucstring(subtitle))
# proc set_subtitle*(self: HeaderBar, subtitle: ustring) {.inline.} =

# gtk_header_bar_set_title
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# title 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_header_bar_set_title(self: ptr THeaderBar, title: ucstring) {.cdecl, dynlib: lib, importc: "gtk_header_bar_set_title".}
proc set_title*(self: HeaderBar, title: ustring) {.inline.} =
  gtk_header_bar_set_title(self, ucstring(title))
# proc set_title*(self: HeaderBar, title: ustring) {.inline.} =

# gtk_im_context_delete_surrounding
# flags: {isMethod} container: IMContext
# need sugar: is method
# offset 'int32' 'int32' IN
# n_chars 'int32' 'int32' IN
# 'bool' 'bool'
proc gtk_im_context_delete_surrounding(self: ptr TIMContext, offset: int32, n_chars: int32): bool {.cdecl, dynlib: lib, importc: "gtk_im_context_delete_surrounding".}
proc delete_surrounding*(self: IMContext, offset: int32, n_chars: int32): bool {.inline.} =
  gtk_im_context_delete_surrounding(self, offset, n_chars)
# proc delete_surrounding*(self: IMContext, offset: int32, n_chars: int32): bool {.inline.} =

# gtk_im_context_filter_keypress
# flags: {isMethod} container: IMContext
# need sugar: is method
# event 'Gdk3.TEventKey' 'ptr Gdk3.TEventKey' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_im_context_filter_keypress(self: ptr TIMContext, event: ptr Gdk3.TEventKey): bool {.cdecl, dynlib: lib, importc: "gtk_im_context_filter_keypress".}
proc filter_keypress*(self: IMContext, event: Gdk3.TEventKey): bool {.inline.} =
  gtk_im_context_filter_keypress(self, myUnsafeAddr(event))
# proc filter_keypress*(self: IMContext, event: Gdk3.TEventKey): bool {.inline.} =

# gtk_im_context_focus_in
# flags: {isMethod} container: IMContext
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_im_context_focus_in(self: ptr TIMContext) {.cdecl, dynlib: lib, importc: "gtk_im_context_focus_in".}
proc focus_in*(self: IMContext) {.inline.} =
  gtk_im_context_focus_in(self)
# proc focus_in*(self: IMContext) {.inline.} =

# gtk_im_context_focus_out
# flags: {isMethod} container: IMContext
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_im_context_focus_out(self: ptr TIMContext) {.cdecl, dynlib: lib, importc: "gtk_im_context_focus_out".}
proc focus_out*(self: IMContext) {.inline.} =
  gtk_im_context_focus_out(self)
# proc focus_out*(self: IMContext) {.inline.} =

# gtk_im_context_get_preedit_string
# flags: {isMethod} container: IMContext
# need sugar: is method
# str 'var ucstring' 'ptr ucstring' OUT (diff., need sugar)
# attrs 'var Pango1.TAttrList' 'ptr Pango1.TAttrList' OUT (diff., need sugar)
# cursor_pos 'var int32' 'ptr int32' OUT (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_im_context_get_preedit_string(self: ptr TIMContext, str: ptr ucstring, attrs: ptr Pango1.TAttrList, cursor_pos: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_im_context_get_preedit_string".}
proc get_preedit_string*(self: IMContext, str: var ucstring, attrs: var Pango1.TAttrList, cursor_pos: var int32) {.inline.} =
  gtk_im_context_get_preedit_string(self, addr(str), addr(attrs), addr(cursor_pos))
# tuple-return
# str: var ucstring
# attrs: var Pango1.TAttrList
# cursor_pos: var int32
# proc get_preedit_string*(self: IMContext) {.inline.} =

# gtk_im_context_get_surrounding
# flags: {isMethod} container: IMContext
# need sugar: is method
# text 'var ucstring' 'ptr ucstring' OUT (diff., need sugar)
# cursor_index 'var int32' 'ptr int32' OUT (diff., need sugar)
# 'bool' 'bool'
proc gtk_im_context_get_surrounding(self: ptr TIMContext, text: ptr ucstring, cursor_index: ptr int32): bool {.cdecl, dynlib: lib, importc: "gtk_im_context_get_surrounding".}
proc get_surrounding*(self: IMContext, text: var ucstring, cursor_index: var int32): bool {.inline.} =
  gtk_im_context_get_surrounding(self, addr(text), addr(cursor_index))
# tuple-return
# text: var ucstring
# cursor_index: var int32
# proc get_surrounding*(self: IMContext): bool {.inline.} =

# gtk_im_context_reset
# flags: {isMethod} container: IMContext
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_im_context_reset(self: ptr TIMContext) {.cdecl, dynlib: lib, importc: "gtk_im_context_reset".}
proc reset*(self: IMContext) {.inline.} =
  gtk_im_context_reset(self)
# proc reset*(self: IMContext) {.inline.} =

# gtk_im_context_set_client_window
# flags: {isMethod} container: IMContext
# need sugar: is method
# window 'Gdk3.Window' 'ptr Gdk3.TWindow' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_im_context_set_client_window(self: ptr TIMContext, window: ptr Gdk3.TWindow) {.cdecl, dynlib: lib, importc: "gtk_im_context_set_client_window".}
proc set_client_window*(self: IMContext, window: Gdk3.Window) {.inline.} =
  gtk_im_context_set_client_window(self, window.getPointer)
# proc set_client_window*(self: IMContext, window: Gdk3.Window) {.inline.} =

# gtk_im_context_set_cursor_location
# flags: {isMethod} container: IMContext
# need sugar: is method
# area 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_im_context_set_cursor_location(self: ptr TIMContext, area: ptr cairo1.TRectangleInt) {.cdecl, dynlib: lib, importc: "gtk_im_context_set_cursor_location".}
proc set_cursor_location*(self: IMContext, area: cairo1.TRectangleInt) {.inline.} =
  gtk_im_context_set_cursor_location(self, myUnsafeAddr(area))
# proc set_cursor_location*(self: IMContext, area: cairo1.TRectangleInt) {.inline.} =

# gtk_im_context_set_surrounding
# flags: {isMethod} container: IMContext
# need sugar: is method
# text 'ustring' 'ucstring' IN (diff., need sugar)
# len 'int32' 'int32' IN
# cursor_index 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_im_context_set_surrounding(self: ptr TIMContext, text: ucstring, len: int32, cursor_index: int32) {.cdecl, dynlib: lib, importc: "gtk_im_context_set_surrounding".}
proc set_surrounding*(self: IMContext, text: ustring, len: int32, cursor_index: int32) {.inline.} =
  gtk_im_context_set_surrounding(self, ucstring(text), len, cursor_index)
# proc set_surrounding*(self: IMContext, text: ustring, len: int32, cursor_index: int32) {.inline.} =

# gtk_im_context_set_use_preedit
# flags: {isMethod} container: IMContext
# need sugar: is method
# use_preedit 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_im_context_set_use_preedit(self: ptr TIMContext, use_preedit: bool) {.cdecl, dynlib: lib, importc: "gtk_im_context_set_use_preedit".}
proc set_use_preedit*(self: IMContext, use_preedit: bool) {.inline.} =
  gtk_im_context_set_use_preedit(self, use_preedit)
# proc set_use_preedit*(self: IMContext, use_preedit: bool) {.inline.} =

# gtk_im_context_simple_new
# flags: {isConstructor} container: IMContextSimple
# need sugar: is static method
# 'IMContextSimple' 'TransferFull[TIMContextSimple]' (diff., need sugar)
proc gtk_im_context_simple_new(): TransferFull[TIMContextSimple] {.cdecl, dynlib: lib, importc: "gtk_im_context_simple_new".}
proc new_imcontextsimple*(): IMContextSimple {.inline.} =
  wrap(gtk_im_context_simple_new())
# proc new_imcontextsimple*(): IMContextSimple {.inline.} =

# gtk_im_multicontext_new
# flags: {isConstructor} container: IMMulticontext
# need sugar: is static method
# 'IMMulticontext' 'TransferFull[TIMMulticontext]' (diff., need sugar)
proc gtk_im_multicontext_new(): TransferFull[TIMMulticontext] {.cdecl, dynlib: lib, importc: "gtk_im_multicontext_new".}
proc new_immulticontext*(): IMMulticontext {.inline.} =
  wrap(gtk_im_multicontext_new())
# proc new_immulticontext*(): IMMulticontext {.inline.} =

# gtk_im_multicontext_append_menuitems
# flags: {isMethod} container: IMMulticontext (deprecated)
# gtk_im_multicontext_get_context_id
# flags: {isMethod} container: IMMulticontext
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_im_multicontext_get_context_id(self: ptr TIMMulticontext): ucstring {.cdecl, dynlib: lib, importc: "gtk_im_multicontext_get_context_id".}
proc get_context_id*(self: IMMulticontext): ustring {.inline.} =
  ustring($(gtk_im_multicontext_get_context_id(self)))
# proc get_context_id*(self: IMMulticontext): ustring {.inline.} =

# gtk_im_multicontext_set_context_id
# flags: {isMethod} container: IMMulticontext
# need sugar: is method
# context_id 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_im_multicontext_set_context_id(self: ptr TIMMulticontext, context_id: ucstring) {.cdecl, dynlib: lib, importc: "gtk_im_multicontext_set_context_id".}
proc set_context_id*(self: IMMulticontext, context_id: ustring) {.inline.} =
  gtk_im_multicontext_set_context_id(self, ucstring(context_id))
# proc set_context_id*(self: IMMulticontext, context_id: ustring) {.inline.} =

# gtk_icon_factory_new
# flags: {isConstructor} container: IconFactory (deprecated)
# gtk_icon_factory_lookup_default
# flags: {} container: IconFactory (deprecated)
# gtk_icon_factory_add
# flags: {isMethod} container: IconFactory (deprecated)
# gtk_icon_factory_add_default
# flags: {isMethod} container: IconFactory (deprecated)
# gtk_icon_factory_lookup
# flags: {isMethod} container: IconFactory (deprecated)
# gtk_icon_factory_remove_default
# flags: {isMethod} container: IconFactory (deprecated)
# gtk_icon_info_new_for_pixbuf
# flags: {isConstructor} container: IconInfo
# need sugar: is static method
# icon_theme 'IconTheme' 'ptr TIconTheme' IN (diff., need sugar)
# pixbuf 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# 'IconInfo' 'TransferFull[TIconInfo]' (diff., need sugar)
proc gtk_icon_info_new_for_pixbuf(icon_theme: ptr TIconTheme, pixbuf: ptr GdkPixbuf2.TPixbuf): TransferFull[TIconInfo] {.cdecl, dynlib: lib, importc: "gtk_icon_info_new_for_pixbuf".}
proc new_iconinfo_for_pixbuf*(icon_theme: IconTheme, pixbuf: GdkPixbuf2.Pixbuf): IconInfo {.inline.} =
  wrap(gtk_icon_info_new_for_pixbuf(icon_theme.getPointer, pixbuf.getPointer))
# proc new_iconinfo_for_pixbuf*(icon_theme: IconTheme, pixbuf: GdkPixbuf2.Pixbuf): IconInfo {.inline.} =

# gtk_icon_info_get_attach_points
# flags: {isMethod} container: IconInfo (deprecated)
# gtk_icon_info_get_base_scale
# flags: {isMethod} container: IconInfo
# need sugar: is method
# 'int32' 'int32'
proc gtk_icon_info_get_base_scale(self: ptr TIconInfo): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_info_get_base_scale".}
proc get_base_scale*(self: IconInfo): int32 {.inline.} =
  gtk_icon_info_get_base_scale(self)
# proc get_base_scale*(self: IconInfo): int32 {.inline.} =

# gtk_icon_info_get_base_size
# flags: {isMethod} container: IconInfo
# need sugar: is method
# 'int32' 'int32'
proc gtk_icon_info_get_base_size(self: ptr TIconInfo): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_info_get_base_size".}
proc get_base_size*(self: IconInfo): int32 {.inline.} =
  gtk_icon_info_get_base_size(self)
# proc get_base_size*(self: IconInfo): int32 {.inline.} =

# gtk_icon_info_get_builtin_pixbuf
# flags: {isMethod} container: IconInfo (deprecated)
# gtk_icon_info_get_display_name
# flags: {isMethod} container: IconInfo (deprecated)
# gtk_icon_info_get_embedded_rect
# flags: {isMethod} container: IconInfo (deprecated)
# gtk_icon_info_get_filename
# flags: {isMethod} container: IconInfo
# need sugar: is method
# 'string' 'cstring' (diff., need sugar)
proc gtk_icon_info_get_filename(self: ptr TIconInfo): cstring {.cdecl, dynlib: lib, importc: "gtk_icon_info_get_filename".}
proc get_filename*(self: IconInfo): string {.inline.} =
  $(gtk_icon_info_get_filename(self))
# proc get_filename*(self: IconInfo): string {.inline.} =

# gtk_icon_info_is_symbolic
# flags: {isMethod} container: IconInfo
# need sugar: is method
# 'bool' 'bool'
proc gtk_icon_info_is_symbolic(self: ptr TIconInfo): bool {.cdecl, dynlib: lib, importc: "gtk_icon_info_is_symbolic".}
proc is_symbolic*(self: IconInfo): bool {.inline.} =
  gtk_icon_info_is_symbolic(self)
# proc is_symbolic*(self: IconInfo): bool {.inline.} =

# gtk_icon_info_load_icon
# flags: {isMethod, throws} container: IconInfo
# can throw
# need sugar: is method
# 'GdkPixbuf2.Pixbuf' 'TransferFull[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_icon_info_load_icon(self: ptr TIconInfo, error: ptr PGError=nil): TransferFull[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_icon_info_load_icon".}
proc load_icon*(self: IconInfo): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_icon_info_load_icon(self))
# proc load_icon*(self: IconInfo): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_icon_info_load_icon_async
# flags: {isMethod} container: IconInfo
# need sugar: is method
# cancellable 'Gio2.Cancellable' 'ptr Gio2.TCancellable' IN (diff., need sugar)
# callback 'pointer' 'pointer' IN
# user_data 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_info_load_icon_async(self: ptr TIconInfo, cancellable: ptr Gio2.TCancellable, callback: pointer, user_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_icon_info_load_icon_async".}
proc load_icon_async*(self: IconInfo, cancellable: Gio2.Cancellable, callback: pointer, user_data: pointer) {.inline.} =
  gtk_icon_info_load_icon_async(self, cancellable.getPointer, callback, user_data)
# proc load_icon_async*(self: IconInfo, cancellable: Gio2.Cancellable, callback: pointer, user_data: pointer) {.inline.} =

# gtk_icon_info_load_icon_finish
# flags: {isMethod, throws} container: IconInfo
# can throw
# need sugar: is method
# res 'Gio2.AsyncResult' 'ptr Gio2.TAsyncResult' IN (diff., need sugar)
# 'GdkPixbuf2.Pixbuf' 'TransferFull[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_icon_info_load_icon_finish(self: ptr TIconInfo, res: ptr Gio2.TAsyncResult, error: ptr PGError=nil): TransferFull[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_icon_info_load_icon_finish".}
proc load_icon_finish*(self: IconInfo, res: Gio2.AsyncResult): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_icon_info_load_icon_finish(self, unwrap(res)))
# proc load_icon_finish*(self: IconInfo, res: Gio2.AsyncResult): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_icon_info_load_surface
# flags: {isMethod, throws} container: IconInfo
# can throw
# need sugar: is method
# for_window 'Gdk3.Window' 'ptr Gdk3.TWindow' IN (diff., need sugar)
# 'cairo1.TSurface' 'ptr cairo1.TSurface' (diff., need sugar)
proc gtk_icon_info_load_surface(self: ptr TIconInfo, for_window: ptr Gdk3.TWindow, error: ptr PGError=nil): ptr cairo1.TSurface {.cdecl, dynlib: lib, importc: "gtk_icon_info_load_surface".}
proc load_surface*(self: IconInfo, for_window: Gdk3.Window): cairo1.TSurface {.inline.} =
  (gtk_icon_info_load_surface(self, for_window.getPointer))[]
# proc load_surface*(self: IconInfo, for_window: Gdk3.Window): cairo1.TSurface {.inline.} =

# gtk_icon_info_load_symbolic
# flags: {isMethod, throws} container: IconInfo
# can throw
# need sugar: is method
# fg 'Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN (diff., need sugar)
# success_color 'Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN (diff., need sugar)
# warning_color 'Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN (diff., need sugar)
# error_color 'Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN (diff., need sugar)
# was_symbolic 'var bool' 'ptr bool' OUT (diff., need sugar) optional
# 'GdkPixbuf2.Pixbuf' 'TransferFull[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_icon_info_load_symbolic(self: ptr TIconInfo, fg: ptr Gdk3.TRGBA, success_color: ptr Gdk3.TRGBA, warning_color: ptr Gdk3.TRGBA, error_color: ptr Gdk3.TRGBA, was_symbolic: ptr bool, error: ptr PGError=nil): TransferFull[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_icon_info_load_symbolic".}
proc load_symbolic*(self: IconInfo, fg: Gdk3.TRGBA, success_color: Gdk3.TRGBA, warning_color: Gdk3.TRGBA, error_color: Gdk3.TRGBA, was_symbolic: var bool): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_icon_info_load_symbolic(self, myUnsafeAddr(fg), myUnsafeAddr(success_color), myUnsafeAddr(warning_color), myUnsafeAddr(error_color), addr(was_symbolic)))
# tuple-return
# was_symbolic: var bool
# proc load_symbolic*(self: IconInfo, fg: Gdk3.TRGBA, success_color: Gdk3.TRGBA, warning_color: Gdk3.TRGBA, error_color: Gdk3.TRGBA): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_icon_info_load_symbolic_async
# flags: {isMethod} container: IconInfo
# need sugar: is method
# fg 'Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN (diff., need sugar)
# success_color 'Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN (diff., need sugar)
# warning_color 'Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN (diff., need sugar)
# error_color 'Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN (diff., need sugar)
# cancellable 'Gio2.Cancellable' 'ptr Gio2.TCancellable' IN (diff., need sugar)
# callback 'pointer' 'pointer' IN
# user_data 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_info_load_symbolic_async(self: ptr TIconInfo, fg: ptr Gdk3.TRGBA, success_color: ptr Gdk3.TRGBA, warning_color: ptr Gdk3.TRGBA, error_color: ptr Gdk3.TRGBA, cancellable: ptr Gio2.TCancellable, callback: pointer, user_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_icon_info_load_symbolic_async".}
proc load_symbolic_async*(self: IconInfo, fg: Gdk3.TRGBA, success_color: Gdk3.TRGBA, warning_color: Gdk3.TRGBA, error_color: Gdk3.TRGBA, cancellable: Gio2.Cancellable, callback: pointer, user_data: pointer) {.inline.} =
  gtk_icon_info_load_symbolic_async(self, myUnsafeAddr(fg), myUnsafeAddr(success_color), myUnsafeAddr(warning_color), myUnsafeAddr(error_color), cancellable.getPointer, callback, user_data)
# proc load_symbolic_async*(self: IconInfo, fg: Gdk3.TRGBA, success_color: Gdk3.TRGBA, warning_color: Gdk3.TRGBA, error_color: Gdk3.TRGBA, cancellable: Gio2.Cancellable, callback: pointer, user_data: pointer) {.inline.} =

# gtk_icon_info_load_symbolic_finish
# flags: {isMethod, throws} container: IconInfo
# can throw
# need sugar: is method
# res 'Gio2.AsyncResult' 'ptr Gio2.TAsyncResult' IN (diff., need sugar)
# was_symbolic 'var bool' 'ptr bool' OUT (diff., need sugar) optional
# 'GdkPixbuf2.Pixbuf' 'TransferFull[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_icon_info_load_symbolic_finish(self: ptr TIconInfo, res: ptr Gio2.TAsyncResult, was_symbolic: ptr bool, error: ptr PGError=nil): TransferFull[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_icon_info_load_symbolic_finish".}
proc load_symbolic_finish*(self: IconInfo, res: Gio2.AsyncResult, was_symbolic: var bool): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_icon_info_load_symbolic_finish(self, unwrap(res), addr(was_symbolic)))
# tuple-return
# was_symbolic: var bool
# proc load_symbolic_finish*(self: IconInfo, res: Gio2.AsyncResult): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_icon_info_load_symbolic_for_context
# flags: {isMethod, throws} container: IconInfo
# can throw
# need sugar: is method
# context 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# was_symbolic 'var bool' 'ptr bool' OUT (diff., need sugar) optional
# 'GdkPixbuf2.Pixbuf' 'TransferFull[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_icon_info_load_symbolic_for_context(self: ptr TIconInfo, context: ptr TStyleContext, was_symbolic: ptr bool, error: ptr PGError=nil): TransferFull[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_icon_info_load_symbolic_for_context".}
proc load_symbolic_for_context*(self: IconInfo, context: StyleContext, was_symbolic: var bool): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_icon_info_load_symbolic_for_context(self, context.getPointer, addr(was_symbolic)))
# tuple-return
# was_symbolic: var bool
# proc load_symbolic_for_context*(self: IconInfo, context: StyleContext): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_icon_info_load_symbolic_for_context_async
# flags: {isMethod} container: IconInfo
# need sugar: is method
# context 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# cancellable 'Gio2.Cancellable' 'ptr Gio2.TCancellable' IN (diff., need sugar)
# callback 'pointer' 'pointer' IN
# user_data 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_info_load_symbolic_for_context_async(self: ptr TIconInfo, context: ptr TStyleContext, cancellable: ptr Gio2.TCancellable, callback: pointer, user_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_icon_info_load_symbolic_for_context_async".}
proc load_symbolic_for_context_async*(self: IconInfo, context: StyleContext, cancellable: Gio2.Cancellable, callback: pointer, user_data: pointer) {.inline.} =
  gtk_icon_info_load_symbolic_for_context_async(self, context.getPointer, cancellable.getPointer, callback, user_data)
# proc load_symbolic_for_context_async*(self: IconInfo, context: StyleContext, cancellable: Gio2.Cancellable, callback: pointer, user_data: pointer) {.inline.} =

# gtk_icon_info_load_symbolic_for_context_finish
# flags: {isMethod, throws} container: IconInfo
# can throw
# need sugar: is method
# res 'Gio2.AsyncResult' 'ptr Gio2.TAsyncResult' IN (diff., need sugar)
# was_symbolic 'var bool' 'ptr bool' OUT (diff., need sugar) optional
# 'GdkPixbuf2.Pixbuf' 'TransferFull[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_icon_info_load_symbolic_for_context_finish(self: ptr TIconInfo, res: ptr Gio2.TAsyncResult, was_symbolic: ptr bool, error: ptr PGError=nil): TransferFull[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_icon_info_load_symbolic_for_context_finish".}
proc load_symbolic_for_context_finish*(self: IconInfo, res: Gio2.AsyncResult, was_symbolic: var bool): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_icon_info_load_symbolic_for_context_finish(self, unwrap(res), addr(was_symbolic)))
# tuple-return
# was_symbolic: var bool
# proc load_symbolic_for_context_finish*(self: IconInfo, res: Gio2.AsyncResult): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_icon_info_load_symbolic_for_style
# flags: {isMethod, throws} container: IconInfo (deprecated)
# can throw
# gtk_icon_info_set_raw_coordinates
# flags: {isMethod} container: IconInfo (deprecated)
# gtk_icon_theme_new
# flags: {isConstructor} container: IconTheme
# need sugar: is static method
# 'IconTheme' 'TransferFull[TIconTheme]' (diff., need sugar)
proc gtk_icon_theme_new(): TransferFull[TIconTheme] {.cdecl, dynlib: lib, importc: "gtk_icon_theme_new".}
proc new_icontheme*(): IconTheme {.inline.} =
  wrap(gtk_icon_theme_new())
# proc new_icontheme*(): IconTheme {.inline.} =

# gtk_icon_theme_add_builtin_icon
# flags: {} container: IconTheme (deprecated)
# gtk_icon_theme_get_default
# flags: {} container: IconTheme
# need sugar: is static method
# 'IconTheme' 'TransferNone[TIconTheme]' (diff., need sugar)
proc gtk_icon_theme_get_default(): TransferNone[TIconTheme] {.cdecl, dynlib: lib, importc: "gtk_icon_theme_get_default".}
template get_default*(klass_parameter: typedesc[IconTheme]): IconTheme =
  wrap(gtk_icon_theme_get_default())
# template get_default*(klass_parameter: typedesc[IconTheme]): IconTheme =

# gtk_icon_theme_get_for_screen
# flags: {} container: IconTheme
# need sugar: is static method
# screen 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# 'IconTheme' 'TransferNone[TIconTheme]' (diff., need sugar)
proc gtk_icon_theme_get_for_screen(screen: ptr Gdk3.TScreen): TransferNone[TIconTheme] {.cdecl, dynlib: lib, importc: "gtk_icon_theme_get_for_screen".}
template get_for_screen*(klass_parameter: typedesc[IconTheme], screen: Gdk3.Screen): IconTheme =
  wrap(gtk_icon_theme_get_for_screen(screen.getPointer))
# template get_for_screen*(klass_parameter: typedesc[IconTheme], screen: Gdk3.Screen): IconTheme =

# gtk_icon_theme_add_resource_path
# flags: {isMethod} container: IconTheme
# need sugar: is method
# path 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_theme_add_resource_path(self: ptr TIconTheme, path: ucstring) {.cdecl, dynlib: lib, importc: "gtk_icon_theme_add_resource_path".}
proc add_resource_path*(self: IconTheme, path: ustring) {.inline.} =
  gtk_icon_theme_add_resource_path(self, ucstring(path))
# proc add_resource_path*(self: IconTheme, path: ustring) {.inline.} =

# gtk_icon_theme_append_search_path
# flags: {isMethod} container: IconTheme
# need sugar: is method
# path 'string' 'cstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_theme_append_search_path(self: ptr TIconTheme, path: cstring) {.cdecl, dynlib: lib, importc: "gtk_icon_theme_append_search_path".}
proc append_search_path*(self: IconTheme, path: string) {.inline.} =
  gtk_icon_theme_append_search_path(self, cstring(path))
# proc append_search_path*(self: IconTheme, path: string) {.inline.} =

# gtk_icon_theme_choose_icon
# flags: {isMethod} container: IconTheme
# need sugar: is method
# icon_names 'uncheckedArray[ucstring]' 'uncheckedArray[ucstring]' IN array zero-terminated
# size 'int32' 'int32' IN
# flags 'SIconLookupFlags' 'SIconLookupFlags' IN
# 'IconInfo' 'TransferFull[TIconInfo]' (diff., need sugar)
proc gtk_icon_theme_choose_icon(self: ptr TIconTheme, icon_names: uncheckedArray[ucstring], size: int32, flags: SIconLookupFlags): TransferFull[TIconInfo] {.cdecl, dynlib: lib, importc: "gtk_icon_theme_choose_icon".}
proc choose_icon*(self: IconTheme, icon_names: uncheckedArray[ucstring], size: int32, flags: SIconLookupFlags): IconInfo {.inline.} =
  wrap(gtk_icon_theme_choose_icon(self, icon_names, size, flags))
# proc choose_icon*(self: IconTheme, icon_names: uncheckedArray[ucstring], size: int32, flags: SIconLookupFlags): IconInfo {.inline.} =

# gtk_icon_theme_choose_icon_for_scale
# flags: {isMethod} container: IconTheme
# need sugar: is method
# icon_names 'uncheckedArray[ucstring]' 'uncheckedArray[ucstring]' IN array zero-terminated
# size 'int32' 'int32' IN
# scale 'int32' 'int32' IN
# flags 'SIconLookupFlags' 'SIconLookupFlags' IN
# 'IconInfo' 'TransferFull[TIconInfo]' (diff., need sugar)
proc gtk_icon_theme_choose_icon_for_scale(self: ptr TIconTheme, icon_names: uncheckedArray[ucstring], size: int32, scale: int32, flags: SIconLookupFlags): TransferFull[TIconInfo] {.cdecl, dynlib: lib, importc: "gtk_icon_theme_choose_icon_for_scale".}
proc choose_icon_for_scale*(self: IconTheme, icon_names: uncheckedArray[ucstring], size: int32, scale: int32, flags: SIconLookupFlags): IconInfo {.inline.} =
  wrap(gtk_icon_theme_choose_icon_for_scale(self, icon_names, size, scale, flags))
# proc choose_icon_for_scale*(self: IconTheme, icon_names: uncheckedArray[ucstring], size: int32, scale: int32, flags: SIconLookupFlags): IconInfo {.inline.} =

# gtk_icon_theme_get_example_icon_name
# flags: {isMethod} container: IconTheme
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_icon_theme_get_example_icon_name(self: ptr TIconTheme): ucstring {.cdecl, dynlib: lib, importc: "gtk_icon_theme_get_example_icon_name".}
proc get_example_icon_name*(self: IconTheme): ustring {.inline.} =
  ustring($(gtk_icon_theme_get_example_icon_name(self)))
# proc get_example_icon_name*(self: IconTheme): ustring {.inline.} =

# gtk_icon_theme_get_icon_sizes
# flags: {isMethod} container: IconTheme
# need sugar: is method
# icon_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'zeroTerminatedArray[int32]' 'zeroTerminatedArray[int32]'
proc gtk_icon_theme_get_icon_sizes(self: ptr TIconTheme, icon_name: ucstring): zeroTerminatedArray[int32] {.cdecl, dynlib: lib, importc: "gtk_icon_theme_get_icon_sizes".}
proc get_icon_sizes*(self: IconTheme, icon_name: ustring): zeroTerminatedArray[int32] {.inline.} =
  gtk_icon_theme_get_icon_sizes(self, ucstring(icon_name))
# proc get_icon_sizes*(self: IconTheme, icon_name: ustring): zeroTerminatedArray[int32] {.inline.} =

# gtk_icon_theme_get_search_path
# flags: {isMethod} container: IconTheme
# need sugar: is method
# path 'var openarray[cstring]' 'openarray[cstring]' OUT (diff., need sugar) array lengthArg: 1 optional
# n_elements 'var int32' 'ptr int32' OUT (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_theme_get_search_path(self: ptr TIconTheme, path: openarray[cstring], n_elements: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_icon_theme_get_search_path".}
proc get_search_path*(self: IconTheme, path: var openarray[cstring], n_elements: var int32) {.inline.} =
  gtk_icon_theme_get_search_path(self, path, addr(n_elements))
# tuple-return
# path: var openarray[cstring]
# n_elements: var int32
# proc get_search_path*(self: IconTheme) {.inline.} =

# gtk_icon_theme_has_icon
# flags: {isMethod} container: IconTheme
# need sugar: is method
# icon_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_icon_theme_has_icon(self: ptr TIconTheme, icon_name: ucstring): bool {.cdecl, dynlib: lib, importc: "gtk_icon_theme_has_icon".}
proc has_icon*(self: IconTheme, icon_name: ustring): bool {.inline.} =
  gtk_icon_theme_has_icon(self, ucstring(icon_name))
# proc has_icon*(self: IconTheme, icon_name: ustring): bool {.inline.} =

# gtk_icon_theme_list_contexts
# flags: {isMethod} container: IconTheme
# need sugar: is method
# 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_icon_theme_list_contexts(self: ptr TIconTheme): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_icon_theme_list_contexts".}
proc list_contexts*(self: IconTheme): ptr GLIST_TODO {.inline.} =
  gtk_icon_theme_list_contexts(self)
# proc list_contexts*(self: IconTheme): ptr GLIST_TODO {.inline.} =

# gtk_icon_theme_list_icons
# flags: {isMethod} container: IconTheme
# need sugar: is method
# context 'ustring' 'ucstring' IN (diff., need sugar)
# 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_icon_theme_list_icons(self: ptr TIconTheme, context: ucstring): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_icon_theme_list_icons".}
proc list_icons*(self: IconTheme, context: ustring): ptr GLIST_TODO {.inline.} =
  gtk_icon_theme_list_icons(self, ucstring(context))
# proc list_icons*(self: IconTheme, context: ustring): ptr GLIST_TODO {.inline.} =

# gtk_icon_theme_load_icon
# flags: {isMethod, throws} container: IconTheme
# can throw
# need sugar: is method
# icon_name 'ustring' 'ucstring' IN (diff., need sugar)
# size 'int32' 'int32' IN
# flags 'SIconLookupFlags' 'SIconLookupFlags' IN
# 'GdkPixbuf2.Pixbuf' 'TransferFull[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_icon_theme_load_icon(self: ptr TIconTheme, icon_name: ucstring, size: int32, flags: SIconLookupFlags, error: ptr PGError=nil): TransferFull[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_icon_theme_load_icon".}
proc load_icon*(self: IconTheme, icon_name: ustring, size: int32, flags: SIconLookupFlags): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_icon_theme_load_icon(self, ucstring(icon_name), size, flags))
# proc load_icon*(self: IconTheme, icon_name: ustring, size: int32, flags: SIconLookupFlags): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_icon_theme_load_icon_for_scale
# flags: {isMethod, throws} container: IconTheme
# can throw
# need sugar: is method
# icon_name 'ustring' 'ucstring' IN (diff., need sugar)
# size 'int32' 'int32' IN
# scale 'int32' 'int32' IN
# flags 'SIconLookupFlags' 'SIconLookupFlags' IN
# 'GdkPixbuf2.Pixbuf' 'TransferFull[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_icon_theme_load_icon_for_scale(self: ptr TIconTheme, icon_name: ucstring, size: int32, scale: int32, flags: SIconLookupFlags, error: ptr PGError=nil): TransferFull[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_icon_theme_load_icon_for_scale".}
proc load_icon_for_scale*(self: IconTheme, icon_name: ustring, size: int32, scale: int32, flags: SIconLookupFlags): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_icon_theme_load_icon_for_scale(self, ucstring(icon_name), size, scale, flags))
# proc load_icon_for_scale*(self: IconTheme, icon_name: ustring, size: int32, scale: int32, flags: SIconLookupFlags): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_icon_theme_load_surface
# flags: {isMethod, throws} container: IconTheme
# can throw
# need sugar: is method
# icon_name 'ustring' 'ucstring' IN (diff., need sugar)
# size 'int32' 'int32' IN
# scale 'int32' 'int32' IN
# for_window 'Gdk3.Window' 'ptr Gdk3.TWindow' IN (diff., need sugar)
# flags 'SIconLookupFlags' 'SIconLookupFlags' IN
# 'cairo1.TSurface' 'ptr cairo1.TSurface' (diff., need sugar)
proc gtk_icon_theme_load_surface(self: ptr TIconTheme, icon_name: ucstring, size: int32, scale: int32, for_window: ptr Gdk3.TWindow, flags: SIconLookupFlags, error: ptr PGError=nil): ptr cairo1.TSurface {.cdecl, dynlib: lib, importc: "gtk_icon_theme_load_surface".}
proc load_surface*(self: IconTheme, icon_name: ustring, size: int32, scale: int32, for_window: Gdk3.Window, flags: SIconLookupFlags): cairo1.TSurface {.inline.} =
  (gtk_icon_theme_load_surface(self, ucstring(icon_name), size, scale, for_window.getPointer, flags))[]
# proc load_surface*(self: IconTheme, icon_name: ustring, size: int32, scale: int32, for_window: Gdk3.Window, flags: SIconLookupFlags): cairo1.TSurface {.inline.} =

# gtk_icon_theme_lookup_by_gicon
# flags: {isMethod} container: IconTheme
# need sugar: is method
# icon 'Gio2.Icon' 'ptr Gio2.TIcon' IN (diff., need sugar)
# size 'int32' 'int32' IN
# flags 'SIconLookupFlags' 'SIconLookupFlags' IN
# 'IconInfo' 'TransferFull[TIconInfo]' (diff., need sugar)
proc gtk_icon_theme_lookup_by_gicon(self: ptr TIconTheme, icon: ptr Gio2.TIcon, size: int32, flags: SIconLookupFlags): TransferFull[TIconInfo] {.cdecl, dynlib: lib, importc: "gtk_icon_theme_lookup_by_gicon".}
proc lookup_by_gicon*(self: IconTheme, icon: Gio2.Icon, size: int32, flags: SIconLookupFlags): IconInfo {.inline.} =
  wrap(gtk_icon_theme_lookup_by_gicon(self, unwrap(icon), size, flags))
# proc lookup_by_gicon*(self: IconTheme, icon: Gio2.Icon, size: int32, flags: SIconLookupFlags): IconInfo {.inline.} =

# gtk_icon_theme_lookup_by_gicon_for_scale
# flags: {isMethod} container: IconTheme
# need sugar: is method
# icon 'Gio2.Icon' 'ptr Gio2.TIcon' IN (diff., need sugar)
# size 'int32' 'int32' IN
# scale 'int32' 'int32' IN
# flags 'SIconLookupFlags' 'SIconLookupFlags' IN
# 'IconInfo' 'TransferFull[TIconInfo]' (diff., need sugar)
proc gtk_icon_theme_lookup_by_gicon_for_scale(self: ptr TIconTheme, icon: ptr Gio2.TIcon, size: int32, scale: int32, flags: SIconLookupFlags): TransferFull[TIconInfo] {.cdecl, dynlib: lib, importc: "gtk_icon_theme_lookup_by_gicon_for_scale".}
proc lookup_by_gicon_for_scale*(self: IconTheme, icon: Gio2.Icon, size: int32, scale: int32, flags: SIconLookupFlags): IconInfo {.inline.} =
  wrap(gtk_icon_theme_lookup_by_gicon_for_scale(self, unwrap(icon), size, scale, flags))
# proc lookup_by_gicon_for_scale*(self: IconTheme, icon: Gio2.Icon, size: int32, scale: int32, flags: SIconLookupFlags): IconInfo {.inline.} =

# gtk_icon_theme_lookup_icon
# flags: {isMethod} container: IconTheme
# need sugar: is method
# icon_name 'ustring' 'ucstring' IN (diff., need sugar)
# size 'int32' 'int32' IN
# flags 'SIconLookupFlags' 'SIconLookupFlags' IN
# 'IconInfo' 'TransferFull[TIconInfo]' (diff., need sugar)
proc gtk_icon_theme_lookup_icon(self: ptr TIconTheme, icon_name: ucstring, size: int32, flags: SIconLookupFlags): TransferFull[TIconInfo] {.cdecl, dynlib: lib, importc: "gtk_icon_theme_lookup_icon".}
proc lookup_icon*(self: IconTheme, icon_name: ustring, size: int32, flags: SIconLookupFlags): IconInfo {.inline.} =
  wrap(gtk_icon_theme_lookup_icon(self, ucstring(icon_name), size, flags))
# proc lookup_icon*(self: IconTheme, icon_name: ustring, size: int32, flags: SIconLookupFlags): IconInfo {.inline.} =

# gtk_icon_theme_lookup_icon_for_scale
# flags: {isMethod} container: IconTheme
# need sugar: is method
# icon_name 'ustring' 'ucstring' IN (diff., need sugar)
# size 'int32' 'int32' IN
# scale 'int32' 'int32' IN
# flags 'SIconLookupFlags' 'SIconLookupFlags' IN
# 'IconInfo' 'TransferFull[TIconInfo]' (diff., need sugar)
proc gtk_icon_theme_lookup_icon_for_scale(self: ptr TIconTheme, icon_name: ucstring, size: int32, scale: int32, flags: SIconLookupFlags): TransferFull[TIconInfo] {.cdecl, dynlib: lib, importc: "gtk_icon_theme_lookup_icon_for_scale".}
proc lookup_icon_for_scale*(self: IconTheme, icon_name: ustring, size: int32, scale: int32, flags: SIconLookupFlags): IconInfo {.inline.} =
  wrap(gtk_icon_theme_lookup_icon_for_scale(self, ucstring(icon_name), size, scale, flags))
# proc lookup_icon_for_scale*(self: IconTheme, icon_name: ustring, size: int32, scale: int32, flags: SIconLookupFlags): IconInfo {.inline.} =

# gtk_icon_theme_prepend_search_path
# flags: {isMethod} container: IconTheme
# need sugar: is method
# path 'string' 'cstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_theme_prepend_search_path(self: ptr TIconTheme, path: cstring) {.cdecl, dynlib: lib, importc: "gtk_icon_theme_prepend_search_path".}
proc prepend_search_path*(self: IconTheme, path: string) {.inline.} =
  gtk_icon_theme_prepend_search_path(self, cstring(path))
# proc prepend_search_path*(self: IconTheme, path: string) {.inline.} =

# gtk_icon_theme_rescan_if_needed
# flags: {isMethod} container: IconTheme
# need sugar: is method
# 'bool' 'bool'
proc gtk_icon_theme_rescan_if_needed(self: ptr TIconTheme): bool {.cdecl, dynlib: lib, importc: "gtk_icon_theme_rescan_if_needed".}
proc rescan_if_needed*(self: IconTheme): bool {.inline.} =
  gtk_icon_theme_rescan_if_needed(self)
# proc rescan_if_needed*(self: IconTheme): bool {.inline.} =

# gtk_icon_theme_set_custom_theme
# flags: {isMethod} container: IconTheme
# need sugar: is method
# theme_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_theme_set_custom_theme(self: ptr TIconTheme, theme_name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_icon_theme_set_custom_theme".}
proc set_custom_theme*(self: IconTheme, theme_name: ustring) {.inline.} =
  gtk_icon_theme_set_custom_theme(self, ucstring(theme_name))
# proc set_custom_theme*(self: IconTheme, theme_name: ustring) {.inline.} =

# gtk_icon_theme_set_screen
# flags: {isMethod} container: IconTheme
# need sugar: is method
# screen 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_theme_set_screen(self: ptr TIconTheme, screen: ptr Gdk3.TScreen) {.cdecl, dynlib: lib, importc: "gtk_icon_theme_set_screen".}
proc set_screen*(self: IconTheme, screen: Gdk3.Screen) {.inline.} =
  gtk_icon_theme_set_screen(self, screen.getPointer)
# proc set_screen*(self: IconTheme, screen: Gdk3.Screen) {.inline.} =

# gtk_icon_theme_set_search_path
# flags: {isMethod} container: IconTheme
# need sugar: is method
# path 'var openarray[cstring]' 'openarray[cstring]' IN (diff., need sugar) array lengthArg: 1
# n_elements 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_theme_set_search_path(self: ptr TIconTheme, path: openarray[cstring], n_elements: int32) {.cdecl, dynlib: lib, importc: "gtk_icon_theme_set_search_path".}
proc set_search_path*(self: IconTheme, path: var openarray[cstring]) {.inline.} =
  gtk_icon_theme_set_search_path(self, path, path.len.int32)
# proc set_search_path*(self: IconTheme, path: var openarray[cstring]) {.inline.} =

# gtk_icon_view_new
# flags: {isConstructor} container: IconView
# need sugar: is static method
# 'IconView' 'TransferNone[TIconView]' (diff., need sugar)
proc gtk_icon_view_new(): TransferNone[TIconView] {.cdecl, dynlib: lib, importc: "gtk_icon_view_new".}
proc new_iconview*(): IconView {.inline.} =
  wrap(gtk_icon_view_new())
# proc new_iconview*(): IconView {.inline.} =

# gtk_icon_view_new_with_area
# flags: {isConstructor} container: IconView
# need sugar: is static method
# area 'CellArea' 'ptr TCellArea' IN (diff., need sugar)
# 'IconView' 'TransferNone[TIconView]' (diff., need sugar)
proc gtk_icon_view_new_with_area(area: ptr TCellArea): TransferNone[TIconView] {.cdecl, dynlib: lib, importc: "gtk_icon_view_new_with_area".}
proc new_iconview_with_area*(area: CellArea): IconView {.inline.} =
  wrap(gtk_icon_view_new_with_area(area.getPointer))
# proc new_iconview_with_area*(area: CellArea): IconView {.inline.} =

# gtk_icon_view_new_with_model
# flags: {isConstructor} container: IconView
# need sugar: is static method
# model 'TreeModel' 'ptr TTreeModel' IN (diff., need sugar)
# 'IconView' 'TransferNone[TIconView]' (diff., need sugar)
proc gtk_icon_view_new_with_model(model: ptr TTreeModel): TransferNone[TIconView] {.cdecl, dynlib: lib, importc: "gtk_icon_view_new_with_model".}
proc new_iconview_with_model*(model: TreeModel): IconView {.inline.} =
  wrap(gtk_icon_view_new_with_model(unwrap(model)))
# proc new_iconview_with_model*(model: TreeModel): IconView {.inline.} =

# gtk_icon_view_convert_widget_to_bin_window_coords
# flags: {isMethod} container: IconView
# need sugar: is method
# wx 'int32' 'int32' IN
# wy 'int32' 'int32' IN
# bx 'var int32' 'ptr int32' OUT (diff., need sugar)
# by 'var int32' 'ptr int32' OUT (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_convert_widget_to_bin_window_coords(self: ptr TIconView, wx: int32, wy: int32, bx: ptr int32, by: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_icon_view_convert_widget_to_bin_window_coords".}
proc convert_widget_to_bin_window_coords*(self: IconView, wx: int32, wy: int32, bx: var int32, by: var int32) {.inline.} =
  gtk_icon_view_convert_widget_to_bin_window_coords(self, wx, wy, addr(bx), addr(by))
# tuple-return
# bx: var int32
# by: var int32
# proc convert_widget_to_bin_window_coords*(self: IconView, wx: int32, wy: int32) {.inline.} =

# gtk_icon_view_create_drag_icon
# flags: {isMethod} container: IconView
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'cairo1.TSurface' 'ptr cairo1.TSurface' (diff., need sugar)
proc gtk_icon_view_create_drag_icon(self: ptr TIconView, path: ptr TTreePath): ptr cairo1.TSurface {.cdecl, dynlib: lib, importc: "gtk_icon_view_create_drag_icon".}
proc create_drag_icon*(self: IconView, path: TTreePath): cairo1.TSurface {.inline.} =
  (gtk_icon_view_create_drag_icon(self, myUnsafeAddr(path)))[]
# proc create_drag_icon*(self: IconView, path: TTreePath): cairo1.TSurface {.inline.} =

# gtk_icon_view_enable_model_drag_dest
# flags: {isMethod} container: IconView
# need sugar: is method
# targets 'var openarray[TTargetEntry]' 'openarray[TTargetEntry]' IN (diff., need sugar) array lengthArg: 1
# n_targets 'int32' 'int32' IN
# actions 'Gdk3.SDragAction' 'Gdk3.SDragAction' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_enable_model_drag_dest(self: ptr TIconView, targets: openarray[TTargetEntry], n_targets: int32, actions: Gdk3.SDragAction) {.cdecl, dynlib: lib, importc: "gtk_icon_view_enable_model_drag_dest".}
proc enable_model_drag_dest*(self: IconView, targets: var openarray[TTargetEntry], actions: Gdk3.SDragAction) {.inline.} =
  gtk_icon_view_enable_model_drag_dest(self, targets, targets.len.int32, actions)
# proc enable_model_drag_dest*(self: IconView, targets: var openarray[TTargetEntry], actions: Gdk3.SDragAction) {.inline.} =

# gtk_icon_view_enable_model_drag_source
# flags: {isMethod} container: IconView
# need sugar: is method
# start_button_mask 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# targets 'var openarray[TTargetEntry]' 'openarray[TTargetEntry]' IN (diff., need sugar) array lengthArg: 2
# n_targets 'int32' 'int32' IN
# actions 'Gdk3.SDragAction' 'Gdk3.SDragAction' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_enable_model_drag_source(self: ptr TIconView, start_button_mask: Gdk3.SModifierType, targets: openarray[TTargetEntry], n_targets: int32, actions: Gdk3.SDragAction) {.cdecl, dynlib: lib, importc: "gtk_icon_view_enable_model_drag_source".}
proc enable_model_drag_source*(self: IconView, start_button_mask: Gdk3.SModifierType, targets: var openarray[TTargetEntry], actions: Gdk3.SDragAction) {.inline.} =
  gtk_icon_view_enable_model_drag_source(self, start_button_mask, targets, targets.len.int32, actions)
# proc enable_model_drag_source*(self: IconView, start_button_mask: Gdk3.SModifierType, targets: var openarray[TTargetEntry], actions: Gdk3.SDragAction) {.inline.} =

# gtk_icon_view_get_activate_on_single_click
# flags: {isMethod} container: IconView
# need sugar: is method
# 'bool' 'bool'
proc gtk_icon_view_get_activate_on_single_click(self: ptr TIconView): bool {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_activate_on_single_click".}
proc get_activate_on_single_click*(self: IconView): bool {.inline.} =
  gtk_icon_view_get_activate_on_single_click(self)
# proc get_activate_on_single_click*(self: IconView): bool {.inline.} =

# gtk_icon_view_get_cell_rect
# flags: {isMethod} container: IconView
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# cell 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# rect 'var cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' OUT (diff., need sugar) caller-allocates
# 'bool' 'bool'
proc gtk_icon_view_get_cell_rect(self: ptr TIconView, path: ptr TTreePath, cell: ptr TCellRenderer, rect: ptr cairo1.TRectangleInt): bool {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_cell_rect".}
proc get_cell_rect*(self: IconView, path: TTreePath, cell: CellRenderer, rect: var cairo1.TRectangleInt): bool {.inline.} =
  gtk_icon_view_get_cell_rect(self, myUnsafeAddr(path), cell.getPointer, addr(rect))
# tuple-return
# rect: var cairo1.TRectangleInt
# proc get_cell_rect*(self: IconView, path: TTreePath, cell: CellRenderer): bool {.inline.} =

# gtk_icon_view_get_column_spacing
# flags: {isMethod} container: IconView
# need sugar: is method
# 'int32' 'int32'
proc gtk_icon_view_get_column_spacing(self: ptr TIconView): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_column_spacing".}
proc get_column_spacing*(self: IconView): int32 {.inline.} =
  gtk_icon_view_get_column_spacing(self)
# proc get_column_spacing*(self: IconView): int32 {.inline.} =

# gtk_icon_view_get_columns
# flags: {isMethod} container: IconView
# need sugar: is method
# 'int32' 'int32'
proc gtk_icon_view_get_columns(self: ptr TIconView): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_columns".}
proc get_columns*(self: IconView): int32 {.inline.} =
  gtk_icon_view_get_columns(self)
# proc get_columns*(self: IconView): int32 {.inline.} =

# gtk_icon_view_get_cursor
# flags: {isMethod} container: IconView
# need sugar: is method
# path 'var TTreePath' 'ptr TTreePath' OUT (diff., need sugar) optional
# cell 'var CellRenderer' 'ptr TCellRenderer' OUT (diff., need sugar) optional
# 'bool' 'bool'
proc gtk_icon_view_get_cursor(self: ptr TIconView, path: ptr TTreePath, cell: ptr TCellRenderer): bool {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_cursor".}
proc get_cursor*(self: IconView, path: var TTreePath, cell: var CellRenderer): bool {.inline.} =
  gtk_icon_view_get_cursor(self, addr(path), cell.getPointer)
# tuple-return
# path: var TTreePath
# cell: var CellRenderer
# proc get_cursor*(self: IconView): bool {.inline.} =

# gtk_icon_view_get_dest_item_at_pos
# flags: {isMethod} container: IconView
# need sugar: is method
# drag_x 'int32' 'int32' IN
# drag_y 'int32' 'int32' IN
# path 'var TTreePath' 'ptr TTreePath' OUT (diff., need sugar) optional
# pos 'IconViewDropPosition' 'IconViewDropPosition' OUT optional
# 'bool' 'bool'
proc gtk_icon_view_get_dest_item_at_pos(self: ptr TIconView, drag_x: int32, drag_y: int32, path: ptr TTreePath, pos: IconViewDropPosition): bool {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_dest_item_at_pos".}
proc get_dest_item_at_pos*(self: IconView, drag_x: int32, drag_y: int32, path: var TTreePath, pos: IconViewDropPosition): bool {.inline.} =
  gtk_icon_view_get_dest_item_at_pos(self, drag_x, drag_y, addr(path), pos)
# tuple-return
# path: var TTreePath
# pos: IconViewDropPosition
# proc get_dest_item_at_pos*(self: IconView, drag_x: int32, drag_y: int32): bool {.inline.} =

# gtk_icon_view_get_drag_dest_item
# flags: {isMethod} container: IconView
# need sugar: is method
# path 'var TTreePath' 'ptr TTreePath' OUT (diff., need sugar) optional
# pos 'IconViewDropPosition' 'IconViewDropPosition' OUT optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_get_drag_dest_item(self: ptr TIconView, path: ptr TTreePath, pos: IconViewDropPosition) {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_drag_dest_item".}
proc get_drag_dest_item*(self: IconView, path: var TTreePath, pos: IconViewDropPosition) {.inline.} =
  gtk_icon_view_get_drag_dest_item(self, addr(path), pos)
# tuple-return
# path: var TTreePath
# pos: IconViewDropPosition
# proc get_drag_dest_item*(self: IconView) {.inline.} =

# gtk_icon_view_get_item_at_pos
# flags: {isMethod} container: IconView
# need sugar: is method
# x 'int32' 'int32' IN
# y 'int32' 'int32' IN
# path 'var TTreePath' 'ptr TTreePath' OUT (diff., need sugar) optional
# cell 'var CellRenderer' 'ptr TCellRenderer' OUT (diff., need sugar) optional
# 'bool' 'bool'
proc gtk_icon_view_get_item_at_pos(self: ptr TIconView, x: int32, y: int32, path: ptr TTreePath, cell: ptr TCellRenderer): bool {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_item_at_pos".}
proc get_item_at_pos*(self: IconView, x: int32, y: int32, path: var TTreePath, cell: var CellRenderer): bool {.inline.} =
  gtk_icon_view_get_item_at_pos(self, x, y, addr(path), cell.getPointer)
# tuple-return
# path: var TTreePath
# cell: var CellRenderer
# proc get_item_at_pos*(self: IconView, x: int32, y: int32): bool {.inline.} =

# gtk_icon_view_get_item_column
# flags: {isMethod} container: IconView
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'int32' 'int32'
proc gtk_icon_view_get_item_column(self: ptr TIconView, path: ptr TTreePath): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_item_column".}
proc get_item_column*(self: IconView, path: TTreePath): int32 {.inline.} =
  gtk_icon_view_get_item_column(self, myUnsafeAddr(path))
# proc get_item_column*(self: IconView, path: TTreePath): int32 {.inline.} =

# gtk_icon_view_get_item_orientation
# flags: {isMethod} container: IconView
# need sugar: is method
# 'Orientation' 'Orientation'
proc gtk_icon_view_get_item_orientation(self: ptr TIconView): Orientation {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_item_orientation".}
proc get_item_orientation*(self: IconView): Orientation {.inline.} =
  gtk_icon_view_get_item_orientation(self)
# proc get_item_orientation*(self: IconView): Orientation {.inline.} =

# gtk_icon_view_get_item_padding
# flags: {isMethod} container: IconView
# need sugar: is method
# 'int32' 'int32'
proc gtk_icon_view_get_item_padding(self: ptr TIconView): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_item_padding".}
proc get_item_padding*(self: IconView): int32 {.inline.} =
  gtk_icon_view_get_item_padding(self)
# proc get_item_padding*(self: IconView): int32 {.inline.} =

# gtk_icon_view_get_item_row
# flags: {isMethod} container: IconView
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'int32' 'int32'
proc gtk_icon_view_get_item_row(self: ptr TIconView, path: ptr TTreePath): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_item_row".}
proc get_item_row*(self: IconView, path: TTreePath): int32 {.inline.} =
  gtk_icon_view_get_item_row(self, myUnsafeAddr(path))
# proc get_item_row*(self: IconView, path: TTreePath): int32 {.inline.} =

# gtk_icon_view_get_item_width
# flags: {isMethod} container: IconView
# need sugar: is method
# 'int32' 'int32'
proc gtk_icon_view_get_item_width(self: ptr TIconView): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_item_width".}
proc get_item_width*(self: IconView): int32 {.inline.} =
  gtk_icon_view_get_item_width(self)
# proc get_item_width*(self: IconView): int32 {.inline.} =

# gtk_icon_view_get_margin
# flags: {isMethod} container: IconView
# need sugar: is method
# 'int32' 'int32'
proc gtk_icon_view_get_margin(self: ptr TIconView): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_margin".}
proc get_margin*(self: IconView): int32 {.inline.} =
  gtk_icon_view_get_margin(self)
# proc get_margin*(self: IconView): int32 {.inline.} =

# gtk_icon_view_get_markup_column
# flags: {isMethod} container: IconView
# need sugar: is method
# 'int32' 'int32'
proc gtk_icon_view_get_markup_column(self: ptr TIconView): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_markup_column".}
proc get_markup_column*(self: IconView): int32 {.inline.} =
  gtk_icon_view_get_markup_column(self)
# proc get_markup_column*(self: IconView): int32 {.inline.} =

# gtk_icon_view_get_model
# flags: {isMethod} container: IconView
# need sugar: is method
# 'TreeModel' 'TransferNone[TTreeModel]' (diff., need sugar)
proc gtk_icon_view_get_model(self: ptr TIconView): TransferNone[TTreeModel] {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_model".}
proc get_model*(self: IconView): TreeModel {.inline.} =
  wrap(gtk_icon_view_get_model(self))
# proc get_model*(self: IconView): TreeModel {.inline.} =

# gtk_icon_view_get_path_at_pos
# flags: {isMethod} container: IconView
# need sugar: is method
# x 'int32' 'int32' IN
# y 'int32' 'int32' IN
# 'TTreePath' 'ptr TTreePath' (diff., need sugar)
proc gtk_icon_view_get_path_at_pos(self: ptr TIconView, x: int32, y: int32): ptr TTreePath {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_path_at_pos".}
proc get_path_at_pos*(self: IconView, x: int32, y: int32): TTreePath {.inline.} =
  (gtk_icon_view_get_path_at_pos(self, x, y))[]
# proc get_path_at_pos*(self: IconView, x: int32, y: int32): TTreePath {.inline.} =

# gtk_icon_view_get_pixbuf_column
# flags: {isMethod} container: IconView
# need sugar: is method
# 'int32' 'int32'
proc gtk_icon_view_get_pixbuf_column(self: ptr TIconView): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_pixbuf_column".}
proc get_pixbuf_column*(self: IconView): int32 {.inline.} =
  gtk_icon_view_get_pixbuf_column(self)
# proc get_pixbuf_column*(self: IconView): int32 {.inline.} =

# gtk_icon_view_get_reorderable
# flags: {isMethod} container: IconView
# need sugar: is method
# 'bool' 'bool'
proc gtk_icon_view_get_reorderable(self: ptr TIconView): bool {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_reorderable".}
proc get_reorderable*(self: IconView): bool {.inline.} =
  gtk_icon_view_get_reorderable(self)
# proc get_reorderable*(self: IconView): bool {.inline.} =

# gtk_icon_view_get_row_spacing
# flags: {isMethod} container: IconView
# need sugar: is method
# 'int32' 'int32'
proc gtk_icon_view_get_row_spacing(self: ptr TIconView): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_row_spacing".}
proc get_row_spacing*(self: IconView): int32 {.inline.} =
  gtk_icon_view_get_row_spacing(self)
# proc get_row_spacing*(self: IconView): int32 {.inline.} =

# gtk_icon_view_get_selected_items
# flags: {isMethod} container: IconView
# need sugar: is method
# 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_icon_view_get_selected_items(self: ptr TIconView): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_selected_items".}
proc get_selected_items*(self: IconView): ptr GLIST_TODO {.inline.} =
  gtk_icon_view_get_selected_items(self)
# proc get_selected_items*(self: IconView): ptr GLIST_TODO {.inline.} =

# gtk_icon_view_get_selection_mode
# flags: {isMethod} container: IconView
# need sugar: is method
# 'SelectionMode' 'SelectionMode'
proc gtk_icon_view_get_selection_mode(self: ptr TIconView): SelectionMode {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_selection_mode".}
proc get_selection_mode*(self: IconView): SelectionMode {.inline.} =
  gtk_icon_view_get_selection_mode(self)
# proc get_selection_mode*(self: IconView): SelectionMode {.inline.} =

# gtk_icon_view_get_spacing
# flags: {isMethod} container: IconView
# need sugar: is method
# 'int32' 'int32'
proc gtk_icon_view_get_spacing(self: ptr TIconView): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_spacing".}
proc get_spacing*(self: IconView): int32 {.inline.} =
  gtk_icon_view_get_spacing(self)
# proc get_spacing*(self: IconView): int32 {.inline.} =

# gtk_icon_view_get_text_column
# flags: {isMethod} container: IconView
# need sugar: is method
# 'int32' 'int32'
proc gtk_icon_view_get_text_column(self: ptr TIconView): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_text_column".}
proc get_text_column*(self: IconView): int32 {.inline.} =
  gtk_icon_view_get_text_column(self)
# proc get_text_column*(self: IconView): int32 {.inline.} =

# gtk_icon_view_get_tooltip_column
# flags: {isMethod} container: IconView
# need sugar: is method
# 'int32' 'int32'
proc gtk_icon_view_get_tooltip_column(self: ptr TIconView): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_tooltip_column".}
proc get_tooltip_column*(self: IconView): int32 {.inline.} =
  gtk_icon_view_get_tooltip_column(self)
# proc get_tooltip_column*(self: IconView): int32 {.inline.} =

# gtk_icon_view_get_tooltip_context
# flags: {isMethod} container: IconView
# need sugar: is method
# x 'var int32' 'ptr int32' INOUT (diff., need sugar)
# y 'var int32' 'ptr int32' INOUT (diff., need sugar)
# keyboard_tip 'bool' 'bool' IN
# model 'var TreeModel' 'ptr TTreeModel' OUT (diff., need sugar) optional
# path 'var TTreePath' 'ptr TTreePath' OUT (diff., need sugar) optional
# iter 'var TTreeIter' 'ptr TTreeIter' OUT (diff., need sugar) caller-allocates optional
# 'bool' 'bool'
proc gtk_icon_view_get_tooltip_context(self: ptr TIconView, x: ptr int32, y: ptr int32, keyboard_tip: bool, model: ptr TTreeModel, path: ptr TTreePath, iter: ptr TTreeIter): bool {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_tooltip_context".}
proc get_tooltip_context*(self: IconView, x: var int32, y: var int32, keyboard_tip: bool, model: var TreeModel, path: var TTreePath, iter: var TTreeIter): bool {.inline.} =
  gtk_icon_view_get_tooltip_context(self, addr(x), addr(y), keyboard_tip, unwrap(model), addr(path), addr(iter))
# tuple-return
# model: var TreeModel
# path: var TTreePath
# iter: var TTreeIter
# proc get_tooltip_context*(self: IconView, x: var int32, y: var int32, keyboard_tip: bool): bool {.inline.} =

# gtk_icon_view_get_visible_range
# flags: {isMethod} container: IconView
# need sugar: is method
# start_path 'var TTreePath' 'ptr TTreePath' OUT (diff., need sugar) optional
# end_path 'var TTreePath' 'ptr TTreePath' OUT (diff., need sugar) optional
# 'bool' 'bool'
proc gtk_icon_view_get_visible_range(self: ptr TIconView, start_path: ptr TTreePath, end_path: ptr TTreePath): bool {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_visible_range".}
proc get_visible_range*(self: IconView, start_path: var TTreePath, end_path: var TTreePath): bool {.inline.} =
  gtk_icon_view_get_visible_range(self, addr(start_path), addr(end_path))
# tuple-return
# start_path: var TTreePath
# end_path: var TTreePath
# proc get_visible_range*(self: IconView): bool {.inline.} =

# gtk_icon_view_item_activated
# flags: {isMethod} container: IconView
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_item_activated(self: ptr TIconView, path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_icon_view_item_activated".}
proc item_activated*(self: IconView, path: TTreePath) {.inline.} =
  gtk_icon_view_item_activated(self, myUnsafeAddr(path))
# proc item_activated*(self: IconView, path: TTreePath) {.inline.} =

# gtk_icon_view_path_is_selected
# flags: {isMethod} container: IconView
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_icon_view_path_is_selected(self: ptr TIconView, path: ptr TTreePath): bool {.cdecl, dynlib: lib, importc: "gtk_icon_view_path_is_selected".}
proc path_is_selected*(self: IconView, path: TTreePath): bool {.inline.} =
  gtk_icon_view_path_is_selected(self, myUnsafeAddr(path))
# proc path_is_selected*(self: IconView, path: TTreePath): bool {.inline.} =

# gtk_icon_view_scroll_to_path
# flags: {isMethod} container: IconView
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# use_align 'bool' 'bool' IN
# row_align 'float32' 'float32' IN
# col_align 'float32' 'float32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_scroll_to_path(self: ptr TIconView, path: ptr TTreePath, use_align: bool, row_align: float32, col_align: float32) {.cdecl, dynlib: lib, importc: "gtk_icon_view_scroll_to_path".}
proc scroll_to_path*(self: IconView, path: TTreePath, use_align: bool, row_align: float32, col_align: float32) {.inline.} =
  gtk_icon_view_scroll_to_path(self, myUnsafeAddr(path), use_align, row_align, col_align)
# proc scroll_to_path*(self: IconView, path: TTreePath, use_align: bool, row_align: float32, col_align: float32) {.inline.} =

# gtk_icon_view_select_all
# flags: {isMethod} container: IconView
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_select_all(self: ptr TIconView) {.cdecl, dynlib: lib, importc: "gtk_icon_view_select_all".}
proc select_all*(self: IconView) {.inline.} =
  gtk_icon_view_select_all(self)
# proc select_all*(self: IconView) {.inline.} =

# gtk_icon_view_select_path
# flags: {isMethod} container: IconView
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_select_path(self: ptr TIconView, path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_icon_view_select_path".}
proc select_path*(self: IconView, path: TTreePath) {.inline.} =
  gtk_icon_view_select_path(self, myUnsafeAddr(path))
# proc select_path*(self: IconView, path: TTreePath) {.inline.} =

# gtk_icon_view_selected_foreach
# flags: {isMethod} container: IconView
# need sugar: is method
# func 'pointer' 'pointer' IN
# data 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_selected_foreach(self: ptr TIconView, func_x: pointer, data: pointer) {.cdecl, dynlib: lib, importc: "gtk_icon_view_selected_foreach".}
proc selected_foreach*(self: IconView, func_x: pointer, data: pointer) {.inline.} =
  gtk_icon_view_selected_foreach(self, func_x, data)
# proc selected_foreach*(self: IconView, func_x: pointer, data: pointer) {.inline.} =

# gtk_icon_view_set_activate_on_single_click
# flags: {isMethod} container: IconView
# need sugar: is method
# single 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_activate_on_single_click(self: ptr TIconView, single: bool) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_activate_on_single_click".}
proc set_activate_on_single_click*(self: IconView, single: bool) {.inline.} =
  gtk_icon_view_set_activate_on_single_click(self, single)
# proc set_activate_on_single_click*(self: IconView, single: bool) {.inline.} =

# gtk_icon_view_set_column_spacing
# flags: {isMethod} container: IconView
# need sugar: is method
# column_spacing 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_column_spacing(self: ptr TIconView, column_spacing: int32) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_column_spacing".}
proc set_column_spacing*(self: IconView, column_spacing: int32) {.inline.} =
  gtk_icon_view_set_column_spacing(self, column_spacing)
# proc set_column_spacing*(self: IconView, column_spacing: int32) {.inline.} =

# gtk_icon_view_set_columns
# flags: {isMethod} container: IconView
# need sugar: is method
# columns 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_columns(self: ptr TIconView, columns: int32) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_columns".}
proc set_columns*(self: IconView, columns: int32) {.inline.} =
  gtk_icon_view_set_columns(self, columns)
# proc set_columns*(self: IconView, columns: int32) {.inline.} =

# gtk_icon_view_set_cursor
# flags: {isMethod} container: IconView
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# cell 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# start_editing 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_cursor(self: ptr TIconView, path: ptr TTreePath, cell: ptr TCellRenderer, start_editing: bool) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_cursor".}
proc set_cursor*(self: IconView, path: TTreePath, cell: CellRenderer, start_editing: bool) {.inline.} =
  gtk_icon_view_set_cursor(self, myUnsafeAddr(path), cell.getPointer, start_editing)
# proc set_cursor*(self: IconView, path: TTreePath, cell: CellRenderer, start_editing: bool) {.inline.} =

# gtk_icon_view_set_drag_dest_item
# flags: {isMethod} container: IconView
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# pos 'IconViewDropPosition' 'IconViewDropPosition' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_drag_dest_item(self: ptr TIconView, path: ptr TTreePath, pos: IconViewDropPosition) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_drag_dest_item".}
proc set_drag_dest_item*(self: IconView, path: TTreePath, pos: IconViewDropPosition) {.inline.} =
  gtk_icon_view_set_drag_dest_item(self, myUnsafeAddr(path), pos)
# proc set_drag_dest_item*(self: IconView, path: TTreePath, pos: IconViewDropPosition) {.inline.} =

# gtk_icon_view_set_item_orientation
# flags: {isMethod} container: IconView
# need sugar: is method
# orientation 'Orientation' 'Orientation' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_item_orientation(self: ptr TIconView, orientation: Orientation) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_item_orientation".}
proc set_item_orientation*(self: IconView, orientation: Orientation) {.inline.} =
  gtk_icon_view_set_item_orientation(self, orientation)
# proc set_item_orientation*(self: IconView, orientation: Orientation) {.inline.} =

# gtk_icon_view_set_item_padding
# flags: {isMethod} container: IconView
# need sugar: is method
# item_padding 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_item_padding(self: ptr TIconView, item_padding: int32) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_item_padding".}
proc set_item_padding*(self: IconView, item_padding: int32) {.inline.} =
  gtk_icon_view_set_item_padding(self, item_padding)
# proc set_item_padding*(self: IconView, item_padding: int32) {.inline.} =

# gtk_icon_view_set_item_width
# flags: {isMethod} container: IconView
# need sugar: is method
# item_width 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_item_width(self: ptr TIconView, item_width: int32) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_item_width".}
proc set_item_width*(self: IconView, item_width: int32) {.inline.} =
  gtk_icon_view_set_item_width(self, item_width)
# proc set_item_width*(self: IconView, item_width: int32) {.inline.} =

# gtk_icon_view_set_margin
# flags: {isMethod} container: IconView
# need sugar: is method
# margin 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_margin(self: ptr TIconView, margin: int32) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_margin".}
proc set_margin*(self: IconView, margin: int32) {.inline.} =
  gtk_icon_view_set_margin(self, margin)
# proc set_margin*(self: IconView, margin: int32) {.inline.} =

# gtk_icon_view_set_markup_column
# flags: {isMethod} container: IconView
# need sugar: is method
# column 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_markup_column(self: ptr TIconView, column: int32) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_markup_column".}
proc set_markup_column*(self: IconView, column: int32) {.inline.} =
  gtk_icon_view_set_markup_column(self, column)
# proc set_markup_column*(self: IconView, column: int32) {.inline.} =

# gtk_icon_view_set_model
# flags: {isMethod} container: IconView
# need sugar: is method
# model 'TreeModel' 'ptr TTreeModel' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_model(self: ptr TIconView, model: ptr TTreeModel) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_model".}
proc set_model*(self: IconView, model: TreeModel) {.inline.} =
  gtk_icon_view_set_model(self, unwrap(model))
# proc set_model*(self: IconView, model: TreeModel) {.inline.} =

# gtk_icon_view_set_pixbuf_column
# flags: {isMethod} container: IconView
# need sugar: is method
# column 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_pixbuf_column(self: ptr TIconView, column: int32) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_pixbuf_column".}
proc set_pixbuf_column*(self: IconView, column: int32) {.inline.} =
  gtk_icon_view_set_pixbuf_column(self, column)
# proc set_pixbuf_column*(self: IconView, column: int32) {.inline.} =

# gtk_icon_view_set_reorderable
# flags: {isMethod} container: IconView
# need sugar: is method
# reorderable 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_reorderable(self: ptr TIconView, reorderable: bool) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_reorderable".}
proc set_reorderable*(self: IconView, reorderable: bool) {.inline.} =
  gtk_icon_view_set_reorderable(self, reorderable)
# proc set_reorderable*(self: IconView, reorderable: bool) {.inline.} =

# gtk_icon_view_set_row_spacing
# flags: {isMethod} container: IconView
# need sugar: is method
# row_spacing 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_row_spacing(self: ptr TIconView, row_spacing: int32) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_row_spacing".}
proc set_row_spacing*(self: IconView, row_spacing: int32) {.inline.} =
  gtk_icon_view_set_row_spacing(self, row_spacing)
# proc set_row_spacing*(self: IconView, row_spacing: int32) {.inline.} =

# gtk_icon_view_set_selection_mode
# flags: {isMethod} container: IconView
# need sugar: is method
# mode 'SelectionMode' 'SelectionMode' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_selection_mode(self: ptr TIconView, mode: SelectionMode) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_selection_mode".}
proc set_selection_mode*(self: IconView, mode: SelectionMode) {.inline.} =
  gtk_icon_view_set_selection_mode(self, mode)
# proc set_selection_mode*(self: IconView, mode: SelectionMode) {.inline.} =

# gtk_icon_view_set_spacing
# flags: {isMethod} container: IconView
# need sugar: is method
# spacing 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_spacing(self: ptr TIconView, spacing: int32) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_spacing".}
proc set_spacing*(self: IconView, spacing: int32) {.inline.} =
  gtk_icon_view_set_spacing(self, spacing)
# proc set_spacing*(self: IconView, spacing: int32) {.inline.} =

# gtk_icon_view_set_text_column
# flags: {isMethod} container: IconView
# need sugar: is method
# column 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_text_column(self: ptr TIconView, column: int32) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_text_column".}
proc set_text_column*(self: IconView, column: int32) {.inline.} =
  gtk_icon_view_set_text_column(self, column)
# proc set_text_column*(self: IconView, column: int32) {.inline.} =

# gtk_icon_view_set_tooltip_cell
# flags: {isMethod} container: IconView
# need sugar: is method
# tooltip 'Tooltip' 'ptr TTooltip' IN (diff., need sugar)
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# cell 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_tooltip_cell(self: ptr TIconView, tooltip: ptr TTooltip, path: ptr TTreePath, cell: ptr TCellRenderer) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_tooltip_cell".}
proc set_tooltip_cell*(self: IconView, tooltip: Tooltip, path: TTreePath, cell: CellRenderer) {.inline.} =
  gtk_icon_view_set_tooltip_cell(self, tooltip.getPointer, myUnsafeAddr(path), cell.getPointer)
# proc set_tooltip_cell*(self: IconView, tooltip: Tooltip, path: TTreePath, cell: CellRenderer) {.inline.} =

# gtk_icon_view_set_tooltip_column
# flags: {isMethod} container: IconView
# need sugar: is method
# column 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_tooltip_column(self: ptr TIconView, column: int32) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_tooltip_column".}
proc set_tooltip_column*(self: IconView, column: int32) {.inline.} =
  gtk_icon_view_set_tooltip_column(self, column)
# proc set_tooltip_column*(self: IconView, column: int32) {.inline.} =

# gtk_icon_view_set_tooltip_item
# flags: {isMethod} container: IconView
# need sugar: is method
# tooltip 'Tooltip' 'ptr TTooltip' IN (diff., need sugar)
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_tooltip_item(self: ptr TIconView, tooltip: ptr TTooltip, path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_tooltip_item".}
proc set_tooltip_item*(self: IconView, tooltip: Tooltip, path: TTreePath) {.inline.} =
  gtk_icon_view_set_tooltip_item(self, tooltip.getPointer, myUnsafeAddr(path))
# proc set_tooltip_item*(self: IconView, tooltip: Tooltip, path: TTreePath) {.inline.} =

# gtk_icon_view_unselect_all
# flags: {isMethod} container: IconView
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_unselect_all(self: ptr TIconView) {.cdecl, dynlib: lib, importc: "gtk_icon_view_unselect_all".}
proc unselect_all*(self: IconView) {.inline.} =
  gtk_icon_view_unselect_all(self)
# proc unselect_all*(self: IconView) {.inline.} =

# gtk_icon_view_unselect_path
# flags: {isMethod} container: IconView
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_unselect_path(self: ptr TIconView, path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_icon_view_unselect_path".}
proc unselect_path*(self: IconView, path: TTreePath) {.inline.} =
  gtk_icon_view_unselect_path(self, myUnsafeAddr(path))
# proc unselect_path*(self: IconView, path: TTreePath) {.inline.} =

# gtk_icon_view_unset_model_drag_dest
# flags: {isMethod} container: IconView
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_unset_model_drag_dest(self: ptr TIconView) {.cdecl, dynlib: lib, importc: "gtk_icon_view_unset_model_drag_dest".}
proc unset_model_drag_dest*(self: IconView) {.inline.} =
  gtk_icon_view_unset_model_drag_dest(self)
# proc unset_model_drag_dest*(self: IconView) {.inline.} =

# gtk_icon_view_unset_model_drag_source
# flags: {isMethod} container: IconView
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_unset_model_drag_source(self: ptr TIconView) {.cdecl, dynlib: lib, importc: "gtk_icon_view_unset_model_drag_source".}
proc unset_model_drag_source*(self: IconView) {.inline.} =
  gtk_icon_view_unset_model_drag_source(self)
# proc unset_model_drag_source*(self: IconView) {.inline.} =

# gtk_image_new
# flags: {isConstructor} container: Image
# need sugar: is static method
# 'Image' 'TransferNone[TImage]' (diff., need sugar)
proc gtk_image_new(): TransferNone[TImage] {.cdecl, dynlib: lib, importc: "gtk_image_new".}
proc new_image*(): Image {.inline.} =
  wrap(gtk_image_new())
# proc new_image*(): Image {.inline.} =

# gtk_image_new_from_animation
# flags: {isConstructor} container: Image
# need sugar: is static method
# animation 'GdkPixbuf2.PixbufAnimation' 'ptr GdkPixbuf2.TPixbufAnimation' IN (diff., need sugar)
# 'Image' 'TransferNone[TImage]' (diff., need sugar)
proc gtk_image_new_from_animation(animation: ptr GdkPixbuf2.TPixbufAnimation): TransferNone[TImage] {.cdecl, dynlib: lib, importc: "gtk_image_new_from_animation".}
proc new_image_from_animation*(animation: GdkPixbuf2.PixbufAnimation): Image {.inline.} =
  wrap(gtk_image_new_from_animation(animation.getPointer))
# proc new_image_from_animation*(animation: GdkPixbuf2.PixbufAnimation): Image {.inline.} =

# gtk_image_new_from_file
# flags: {isConstructor} container: Image
# need sugar: is static method
# filename 'string' 'cstring' IN (diff., need sugar)
# 'Image' 'TransferNone[TImage]' (diff., need sugar)
proc gtk_image_new_from_file(filename: cstring): TransferNone[TImage] {.cdecl, dynlib: lib, importc: "gtk_image_new_from_file".}
proc new_image_from_file*(filename: string): Image {.inline.} =
  wrap(gtk_image_new_from_file(cstring(filename)))
# proc new_image_from_file*(filename: string): Image {.inline.} =

# gtk_image_new_from_gicon
# flags: {isConstructor} container: Image
# need sugar: is static method
# icon 'Gio2.Icon' 'ptr Gio2.TIcon' IN (diff., need sugar)
# size 'int32' 'int32' IN
# 'Image' 'TransferNone[TImage]' (diff., need sugar)
proc gtk_image_new_from_gicon(icon: ptr Gio2.TIcon, size: int32): TransferNone[TImage] {.cdecl, dynlib: lib, importc: "gtk_image_new_from_gicon".}
proc new_image_from_gicon*(icon: Gio2.Icon, size: int32): Image {.inline.} =
  wrap(gtk_image_new_from_gicon(unwrap(icon), size))
# proc new_image_from_gicon*(icon: Gio2.Icon, size: int32): Image {.inline.} =

# gtk_image_new_from_icon_name
# flags: {isConstructor} container: Image
# need sugar: is static method
# icon_name 'ustring' 'ucstring' IN (diff., need sugar)
# size 'int32' 'int32' IN
# 'Image' 'TransferNone[TImage]' (diff., need sugar)
proc gtk_image_new_from_icon_name(icon_name: ucstring, size: int32): TransferNone[TImage] {.cdecl, dynlib: lib, importc: "gtk_image_new_from_icon_name".}
proc new_image_from_icon_name*(icon_name: ustring, size: int32): Image {.inline.} =
  wrap(gtk_image_new_from_icon_name(ucstring(icon_name), size))
# proc new_image_from_icon_name*(icon_name: ustring, size: int32): Image {.inline.} =

# gtk_image_new_from_icon_set
# flags: {isConstructor} container: Image (deprecated)
# gtk_image_new_from_pixbuf
# flags: {isConstructor} container: Image
# need sugar: is static method
# pixbuf 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# 'Image' 'TransferNone[TImage]' (diff., need sugar)
proc gtk_image_new_from_pixbuf(pixbuf: ptr GdkPixbuf2.TPixbuf): TransferNone[TImage] {.cdecl, dynlib: lib, importc: "gtk_image_new_from_pixbuf".}
proc new_image_from_pixbuf*(pixbuf: GdkPixbuf2.Pixbuf): Image {.inline.} =
  wrap(gtk_image_new_from_pixbuf(pixbuf.getPointer))
# proc new_image_from_pixbuf*(pixbuf: GdkPixbuf2.Pixbuf): Image {.inline.} =

# gtk_image_new_from_resource
# flags: {isConstructor} container: Image
# need sugar: is static method
# resource_path 'ustring' 'ucstring' IN (diff., need sugar)
# 'Image' 'TransferNone[TImage]' (diff., need sugar)
proc gtk_image_new_from_resource(resource_path: ucstring): TransferNone[TImage] {.cdecl, dynlib: lib, importc: "gtk_image_new_from_resource".}
proc new_image_from_resource*(resource_path: ustring): Image {.inline.} =
  wrap(gtk_image_new_from_resource(ucstring(resource_path)))
# proc new_image_from_resource*(resource_path: ustring): Image {.inline.} =

# gtk_image_new_from_stock
# flags: {isConstructor} container: Image (deprecated)
# gtk_image_new_from_surface
# flags: {isConstructor} container: Image
# need sugar: is static method
# surface 'cairo1.TSurface' 'ptr cairo1.TSurface' IN (diff., need sugar)
# 'Image' 'TransferNone[TImage]' (diff., need sugar)
proc gtk_image_new_from_surface(surface: ptr cairo1.TSurface): TransferNone[TImage] {.cdecl, dynlib: lib, importc: "gtk_image_new_from_surface".}
proc new_image_from_surface*(surface: cairo1.TSurface): Image {.inline.} =
  wrap(gtk_image_new_from_surface(myUnsafeAddr(surface)))
# proc new_image_from_surface*(surface: cairo1.TSurface): Image {.inline.} =

# gtk_image_clear
# flags: {isMethod} container: Image
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_image_clear(self: ptr TImage) {.cdecl, dynlib: lib, importc: "gtk_image_clear".}
proc clear*(self: Image) {.inline.} =
  gtk_image_clear(self)
# proc clear*(self: Image) {.inline.} =

# gtk_image_get_animation
# flags: {isMethod} container: Image
# need sugar: is method
# 'GdkPixbuf2.PixbufAnimation' 'TransferNone[GdkPixbuf2.TPixbufAnimation]' (diff., need sugar)
proc gtk_image_get_animation(self: ptr TImage): TransferNone[GdkPixbuf2.TPixbufAnimation] {.cdecl, dynlib: lib, importc: "gtk_image_get_animation".}
proc get_animation*(self: Image): GdkPixbuf2.PixbufAnimation {.inline.} =
  wrap(gtk_image_get_animation(self))
# proc get_animation*(self: Image): GdkPixbuf2.PixbufAnimation {.inline.} =

# gtk_image_get_gicon
# flags: {isMethod} container: Image
# need sugar: is method
# gicon 'var Gio2.Icon' 'ptr Gio2.TIcon' OUT (diff., need sugar) optional
# size 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_image_get_gicon(self: ptr TImage, gicon: ptr Gio2.TIcon, size: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_image_get_gicon".}
proc get_gicon*(self: Image, gicon: var Gio2.Icon, size: var int32) {.inline.} =
  gtk_image_get_gicon(self, unwrap(gicon), addr(size))
# tuple-return
# gicon: var Gio2.Icon
# size: var int32
# proc get_gicon*(self: Image) {.inline.} =

# gtk_image_get_icon_name
# flags: {isMethod} container: Image
# need sugar: is method
# icon_name 'var ucstring' 'ptr ucstring' OUT (diff., need sugar) optional
# size 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_image_get_icon_name(self: ptr TImage, icon_name: ptr ucstring, size: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_image_get_icon_name".}
proc get_icon_name*(self: Image, icon_name: var ucstring, size: var int32) {.inline.} =
  gtk_image_get_icon_name(self, addr(icon_name), addr(size))
# tuple-return
# icon_name: var ucstring
# size: var int32
# proc get_icon_name*(self: Image) {.inline.} =

# gtk_image_get_icon_set
# flags: {isMethod} container: Image (deprecated)
# gtk_image_get_pixbuf
# flags: {isMethod} container: Image
# need sugar: is method
# 'GdkPixbuf2.Pixbuf' 'TransferNone[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_image_get_pixbuf(self: ptr TImage): TransferNone[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_image_get_pixbuf".}
proc get_pixbuf*(self: Image): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_image_get_pixbuf(self))
# proc get_pixbuf*(self: Image): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_image_get_pixel_size
# flags: {isMethod} container: Image
# need sugar: is method
# 'int32' 'int32'
proc gtk_image_get_pixel_size(self: ptr TImage): int32 {.cdecl, dynlib: lib, importc: "gtk_image_get_pixel_size".}
proc get_pixel_size*(self: Image): int32 {.inline.} =
  gtk_image_get_pixel_size(self)
# proc get_pixel_size*(self: Image): int32 {.inline.} =

# gtk_image_get_stock
# flags: {isMethod} container: Image (deprecated)
# gtk_image_get_storage_type
# flags: {isMethod} container: Image
# need sugar: is method
# 'ImageType' 'ImageType'
proc gtk_image_get_storage_type(self: ptr TImage): ImageType {.cdecl, dynlib: lib, importc: "gtk_image_get_storage_type".}
proc get_storage_type*(self: Image): ImageType {.inline.} =
  gtk_image_get_storage_type(self)
# proc get_storage_type*(self: Image): ImageType {.inline.} =

# gtk_image_set_from_animation
# flags: {isMethod} container: Image
# need sugar: is method
# animation 'GdkPixbuf2.PixbufAnimation' 'ptr GdkPixbuf2.TPixbufAnimation' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_image_set_from_animation(self: ptr TImage, animation: ptr GdkPixbuf2.TPixbufAnimation) {.cdecl, dynlib: lib, importc: "gtk_image_set_from_animation".}
proc set_from_animation*(self: Image, animation: GdkPixbuf2.PixbufAnimation) {.inline.} =
  gtk_image_set_from_animation(self, animation.getPointer)
# proc set_from_animation*(self: Image, animation: GdkPixbuf2.PixbufAnimation) {.inline.} =

# gtk_image_set_from_file
# flags: {isMethod} container: Image
# need sugar: is method
# filename 'string' 'cstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_image_set_from_file(self: ptr TImage, filename: cstring) {.cdecl, dynlib: lib, importc: "gtk_image_set_from_file".}
proc set_from_file*(self: Image, filename: string) {.inline.} =
  gtk_image_set_from_file(self, cstring(filename))
# proc set_from_file*(self: Image, filename: string) {.inline.} =

# gtk_image_set_from_gicon
# flags: {isMethod} container: Image
# need sugar: is method
# icon 'Gio2.Icon' 'ptr Gio2.TIcon' IN (diff., need sugar)
# size 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_image_set_from_gicon(self: ptr TImage, icon: ptr Gio2.TIcon, size: int32) {.cdecl, dynlib: lib, importc: "gtk_image_set_from_gicon".}
proc set_from_gicon*(self: Image, icon: Gio2.Icon, size: int32) {.inline.} =
  gtk_image_set_from_gicon(self, unwrap(icon), size)
# proc set_from_gicon*(self: Image, icon: Gio2.Icon, size: int32) {.inline.} =

# gtk_image_set_from_icon_name
# flags: {isMethod} container: Image
# need sugar: is method
# icon_name 'ustring' 'ucstring' IN (diff., need sugar)
# size 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_image_set_from_icon_name(self: ptr TImage, icon_name: ucstring, size: int32) {.cdecl, dynlib: lib, importc: "gtk_image_set_from_icon_name".}
proc set_from_icon_name*(self: Image, icon_name: ustring, size: int32) {.inline.} =
  gtk_image_set_from_icon_name(self, ucstring(icon_name), size)
# proc set_from_icon_name*(self: Image, icon_name: ustring, size: int32) {.inline.} =

# gtk_image_set_from_icon_set
# flags: {isMethod} container: Image (deprecated)
# gtk_image_set_from_pixbuf
# flags: {isMethod} container: Image
# need sugar: is method
# pixbuf 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_image_set_from_pixbuf(self: ptr TImage, pixbuf: ptr GdkPixbuf2.TPixbuf) {.cdecl, dynlib: lib, importc: "gtk_image_set_from_pixbuf".}
proc set_from_pixbuf*(self: Image, pixbuf: GdkPixbuf2.Pixbuf) {.inline.} =
  gtk_image_set_from_pixbuf(self, pixbuf.getPointer)
# proc set_from_pixbuf*(self: Image, pixbuf: GdkPixbuf2.Pixbuf) {.inline.} =

# gtk_image_set_from_resource
# flags: {isMethod} container: Image
# need sugar: is method
# resource_path 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_image_set_from_resource(self: ptr TImage, resource_path: ucstring) {.cdecl, dynlib: lib, importc: "gtk_image_set_from_resource".}
proc set_from_resource*(self: Image, resource_path: ustring) {.inline.} =
  gtk_image_set_from_resource(self, ucstring(resource_path))
# proc set_from_resource*(self: Image, resource_path: ustring) {.inline.} =

# gtk_image_set_from_stock
# flags: {isMethod} container: Image (deprecated)
# gtk_image_set_from_surface
# flags: {isMethod} container: Image
# need sugar: is method
# surface 'cairo1.TSurface' 'ptr cairo1.TSurface' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_image_set_from_surface(self: ptr TImage, surface: ptr cairo1.TSurface) {.cdecl, dynlib: lib, importc: "gtk_image_set_from_surface".}
proc set_from_surface*(self: Image, surface: cairo1.TSurface) {.inline.} =
  gtk_image_set_from_surface(self, myUnsafeAddr(surface))
# proc set_from_surface*(self: Image, surface: cairo1.TSurface) {.inline.} =

# gtk_image_set_pixel_size
# flags: {isMethod} container: Image
# need sugar: is method
# pixel_size 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_image_set_pixel_size(self: ptr TImage, pixel_size: int32) {.cdecl, dynlib: lib, importc: "gtk_image_set_pixel_size".}
proc set_pixel_size*(self: Image, pixel_size: int32) {.inline.} =
  gtk_image_set_pixel_size(self, pixel_size)
# proc set_pixel_size*(self: Image, pixel_size: int32) {.inline.} =

# gtk_image_menu_item_new
# flags: {isConstructor} container: ImageMenuItem (deprecated)
# gtk_image_menu_item_new_from_stock
# flags: {isConstructor} container: ImageMenuItem (deprecated)
# gtk_image_menu_item_new_with_label
# flags: {isConstructor} container: ImageMenuItem (deprecated)
# gtk_image_menu_item_new_with_mnemonic
# flags: {isConstructor} container: ImageMenuItem (deprecated)
# gtk_image_menu_item_get_always_show_image
# flags: {isMethod} container: ImageMenuItem (deprecated)
# gtk_image_menu_item_get_image
# flags: {isMethod} container: ImageMenuItem (deprecated)
# gtk_image_menu_item_get_use_stock
# flags: {isMethod} container: ImageMenuItem (deprecated)
# gtk_image_menu_item_set_accel_group
# flags: {isMethod} container: ImageMenuItem (deprecated)
# gtk_image_menu_item_set_always_show_image
# flags: {isMethod} container: ImageMenuItem (deprecated)
# gtk_image_menu_item_set_image
# flags: {isMethod} container: ImageMenuItem (deprecated)
# gtk_image_menu_item_set_use_stock
# flags: {isMethod} container: ImageMenuItem (deprecated)
# gtk_info_bar_new
# flags: {isConstructor} container: InfoBar
# need sugar: is static method
# 'InfoBar' 'TransferNone[TInfoBar]' (diff., need sugar)
proc gtk_info_bar_new(): TransferNone[TInfoBar] {.cdecl, dynlib: lib, importc: "gtk_info_bar_new".}
proc new_infobar*(): InfoBar {.inline.} =
  wrap(gtk_info_bar_new())
# proc new_infobar*(): InfoBar {.inline.} =

# gtk_info_bar_add_action_widget
# flags: {isMethod} container: InfoBar
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# response_id 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_info_bar_add_action_widget(self: ptr TInfoBar, child: ptr TWidget, response_id: int32) {.cdecl, dynlib: lib, importc: "gtk_info_bar_add_action_widget".}
proc add_action_widget*(self: InfoBar, child: Widget, response_id: int32) {.inline.} =
  gtk_info_bar_add_action_widget(self, child.getPointer, response_id)
# proc add_action_widget*(self: InfoBar, child: Widget, response_id: int32) {.inline.} =

# gtk_info_bar_add_button
# flags: {isMethod} container: InfoBar
# need sugar: is method
# button_text 'ustring' 'ucstring' IN (diff., need sugar)
# response_id 'int32' 'int32' IN
# 'Button' 'TransferNone[TButton]' (diff., need sugar)
proc gtk_info_bar_add_button(self: ptr TInfoBar, button_text: ucstring, response_id: int32): TransferNone[TButton] {.cdecl, dynlib: lib, importc: "gtk_info_bar_add_button".}
proc add_button*(self: InfoBar, button_text: ustring, response_id: int32): Button {.inline.} =
  wrap(gtk_info_bar_add_button(self, ucstring(button_text), response_id))
# proc add_button*(self: InfoBar, button_text: ustring, response_id: int32): Button {.inline.} =

# gtk_info_bar_get_action_area
# flags: {isMethod} container: InfoBar
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_info_bar_get_action_area(self: ptr TInfoBar): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_info_bar_get_action_area".}
proc get_action_area*(self: InfoBar): Widget {.inline.} =
  wrap(gtk_info_bar_get_action_area(self))
# proc get_action_area*(self: InfoBar): Widget {.inline.} =

# gtk_info_bar_get_content_area
# flags: {isMethod} container: InfoBar
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_info_bar_get_content_area(self: ptr TInfoBar): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_info_bar_get_content_area".}
proc get_content_area*(self: InfoBar): Widget {.inline.} =
  wrap(gtk_info_bar_get_content_area(self))
# proc get_content_area*(self: InfoBar): Widget {.inline.} =

# gtk_info_bar_get_message_type
# flags: {isMethod} container: InfoBar
# need sugar: is method
# 'MessageType' 'MessageType'
proc gtk_info_bar_get_message_type(self: ptr TInfoBar): MessageType {.cdecl, dynlib: lib, importc: "gtk_info_bar_get_message_type".}
proc get_message_type*(self: InfoBar): MessageType {.inline.} =
  gtk_info_bar_get_message_type(self)
# proc get_message_type*(self: InfoBar): MessageType {.inline.} =

# gtk_info_bar_get_show_close_button
# flags: {isMethod} container: InfoBar
# need sugar: is method
# 'bool' 'bool'
proc gtk_info_bar_get_show_close_button(self: ptr TInfoBar): bool {.cdecl, dynlib: lib, importc: "gtk_info_bar_get_show_close_button".}
proc get_show_close_button*(self: InfoBar): bool {.inline.} =
  gtk_info_bar_get_show_close_button(self)
# proc get_show_close_button*(self: InfoBar): bool {.inline.} =

# gtk_info_bar_response
# flags: {isMethod} container: InfoBar
# need sugar: is method
# response_id 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_info_bar_response(self: ptr TInfoBar, response_id: int32) {.cdecl, dynlib: lib, importc: "gtk_info_bar_response".}
proc response*(self: InfoBar, response_id: int32) {.inline.} =
  gtk_info_bar_response(self, response_id)
# proc response*(self: InfoBar, response_id: int32) {.inline.} =

# gtk_info_bar_set_default_response
# flags: {isMethod} container: InfoBar
# need sugar: is method
# response_id 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_info_bar_set_default_response(self: ptr TInfoBar, response_id: int32) {.cdecl, dynlib: lib, importc: "gtk_info_bar_set_default_response".}
proc set_default_response*(self: InfoBar, response_id: int32) {.inline.} =
  gtk_info_bar_set_default_response(self, response_id)
# proc set_default_response*(self: InfoBar, response_id: int32) {.inline.} =

# gtk_info_bar_set_message_type
# flags: {isMethod} container: InfoBar
# need sugar: is method
# message_type 'MessageType' 'MessageType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_info_bar_set_message_type(self: ptr TInfoBar, message_type: MessageType) {.cdecl, dynlib: lib, importc: "gtk_info_bar_set_message_type".}
proc set_message_type*(self: InfoBar, message_type: MessageType) {.inline.} =
  gtk_info_bar_set_message_type(self, message_type)
# proc set_message_type*(self: InfoBar, message_type: MessageType) {.inline.} =

# gtk_info_bar_set_response_sensitive
# flags: {isMethod} container: InfoBar
# need sugar: is method
# response_id 'int32' 'int32' IN
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_info_bar_set_response_sensitive(self: ptr TInfoBar, response_id: int32, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_info_bar_set_response_sensitive".}
proc set_response_sensitive*(self: InfoBar, response_id: int32, setting: bool) {.inline.} =
  gtk_info_bar_set_response_sensitive(self, response_id, setting)
# proc set_response_sensitive*(self: InfoBar, response_id: int32, setting: bool) {.inline.} =

# gtk_info_bar_set_show_close_button
# flags: {isMethod} container: InfoBar
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_info_bar_set_show_close_button(self: ptr TInfoBar, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_info_bar_set_show_close_button".}
proc set_show_close_button*(self: InfoBar, setting: bool) {.inline.} =
  gtk_info_bar_set_show_close_button(self, setting)
# proc set_show_close_button*(self: InfoBar, setting: bool) {.inline.} =

# gtk_invisible_new
# flags: {isConstructor} container: Invisible
# need sugar: is static method
# 'Invisible' 'TransferNone[TInvisible]' (diff., need sugar)
proc gtk_invisible_new(): TransferNone[TInvisible] {.cdecl, dynlib: lib, importc: "gtk_invisible_new".}
proc new_invisible*(): Invisible {.inline.} =
  wrap(gtk_invisible_new())
# proc new_invisible*(): Invisible {.inline.} =

# gtk_invisible_new_for_screen
# flags: {isConstructor} container: Invisible
# need sugar: is static method
# screen 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# 'Invisible' 'TransferNone[TInvisible]' (diff., need sugar)
proc gtk_invisible_new_for_screen(screen: ptr Gdk3.TScreen): TransferNone[TInvisible] {.cdecl, dynlib: lib, importc: "gtk_invisible_new_for_screen".}
proc new_invisible_for_screen*(screen: Gdk3.Screen): Invisible {.inline.} =
  wrap(gtk_invisible_new_for_screen(screen.getPointer))
# proc new_invisible_for_screen*(screen: Gdk3.Screen): Invisible {.inline.} =

# gtk_invisible_get_screen
# flags: {isMethod} container: Invisible
# need sugar: is method
# 'Gdk3.Screen' 'TransferNone[Gdk3.TScreen]' (diff., need sugar)
proc gtk_invisible_get_screen(self: ptr TInvisible): TransferNone[Gdk3.TScreen] {.cdecl, dynlib: lib, importc: "gtk_invisible_get_screen".}
proc get_screen*(self: Invisible): Gdk3.Screen {.inline.} =
  wrap(gtk_invisible_get_screen(self))
# proc get_screen*(self: Invisible): Gdk3.Screen {.inline.} =

# gtk_invisible_set_screen
# flags: {isMethod} container: Invisible
# need sugar: is method
# screen 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_invisible_set_screen(self: ptr TInvisible, screen: ptr Gdk3.TScreen) {.cdecl, dynlib: lib, importc: "gtk_invisible_set_screen".}
proc set_screen*(self: Invisible, screen: Gdk3.Screen) {.inline.} =
  gtk_invisible_set_screen(self, screen.getPointer)
# proc set_screen*(self: Invisible, screen: Gdk3.Screen) {.inline.} =

# gtk_label_new
# flags: {isConstructor} container: Label
# need sugar: is static method
# str 'ustring' 'ucstring' IN (diff., need sugar)
# 'Label' 'TransferNone[TLabel]' (diff., need sugar)
proc gtk_label_new(str: ucstring): TransferNone[TLabel] {.cdecl, dynlib: lib, importc: "gtk_label_new".}
proc new_label*(str: ustring): Label {.inline.} =
  wrap(gtk_label_new(ucstring(str)))
# proc new_label*(str: ustring): Label {.inline.} =

# gtk_label_new_with_mnemonic
# flags: {isConstructor} container: Label
# need sugar: is static method
# str 'ustring' 'ucstring' IN (diff., need sugar)
# 'Label' 'TransferNone[TLabel]' (diff., need sugar)
proc gtk_label_new_with_mnemonic(str: ucstring): TransferNone[TLabel] {.cdecl, dynlib: lib, importc: "gtk_label_new_with_mnemonic".}
proc new_label_with_mnemonic*(str: ustring): Label {.inline.} =
  wrap(gtk_label_new_with_mnemonic(ucstring(str)))
# proc new_label_with_mnemonic*(str: ustring): Label {.inline.} =

# gtk_label_get_angle
# flags: {isMethod} container: Label
# need sugar: is method
# 'float64' 'float64'
proc gtk_label_get_angle(self: ptr TLabel): float64 {.cdecl, dynlib: lib, importc: "gtk_label_get_angle".}
proc get_angle*(self: Label): float64 {.inline.} =
  gtk_label_get_angle(self)
# proc get_angle*(self: Label): float64 {.inline.} =

# gtk_label_get_attributes
# flags: {isMethod} container: Label
# need sugar: is method
# 'Pango1.TAttrList' 'ptr Pango1.TAttrList' (diff., need sugar)
proc gtk_label_get_attributes(self: ptr TLabel): ptr Pango1.TAttrList {.cdecl, dynlib: lib, importc: "gtk_label_get_attributes".}
proc get_attributes*(self: Label): Pango1.TAttrList {.inline.} =
  (gtk_label_get_attributes(self))[]
# proc get_attributes*(self: Label): Pango1.TAttrList {.inline.} =

# gtk_label_get_current_uri
# flags: {isMethod} container: Label
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_label_get_current_uri(self: ptr TLabel): ucstring {.cdecl, dynlib: lib, importc: "gtk_label_get_current_uri".}
proc get_current_uri*(self: Label): ustring {.inline.} =
  ustring($(gtk_label_get_current_uri(self)))
# proc get_current_uri*(self: Label): ustring {.inline.} =

# gtk_label_get_ellipsize
# flags: {isMethod} container: Label
# need sugar: is method
# 'Pango1.EllipsizeMode' 'Pango1.EllipsizeMode'
proc gtk_label_get_ellipsize(self: ptr TLabel): Pango1.EllipsizeMode {.cdecl, dynlib: lib, importc: "gtk_label_get_ellipsize".}
proc get_ellipsize*(self: Label): Pango1.EllipsizeMode {.inline.} =
  gtk_label_get_ellipsize(self)
# proc get_ellipsize*(self: Label): Pango1.EllipsizeMode {.inline.} =

# gtk_label_get_justify
# flags: {isMethod} container: Label
# need sugar: is method
# 'Justification' 'Justification'
proc gtk_label_get_justify(self: ptr TLabel): Justification {.cdecl, dynlib: lib, importc: "gtk_label_get_justify".}
proc get_justify*(self: Label): Justification {.inline.} =
  gtk_label_get_justify(self)
# proc get_justify*(self: Label): Justification {.inline.} =

# gtk_label_get_label
# flags: {isMethod} container: Label
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_label_get_label(self: ptr TLabel): ucstring {.cdecl, dynlib: lib, importc: "gtk_label_get_label".}
proc get_label*(self: Label): ustring {.inline.} =
  ustring($(gtk_label_get_label(self)))
# proc get_label*(self: Label): ustring {.inline.} =

# gtk_label_get_layout
# flags: {isMethod} container: Label
# need sugar: is method
# 'Pango1.Layout' 'TransferNone[Pango1.TLayout]' (diff., need sugar)
proc gtk_label_get_layout(self: ptr TLabel): TransferNone[Pango1.TLayout] {.cdecl, dynlib: lib, importc: "gtk_label_get_layout".}
proc get_layout*(self: Label): Pango1.Layout {.inline.} =
  wrap(gtk_label_get_layout(self))
# proc get_layout*(self: Label): Pango1.Layout {.inline.} =

# gtk_label_get_layout_offsets
# flags: {isMethod} container: Label
# need sugar: is method
# x 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# y 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_label_get_layout_offsets(self: ptr TLabel, x: ptr int32, y: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_label_get_layout_offsets".}
proc get_layout_offsets*(self: Label, x: var int32, y: var int32) {.inline.} =
  gtk_label_get_layout_offsets(self, addr(x), addr(y))
# tuple-return
# x: var int32
# y: var int32
# proc get_layout_offsets*(self: Label) {.inline.} =

# gtk_label_get_line_wrap
# flags: {isMethod} container: Label
# need sugar: is method
# 'bool' 'bool'
proc gtk_label_get_line_wrap(self: ptr TLabel): bool {.cdecl, dynlib: lib, importc: "gtk_label_get_line_wrap".}
proc get_line_wrap*(self: Label): bool {.inline.} =
  gtk_label_get_line_wrap(self)
# proc get_line_wrap*(self: Label): bool {.inline.} =

# gtk_label_get_line_wrap_mode
# flags: {isMethod} container: Label
# need sugar: is method
# 'Pango1.WrapMode' 'Pango1.WrapMode'
proc gtk_label_get_line_wrap_mode(self: ptr TLabel): Pango1.WrapMode {.cdecl, dynlib: lib, importc: "gtk_label_get_line_wrap_mode".}
proc get_line_wrap_mode*(self: Label): Pango1.WrapMode {.inline.} =
  gtk_label_get_line_wrap_mode(self)
# proc get_line_wrap_mode*(self: Label): Pango1.WrapMode {.inline.} =

# gtk_label_get_lines
# flags: {isMethod} container: Label
# need sugar: is method
# 'int32' 'int32'
proc gtk_label_get_lines(self: ptr TLabel): int32 {.cdecl, dynlib: lib, importc: "gtk_label_get_lines".}
proc get_lines*(self: Label): int32 {.inline.} =
  gtk_label_get_lines(self)
# proc get_lines*(self: Label): int32 {.inline.} =

# gtk_label_get_max_width_chars
# flags: {isMethod} container: Label
# need sugar: is method
# 'int32' 'int32'
proc gtk_label_get_max_width_chars(self: ptr TLabel): int32 {.cdecl, dynlib: lib, importc: "gtk_label_get_max_width_chars".}
proc get_max_width_chars*(self: Label): int32 {.inline.} =
  gtk_label_get_max_width_chars(self)
# proc get_max_width_chars*(self: Label): int32 {.inline.} =

# gtk_label_get_mnemonic_keyval
# flags: {isMethod} container: Label
# need sugar: is method
# 'uint32' 'uint32'
proc gtk_label_get_mnemonic_keyval(self: ptr TLabel): uint32 {.cdecl, dynlib: lib, importc: "gtk_label_get_mnemonic_keyval".}
proc get_mnemonic_keyval*(self: Label): uint32 {.inline.} =
  gtk_label_get_mnemonic_keyval(self)
# proc get_mnemonic_keyval*(self: Label): uint32 {.inline.} =

# gtk_label_get_mnemonic_widget
# flags: {isMethod} container: Label
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_label_get_mnemonic_widget(self: ptr TLabel): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_label_get_mnemonic_widget".}
proc get_mnemonic_widget*(self: Label): Widget {.inline.} =
  wrap(gtk_label_get_mnemonic_widget(self))
# proc get_mnemonic_widget*(self: Label): Widget {.inline.} =

# gtk_label_get_selectable
# flags: {isMethod} container: Label
# need sugar: is method
# 'bool' 'bool'
proc gtk_label_get_selectable(self: ptr TLabel): bool {.cdecl, dynlib: lib, importc: "gtk_label_get_selectable".}
proc get_selectable*(self: Label): bool {.inline.} =
  gtk_label_get_selectable(self)
# proc get_selectable*(self: Label): bool {.inline.} =

# gtk_label_get_selection_bounds
# flags: {isMethod} container: Label
# need sugar: is method
# start 'var int32' 'ptr int32' OUT (diff., need sugar)
# end 'var int32' 'ptr int32' OUT (diff., need sugar)
# 'bool' 'bool'
proc gtk_label_get_selection_bounds(self: ptr TLabel, start: ptr int32, end_x: ptr int32): bool {.cdecl, dynlib: lib, importc: "gtk_label_get_selection_bounds".}
proc get_selection_bounds*(self: Label, start: var int32, end_x: var int32): bool {.inline.} =
  gtk_label_get_selection_bounds(self, addr(start), addr(end_x))
# tuple-return
# start: var int32
# end: var int32
# proc get_selection_bounds*(self: Label): bool {.inline.} =

# gtk_label_get_single_line_mode
# flags: {isMethod} container: Label
# need sugar: is method
# 'bool' 'bool'
proc gtk_label_get_single_line_mode(self: ptr TLabel): bool {.cdecl, dynlib: lib, importc: "gtk_label_get_single_line_mode".}
proc get_single_line_mode*(self: Label): bool {.inline.} =
  gtk_label_get_single_line_mode(self)
# proc get_single_line_mode*(self: Label): bool {.inline.} =

# gtk_label_get_text
# flags: {isMethod} container: Label
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_label_get_text(self: ptr TLabel): ucstring {.cdecl, dynlib: lib, importc: "gtk_label_get_text".}
proc get_text*(self: Label): ustring {.inline.} =
  ustring($(gtk_label_get_text(self)))
# proc get_text*(self: Label): ustring {.inline.} =

# gtk_label_get_track_visited_links
# flags: {isMethod} container: Label
# need sugar: is method
# 'bool' 'bool'
proc gtk_label_get_track_visited_links(self: ptr TLabel): bool {.cdecl, dynlib: lib, importc: "gtk_label_get_track_visited_links".}
proc get_track_visited_links*(self: Label): bool {.inline.} =
  gtk_label_get_track_visited_links(self)
# proc get_track_visited_links*(self: Label): bool {.inline.} =

# gtk_label_get_use_markup
# flags: {isMethod} container: Label
# need sugar: is method
# 'bool' 'bool'
proc gtk_label_get_use_markup(self: ptr TLabel): bool {.cdecl, dynlib: lib, importc: "gtk_label_get_use_markup".}
proc get_use_markup*(self: Label): bool {.inline.} =
  gtk_label_get_use_markup(self)
# proc get_use_markup*(self: Label): bool {.inline.} =

# gtk_label_get_use_underline
# flags: {isMethod} container: Label
# need sugar: is method
# 'bool' 'bool'
proc gtk_label_get_use_underline(self: ptr TLabel): bool {.cdecl, dynlib: lib, importc: "gtk_label_get_use_underline".}
proc get_use_underline*(self: Label): bool {.inline.} =
  gtk_label_get_use_underline(self)
# proc get_use_underline*(self: Label): bool {.inline.} =

# gtk_label_get_width_chars
# flags: {isMethod} container: Label
# need sugar: is method
# 'int32' 'int32'
proc gtk_label_get_width_chars(self: ptr TLabel): int32 {.cdecl, dynlib: lib, importc: "gtk_label_get_width_chars".}
proc get_width_chars*(self: Label): int32 {.inline.} =
  gtk_label_get_width_chars(self)
# proc get_width_chars*(self: Label): int32 {.inline.} =

# gtk_label_select_region
# flags: {isMethod} container: Label
# need sugar: is method
# start_offset 'int32' 'int32' IN
# end_offset 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_label_select_region(self: ptr TLabel, start_offset: int32, end_offset: int32) {.cdecl, dynlib: lib, importc: "gtk_label_select_region".}
proc select_region*(self: Label, start_offset: int32, end_offset: int32) {.inline.} =
  gtk_label_select_region(self, start_offset, end_offset)
# proc select_region*(self: Label, start_offset: int32, end_offset: int32) {.inline.} =

# gtk_label_set_angle
# flags: {isMethod} container: Label
# need sugar: is method
# angle 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_angle(self: ptr TLabel, angle: float64) {.cdecl, dynlib: lib, importc: "gtk_label_set_angle".}
proc set_angle*(self: Label, angle: float64) {.inline.} =
  gtk_label_set_angle(self, angle)
# proc set_angle*(self: Label, angle: float64) {.inline.} =

# gtk_label_set_attributes
# flags: {isMethod} container: Label
# need sugar: is method
# attrs 'Pango1.TAttrList' 'ptr Pango1.TAttrList' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_attributes(self: ptr TLabel, attrs: ptr Pango1.TAttrList) {.cdecl, dynlib: lib, importc: "gtk_label_set_attributes".}
proc set_attributes*(self: Label, attrs: Pango1.TAttrList) {.inline.} =
  gtk_label_set_attributes(self, myUnsafeAddr(attrs))
# proc set_attributes*(self: Label, attrs: Pango1.TAttrList) {.inline.} =

# gtk_label_set_ellipsize
# flags: {isMethod} container: Label
# need sugar: is method
# mode 'Pango1.EllipsizeMode' 'Pango1.EllipsizeMode' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_ellipsize(self: ptr TLabel, mode: Pango1.EllipsizeMode) {.cdecl, dynlib: lib, importc: "gtk_label_set_ellipsize".}
proc set_ellipsize*(self: Label, mode: Pango1.EllipsizeMode) {.inline.} =
  gtk_label_set_ellipsize(self, mode)
# proc set_ellipsize*(self: Label, mode: Pango1.EllipsizeMode) {.inline.} =

# gtk_label_set_justify
# flags: {isMethod} container: Label
# need sugar: is method
# jtype 'Justification' 'Justification' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_justify(self: ptr TLabel, jtype: Justification) {.cdecl, dynlib: lib, importc: "gtk_label_set_justify".}
proc set_justify*(self: Label, jtype: Justification) {.inline.} =
  gtk_label_set_justify(self, jtype)
# proc set_justify*(self: Label, jtype: Justification) {.inline.} =

# gtk_label_set_label
# flags: {isMethod} container: Label
# need sugar: is method
# str 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_label(self: ptr TLabel, str: ucstring) {.cdecl, dynlib: lib, importc: "gtk_label_set_label".}
proc set_label*(self: Label, str: ustring) {.inline.} =
  gtk_label_set_label(self, ucstring(str))
# proc set_label*(self: Label, str: ustring) {.inline.} =

# gtk_label_set_line_wrap
# flags: {isMethod} container: Label
# need sugar: is method
# wrap 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_line_wrap(self: ptr TLabel, wrap: bool) {.cdecl, dynlib: lib, importc: "gtk_label_set_line_wrap".}
proc set_line_wrap*(self: Label, wrap: bool) {.inline.} =
  gtk_label_set_line_wrap(self, wrap)
# proc set_line_wrap*(self: Label, wrap: bool) {.inline.} =

# gtk_label_set_line_wrap_mode
# flags: {isMethod} container: Label
# need sugar: is method
# wrap_mode 'Pango1.WrapMode' 'Pango1.WrapMode' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_line_wrap_mode(self: ptr TLabel, wrap_mode: Pango1.WrapMode) {.cdecl, dynlib: lib, importc: "gtk_label_set_line_wrap_mode".}
proc set_line_wrap_mode*(self: Label, wrap_mode: Pango1.WrapMode) {.inline.} =
  gtk_label_set_line_wrap_mode(self, wrap_mode)
# proc set_line_wrap_mode*(self: Label, wrap_mode: Pango1.WrapMode) {.inline.} =

# gtk_label_set_lines
# flags: {isMethod} container: Label
# need sugar: is method
# lines 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_lines(self: ptr TLabel, lines: int32) {.cdecl, dynlib: lib, importc: "gtk_label_set_lines".}
proc set_lines*(self: Label, lines: int32) {.inline.} =
  gtk_label_set_lines(self, lines)
# proc set_lines*(self: Label, lines: int32) {.inline.} =

# gtk_label_set_markup
# flags: {isMethod} container: Label
# need sugar: is method
# str 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_markup(self: ptr TLabel, str: ucstring) {.cdecl, dynlib: lib, importc: "gtk_label_set_markup".}
proc set_markup*(self: Label, str: ustring) {.inline.} =
  gtk_label_set_markup(self, ucstring(str))
# proc set_markup*(self: Label, str: ustring) {.inline.} =

# gtk_label_set_markup_with_mnemonic
# flags: {isMethod} container: Label
# need sugar: is method
# str 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_markup_with_mnemonic(self: ptr TLabel, str: ucstring) {.cdecl, dynlib: lib, importc: "gtk_label_set_markup_with_mnemonic".}
proc set_markup_with_mnemonic*(self: Label, str: ustring) {.inline.} =
  gtk_label_set_markup_with_mnemonic(self, ucstring(str))
# proc set_markup_with_mnemonic*(self: Label, str: ustring) {.inline.} =

# gtk_label_set_max_width_chars
# flags: {isMethod} container: Label
# need sugar: is method
# n_chars 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_max_width_chars(self: ptr TLabel, n_chars: int32) {.cdecl, dynlib: lib, importc: "gtk_label_set_max_width_chars".}
proc set_max_width_chars*(self: Label, n_chars: int32) {.inline.} =
  gtk_label_set_max_width_chars(self, n_chars)
# proc set_max_width_chars*(self: Label, n_chars: int32) {.inline.} =

# gtk_label_set_mnemonic_widget
# flags: {isMethod} container: Label
# need sugar: is method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_mnemonic_widget(self: ptr TLabel, widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_label_set_mnemonic_widget".}
proc set_mnemonic_widget*(self: Label, widget: Widget) {.inline.} =
  gtk_label_set_mnemonic_widget(self, widget.getPointer)
# proc set_mnemonic_widget*(self: Label, widget: Widget) {.inline.} =

# gtk_label_set_pattern
# flags: {isMethod} container: Label
# need sugar: is method
# pattern 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_pattern(self: ptr TLabel, pattern: ucstring) {.cdecl, dynlib: lib, importc: "gtk_label_set_pattern".}
proc set_pattern*(self: Label, pattern: ustring) {.inline.} =
  gtk_label_set_pattern(self, ucstring(pattern))
# proc set_pattern*(self: Label, pattern: ustring) {.inline.} =

# gtk_label_set_selectable
# flags: {isMethod} container: Label
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_selectable(self: ptr TLabel, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_label_set_selectable".}
proc set_selectable*(self: Label, setting: bool) {.inline.} =
  gtk_label_set_selectable(self, setting)
# proc set_selectable*(self: Label, setting: bool) {.inline.} =

# gtk_label_set_single_line_mode
# flags: {isMethod} container: Label
# need sugar: is method
# single_line_mode 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_single_line_mode(self: ptr TLabel, single_line_mode: bool) {.cdecl, dynlib: lib, importc: "gtk_label_set_single_line_mode".}
proc set_single_line_mode*(self: Label, single_line_mode: bool) {.inline.} =
  gtk_label_set_single_line_mode(self, single_line_mode)
# proc set_single_line_mode*(self: Label, single_line_mode: bool) {.inline.} =

# gtk_label_set_text
# flags: {isMethod} container: Label
# need sugar: is method
# str 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_text(self: ptr TLabel, str: ucstring) {.cdecl, dynlib: lib, importc: "gtk_label_set_text".}
proc set_text*(self: Label, str: ustring) {.inline.} =
  gtk_label_set_text(self, ucstring(str))
# proc set_text*(self: Label, str: ustring) {.inline.} =

# gtk_label_set_text_with_mnemonic
# flags: {isMethod} container: Label
# need sugar: is method
# str 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_text_with_mnemonic(self: ptr TLabel, str: ucstring) {.cdecl, dynlib: lib, importc: "gtk_label_set_text_with_mnemonic".}
proc set_text_with_mnemonic*(self: Label, str: ustring) {.inline.} =
  gtk_label_set_text_with_mnemonic(self, ucstring(str))
# proc set_text_with_mnemonic*(self: Label, str: ustring) {.inline.} =

# gtk_label_set_track_visited_links
# flags: {isMethod} container: Label
# need sugar: is method
# track_links 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_track_visited_links(self: ptr TLabel, track_links: bool) {.cdecl, dynlib: lib, importc: "gtk_label_set_track_visited_links".}
proc set_track_visited_links*(self: Label, track_links: bool) {.inline.} =
  gtk_label_set_track_visited_links(self, track_links)
# proc set_track_visited_links*(self: Label, track_links: bool) {.inline.} =

# gtk_label_set_use_markup
# flags: {isMethod} container: Label
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_use_markup(self: ptr TLabel, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_label_set_use_markup".}
proc set_use_markup*(self: Label, setting: bool) {.inline.} =
  gtk_label_set_use_markup(self, setting)
# proc set_use_markup*(self: Label, setting: bool) {.inline.} =

# gtk_label_set_use_underline
# flags: {isMethod} container: Label
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_use_underline(self: ptr TLabel, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_label_set_use_underline".}
proc set_use_underline*(self: Label, setting: bool) {.inline.} =
  gtk_label_set_use_underline(self, setting)
# proc set_use_underline*(self: Label, setting: bool) {.inline.} =

# gtk_label_set_width_chars
# flags: {isMethod} container: Label
# need sugar: is method
# n_chars 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_width_chars(self: ptr TLabel, n_chars: int32) {.cdecl, dynlib: lib, importc: "gtk_label_set_width_chars".}
proc set_width_chars*(self: Label, n_chars: int32) {.inline.} =
  gtk_label_set_width_chars(self, n_chars)
# proc set_width_chars*(self: Label, n_chars: int32) {.inline.} =

# gtk_layout_new
# flags: {isConstructor} container: Layout
# need sugar: is static method
# hadjustment 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# vadjustment 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# 'Layout' 'TransferNone[TLayout]' (diff., need sugar)
proc gtk_layout_new(hadjustment: ptr TAdjustment, vadjustment: ptr TAdjustment): TransferNone[TLayout] {.cdecl, dynlib: lib, importc: "gtk_layout_new".}
proc new_layout*(hadjustment: Adjustment, vadjustment: Adjustment): Layout {.inline.} =
  wrap(gtk_layout_new(hadjustment.getPointer, vadjustment.getPointer))
# proc new_layout*(hadjustment: Adjustment, vadjustment: Adjustment): Layout {.inline.} =

# gtk_layout_get_bin_window
# flags: {isMethod} container: Layout
# need sugar: is method
# 'Gdk3.Window' 'TransferNone[Gdk3.TWindow]' (diff., need sugar)
proc gtk_layout_get_bin_window(self: ptr TLayout): TransferNone[Gdk3.TWindow] {.cdecl, dynlib: lib, importc: "gtk_layout_get_bin_window".}
proc get_bin_window*(self: Layout): Gdk3.Window {.inline.} =
  wrap(gtk_layout_get_bin_window(self))
# proc get_bin_window*(self: Layout): Gdk3.Window {.inline.} =

# gtk_layout_get_hadjustment
# flags: {isMethod} container: Layout (deprecated)
# gtk_layout_get_size
# flags: {isMethod} container: Layout
# need sugar: is method
# width 'var uint32' 'ptr uint32' OUT (diff., need sugar) optional
# height 'var uint32' 'ptr uint32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_layout_get_size(self: ptr TLayout, width: ptr uint32, height: ptr uint32) {.cdecl, dynlib: lib, importc: "gtk_layout_get_size".}
proc get_size*(self: Layout, width: var uint32, height: var uint32) {.inline.} =
  gtk_layout_get_size(self, addr(width), addr(height))
# tuple-return
# width: var uint32
# height: var uint32
# proc get_size*(self: Layout) {.inline.} =

# gtk_layout_get_vadjustment
# flags: {isMethod} container: Layout (deprecated)
# gtk_layout_move
# flags: {isMethod} container: Layout
# need sugar: is method
# child_widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# x 'int32' 'int32' IN
# y 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_layout_move(self: ptr TLayout, child_widget: ptr TWidget, x: int32, y: int32) {.cdecl, dynlib: lib, importc: "gtk_layout_move".}
proc move*(self: Layout, child_widget: Widget, x: int32, y: int32) {.inline.} =
  gtk_layout_move(self, child_widget.getPointer, x, y)
# proc move*(self: Layout, child_widget: Widget, x: int32, y: int32) {.inline.} =

# gtk_layout_put
# flags: {isMethod} container: Layout
# need sugar: is method
# child_widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# x 'int32' 'int32' IN
# y 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_layout_put(self: ptr TLayout, child_widget: ptr TWidget, x: int32, y: int32) {.cdecl, dynlib: lib, importc: "gtk_layout_put".}
proc put*(self: Layout, child_widget: Widget, x: int32, y: int32) {.inline.} =
  gtk_layout_put(self, child_widget.getPointer, x, y)
# proc put*(self: Layout, child_widget: Widget, x: int32, y: int32) {.inline.} =

# gtk_layout_set_hadjustment
# flags: {isMethod} container: Layout (deprecated)
# gtk_layout_set_size
# flags: {isMethod} container: Layout
# need sugar: is method
# width 'uint32' 'uint32' IN
# height 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_layout_set_size(self: ptr TLayout, width: uint32, height: uint32) {.cdecl, dynlib: lib, importc: "gtk_layout_set_size".}
proc set_size*(self: Layout, width: uint32, height: uint32) {.inline.} =
  gtk_layout_set_size(self, width, height)
# proc set_size*(self: Layout, width: uint32, height: uint32) {.inline.} =

# gtk_layout_set_vadjustment
# flags: {isMethod} container: Layout (deprecated)
# gtk_level_bar_new
# flags: {isConstructor} container: LevelBar
# need sugar: is static method
# 'LevelBar' 'TransferNone[TLevelBar]' (diff., need sugar)
proc gtk_level_bar_new(): TransferNone[TLevelBar] {.cdecl, dynlib: lib, importc: "gtk_level_bar_new".}
proc new_levelbar*(): LevelBar {.inline.} =
  wrap(gtk_level_bar_new())
# proc new_levelbar*(): LevelBar {.inline.} =

# gtk_level_bar_new_for_interval
# flags: {isConstructor} container: LevelBar
# need sugar: is static method
# min_value 'float64' 'float64' IN
# max_value 'float64' 'float64' IN
# 'LevelBar' 'TransferNone[TLevelBar]' (diff., need sugar)
proc gtk_level_bar_new_for_interval(min_value: float64, max_value: float64): TransferNone[TLevelBar] {.cdecl, dynlib: lib, importc: "gtk_level_bar_new_for_interval".}
proc new_levelbar_for_interval*(min_value: float64, max_value: float64): LevelBar {.inline.} =
  wrap(gtk_level_bar_new_for_interval(min_value, max_value))
# proc new_levelbar_for_interval*(min_value: float64, max_value: float64): LevelBar {.inline.} =

# gtk_level_bar_add_offset_value
# flags: {isMethod} container: LevelBar
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# value 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_level_bar_add_offset_value(self: ptr TLevelBar, name: ucstring, value: float64) {.cdecl, dynlib: lib, importc: "gtk_level_bar_add_offset_value".}
proc add_offset_value*(self: LevelBar, name: ustring, value: float64) {.inline.} =
  gtk_level_bar_add_offset_value(self, ucstring(name), value)
# proc add_offset_value*(self: LevelBar, name: ustring, value: float64) {.inline.} =

# gtk_level_bar_get_inverted
# flags: {isMethod} container: LevelBar
# need sugar: is method
# 'bool' 'bool'
proc gtk_level_bar_get_inverted(self: ptr TLevelBar): bool {.cdecl, dynlib: lib, importc: "gtk_level_bar_get_inverted".}
proc get_inverted*(self: LevelBar): bool {.inline.} =
  gtk_level_bar_get_inverted(self)
# proc get_inverted*(self: LevelBar): bool {.inline.} =

# gtk_level_bar_get_max_value
# flags: {isMethod} container: LevelBar
# need sugar: is method
# 'float64' 'float64'
proc gtk_level_bar_get_max_value(self: ptr TLevelBar): float64 {.cdecl, dynlib: lib, importc: "gtk_level_bar_get_max_value".}
proc get_max_value*(self: LevelBar): float64 {.inline.} =
  gtk_level_bar_get_max_value(self)
# proc get_max_value*(self: LevelBar): float64 {.inline.} =

# gtk_level_bar_get_min_value
# flags: {isMethod} container: LevelBar
# need sugar: is method
# 'float64' 'float64'
proc gtk_level_bar_get_min_value(self: ptr TLevelBar): float64 {.cdecl, dynlib: lib, importc: "gtk_level_bar_get_min_value".}
proc get_min_value*(self: LevelBar): float64 {.inline.} =
  gtk_level_bar_get_min_value(self)
# proc get_min_value*(self: LevelBar): float64 {.inline.} =

# gtk_level_bar_get_mode
# flags: {isMethod} container: LevelBar
# need sugar: is method
# 'LevelBarMode' 'LevelBarMode'
proc gtk_level_bar_get_mode(self: ptr TLevelBar): LevelBarMode {.cdecl, dynlib: lib, importc: "gtk_level_bar_get_mode".}
proc get_mode*(self: LevelBar): LevelBarMode {.inline.} =
  gtk_level_bar_get_mode(self)
# proc get_mode*(self: LevelBar): LevelBarMode {.inline.} =

# gtk_level_bar_get_offset_value
# flags: {isMethod} container: LevelBar
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# value 'var float64' 'ptr float64' OUT (diff., need sugar)
# 'bool' 'bool'
proc gtk_level_bar_get_offset_value(self: ptr TLevelBar, name: ucstring, value: ptr float64): bool {.cdecl, dynlib: lib, importc: "gtk_level_bar_get_offset_value".}
proc get_offset_value*(self: LevelBar, name: ustring, value: var float64): bool {.inline.} =
  gtk_level_bar_get_offset_value(self, ucstring(name), addr(value))
# tuple-return
# value: var float64
# proc get_offset_value*(self: LevelBar, name: ustring): bool {.inline.} =

# gtk_level_bar_get_value
# flags: {isMethod} container: LevelBar
# need sugar: is method
# 'float64' 'float64'
proc gtk_level_bar_get_value(self: ptr TLevelBar): float64 {.cdecl, dynlib: lib, importc: "gtk_level_bar_get_value".}
proc get_value*(self: LevelBar): float64 {.inline.} =
  gtk_level_bar_get_value(self)
# proc get_value*(self: LevelBar): float64 {.inline.} =

# gtk_level_bar_remove_offset_value
# flags: {isMethod} container: LevelBar
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_level_bar_remove_offset_value(self: ptr TLevelBar, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_level_bar_remove_offset_value".}
proc remove_offset_value*(self: LevelBar, name: ustring) {.inline.} =
  gtk_level_bar_remove_offset_value(self, ucstring(name))
# proc remove_offset_value*(self: LevelBar, name: ustring) {.inline.} =

# gtk_level_bar_set_inverted
# flags: {isMethod} container: LevelBar
# need sugar: is method
# inverted 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_level_bar_set_inverted(self: ptr TLevelBar, inverted: bool) {.cdecl, dynlib: lib, importc: "gtk_level_bar_set_inverted".}
proc set_inverted*(self: LevelBar, inverted: bool) {.inline.} =
  gtk_level_bar_set_inverted(self, inverted)
# proc set_inverted*(self: LevelBar, inverted: bool) {.inline.} =

# gtk_level_bar_set_max_value
# flags: {isMethod} container: LevelBar
# need sugar: is method
# value 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_level_bar_set_max_value(self: ptr TLevelBar, value: float64) {.cdecl, dynlib: lib, importc: "gtk_level_bar_set_max_value".}
proc set_max_value*(self: LevelBar, value: float64) {.inline.} =
  gtk_level_bar_set_max_value(self, value)
# proc set_max_value*(self: LevelBar, value: float64) {.inline.} =

# gtk_level_bar_set_min_value
# flags: {isMethod} container: LevelBar
# need sugar: is method
# value 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_level_bar_set_min_value(self: ptr TLevelBar, value: float64) {.cdecl, dynlib: lib, importc: "gtk_level_bar_set_min_value".}
proc set_min_value*(self: LevelBar, value: float64) {.inline.} =
  gtk_level_bar_set_min_value(self, value)
# proc set_min_value*(self: LevelBar, value: float64) {.inline.} =

# gtk_level_bar_set_mode
# flags: {isMethod} container: LevelBar
# need sugar: is method
# mode 'LevelBarMode' 'LevelBarMode' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_level_bar_set_mode(self: ptr TLevelBar, mode: LevelBarMode) {.cdecl, dynlib: lib, importc: "gtk_level_bar_set_mode".}
proc set_mode*(self: LevelBar, mode: LevelBarMode) {.inline.} =
  gtk_level_bar_set_mode(self, mode)
# proc set_mode*(self: LevelBar, mode: LevelBarMode) {.inline.} =

# gtk_level_bar_set_value
# flags: {isMethod} container: LevelBar
# need sugar: is method
# value 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_level_bar_set_value(self: ptr TLevelBar, value: float64) {.cdecl, dynlib: lib, importc: "gtk_level_bar_set_value".}
proc set_value*(self: LevelBar, value: float64) {.inline.} =
  gtk_level_bar_set_value(self, value)
# proc set_value*(self: LevelBar, value: float64) {.inline.} =

# gtk_link_button_new
# flags: {isConstructor} container: LinkButton
# need sugar: is static method
# uri 'ustring' 'ucstring' IN (diff., need sugar)
# 'LinkButton' 'TransferNone[TLinkButton]' (diff., need sugar)
proc gtk_link_button_new(uri: ucstring): TransferNone[TLinkButton] {.cdecl, dynlib: lib, importc: "gtk_link_button_new".}
proc new_linkbutton*(uri: ustring): LinkButton {.inline.} =
  wrap(gtk_link_button_new(ucstring(uri)))
# proc new_linkbutton*(uri: ustring): LinkButton {.inline.} =

# gtk_link_button_new_with_label
# flags: {isConstructor} container: LinkButton
# need sugar: is static method
# uri 'ustring' 'ucstring' IN (diff., need sugar)
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'LinkButton' 'TransferNone[TLinkButton]' (diff., need sugar)
proc gtk_link_button_new_with_label(uri: ucstring, label: ucstring): TransferNone[TLinkButton] {.cdecl, dynlib: lib, importc: "gtk_link_button_new_with_label".}
proc new_linkbutton_with_label*(uri: ustring, label: ustring): LinkButton {.inline.} =
  wrap(gtk_link_button_new_with_label(ucstring(uri), ucstring(label)))
# proc new_linkbutton_with_label*(uri: ustring, label: ustring): LinkButton {.inline.} =

# gtk_link_button_get_uri
# flags: {isMethod} container: LinkButton
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_link_button_get_uri(self: ptr TLinkButton): ucstring {.cdecl, dynlib: lib, importc: "gtk_link_button_get_uri".}
proc get_uri*(self: LinkButton): ustring {.inline.} =
  ustring($(gtk_link_button_get_uri(self)))
# proc get_uri*(self: LinkButton): ustring {.inline.} =

# gtk_link_button_get_visited
# flags: {isMethod} container: LinkButton
# need sugar: is method
# 'bool' 'bool'
proc gtk_link_button_get_visited(self: ptr TLinkButton): bool {.cdecl, dynlib: lib, importc: "gtk_link_button_get_visited".}
proc get_visited*(self: LinkButton): bool {.inline.} =
  gtk_link_button_get_visited(self)
# proc get_visited*(self: LinkButton): bool {.inline.} =

# gtk_link_button_set_uri
# flags: {isMethod} container: LinkButton
# need sugar: is method
# uri 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_link_button_set_uri(self: ptr TLinkButton, uri: ucstring) {.cdecl, dynlib: lib, importc: "gtk_link_button_set_uri".}
proc set_uri*(self: LinkButton, uri: ustring) {.inline.} =
  gtk_link_button_set_uri(self, ucstring(uri))
# proc set_uri*(self: LinkButton, uri: ustring) {.inline.} =

# gtk_link_button_set_visited
# flags: {isMethod} container: LinkButton
# need sugar: is method
# visited 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_link_button_set_visited(self: ptr TLinkButton, visited: bool) {.cdecl, dynlib: lib, importc: "gtk_link_button_set_visited".}
proc set_visited*(self: LinkButton, visited: bool) {.inline.} =
  gtk_link_button_set_visited(self, visited)
# proc set_visited*(self: LinkButton, visited: bool) {.inline.} =

# gtk_list_box_new
# flags: {isConstructor} container: ListBox
# need sugar: is static method
# 'ListBox' 'TransferNone[TListBox]' (diff., need sugar)
proc gtk_list_box_new(): TransferNone[TListBox] {.cdecl, dynlib: lib, importc: "gtk_list_box_new".}
proc new_listbox*(): ListBox {.inline.} =
  wrap(gtk_list_box_new())
# proc new_listbox*(): ListBox {.inline.} =

# gtk_list_box_drag_highlight_row
# flags: {isMethod} container: ListBox
# need sugar: is method
# row 'ListBoxRow' 'ptr TListBoxRow' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_drag_highlight_row(self: ptr TListBox, row: ptr TListBoxRow) {.cdecl, dynlib: lib, importc: "gtk_list_box_drag_highlight_row".}
proc drag_highlight_row*(self: ListBox, row: ListBoxRow) {.inline.} =
  gtk_list_box_drag_highlight_row(self, row.getPointer)
# proc drag_highlight_row*(self: ListBox, row: ListBoxRow) {.inline.} =

# gtk_list_box_drag_unhighlight_row
# flags: {isMethod} container: ListBox
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_drag_unhighlight_row(self: ptr TListBox) {.cdecl, dynlib: lib, importc: "gtk_list_box_drag_unhighlight_row".}
proc drag_unhighlight_row*(self: ListBox) {.inline.} =
  gtk_list_box_drag_unhighlight_row(self)
# proc drag_unhighlight_row*(self: ListBox) {.inline.} =

# gtk_list_box_get_activate_on_single_click
# flags: {isMethod} container: ListBox
# need sugar: is method
# 'bool' 'bool'
proc gtk_list_box_get_activate_on_single_click(self: ptr TListBox): bool {.cdecl, dynlib: lib, importc: "gtk_list_box_get_activate_on_single_click".}
proc get_activate_on_single_click*(self: ListBox): bool {.inline.} =
  gtk_list_box_get_activate_on_single_click(self)
# proc get_activate_on_single_click*(self: ListBox): bool {.inline.} =

# gtk_list_box_get_adjustment
# flags: {isMethod} container: ListBox
# need sugar: is method
# 'Adjustment' 'TransferNone[TAdjustment]' (diff., need sugar)
proc gtk_list_box_get_adjustment(self: ptr TListBox): TransferNone[TAdjustment] {.cdecl, dynlib: lib, importc: "gtk_list_box_get_adjustment".}
proc get_adjustment*(self: ListBox): Adjustment {.inline.} =
  wrap(gtk_list_box_get_adjustment(self))
# proc get_adjustment*(self: ListBox): Adjustment {.inline.} =

# gtk_list_box_get_row_at_index
# flags: {isMethod} container: ListBox
# need sugar: is method
# index_ 'int32' 'int32' IN
# 'ListBoxRow' 'TransferNone[TListBoxRow]' (diff., need sugar)
proc gtk_list_box_get_row_at_index(self: ptr TListBox, index_x: int32): TransferNone[TListBoxRow] {.cdecl, dynlib: lib, importc: "gtk_list_box_get_row_at_index".}
proc get_row_at_index*(self: ListBox, index_x: int32): ListBoxRow {.inline.} =
  wrap(gtk_list_box_get_row_at_index(self, index_x))
# proc get_row_at_index*(self: ListBox, index_x: int32): ListBoxRow {.inline.} =

# gtk_list_box_get_row_at_y
# flags: {isMethod} container: ListBox
# need sugar: is method
# y 'int32' 'int32' IN
# 'ListBoxRow' 'TransferNone[TListBoxRow]' (diff., need sugar)
proc gtk_list_box_get_row_at_y(self: ptr TListBox, y: int32): TransferNone[TListBoxRow] {.cdecl, dynlib: lib, importc: "gtk_list_box_get_row_at_y".}
proc get_row_at_y*(self: ListBox, y: int32): ListBoxRow {.inline.} =
  wrap(gtk_list_box_get_row_at_y(self, y))
# proc get_row_at_y*(self: ListBox, y: int32): ListBoxRow {.inline.} =

# gtk_list_box_get_selected_row
# flags: {isMethod} container: ListBox
# need sugar: is method
# 'ListBoxRow' 'TransferNone[TListBoxRow]' (diff., need sugar)
proc gtk_list_box_get_selected_row(self: ptr TListBox): TransferNone[TListBoxRow] {.cdecl, dynlib: lib, importc: "gtk_list_box_get_selected_row".}
proc get_selected_row*(self: ListBox): ListBoxRow {.inline.} =
  wrap(gtk_list_box_get_selected_row(self))
# proc get_selected_row*(self: ListBox): ListBoxRow {.inline.} =

# gtk_list_box_get_selected_rows
# flags: {isMethod} container: ListBox
# need sugar: is method
# 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_list_box_get_selected_rows(self: ptr TListBox): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_list_box_get_selected_rows".}
proc get_selected_rows*(self: ListBox): ptr GLIST_TODO {.inline.} =
  gtk_list_box_get_selected_rows(self)
# proc get_selected_rows*(self: ListBox): ptr GLIST_TODO {.inline.} =

# gtk_list_box_get_selection_mode
# flags: {isMethod} container: ListBox
# need sugar: is method
# 'SelectionMode' 'SelectionMode'
proc gtk_list_box_get_selection_mode(self: ptr TListBox): SelectionMode {.cdecl, dynlib: lib, importc: "gtk_list_box_get_selection_mode".}
proc get_selection_mode*(self: ListBox): SelectionMode {.inline.} =
  gtk_list_box_get_selection_mode(self)
# proc get_selection_mode*(self: ListBox): SelectionMode {.inline.} =

# gtk_list_box_insert
# flags: {isMethod} container: ListBox
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# position 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_insert(self: ptr TListBox, child: ptr TWidget, position: int32) {.cdecl, dynlib: lib, importc: "gtk_list_box_insert".}
proc insert*(self: ListBox, child: Widget, position: int32) {.inline.} =
  gtk_list_box_insert(self, child.getPointer, position)
# proc insert*(self: ListBox, child: Widget, position: int32) {.inline.} =

# gtk_list_box_invalidate_filter
# flags: {isMethod} container: ListBox
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_invalidate_filter(self: ptr TListBox) {.cdecl, dynlib: lib, importc: "gtk_list_box_invalidate_filter".}
proc invalidate_filter*(self: ListBox) {.inline.} =
  gtk_list_box_invalidate_filter(self)
# proc invalidate_filter*(self: ListBox) {.inline.} =

# gtk_list_box_invalidate_headers
# flags: {isMethod} container: ListBox
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_invalidate_headers(self: ptr TListBox) {.cdecl, dynlib: lib, importc: "gtk_list_box_invalidate_headers".}
proc invalidate_headers*(self: ListBox) {.inline.} =
  gtk_list_box_invalidate_headers(self)
# proc invalidate_headers*(self: ListBox) {.inline.} =

# gtk_list_box_invalidate_sort
# flags: {isMethod} container: ListBox
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_invalidate_sort(self: ptr TListBox) {.cdecl, dynlib: lib, importc: "gtk_list_box_invalidate_sort".}
proc invalidate_sort*(self: ListBox) {.inline.} =
  gtk_list_box_invalidate_sort(self)
# proc invalidate_sort*(self: ListBox) {.inline.} =

# gtk_list_box_prepend
# flags: {isMethod} container: ListBox
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_prepend(self: ptr TListBox, child: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_list_box_prepend".}
proc prepend*(self: ListBox, child: Widget) {.inline.} =
  gtk_list_box_prepend(self, child.getPointer)
# proc prepend*(self: ListBox, child: Widget) {.inline.} =

# gtk_list_box_select_all
# flags: {isMethod} container: ListBox
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_select_all(self: ptr TListBox) {.cdecl, dynlib: lib, importc: "gtk_list_box_select_all".}
proc select_all*(self: ListBox) {.inline.} =
  gtk_list_box_select_all(self)
# proc select_all*(self: ListBox) {.inline.} =

# gtk_list_box_select_row
# flags: {isMethod} container: ListBox
# need sugar: is method
# row 'ListBoxRow' 'ptr TListBoxRow' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_select_row(self: ptr TListBox, row: ptr TListBoxRow) {.cdecl, dynlib: lib, importc: "gtk_list_box_select_row".}
proc select_row*(self: ListBox, row: ListBoxRow) {.inline.} =
  gtk_list_box_select_row(self, row.getPointer)
# proc select_row*(self: ListBox, row: ListBoxRow) {.inline.} =

# gtk_list_box_selected_foreach
# flags: {isMethod} container: ListBox
# need sugar: is method
# func 'pointer' 'pointer' IN
# data 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_selected_foreach(self: ptr TListBox, func_x: pointer, data: pointer) {.cdecl, dynlib: lib, importc: "gtk_list_box_selected_foreach".}
proc selected_foreach*(self: ListBox, func_x: pointer, data: pointer) {.inline.} =
  gtk_list_box_selected_foreach(self, func_x, data)
# proc selected_foreach*(self: ListBox, func_x: pointer, data: pointer) {.inline.} =

# gtk_list_box_set_activate_on_single_click
# flags: {isMethod} container: ListBox
# need sugar: is method
# single 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_set_activate_on_single_click(self: ptr TListBox, single: bool) {.cdecl, dynlib: lib, importc: "gtk_list_box_set_activate_on_single_click".}
proc set_activate_on_single_click*(self: ListBox, single: bool) {.inline.} =
  gtk_list_box_set_activate_on_single_click(self, single)
# proc set_activate_on_single_click*(self: ListBox, single: bool) {.inline.} =

# gtk_list_box_set_adjustment
# flags: {isMethod} container: ListBox
# need sugar: is method
# adjustment 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_set_adjustment(self: ptr TListBox, adjustment: ptr TAdjustment) {.cdecl, dynlib: lib, importc: "gtk_list_box_set_adjustment".}
proc set_adjustment*(self: ListBox, adjustment: Adjustment) {.inline.} =
  gtk_list_box_set_adjustment(self, adjustment.getPointer)
# proc set_adjustment*(self: ListBox, adjustment: Adjustment) {.inline.} =

# gtk_list_box_set_filter_func
# flags: {isMethod} container: ListBox
# need sugar: is method
# filter_func 'pointer' 'pointer' IN
# user_data 'pointer' 'pointer' IN
# destroy 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_set_filter_func(self: ptr TListBox, filter_func: pointer, user_data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_list_box_set_filter_func".}
proc set_filter_func*(self: ListBox, filter_func: pointer, user_data: pointer, destroy: pointer) {.inline.} =
  gtk_list_box_set_filter_func(self, filter_func, user_data, destroy)
# proc set_filter_func*(self: ListBox, filter_func: pointer, user_data: pointer, destroy: pointer) {.inline.} =

# gtk_list_box_set_header_func
# flags: {isMethod} container: ListBox
# need sugar: is method
# update_header 'pointer' 'pointer' IN
# user_data 'pointer' 'pointer' IN
# destroy 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_set_header_func(self: ptr TListBox, update_header: pointer, user_data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_list_box_set_header_func".}
proc set_header_func*(self: ListBox, update_header: pointer, user_data: pointer, destroy: pointer) {.inline.} =
  gtk_list_box_set_header_func(self, update_header, user_data, destroy)
# proc set_header_func*(self: ListBox, update_header: pointer, user_data: pointer, destroy: pointer) {.inline.} =

# gtk_list_box_set_placeholder
# flags: {isMethod} container: ListBox
# need sugar: is method
# placeholder 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_set_placeholder(self: ptr TListBox, placeholder: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_list_box_set_placeholder".}
proc set_placeholder*(self: ListBox, placeholder: Widget) {.inline.} =
  gtk_list_box_set_placeholder(self, placeholder.getPointer)
# proc set_placeholder*(self: ListBox, placeholder: Widget) {.inline.} =

# gtk_list_box_set_selection_mode
# flags: {isMethod} container: ListBox
# need sugar: is method
# mode 'SelectionMode' 'SelectionMode' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_set_selection_mode(self: ptr TListBox, mode: SelectionMode) {.cdecl, dynlib: lib, importc: "gtk_list_box_set_selection_mode".}
proc set_selection_mode*(self: ListBox, mode: SelectionMode) {.inline.} =
  gtk_list_box_set_selection_mode(self, mode)
# proc set_selection_mode*(self: ListBox, mode: SelectionMode) {.inline.} =

# gtk_list_box_set_sort_func
# flags: {isMethod} container: ListBox
# need sugar: is method
# sort_func 'pointer' 'pointer' IN
# user_data 'pointer' 'pointer' IN
# destroy 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_set_sort_func(self: ptr TListBox, sort_func: pointer, user_data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_list_box_set_sort_func".}
proc set_sort_func*(self: ListBox, sort_func: pointer, user_data: pointer, destroy: pointer) {.inline.} =
  gtk_list_box_set_sort_func(self, sort_func, user_data, destroy)
# proc set_sort_func*(self: ListBox, sort_func: pointer, user_data: pointer, destroy: pointer) {.inline.} =

# gtk_list_box_unselect_all
# flags: {isMethod} container: ListBox
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_unselect_all(self: ptr TListBox) {.cdecl, dynlib: lib, importc: "gtk_list_box_unselect_all".}
proc unselect_all*(self: ListBox) {.inline.} =
  gtk_list_box_unselect_all(self)
# proc unselect_all*(self: ListBox) {.inline.} =

# gtk_list_box_unselect_row
# flags: {isMethod} container: ListBox
# need sugar: is method
# row 'ListBoxRow' 'ptr TListBoxRow' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_unselect_row(self: ptr TListBox, row: ptr TListBoxRow) {.cdecl, dynlib: lib, importc: "gtk_list_box_unselect_row".}
proc unselect_row*(self: ListBox, row: ListBoxRow) {.inline.} =
  gtk_list_box_unselect_row(self, row.getPointer)
# proc unselect_row*(self: ListBox, row: ListBoxRow) {.inline.} =

# gtk_list_box_row_new
# flags: {isConstructor} container: ListBoxRow
# need sugar: is static method
# 'ListBoxRow' 'TransferNone[TListBoxRow]' (diff., need sugar)
proc gtk_list_box_row_new(): TransferNone[TListBoxRow] {.cdecl, dynlib: lib, importc: "gtk_list_box_row_new".}
proc new_listboxrow*(): ListBoxRow {.inline.} =
  wrap(gtk_list_box_row_new())
# proc new_listboxrow*(): ListBoxRow {.inline.} =

# gtk_list_box_row_changed
# flags: {isMethod} container: ListBoxRow
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_row_changed(self: ptr TListBoxRow) {.cdecl, dynlib: lib, importc: "gtk_list_box_row_changed".}
proc changed*(self: ListBoxRow) {.inline.} =
  gtk_list_box_row_changed(self)
# proc changed*(self: ListBoxRow) {.inline.} =

# gtk_list_box_row_get_activatable
# flags: {isMethod} container: ListBoxRow
# need sugar: is method
# 'bool' 'bool'
proc gtk_list_box_row_get_activatable(self: ptr TListBoxRow): bool {.cdecl, dynlib: lib, importc: "gtk_list_box_row_get_activatable".}
proc get_activatable*(self: ListBoxRow): bool {.inline.} =
  gtk_list_box_row_get_activatable(self)
# proc get_activatable*(self: ListBoxRow): bool {.inline.} =

# gtk_list_box_row_get_header
# flags: {isMethod} container: ListBoxRow
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_list_box_row_get_header(self: ptr TListBoxRow): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_list_box_row_get_header".}
proc get_header*(self: ListBoxRow): Widget {.inline.} =
  wrap(gtk_list_box_row_get_header(self))
# proc get_header*(self: ListBoxRow): Widget {.inline.} =

# gtk_list_box_row_get_index
# flags: {isMethod} container: ListBoxRow
# need sugar: is method
# 'int32' 'int32'
proc gtk_list_box_row_get_index(self: ptr TListBoxRow): int32 {.cdecl, dynlib: lib, importc: "gtk_list_box_row_get_index".}
proc get_index*(self: ListBoxRow): int32 {.inline.} =
  gtk_list_box_row_get_index(self)
# proc get_index*(self: ListBoxRow): int32 {.inline.} =

# gtk_list_box_row_get_selectable
# flags: {isMethod} container: ListBoxRow
# need sugar: is method
# 'bool' 'bool'
proc gtk_list_box_row_get_selectable(self: ptr TListBoxRow): bool {.cdecl, dynlib: lib, importc: "gtk_list_box_row_get_selectable".}
proc get_selectable*(self: ListBoxRow): bool {.inline.} =
  gtk_list_box_row_get_selectable(self)
# proc get_selectable*(self: ListBoxRow): bool {.inline.} =

# gtk_list_box_row_is_selected
# flags: {isMethod} container: ListBoxRow
# need sugar: is method
# 'bool' 'bool'
proc gtk_list_box_row_is_selected(self: ptr TListBoxRow): bool {.cdecl, dynlib: lib, importc: "gtk_list_box_row_is_selected".}
proc is_selected*(self: ListBoxRow): bool {.inline.} =
  gtk_list_box_row_is_selected(self)
# proc is_selected*(self: ListBoxRow): bool {.inline.} =

# gtk_list_box_row_set_activatable
# flags: {isMethod} container: ListBoxRow
# need sugar: is method
# activatable 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_row_set_activatable(self: ptr TListBoxRow, activatable: bool) {.cdecl, dynlib: lib, importc: "gtk_list_box_row_set_activatable".}
proc set_activatable*(self: ListBoxRow, activatable: bool) {.inline.} =
  gtk_list_box_row_set_activatable(self, activatable)
# proc set_activatable*(self: ListBoxRow, activatable: bool) {.inline.} =

# gtk_list_box_row_set_header
# flags: {isMethod} container: ListBoxRow
# need sugar: is method
# header 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_row_set_header(self: ptr TListBoxRow, header: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_list_box_row_set_header".}
proc set_header*(self: ListBoxRow, header: Widget) {.inline.} =
  gtk_list_box_row_set_header(self, header.getPointer)
# proc set_header*(self: ListBoxRow, header: Widget) {.inline.} =

# gtk_list_box_row_set_selectable
# flags: {isMethod} container: ListBoxRow
# need sugar: is method
# selectable 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_row_set_selectable(self: ptr TListBoxRow, selectable: bool) {.cdecl, dynlib: lib, importc: "gtk_list_box_row_set_selectable".}
proc set_selectable*(self: ListBoxRow, selectable: bool) {.inline.} =
  gtk_list_box_row_set_selectable(self, selectable)
# proc set_selectable*(self: ListBoxRow, selectable: bool) {.inline.} =

# gtk_list_store_newv
# flags: {isConstructor} container: ListStore
# need sugar: is static method
# n_columns 'int32' 'int32' IN
# types 'var openarray[GType]' 'openarray[GType]' IN (diff., need sugar) array lengthArg: 0
# 'ListStore' 'TransferFull[TListStore]' (diff., need sugar)
proc gtk_list_store_newv(n_columns: int32, types: openarray[GType]): TransferFull[TListStore] {.cdecl, dynlib: lib, importc: "gtk_list_store_newv".}
proc new_liststore*(types: var openarray[GType]): ListStore {.inline.} =
  wrap(gtk_list_store_newv(types.len.int32, types))
# proc new_liststore*(types: var openarray[GType]): ListStore {.inline.} =

# gtk_list_store_append
# flags: {isMethod} container: ListStore
# need sugar: is method
# iter 'var TTreeIter' 'ptr TTreeIter' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_append(self: ptr TListStore, iter: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_list_store_append".}
proc append*(self: ListStore, iter: var TTreeIter) {.inline.} =
  gtk_list_store_append(self, addr(iter))
# tuple-return
# iter: var TTreeIter
# proc append*(self: ListStore) {.inline.} =

# gtk_list_store_clear
# flags: {isMethod} container: ListStore
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_clear(self: ptr TListStore) {.cdecl, dynlib: lib, importc: "gtk_list_store_clear".}
proc clear*(self: ListStore) {.inline.} =
  gtk_list_store_clear(self)
# proc clear*(self: ListStore) {.inline.} =

# gtk_list_store_insert
# flags: {isMethod} container: ListStore
# need sugar: is method
# iter 'var TTreeIter' 'ptr TTreeIter' OUT (diff., need sugar) caller-allocates
# position 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_insert(self: ptr TListStore, iter: ptr TTreeIter, position: int32) {.cdecl, dynlib: lib, importc: "gtk_list_store_insert".}
proc insert*(self: ListStore, iter: var TTreeIter, position: int32) {.inline.} =
  gtk_list_store_insert(self, addr(iter), position)
# tuple-return
# iter: var TTreeIter
# proc insert*(self: ListStore, position: int32) {.inline.} =

# gtk_list_store_insert_after
# flags: {isMethod} container: ListStore
# need sugar: is method
# iter 'var TTreeIter' 'ptr TTreeIter' OUT (diff., need sugar) caller-allocates
# sibling 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_insert_after(self: ptr TListStore, iter: ptr TTreeIter, sibling: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_list_store_insert_after".}
proc insert_after*(self: ListStore, iter: var TTreeIter, sibling: TTreeIter) {.inline.} =
  gtk_list_store_insert_after(self, addr(iter), myUnsafeAddr(sibling))
# tuple-return
# iter: var TTreeIter
# proc insert_after*(self: ListStore, sibling: TTreeIter) {.inline.} =

# gtk_list_store_insert_before
# flags: {isMethod} container: ListStore
# need sugar: is method
# iter 'var TTreeIter' 'ptr TTreeIter' OUT (diff., need sugar) caller-allocates
# sibling 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_insert_before(self: ptr TListStore, iter: ptr TTreeIter, sibling: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_list_store_insert_before".}
proc insert_before*(self: ListStore, iter: var TTreeIter, sibling: TTreeIter) {.inline.} =
  gtk_list_store_insert_before(self, addr(iter), myUnsafeAddr(sibling))
# tuple-return
# iter: var TTreeIter
# proc insert_before*(self: ListStore, sibling: TTreeIter) {.inline.} =

# gtk_list_store_insert_with_valuesv
# flags: {isMethod} container: ListStore
# need sugar: is method
# iter 'var TTreeIter' 'ptr TTreeIter' OUT (diff., need sugar) caller-allocates optional
# position 'int32' 'int32' IN
# columns 'var openarray[int32]' 'openarray[int32]' IN (diff., need sugar) array lengthArg: 4
# values 'var openarray[GObject2.TValue]' 'openarray[GObject2.TValue]' IN (diff., need sugar) array lengthArg: 4
# n_values 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_insert_with_valuesv(self: ptr TListStore, iter: ptr TTreeIter, position: int32, columns: openarray[int32], values: openarray[GObject2.TValue], n_values: int32) {.cdecl, dynlib: lib, importc: "gtk_list_store_insert_with_valuesv".}
proc insert_with_valuesv*(self: ListStore, iter: var TTreeIter, position: int32, columns: var openarray[int32], values: var openarray[GObject2.TValue]) {.inline.} =
  gtk_list_store_insert_with_valuesv(self, addr(iter), position, columns, values, values.len.int32)
# tuple-return
# iter: var TTreeIter
# proc insert_with_valuesv*(self: ListStore, position: int32, columns: var openarray[int32], values: var openarray[GObject2.TValue]) {.inline.} =

# gtk_list_store_iter_is_valid
# flags: {isMethod} container: ListStore
# need sugar: is method
# iter 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_list_store_iter_is_valid(self: ptr TListStore, iter: ptr TTreeIter): bool {.cdecl, dynlib: lib, importc: "gtk_list_store_iter_is_valid".}
proc iter_is_valid*(self: ListStore, iter: TTreeIter): bool {.inline.} =
  gtk_list_store_iter_is_valid(self, myUnsafeAddr(iter))
# proc iter_is_valid*(self: ListStore, iter: TTreeIter): bool {.inline.} =

# gtk_list_store_move_after
# flags: {isMethod} container: ListStore
# need sugar: is method
# iter 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# position 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_move_after(self: ptr TListStore, iter: ptr TTreeIter, position: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_list_store_move_after".}
proc move_after*(self: ListStore, iter: TTreeIter, position: TTreeIter) {.inline.} =
  gtk_list_store_move_after(self, myUnsafeAddr(iter), myUnsafeAddr(position))
# proc move_after*(self: ListStore, iter: TTreeIter, position: TTreeIter) {.inline.} =

# gtk_list_store_move_before
# flags: {isMethod} container: ListStore
# need sugar: is method
# iter 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# position 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_move_before(self: ptr TListStore, iter: ptr TTreeIter, position: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_list_store_move_before".}
proc move_before*(self: ListStore, iter: TTreeIter, position: TTreeIter) {.inline.} =
  gtk_list_store_move_before(self, myUnsafeAddr(iter), myUnsafeAddr(position))
# proc move_before*(self: ListStore, iter: TTreeIter, position: TTreeIter) {.inline.} =

# gtk_list_store_prepend
# flags: {isMethod} container: ListStore
# need sugar: is method
# iter 'var TTreeIter' 'ptr TTreeIter' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_prepend(self: ptr TListStore, iter: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_list_store_prepend".}
proc prepend*(self: ListStore, iter: var TTreeIter) {.inline.} =
  gtk_list_store_prepend(self, addr(iter))
# tuple-return
# iter: var TTreeIter
# proc prepend*(self: ListStore) {.inline.} =

# gtk_list_store_remove
# flags: {isMethod} container: ListStore
# need sugar: is method
# iter 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_list_store_remove(self: ptr TListStore, iter: ptr TTreeIter): bool {.cdecl, dynlib: lib, importc: "gtk_list_store_remove".}
proc remove*(self: ListStore, iter: TTreeIter): bool {.inline.} =
  gtk_list_store_remove(self, myUnsafeAddr(iter))
# proc remove*(self: ListStore, iter: TTreeIter): bool {.inline.} =

# gtk_list_store_reorder
# flags: {isMethod} container: ListStore
# need sugar: is method
# new_order 'uncheckedArray[int32]' 'uncheckedArray[int32]' IN array zero-terminated
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_reorder(self: ptr TListStore, new_order: uncheckedArray[int32]) {.cdecl, dynlib: lib, importc: "gtk_list_store_reorder".}
proc reorder*(self: ListStore, new_order: uncheckedArray[int32]) {.inline.} =
  gtk_list_store_reorder(self, new_order)
# proc reorder*(self: ListStore, new_order: uncheckedArray[int32]) {.inline.} =

# gtk_list_store_set_column_types
# flags: {isMethod} container: ListStore
# need sugar: is method
# n_columns 'int32' 'int32' IN
# types 'var openarray[GType]' 'openarray[GType]' IN (diff., need sugar) array lengthArg: 0
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_set_column_types(self: ptr TListStore, n_columns: int32, types: openarray[GType]) {.cdecl, dynlib: lib, importc: "gtk_list_store_set_column_types".}
proc set_column_types*(self: ListStore, types: var openarray[GType]) {.inline.} =
  gtk_list_store_set_column_types(self, types.len.int32, types)
# proc set_column_types*(self: ListStore, types: var openarray[GType]) {.inline.} =

# gtk_list_store_set_value
# flags: {isMethod} container: ListStore
# need sugar: is method
# iter 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# column 'int32' 'int32' IN
# value 'GObject2.TValue' 'ptr GObject2.TValue' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_set_value(self: ptr TListStore, iter: ptr TTreeIter, column: int32, value: ptr GObject2.TValue) {.cdecl, dynlib: lib, importc: "gtk_list_store_set_value".}
proc set_value*(self: ListStore, iter: TTreeIter, column: int32, value: GObject2.TValue) {.inline.} =
  gtk_list_store_set_value(self, myUnsafeAddr(iter), column, myUnsafeAddr(value))
# proc set_value*(self: ListStore, iter: TTreeIter, column: int32, value: GObject2.TValue) {.inline.} =

# gtk_list_store_set_valuesv
# flags: {isMethod} container: ListStore
# need sugar: is method
# iter 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# columns 'var openarray[int32]' 'openarray[int32]' IN (diff., need sugar) array lengthArg: 3
# values 'var openarray[GObject2.TValue]' 'openarray[GObject2.TValue]' IN (diff., need sugar) array lengthArg: 3
# n_values 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_set_valuesv(self: ptr TListStore, iter: ptr TTreeIter, columns: openarray[int32], values: openarray[GObject2.TValue], n_values: int32) {.cdecl, dynlib: lib, importc: "gtk_list_store_set_valuesv".}
proc set*(self: ListStore, iter: TTreeIter, columns: var openarray[int32], values: var openarray[GObject2.TValue]) {.inline.} =
  gtk_list_store_set_valuesv(self, myUnsafeAddr(iter), columns, values, values.len.int32)
# proc set*(self: ListStore, iter: TTreeIter, columns: var openarray[int32], values: var openarray[GObject2.TValue]) {.inline.} =

# gtk_list_store_swap
# flags: {isMethod} container: ListStore
# need sugar: is method
# a 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# b 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_swap(self: ptr TListStore, a: ptr TTreeIter, b: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_list_store_swap".}
proc swap*(self: ListStore, a: TTreeIter, b: TTreeIter) {.inline.} =
  gtk_list_store_swap(self, myUnsafeAddr(a), myUnsafeAddr(b))
# proc swap*(self: ListStore, a: TTreeIter, b: TTreeIter) {.inline.} =

# gtk_lock_button_new
# flags: {isConstructor} container: LockButton
# need sugar: is static method
# permission 'Gio2.Permission' 'ptr Gio2.TPermission' IN (diff., need sugar)
# 'LockButton' 'TransferNone[TLockButton]' (diff., need sugar)
proc gtk_lock_button_new(permission: ptr Gio2.TPermission): TransferNone[TLockButton] {.cdecl, dynlib: lib, importc: "gtk_lock_button_new".}
proc new_lockbutton*(permission: Gio2.Permission): LockButton {.inline.} =
  wrap(gtk_lock_button_new(permission.getPointer))
# proc new_lockbutton*(permission: Gio2.Permission): LockButton {.inline.} =

# gtk_lock_button_get_permission
# flags: {isMethod} container: LockButton
# need sugar: is method
# 'Gio2.Permission' 'TransferNone[Gio2.TPermission]' (diff., need sugar)
proc gtk_lock_button_get_permission(self: ptr TLockButton): TransferNone[Gio2.TPermission] {.cdecl, dynlib: lib, importc: "gtk_lock_button_get_permission".}
proc get_permission*(self: LockButton): Gio2.Permission {.inline.} =
  wrap(gtk_lock_button_get_permission(self))
# proc get_permission*(self: LockButton): Gio2.Permission {.inline.} =

# gtk_lock_button_set_permission
# flags: {isMethod} container: LockButton
# need sugar: is method
# permission 'Gio2.Permission' 'ptr Gio2.TPermission' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_lock_button_set_permission(self: ptr TLockButton, permission: ptr Gio2.TPermission) {.cdecl, dynlib: lib, importc: "gtk_lock_button_set_permission".}
proc set_permission*(self: LockButton, permission: Gio2.Permission) {.inline.} =
  gtk_lock_button_set_permission(self, permission.getPointer)
# proc set_permission*(self: LockButton, permission: Gio2.Permission) {.inline.} =

# gtk_menu_new
# flags: {isConstructor} container: Menu
# need sugar: is static method
# 'Menu' 'TransferNone[TMenu]' (diff., need sugar)
proc gtk_menu_new(): TransferNone[TMenu] {.cdecl, dynlib: lib, importc: "gtk_menu_new".}
proc new_menu*(): Menu {.inline.} =
  wrap(gtk_menu_new())
# proc new_menu*(): Menu {.inline.} =

# gtk_menu_new_from_model
# flags: {isConstructor} container: Menu
# need sugar: is static method
# model 'Gio2.MenuModel' 'ptr Gio2.TMenuModel' IN (diff., need sugar)
# 'Menu' 'TransferNone[TMenu]' (diff., need sugar)
proc gtk_menu_new_from_model(model: ptr Gio2.TMenuModel): TransferNone[TMenu] {.cdecl, dynlib: lib, importc: "gtk_menu_new_from_model".}
proc new_menu_from_model*(model: Gio2.MenuModel): Menu {.inline.} =
  wrap(gtk_menu_new_from_model(model.getPointer))
# proc new_menu_from_model*(model: Gio2.MenuModel): Menu {.inline.} =

# gtk_menu_get_for_attach_widget
# flags: {} container: Menu
# need sugar: is static method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_menu_get_for_attach_widget(widget: ptr TWidget): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_menu_get_for_attach_widget".}
template get_for_attach_widget*(klass_parameter: typedesc[Menu], widget: Widget): ptr GLIST_TODO =
  gtk_menu_get_for_attach_widget(widget.getPointer)
# template get_for_attach_widget*(klass_parameter: typedesc[Menu], widget: Widget): ptr GLIST_TODO =

# gtk_menu_attach
# flags: {isMethod} container: Menu
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# left_attach 'uint32' 'uint32' IN
# right_attach 'uint32' 'uint32' IN
# top_attach 'uint32' 'uint32' IN
# bottom_attach 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_attach(self: ptr TMenu, child: ptr TWidget, left_attach: uint32, right_attach: uint32, top_attach: uint32, bottom_attach: uint32) {.cdecl, dynlib: lib, importc: "gtk_menu_attach".}
proc attach*(self: Menu, child: Widget, left_attach: uint32, right_attach: uint32, top_attach: uint32, bottom_attach: uint32) {.inline.} =
  gtk_menu_attach(self, child.getPointer, left_attach, right_attach, top_attach, bottom_attach)
# proc attach*(self: Menu, child: Widget, left_attach: uint32, right_attach: uint32, top_attach: uint32, bottom_attach: uint32) {.inline.} =

# gtk_menu_attach_to_widget
# flags: {isMethod} container: Menu
# need sugar: is method
# attach_widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# detacher 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_attach_to_widget(self: ptr TMenu, attach_widget: ptr TWidget, detacher: pointer) {.cdecl, dynlib: lib, importc: "gtk_menu_attach_to_widget".}
proc attach_to_widget*(self: Menu, attach_widget: Widget, detacher: pointer) {.inline.} =
  gtk_menu_attach_to_widget(self, attach_widget.getPointer, detacher)
# proc attach_to_widget*(self: Menu, attach_widget: Widget, detacher: pointer) {.inline.} =

# gtk_menu_detach
# flags: {isMethod} container: Menu
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_detach(self: ptr TMenu) {.cdecl, dynlib: lib, importc: "gtk_menu_detach".}
proc detach*(self: Menu) {.inline.} =
  gtk_menu_detach(self)
# proc detach*(self: Menu) {.inline.} =

# gtk_menu_get_accel_group
# flags: {isMethod} container: Menu
# need sugar: is method
# 'AccelGroup' 'TransferNone[TAccelGroup]' (diff., need sugar)
proc gtk_menu_get_accel_group(self: ptr TMenu): TransferNone[TAccelGroup] {.cdecl, dynlib: lib, importc: "gtk_menu_get_accel_group".}
proc get_accel_group*(self: Menu): AccelGroup {.inline.} =
  wrap(gtk_menu_get_accel_group(self))
# proc get_accel_group*(self: Menu): AccelGroup {.inline.} =

# gtk_menu_get_accel_path
# flags: {isMethod} container: Menu
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_menu_get_accel_path(self: ptr TMenu): ucstring {.cdecl, dynlib: lib, importc: "gtk_menu_get_accel_path".}
proc get_accel_path*(self: Menu): ustring {.inline.} =
  ustring($(gtk_menu_get_accel_path(self)))
# proc get_accel_path*(self: Menu): ustring {.inline.} =

# gtk_menu_get_active
# flags: {isMethod} container: Menu
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_menu_get_active(self: ptr TMenu): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_menu_get_active".}
proc get_active*(self: Menu): Widget {.inline.} =
  wrap(gtk_menu_get_active(self))
# proc get_active*(self: Menu): Widget {.inline.} =

# gtk_menu_get_attach_widget
# flags: {isMethod} container: Menu
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_menu_get_attach_widget(self: ptr TMenu): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_menu_get_attach_widget".}
proc get_attach_widget*(self: Menu): Widget {.inline.} =
  wrap(gtk_menu_get_attach_widget(self))
# proc get_attach_widget*(self: Menu): Widget {.inline.} =

# gtk_menu_get_monitor
# flags: {isMethod} container: Menu
# need sugar: is method
# 'int32' 'int32'
proc gtk_menu_get_monitor(self: ptr TMenu): int32 {.cdecl, dynlib: lib, importc: "gtk_menu_get_monitor".}
proc get_monitor*(self: Menu): int32 {.inline.} =
  gtk_menu_get_monitor(self)
# proc get_monitor*(self: Menu): int32 {.inline.} =

# gtk_menu_get_reserve_toggle_size
# flags: {isMethod} container: Menu
# need sugar: is method
# 'bool' 'bool'
proc gtk_menu_get_reserve_toggle_size(self: ptr TMenu): bool {.cdecl, dynlib: lib, importc: "gtk_menu_get_reserve_toggle_size".}
proc get_reserve_toggle_size*(self: Menu): bool {.inline.} =
  gtk_menu_get_reserve_toggle_size(self)
# proc get_reserve_toggle_size*(self: Menu): bool {.inline.} =

# gtk_menu_get_tearoff_state
# flags: {isMethod} container: Menu (deprecated)
# gtk_menu_get_title
# flags: {isMethod} container: Menu (deprecated)
# gtk_menu_popdown
# flags: {isMethod} container: Menu
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_popdown(self: ptr TMenu) {.cdecl, dynlib: lib, importc: "gtk_menu_popdown".}
proc popdown*(self: Menu) {.inline.} =
  gtk_menu_popdown(self)
# proc popdown*(self: Menu) {.inline.} =

# gtk_menu_popup
# flags: {isMethod} container: Menu
# need sugar: is method
# parent_menu_shell 'Widget' 'ptr TWidget' IN (diff., need sugar)
# parent_menu_item 'Widget' 'ptr TWidget' IN (diff., need sugar)
# func 'pointer' 'pointer' IN
# data 'pointer' 'pointer' IN
# button 'uint32' 'uint32' IN
# activate_time 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_popup(self: ptr TMenu, parent_menu_shell: ptr TWidget, parent_menu_item: ptr TWidget, func_x: pointer, data: pointer, button: uint32, activate_time: uint32) {.cdecl, dynlib: lib, importc: "gtk_menu_popup".}
proc popup*(self: Menu, parent_menu_shell: Widget, parent_menu_item: Widget, func_x: pointer, data: pointer, button: uint32, activate_time: uint32) {.inline.} =
  gtk_menu_popup(self, parent_menu_shell.getPointer, parent_menu_item.getPointer, func_x, data, button, activate_time)
# proc popup*(self: Menu, parent_menu_shell: Widget, parent_menu_item: Widget, func_x: pointer, data: pointer, button: uint32, activate_time: uint32) {.inline.} =

# gtk_menu_popup_for_device
# flags: {isMethod} container: Menu
# need sugar: is method
# device 'Gdk3.Device' 'ptr Gdk3.TDevice' IN (diff., need sugar)
# parent_menu_shell 'Widget' 'ptr TWidget' IN (diff., need sugar)
# parent_menu_item 'Widget' 'ptr TWidget' IN (diff., need sugar)
# func 'pointer' 'pointer' IN
# data 'pointer' 'pointer' IN
# destroy 'pointer' 'pointer' IN
# button 'uint32' 'uint32' IN
# activate_time 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_popup_for_device(self: ptr TMenu, device: ptr Gdk3.TDevice, parent_menu_shell: ptr TWidget, parent_menu_item: ptr TWidget, func_x: pointer, data: pointer, destroy: pointer, button: uint32, activate_time: uint32) {.cdecl, dynlib: lib, importc: "gtk_menu_popup_for_device".}
proc popup_for_device*(self: Menu, device: Gdk3.Device, parent_menu_shell: Widget, parent_menu_item: Widget, func_x: pointer, data: pointer, destroy: pointer, button: uint32, activate_time: uint32) {.inline.} =
  gtk_menu_popup_for_device(self, device.getPointer, parent_menu_shell.getPointer, parent_menu_item.getPointer, func_x, data, destroy, button, activate_time)
# proc popup_for_device*(self: Menu, device: Gdk3.Device, parent_menu_shell: Widget, parent_menu_item: Widget, func_x: pointer, data: pointer, destroy: pointer, button: uint32, activate_time: uint32) {.inline.} =

# gtk_menu_reorder_child
# flags: {isMethod} container: Menu
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# position 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_reorder_child(self: ptr TMenu, child: ptr TWidget, position: int32) {.cdecl, dynlib: lib, importc: "gtk_menu_reorder_child".}
proc reorder_child*(self: Menu, child: Widget, position: int32) {.inline.} =
  gtk_menu_reorder_child(self, child.getPointer, position)
# proc reorder_child*(self: Menu, child: Widget, position: int32) {.inline.} =

# gtk_menu_reposition
# flags: {isMethod} container: Menu
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_reposition(self: ptr TMenu) {.cdecl, dynlib: lib, importc: "gtk_menu_reposition".}
proc reposition*(self: Menu) {.inline.} =
  gtk_menu_reposition(self)
# proc reposition*(self: Menu) {.inline.} =

# gtk_menu_set_accel_group
# flags: {isMethod} container: Menu
# need sugar: is method
# accel_group 'AccelGroup' 'ptr TAccelGroup' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_set_accel_group(self: ptr TMenu, accel_group: ptr TAccelGroup) {.cdecl, dynlib: lib, importc: "gtk_menu_set_accel_group".}
proc set_accel_group*(self: Menu, accel_group: AccelGroup) {.inline.} =
  gtk_menu_set_accel_group(self, accel_group.getPointer)
# proc set_accel_group*(self: Menu, accel_group: AccelGroup) {.inline.} =

# gtk_menu_set_accel_path
# flags: {isMethod} container: Menu
# need sugar: is method
# accel_path 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_set_accel_path(self: ptr TMenu, accel_path: ucstring) {.cdecl, dynlib: lib, importc: "gtk_menu_set_accel_path".}
proc set_accel_path*(self: Menu, accel_path: ustring) {.inline.} =
  gtk_menu_set_accel_path(self, ucstring(accel_path))
# proc set_accel_path*(self: Menu, accel_path: ustring) {.inline.} =

# gtk_menu_set_active
# flags: {isMethod} container: Menu
# need sugar: is method
# index 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_set_active(self: ptr TMenu, index: uint32) {.cdecl, dynlib: lib, importc: "gtk_menu_set_active".}
proc set_active*(self: Menu, index: uint32) {.inline.} =
  gtk_menu_set_active(self, index)
# proc set_active*(self: Menu, index: uint32) {.inline.} =

# gtk_menu_set_monitor
# flags: {isMethod} container: Menu
# need sugar: is method
# monitor_num 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_set_monitor(self: ptr TMenu, monitor_num: int32) {.cdecl, dynlib: lib, importc: "gtk_menu_set_monitor".}
proc set_monitor*(self: Menu, monitor_num: int32) {.inline.} =
  gtk_menu_set_monitor(self, monitor_num)
# proc set_monitor*(self: Menu, monitor_num: int32) {.inline.} =

# gtk_menu_set_reserve_toggle_size
# flags: {isMethod} container: Menu
# need sugar: is method
# reserve_toggle_size 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_set_reserve_toggle_size(self: ptr TMenu, reserve_toggle_size: bool) {.cdecl, dynlib: lib, importc: "gtk_menu_set_reserve_toggle_size".}
proc set_reserve_toggle_size*(self: Menu, reserve_toggle_size: bool) {.inline.} =
  gtk_menu_set_reserve_toggle_size(self, reserve_toggle_size)
# proc set_reserve_toggle_size*(self: Menu, reserve_toggle_size: bool) {.inline.} =

# gtk_menu_set_screen
# flags: {isMethod} container: Menu
# need sugar: is method
# screen 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_set_screen(self: ptr TMenu, screen: ptr Gdk3.TScreen) {.cdecl, dynlib: lib, importc: "gtk_menu_set_screen".}
proc set_screen*(self: Menu, screen: Gdk3.Screen) {.inline.} =
  gtk_menu_set_screen(self, screen.getPointer)
# proc set_screen*(self: Menu, screen: Gdk3.Screen) {.inline.} =

# gtk_menu_set_tearoff_state
# flags: {isMethod} container: Menu (deprecated)
# gtk_menu_set_title
# flags: {isMethod} container: Menu (deprecated)
# gtk_menu_bar_new
# flags: {isConstructor} container: MenuBar
# need sugar: is static method
# 'MenuBar' 'TransferNone[TMenuBar]' (diff., need sugar)
proc gtk_menu_bar_new(): TransferNone[TMenuBar] {.cdecl, dynlib: lib, importc: "gtk_menu_bar_new".}
proc new_menubar*(): MenuBar {.inline.} =
  wrap(gtk_menu_bar_new())
# proc new_menubar*(): MenuBar {.inline.} =

# gtk_menu_bar_new_from_model
# flags: {isConstructor} container: MenuBar
# need sugar: is static method
# model 'Gio2.MenuModel' 'ptr Gio2.TMenuModel' IN (diff., need sugar)
# 'MenuBar' 'TransferNone[TMenuBar]' (diff., need sugar)
proc gtk_menu_bar_new_from_model(model: ptr Gio2.TMenuModel): TransferNone[TMenuBar] {.cdecl, dynlib: lib, importc: "gtk_menu_bar_new_from_model".}
proc new_menubar_from_model*(model: Gio2.MenuModel): MenuBar {.inline.} =
  wrap(gtk_menu_bar_new_from_model(model.getPointer))
# proc new_menubar_from_model*(model: Gio2.MenuModel): MenuBar {.inline.} =

# gtk_menu_bar_get_child_pack_direction
# flags: {isMethod} container: MenuBar
# need sugar: is method
# 'PackDirection' 'PackDirection'
proc gtk_menu_bar_get_child_pack_direction(self: ptr TMenuBar): PackDirection {.cdecl, dynlib: lib, importc: "gtk_menu_bar_get_child_pack_direction".}
proc get_child_pack_direction*(self: MenuBar): PackDirection {.inline.} =
  gtk_menu_bar_get_child_pack_direction(self)
# proc get_child_pack_direction*(self: MenuBar): PackDirection {.inline.} =

# gtk_menu_bar_get_pack_direction
# flags: {isMethod} container: MenuBar
# need sugar: is method
# 'PackDirection' 'PackDirection'
proc gtk_menu_bar_get_pack_direction(self: ptr TMenuBar): PackDirection {.cdecl, dynlib: lib, importc: "gtk_menu_bar_get_pack_direction".}
proc get_pack_direction*(self: MenuBar): PackDirection {.inline.} =
  gtk_menu_bar_get_pack_direction(self)
# proc get_pack_direction*(self: MenuBar): PackDirection {.inline.} =

# gtk_menu_bar_set_child_pack_direction
# flags: {isMethod} container: MenuBar
# need sugar: is method
# child_pack_dir 'PackDirection' 'PackDirection' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_bar_set_child_pack_direction(self: ptr TMenuBar, child_pack_dir: PackDirection) {.cdecl, dynlib: lib, importc: "gtk_menu_bar_set_child_pack_direction".}
proc set_child_pack_direction*(self: MenuBar, child_pack_dir: PackDirection) {.inline.} =
  gtk_menu_bar_set_child_pack_direction(self, child_pack_dir)
# proc set_child_pack_direction*(self: MenuBar, child_pack_dir: PackDirection) {.inline.} =

# gtk_menu_bar_set_pack_direction
# flags: {isMethod} container: MenuBar
# need sugar: is method
# pack_dir 'PackDirection' 'PackDirection' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_bar_set_pack_direction(self: ptr TMenuBar, pack_dir: PackDirection) {.cdecl, dynlib: lib, importc: "gtk_menu_bar_set_pack_direction".}
proc set_pack_direction*(self: MenuBar, pack_dir: PackDirection) {.inline.} =
  gtk_menu_bar_set_pack_direction(self, pack_dir)
# proc set_pack_direction*(self: MenuBar, pack_dir: PackDirection) {.inline.} =

# gtk_menu_button_new
# flags: {isConstructor} container: MenuButton
# need sugar: is static method
# 'MenuButton' 'TransferNone[TMenuButton]' (diff., need sugar)
proc gtk_menu_button_new(): TransferNone[TMenuButton] {.cdecl, dynlib: lib, importc: "gtk_menu_button_new".}
proc new_menubutton*(): MenuButton {.inline.} =
  wrap(gtk_menu_button_new())
# proc new_menubutton*(): MenuButton {.inline.} =

# gtk_menu_button_get_align_widget
# flags: {isMethod} container: MenuButton
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_menu_button_get_align_widget(self: ptr TMenuButton): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_menu_button_get_align_widget".}
proc get_align_widget*(self: MenuButton): Widget {.inline.} =
  wrap(gtk_menu_button_get_align_widget(self))
# proc get_align_widget*(self: MenuButton): Widget {.inline.} =

# gtk_menu_button_get_direction
# flags: {isMethod} container: MenuButton
# need sugar: is method
# 'ArrowType' 'ArrowType'
proc gtk_menu_button_get_direction(self: ptr TMenuButton): ArrowType {.cdecl, dynlib: lib, importc: "gtk_menu_button_get_direction".}
proc get_direction*(self: MenuButton): ArrowType {.inline.} =
  gtk_menu_button_get_direction(self)
# proc get_direction*(self: MenuButton): ArrowType {.inline.} =

# gtk_menu_button_get_menu_model
# flags: {isMethod} container: MenuButton
# need sugar: is method
# 'Gio2.MenuModel' 'TransferNone[Gio2.TMenuModel]' (diff., need sugar)
proc gtk_menu_button_get_menu_model(self: ptr TMenuButton): TransferNone[Gio2.TMenuModel] {.cdecl, dynlib: lib, importc: "gtk_menu_button_get_menu_model".}
proc get_menu_model*(self: MenuButton): Gio2.MenuModel {.inline.} =
  wrap(gtk_menu_button_get_menu_model(self))
# proc get_menu_model*(self: MenuButton): Gio2.MenuModel {.inline.} =

# gtk_menu_button_get_popover
# flags: {isMethod} container: MenuButton
# need sugar: is method
# 'Popover' 'TransferNone[TPopover]' (diff., need sugar)
proc gtk_menu_button_get_popover(self: ptr TMenuButton): TransferNone[TPopover] {.cdecl, dynlib: lib, importc: "gtk_menu_button_get_popover".}
proc get_popover*(self: MenuButton): Popover {.inline.} =
  wrap(gtk_menu_button_get_popover(self))
# proc get_popover*(self: MenuButton): Popover {.inline.} =

# gtk_menu_button_get_popup
# flags: {isMethod} container: MenuButton
# need sugar: is method
# 'Menu' 'TransferNone[TMenu]' (diff., need sugar)
proc gtk_menu_button_get_popup(self: ptr TMenuButton): TransferNone[TMenu] {.cdecl, dynlib: lib, importc: "gtk_menu_button_get_popup".}
proc get_popup*(self: MenuButton): Menu {.inline.} =
  wrap(gtk_menu_button_get_popup(self))
# proc get_popup*(self: MenuButton): Menu {.inline.} =

# gtk_menu_button_get_use_popover
# flags: {isMethod} container: MenuButton
# need sugar: is method
# 'bool' 'bool'
proc gtk_menu_button_get_use_popover(self: ptr TMenuButton): bool {.cdecl, dynlib: lib, importc: "gtk_menu_button_get_use_popover".}
proc get_use_popover*(self: MenuButton): bool {.inline.} =
  gtk_menu_button_get_use_popover(self)
# proc get_use_popover*(self: MenuButton): bool {.inline.} =

# gtk_menu_button_set_align_widget
# flags: {isMethod} container: MenuButton
# need sugar: is method
# align_widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_button_set_align_widget(self: ptr TMenuButton, align_widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_menu_button_set_align_widget".}
proc set_align_widget*(self: MenuButton, align_widget: Widget) {.inline.} =
  gtk_menu_button_set_align_widget(self, align_widget.getPointer)
# proc set_align_widget*(self: MenuButton, align_widget: Widget) {.inline.} =

# gtk_menu_button_set_direction
# flags: {isMethod} container: MenuButton
# need sugar: is method
# direction 'ArrowType' 'ArrowType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_button_set_direction(self: ptr TMenuButton, direction: ArrowType) {.cdecl, dynlib: lib, importc: "gtk_menu_button_set_direction".}
proc set_direction*(self: MenuButton, direction: ArrowType) {.inline.} =
  gtk_menu_button_set_direction(self, direction)
# proc set_direction*(self: MenuButton, direction: ArrowType) {.inline.} =

# gtk_menu_button_set_menu_model
# flags: {isMethod} container: MenuButton
# need sugar: is method
# menu_model 'Gio2.MenuModel' 'ptr Gio2.TMenuModel' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_button_set_menu_model(self: ptr TMenuButton, menu_model: ptr Gio2.TMenuModel) {.cdecl, dynlib: lib, importc: "gtk_menu_button_set_menu_model".}
proc set_menu_model*(self: MenuButton, menu_model: Gio2.MenuModel) {.inline.} =
  gtk_menu_button_set_menu_model(self, menu_model.getPointer)
# proc set_menu_model*(self: MenuButton, menu_model: Gio2.MenuModel) {.inline.} =

# gtk_menu_button_set_popover
# flags: {isMethod} container: MenuButton
# need sugar: is method
# popover 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_button_set_popover(self: ptr TMenuButton, popover: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_menu_button_set_popover".}
proc set_popover*(self: MenuButton, popover: Widget) {.inline.} =
  gtk_menu_button_set_popover(self, popover.getPointer)
# proc set_popover*(self: MenuButton, popover: Widget) {.inline.} =

# gtk_menu_button_set_popup
# flags: {isMethod} container: MenuButton
# need sugar: is method
# menu 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_button_set_popup(self: ptr TMenuButton, menu: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_menu_button_set_popup".}
proc set_popup*(self: MenuButton, menu: Widget) {.inline.} =
  gtk_menu_button_set_popup(self, menu.getPointer)
# proc set_popup*(self: MenuButton, menu: Widget) {.inline.} =

# gtk_menu_button_set_use_popover
# flags: {isMethod} container: MenuButton
# need sugar: is method
# use_popover 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_button_set_use_popover(self: ptr TMenuButton, use_popover: bool) {.cdecl, dynlib: lib, importc: "gtk_menu_button_set_use_popover".}
proc set_use_popover*(self: MenuButton, use_popover: bool) {.inline.} =
  gtk_menu_button_set_use_popover(self, use_popover)
# proc set_use_popover*(self: MenuButton, use_popover: bool) {.inline.} =

# gtk_menu_item_new
# flags: {isConstructor} container: MenuItem
# need sugar: is static method
# 'MenuItem' 'TransferNone[TMenuItem]' (diff., need sugar)
proc gtk_menu_item_new(): TransferNone[TMenuItem] {.cdecl, dynlib: lib, importc: "gtk_menu_item_new".}
proc new_menuitem*(): MenuItem {.inline.} =
  wrap(gtk_menu_item_new())
# proc new_menuitem*(): MenuItem {.inline.} =

# gtk_menu_item_new_with_label
# flags: {isConstructor} container: MenuItem
# need sugar: is static method
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'MenuItem' 'TransferNone[TMenuItem]' (diff., need sugar)
proc gtk_menu_item_new_with_label(label: ucstring): TransferNone[TMenuItem] {.cdecl, dynlib: lib, importc: "gtk_menu_item_new_with_label".}
proc new_menuitem_with_label*(label: ustring): MenuItem {.inline.} =
  wrap(gtk_menu_item_new_with_label(ucstring(label)))
# proc new_menuitem_with_label*(label: ustring): MenuItem {.inline.} =

# gtk_menu_item_new_with_mnemonic
# flags: {isConstructor} container: MenuItem
# need sugar: is static method
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'MenuItem' 'TransferNone[TMenuItem]' (diff., need sugar)
proc gtk_menu_item_new_with_mnemonic(label: ucstring): TransferNone[TMenuItem] {.cdecl, dynlib: lib, importc: "gtk_menu_item_new_with_mnemonic".}
proc new_menuitem_with_mnemonic*(label: ustring): MenuItem {.inline.} =
  wrap(gtk_menu_item_new_with_mnemonic(ucstring(label)))
# proc new_menuitem_with_mnemonic*(label: ustring): MenuItem {.inline.} =

# gtk_menu_item_activate
# flags: {isMethod} container: MenuItem
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_item_activate(self: ptr TMenuItem) {.cdecl, dynlib: lib, importc: "gtk_menu_item_activate".}
proc activate*(self: MenuItem) {.inline.} =
  gtk_menu_item_activate(self)
# proc activate*(self: MenuItem) {.inline.} =

# gtk_menu_item_deselect
# flags: {isMethod} container: MenuItem
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_item_deselect(self: ptr TMenuItem) {.cdecl, dynlib: lib, importc: "gtk_menu_item_deselect".}
proc deselect*(self: MenuItem) {.inline.} =
  gtk_menu_item_deselect(self)
# proc deselect*(self: MenuItem) {.inline.} =

# gtk_menu_item_get_accel_path
# flags: {isMethod} container: MenuItem
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_menu_item_get_accel_path(self: ptr TMenuItem): ucstring {.cdecl, dynlib: lib, importc: "gtk_menu_item_get_accel_path".}
proc get_accel_path*(self: MenuItem): ustring {.inline.} =
  ustring($(gtk_menu_item_get_accel_path(self)))
# proc get_accel_path*(self: MenuItem): ustring {.inline.} =

# gtk_menu_item_get_label
# flags: {isMethod} container: MenuItem
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_menu_item_get_label(self: ptr TMenuItem): ucstring {.cdecl, dynlib: lib, importc: "gtk_menu_item_get_label".}
proc get_label*(self: MenuItem): ustring {.inline.} =
  ustring($(gtk_menu_item_get_label(self)))
# proc get_label*(self: MenuItem): ustring {.inline.} =

# gtk_menu_item_get_reserve_indicator
# flags: {isMethod} container: MenuItem
# need sugar: is method
# 'bool' 'bool'
proc gtk_menu_item_get_reserve_indicator(self: ptr TMenuItem): bool {.cdecl, dynlib: lib, importc: "gtk_menu_item_get_reserve_indicator".}
proc get_reserve_indicator*(self: MenuItem): bool {.inline.} =
  gtk_menu_item_get_reserve_indicator(self)
# proc get_reserve_indicator*(self: MenuItem): bool {.inline.} =

# gtk_menu_item_get_right_justified
# flags: {isMethod} container: MenuItem (deprecated)
# gtk_menu_item_get_submenu
# flags: {isMethod} container: MenuItem
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_menu_item_get_submenu(self: ptr TMenuItem): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_menu_item_get_submenu".}
proc get_submenu*(self: MenuItem): Widget {.inline.} =
  wrap(gtk_menu_item_get_submenu(self))
# proc get_submenu*(self: MenuItem): Widget {.inline.} =

# gtk_menu_item_get_use_underline
# flags: {isMethod} container: MenuItem
# need sugar: is method
# 'bool' 'bool'
proc gtk_menu_item_get_use_underline(self: ptr TMenuItem): bool {.cdecl, dynlib: lib, importc: "gtk_menu_item_get_use_underline".}
proc get_use_underline*(self: MenuItem): bool {.inline.} =
  gtk_menu_item_get_use_underline(self)
# proc get_use_underline*(self: MenuItem): bool {.inline.} =

# gtk_menu_item_select
# flags: {isMethod} container: MenuItem
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_item_select(self: ptr TMenuItem) {.cdecl, dynlib: lib, importc: "gtk_menu_item_select".}
proc select*(self: MenuItem) {.inline.} =
  gtk_menu_item_select(self)
# proc select*(self: MenuItem) {.inline.} =

# gtk_menu_item_set_accel_path
# flags: {isMethod} container: MenuItem
# need sugar: is method
# accel_path 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_item_set_accel_path(self: ptr TMenuItem, accel_path: ucstring) {.cdecl, dynlib: lib, importc: "gtk_menu_item_set_accel_path".}
proc set_accel_path*(self: MenuItem, accel_path: ustring) {.inline.} =
  gtk_menu_item_set_accel_path(self, ucstring(accel_path))
# proc set_accel_path*(self: MenuItem, accel_path: ustring) {.inline.} =

# gtk_menu_item_set_label
# flags: {isMethod} container: MenuItem
# need sugar: is method
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_item_set_label(self: ptr TMenuItem, label: ucstring) {.cdecl, dynlib: lib, importc: "gtk_menu_item_set_label".}
proc set_label*(self: MenuItem, label: ustring) {.inline.} =
  gtk_menu_item_set_label(self, ucstring(label))
# proc set_label*(self: MenuItem, label: ustring) {.inline.} =

# gtk_menu_item_set_reserve_indicator
# flags: {isMethod} container: MenuItem
# need sugar: is method
# reserve 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_item_set_reserve_indicator(self: ptr TMenuItem, reserve: bool) {.cdecl, dynlib: lib, importc: "gtk_menu_item_set_reserve_indicator".}
proc set_reserve_indicator*(self: MenuItem, reserve: bool) {.inline.} =
  gtk_menu_item_set_reserve_indicator(self, reserve)
# proc set_reserve_indicator*(self: MenuItem, reserve: bool) {.inline.} =

# gtk_menu_item_set_right_justified
# flags: {isMethod} container: MenuItem (deprecated)
# gtk_menu_item_set_submenu
# flags: {isMethod} container: MenuItem
# need sugar: is method
# submenu 'Menu' 'ptr TMenu' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_item_set_submenu(self: ptr TMenuItem, submenu: ptr TMenu) {.cdecl, dynlib: lib, importc: "gtk_menu_item_set_submenu".}
proc set_submenu*(self: MenuItem, submenu: Menu) {.inline.} =
  gtk_menu_item_set_submenu(self, submenu.getPointer)
# proc set_submenu*(self: MenuItem, submenu: Menu) {.inline.} =

# gtk_menu_item_set_use_underline
# flags: {isMethod} container: MenuItem
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_item_set_use_underline(self: ptr TMenuItem, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_menu_item_set_use_underline".}
proc set_use_underline*(self: MenuItem, setting: bool) {.inline.} =
  gtk_menu_item_set_use_underline(self, setting)
# proc set_use_underline*(self: MenuItem, setting: bool) {.inline.} =

# gtk_menu_item_toggle_size_allocate
# flags: {isMethod} container: MenuItem
# need sugar: is method
# allocation 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_item_toggle_size_allocate(self: ptr TMenuItem, allocation: int32) {.cdecl, dynlib: lib, importc: "gtk_menu_item_toggle_size_allocate".}
proc toggle_size_allocate*(self: MenuItem, allocation: int32) {.inline.} =
  gtk_menu_item_toggle_size_allocate(self, allocation)
# proc toggle_size_allocate*(self: MenuItem, allocation: int32) {.inline.} =

# gtk_menu_item_toggle_size_request
# flags: {isMethod} container: MenuItem
# need sugar: is method
# requisition 'var int32' 'ptr int32' INOUT (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_item_toggle_size_request(self: ptr TMenuItem, requisition: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_menu_item_toggle_size_request".}
proc toggle_size_request*(self: MenuItem, requisition: var int32) {.inline.} =
  gtk_menu_item_toggle_size_request(self, addr(requisition))
# proc toggle_size_request*(self: MenuItem, requisition: var int32) {.inline.} =

# gtk_menu_shell_activate_item
# flags: {isMethod} container: MenuShell
# need sugar: is method
# menu_item 'Widget' 'ptr TWidget' IN (diff., need sugar)
# force_deactivate 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_shell_activate_item(self: ptr TMenuShell, menu_item: ptr TWidget, force_deactivate: bool) {.cdecl, dynlib: lib, importc: "gtk_menu_shell_activate_item".}
proc activate_item*(self: MenuShell, menu_item: Widget, force_deactivate: bool) {.inline.} =
  gtk_menu_shell_activate_item(self, menu_item.getPointer, force_deactivate)
# proc activate_item*(self: MenuShell, menu_item: Widget, force_deactivate: bool) {.inline.} =

# gtk_menu_shell_append
# flags: {isMethod} container: MenuShell
# need sugar: is method
# child 'MenuItem' 'ptr TMenuItem' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_shell_append(self: ptr TMenuShell, child: ptr TMenuItem) {.cdecl, dynlib: lib, importc: "gtk_menu_shell_append".}
proc append*(self: MenuShell, child: MenuItem) {.inline.} =
  gtk_menu_shell_append(self, child.getPointer)
# proc append*(self: MenuShell, child: MenuItem) {.inline.} =

# gtk_menu_shell_bind_model
# flags: {isMethod} container: MenuShell
# need sugar: is method
# model 'Gio2.MenuModel' 'ptr Gio2.TMenuModel' IN (diff., need sugar)
# action_namespace 'ustring' 'ucstring' IN (diff., need sugar)
# with_separators 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_shell_bind_model(self: ptr TMenuShell, model: ptr Gio2.TMenuModel, action_namespace: ucstring, with_separators: bool) {.cdecl, dynlib: lib, importc: "gtk_menu_shell_bind_model".}
proc bind_model*(self: MenuShell, model: Gio2.MenuModel, action_namespace: ustring, with_separators: bool) {.inline.} =
  gtk_menu_shell_bind_model(self, model.getPointer, ucstring(action_namespace), with_separators)
# proc bind_model*(self: MenuShell, model: Gio2.MenuModel, action_namespace: ustring, with_separators: bool) {.inline.} =

# gtk_menu_shell_cancel
# flags: {isMethod} container: MenuShell
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_shell_cancel(self: ptr TMenuShell) {.cdecl, dynlib: lib, importc: "gtk_menu_shell_cancel".}
proc cancel*(self: MenuShell) {.inline.} =
  gtk_menu_shell_cancel(self)
# proc cancel*(self: MenuShell) {.inline.} =

# gtk_menu_shell_deactivate
# flags: {isMethod} container: MenuShell
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_shell_deactivate(self: ptr TMenuShell) {.cdecl, dynlib: lib, importc: "gtk_menu_shell_deactivate".}
proc deactivate*(self: MenuShell) {.inline.} =
  gtk_menu_shell_deactivate(self)
# proc deactivate*(self: MenuShell) {.inline.} =

# gtk_menu_shell_deselect
# flags: {isMethod} container: MenuShell
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_shell_deselect(self: ptr TMenuShell) {.cdecl, dynlib: lib, importc: "gtk_menu_shell_deselect".}
proc deselect*(self: MenuShell) {.inline.} =
  gtk_menu_shell_deselect(self)
# proc deselect*(self: MenuShell) {.inline.} =

# gtk_menu_shell_get_parent_shell
# flags: {isMethod} container: MenuShell
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_menu_shell_get_parent_shell(self: ptr TMenuShell): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_menu_shell_get_parent_shell".}
proc get_parent_shell*(self: MenuShell): Widget {.inline.} =
  wrap(gtk_menu_shell_get_parent_shell(self))
# proc get_parent_shell*(self: MenuShell): Widget {.inline.} =

# gtk_menu_shell_get_selected_item
# flags: {isMethod} container: MenuShell
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_menu_shell_get_selected_item(self: ptr TMenuShell): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_menu_shell_get_selected_item".}
proc get_selected_item*(self: MenuShell): Widget {.inline.} =
  wrap(gtk_menu_shell_get_selected_item(self))
# proc get_selected_item*(self: MenuShell): Widget {.inline.} =

# gtk_menu_shell_get_take_focus
# flags: {isMethod} container: MenuShell
# need sugar: is method
# 'bool' 'bool'
proc gtk_menu_shell_get_take_focus(self: ptr TMenuShell): bool {.cdecl, dynlib: lib, importc: "gtk_menu_shell_get_take_focus".}
proc get_take_focus*(self: MenuShell): bool {.inline.} =
  gtk_menu_shell_get_take_focus(self)
# proc get_take_focus*(self: MenuShell): bool {.inline.} =

# gtk_menu_shell_insert
# flags: {isMethod} container: MenuShell
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# position 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_shell_insert(self: ptr TMenuShell, child: ptr TWidget, position: int32) {.cdecl, dynlib: lib, importc: "gtk_menu_shell_insert".}
proc insert*(self: MenuShell, child: Widget, position: int32) {.inline.} =
  gtk_menu_shell_insert(self, child.getPointer, position)
# proc insert*(self: MenuShell, child: Widget, position: int32) {.inline.} =

# gtk_menu_shell_prepend
# flags: {isMethod} container: MenuShell
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_shell_prepend(self: ptr TMenuShell, child: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_menu_shell_prepend".}
proc prepend*(self: MenuShell, child: Widget) {.inline.} =
  gtk_menu_shell_prepend(self, child.getPointer)
# proc prepend*(self: MenuShell, child: Widget) {.inline.} =

# gtk_menu_shell_select_first
# flags: {isMethod} container: MenuShell
# need sugar: is method
# search_sensitive 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_shell_select_first(self: ptr TMenuShell, search_sensitive: bool) {.cdecl, dynlib: lib, importc: "gtk_menu_shell_select_first".}
proc select_first*(self: MenuShell, search_sensitive: bool) {.inline.} =
  gtk_menu_shell_select_first(self, search_sensitive)
# proc select_first*(self: MenuShell, search_sensitive: bool) {.inline.} =

# gtk_menu_shell_select_item
# flags: {isMethod} container: MenuShell
# need sugar: is method
# menu_item 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_shell_select_item(self: ptr TMenuShell, menu_item: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_menu_shell_select_item".}
proc select_item*(self: MenuShell, menu_item: Widget) {.inline.} =
  gtk_menu_shell_select_item(self, menu_item.getPointer)
# proc select_item*(self: MenuShell, menu_item: Widget) {.inline.} =

# gtk_menu_shell_set_take_focus
# flags: {isMethod} container: MenuShell
# need sugar: is method
# take_focus 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_shell_set_take_focus(self: ptr TMenuShell, take_focus: bool) {.cdecl, dynlib: lib, importc: "gtk_menu_shell_set_take_focus".}
proc set_take_focus*(self: MenuShell, take_focus: bool) {.inline.} =
  gtk_menu_shell_set_take_focus(self, take_focus)
# proc set_take_focus*(self: MenuShell, take_focus: bool) {.inline.} =

# gtk_menu_tool_button_new
# flags: {isConstructor} container: MenuToolButton
# need sugar: is static method
# icon_widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'MenuToolButton' 'TransferNone[TMenuToolButton]' (diff., need sugar)
proc gtk_menu_tool_button_new(icon_widget: ptr TWidget, label: ucstring): TransferNone[TMenuToolButton] {.cdecl, dynlib: lib, importc: "gtk_menu_tool_button_new".}
proc new_menutoolbutton*(icon_widget: Widget, label: ustring): MenuToolButton {.inline.} =
  wrap(gtk_menu_tool_button_new(icon_widget.getPointer, ucstring(label)))
# proc new_menutoolbutton*(icon_widget: Widget, label: ustring): MenuToolButton {.inline.} =

# gtk_menu_tool_button_new_from_stock
# flags: {isConstructor} container: MenuToolButton (deprecated)
# gtk_menu_tool_button_get_menu
# flags: {isMethod} container: MenuToolButton
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_menu_tool_button_get_menu(self: ptr TMenuToolButton): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_menu_tool_button_get_menu".}
proc get_menu*(self: MenuToolButton): Widget {.inline.} =
  wrap(gtk_menu_tool_button_get_menu(self))
# proc get_menu*(self: MenuToolButton): Widget {.inline.} =

# gtk_menu_tool_button_set_arrow_tooltip_markup
# flags: {isMethod} container: MenuToolButton
# need sugar: is method
# markup 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_tool_button_set_arrow_tooltip_markup(self: ptr TMenuToolButton, markup: ucstring) {.cdecl, dynlib: lib, importc: "gtk_menu_tool_button_set_arrow_tooltip_markup".}
proc set_arrow_tooltip_markup*(self: MenuToolButton, markup: ustring) {.inline.} =
  gtk_menu_tool_button_set_arrow_tooltip_markup(self, ucstring(markup))
# proc set_arrow_tooltip_markup*(self: MenuToolButton, markup: ustring) {.inline.} =

# gtk_menu_tool_button_set_arrow_tooltip_text
# flags: {isMethod} container: MenuToolButton
# need sugar: is method
# text 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_tool_button_set_arrow_tooltip_text(self: ptr TMenuToolButton, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_menu_tool_button_set_arrow_tooltip_text".}
proc set_arrow_tooltip_text*(self: MenuToolButton, text: ustring) {.inline.} =
  gtk_menu_tool_button_set_arrow_tooltip_text(self, ucstring(text))
# proc set_arrow_tooltip_text*(self: MenuToolButton, text: ustring) {.inline.} =

# gtk_menu_tool_button_set_menu
# flags: {isMethod} container: MenuToolButton
# need sugar: is method
# menu 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_tool_button_set_menu(self: ptr TMenuToolButton, menu: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_menu_tool_button_set_menu".}
proc set_menu*(self: MenuToolButton, menu: Widget) {.inline.} =
  gtk_menu_tool_button_set_menu(self, menu.getPointer)
# proc set_menu*(self: MenuToolButton, menu: Widget) {.inline.} =

# gtk_message_dialog_get_image
# flags: {isMethod} container: MessageDialog (deprecated)
# gtk_message_dialog_get_message_area
# flags: {isMethod} container: MessageDialog
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_message_dialog_get_message_area(self: ptr TMessageDialog): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_message_dialog_get_message_area".}
proc get_message_area*(self: MessageDialog): Widget {.inline.} =
  wrap(gtk_message_dialog_get_message_area(self))
# proc get_message_area*(self: MessageDialog): Widget {.inline.} =

# gtk_message_dialog_set_image
# flags: {isMethod} container: MessageDialog (deprecated)
# gtk_message_dialog_set_markup
# flags: {isMethod} container: MessageDialog
# need sugar: is method
# str 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_message_dialog_set_markup(self: ptr TMessageDialog, str: ucstring) {.cdecl, dynlib: lib, importc: "gtk_message_dialog_set_markup".}
proc set_markup*(self: MessageDialog, str: ustring) {.inline.} =
  gtk_message_dialog_set_markup(self, ucstring(str))
# proc set_markup*(self: MessageDialog, str: ustring) {.inline.} =

# gtk_misc_get_alignment
# flags: {isMethod} container: Misc (deprecated)
# gtk_misc_get_padding
# flags: {isMethod} container: Misc (deprecated)
# gtk_misc_set_alignment
# flags: {isMethod} container: Misc (deprecated)
# gtk_misc_set_padding
# flags: {isMethod} container: Misc (deprecated)
# gtk_mount_operation_new
# flags: {isConstructor} container: MountOperation
# need sugar: is static method
# parent 'Window' 'ptr TWindow' IN (diff., need sugar)
# 'MountOperation' 'TransferFull[TMountOperation]' (diff., need sugar)
proc gtk_mount_operation_new(parent: ptr TWindow): TransferFull[TMountOperation] {.cdecl, dynlib: lib, importc: "gtk_mount_operation_new".}
proc new_mountoperation*(parent: Window): MountOperation {.inline.} =
  wrap(gtk_mount_operation_new(parent.getPointer))
# proc new_mountoperation*(parent: Window): MountOperation {.inline.} =

# gtk_mount_operation_get_parent
# flags: {isMethod} container: MountOperation
# need sugar: is method
# 'Window' 'TransferNone[TWindow]' (diff., need sugar)
proc gtk_mount_operation_get_parent(self: ptr TMountOperation): TransferNone[TWindow] {.cdecl, dynlib: lib, importc: "gtk_mount_operation_get_parent".}
proc get_parent*(self: MountOperation): Window {.inline.} =
  wrap(gtk_mount_operation_get_parent(self))
# proc get_parent*(self: MountOperation): Window {.inline.} =

# gtk_mount_operation_get_screen
# flags: {isMethod} container: MountOperation
# need sugar: is method
# 'Gdk3.Screen' 'TransferNone[Gdk3.TScreen]' (diff., need sugar)
proc gtk_mount_operation_get_screen(self: ptr TMountOperation): TransferNone[Gdk3.TScreen] {.cdecl, dynlib: lib, importc: "gtk_mount_operation_get_screen".}
proc get_screen*(self: MountOperation): Gdk3.Screen {.inline.} =
  wrap(gtk_mount_operation_get_screen(self))
# proc get_screen*(self: MountOperation): Gdk3.Screen {.inline.} =

# gtk_mount_operation_is_showing
# flags: {isMethod} container: MountOperation
# need sugar: is method
# 'bool' 'bool'
proc gtk_mount_operation_is_showing(self: ptr TMountOperation): bool {.cdecl, dynlib: lib, importc: "gtk_mount_operation_is_showing".}
proc is_showing*(self: MountOperation): bool {.inline.} =
  gtk_mount_operation_is_showing(self)
# proc is_showing*(self: MountOperation): bool {.inline.} =

# gtk_mount_operation_set_parent
# flags: {isMethod} container: MountOperation
# need sugar: is method
# parent 'Window' 'ptr TWindow' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_mount_operation_set_parent(self: ptr TMountOperation, parent: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_mount_operation_set_parent".}
proc set_parent*(self: MountOperation, parent: Window) {.inline.} =
  gtk_mount_operation_set_parent(self, parent.getPointer)
# proc set_parent*(self: MountOperation, parent: Window) {.inline.} =

# gtk_mount_operation_set_screen
# flags: {isMethod} container: MountOperation
# need sugar: is method
# screen 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_mount_operation_set_screen(self: ptr TMountOperation, screen: ptr Gdk3.TScreen) {.cdecl, dynlib: lib, importc: "gtk_mount_operation_set_screen".}
proc set_screen*(self: MountOperation, screen: Gdk3.Screen) {.inline.} =
  gtk_mount_operation_set_screen(self, screen.getPointer)
# proc set_screen*(self: MountOperation, screen: Gdk3.Screen) {.inline.} =

# gtk_notebook_new
# flags: {isConstructor} container: Notebook
# need sugar: is static method
# 'Notebook' 'TransferNone[TNotebook]' (diff., need sugar)
proc gtk_notebook_new(): TransferNone[TNotebook] {.cdecl, dynlib: lib, importc: "gtk_notebook_new".}
proc new_notebook*(): Notebook {.inline.} =
  wrap(gtk_notebook_new())
# proc new_notebook*(): Notebook {.inline.} =

# gtk_notebook_append_page
# flags: {isMethod} container: Notebook
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# tab_label 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'int32' 'int32'
proc gtk_notebook_append_page(self: ptr TNotebook, child: ptr TWidget, tab_label: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_notebook_append_page".}
proc append_page*(self: Notebook, child: Widget, tab_label: Widget): int32 {.inline.} =
  gtk_notebook_append_page(self, child.getPointer, tab_label.getPointer)
# proc append_page*(self: Notebook, child: Widget, tab_label: Widget): int32 {.inline.} =

# gtk_notebook_append_page_menu
# flags: {isMethod} container: Notebook
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# tab_label 'Widget' 'ptr TWidget' IN (diff., need sugar)
# menu_label 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'int32' 'int32'
proc gtk_notebook_append_page_menu(self: ptr TNotebook, child: ptr TWidget, tab_label: ptr TWidget, menu_label: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_notebook_append_page_menu".}
proc append_page_menu*(self: Notebook, child: Widget, tab_label: Widget, menu_label: Widget): int32 {.inline.} =
  gtk_notebook_append_page_menu(self, child.getPointer, tab_label.getPointer, menu_label.getPointer)
# proc append_page_menu*(self: Notebook, child: Widget, tab_label: Widget, menu_label: Widget): int32 {.inline.} =

# gtk_notebook_get_action_widget
# flags: {isMethod} container: Notebook
# need sugar: is method
# pack_type 'PackType' 'PackType' IN
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_notebook_get_action_widget(self: ptr TNotebook, pack_type: PackType): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_notebook_get_action_widget".}
proc get_action_widget*(self: Notebook, pack_type: PackType): Widget {.inline.} =
  wrap(gtk_notebook_get_action_widget(self, pack_type))
# proc get_action_widget*(self: Notebook, pack_type: PackType): Widget {.inline.} =

# gtk_notebook_get_current_page
# flags: {isMethod} container: Notebook
# need sugar: is method
# 'int32' 'int32'
proc gtk_notebook_get_current_page(self: ptr TNotebook): int32 {.cdecl, dynlib: lib, importc: "gtk_notebook_get_current_page".}
proc get_current_page*(self: Notebook): int32 {.inline.} =
  gtk_notebook_get_current_page(self)
# proc get_current_page*(self: Notebook): int32 {.inline.} =

# gtk_notebook_get_group_name
# flags: {isMethod} container: Notebook
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_notebook_get_group_name(self: ptr TNotebook): ucstring {.cdecl, dynlib: lib, importc: "gtk_notebook_get_group_name".}
proc get_group_name*(self: Notebook): ustring {.inline.} =
  ustring($(gtk_notebook_get_group_name(self)))
# proc get_group_name*(self: Notebook): ustring {.inline.} =

# gtk_notebook_get_menu_label
# flags: {isMethod} container: Notebook
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_notebook_get_menu_label(self: ptr TNotebook, child: ptr TWidget): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_notebook_get_menu_label".}
proc get_menu_label*(self: Notebook, child: Widget): Widget {.inline.} =
  wrap(gtk_notebook_get_menu_label(self, child.getPointer))
# proc get_menu_label*(self: Notebook, child: Widget): Widget {.inline.} =

# gtk_notebook_get_menu_label_text
# flags: {isMethod} container: Notebook
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_notebook_get_menu_label_text(self: ptr TNotebook, child: ptr TWidget): ucstring {.cdecl, dynlib: lib, importc: "gtk_notebook_get_menu_label_text".}
proc get_menu_label_text*(self: Notebook, child: Widget): ustring {.inline.} =
  ustring($(gtk_notebook_get_menu_label_text(self, child.getPointer)))
# proc get_menu_label_text*(self: Notebook, child: Widget): ustring {.inline.} =

# gtk_notebook_get_n_pages
# flags: {isMethod} container: Notebook
# need sugar: is method
# 'int32' 'int32'
proc gtk_notebook_get_n_pages(self: ptr TNotebook): int32 {.cdecl, dynlib: lib, importc: "gtk_notebook_get_n_pages".}
proc get_n_pages*(self: Notebook): int32 {.inline.} =
  gtk_notebook_get_n_pages(self)
# proc get_n_pages*(self: Notebook): int32 {.inline.} =

# gtk_notebook_get_nth_page
# flags: {isMethod} container: Notebook
# need sugar: is method
# page_num 'int32' 'int32' IN
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_notebook_get_nth_page(self: ptr TNotebook, page_num: int32): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_notebook_get_nth_page".}
proc get_nth_page*(self: Notebook, page_num: int32): Widget {.inline.} =
  wrap(gtk_notebook_get_nth_page(self, page_num))
# proc get_nth_page*(self: Notebook, page_num: int32): Widget {.inline.} =

# gtk_notebook_get_scrollable
# flags: {isMethod} container: Notebook
# need sugar: is method
# 'bool' 'bool'
proc gtk_notebook_get_scrollable(self: ptr TNotebook): bool {.cdecl, dynlib: lib, importc: "gtk_notebook_get_scrollable".}
proc get_scrollable*(self: Notebook): bool {.inline.} =
  gtk_notebook_get_scrollable(self)
# proc get_scrollable*(self: Notebook): bool {.inline.} =

# gtk_notebook_get_show_border
# flags: {isMethod} container: Notebook
# need sugar: is method
# 'bool' 'bool'
proc gtk_notebook_get_show_border(self: ptr TNotebook): bool {.cdecl, dynlib: lib, importc: "gtk_notebook_get_show_border".}
proc get_show_border*(self: Notebook): bool {.inline.} =
  gtk_notebook_get_show_border(self)
# proc get_show_border*(self: Notebook): bool {.inline.} =

# gtk_notebook_get_show_tabs
# flags: {isMethod} container: Notebook
# need sugar: is method
# 'bool' 'bool'
proc gtk_notebook_get_show_tabs(self: ptr TNotebook): bool {.cdecl, dynlib: lib, importc: "gtk_notebook_get_show_tabs".}
proc get_show_tabs*(self: Notebook): bool {.inline.} =
  gtk_notebook_get_show_tabs(self)
# proc get_show_tabs*(self: Notebook): bool {.inline.} =

# gtk_notebook_get_tab_detachable
# flags: {isMethod} container: Notebook
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_notebook_get_tab_detachable(self: ptr TNotebook, child: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_notebook_get_tab_detachable".}
proc get_tab_detachable*(self: Notebook, child: Widget): bool {.inline.} =
  gtk_notebook_get_tab_detachable(self, child.getPointer)
# proc get_tab_detachable*(self: Notebook, child: Widget): bool {.inline.} =

# gtk_notebook_get_tab_hborder
# flags: {isMethod} container: Notebook (deprecated)
# gtk_notebook_get_tab_label
# flags: {isMethod} container: Notebook
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_notebook_get_tab_label(self: ptr TNotebook, child: ptr TWidget): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_notebook_get_tab_label".}
proc get_tab_label*(self: Notebook, child: Widget): Widget {.inline.} =
  wrap(gtk_notebook_get_tab_label(self, child.getPointer))
# proc get_tab_label*(self: Notebook, child: Widget): Widget {.inline.} =

# gtk_notebook_get_tab_label_text
# flags: {isMethod} container: Notebook
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_notebook_get_tab_label_text(self: ptr TNotebook, child: ptr TWidget): ucstring {.cdecl, dynlib: lib, importc: "gtk_notebook_get_tab_label_text".}
proc get_tab_label_text*(self: Notebook, child: Widget): ustring {.inline.} =
  ustring($(gtk_notebook_get_tab_label_text(self, child.getPointer)))
# proc get_tab_label_text*(self: Notebook, child: Widget): ustring {.inline.} =

# gtk_notebook_get_tab_pos
# flags: {isMethod} container: Notebook
# need sugar: is method
# 'PositionType' 'PositionType'
proc gtk_notebook_get_tab_pos(self: ptr TNotebook): PositionType {.cdecl, dynlib: lib, importc: "gtk_notebook_get_tab_pos".}
proc get_tab_pos*(self: Notebook): PositionType {.inline.} =
  gtk_notebook_get_tab_pos(self)
# proc get_tab_pos*(self: Notebook): PositionType {.inline.} =

# gtk_notebook_get_tab_reorderable
# flags: {isMethod} container: Notebook
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_notebook_get_tab_reorderable(self: ptr TNotebook, child: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_notebook_get_tab_reorderable".}
proc get_tab_reorderable*(self: Notebook, child: Widget): bool {.inline.} =
  gtk_notebook_get_tab_reorderable(self, child.getPointer)
# proc get_tab_reorderable*(self: Notebook, child: Widget): bool {.inline.} =

# gtk_notebook_get_tab_vborder
# flags: {isMethod} container: Notebook (deprecated)
# gtk_notebook_insert_page
# flags: {isMethod} container: Notebook
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# tab_label 'Widget' 'ptr TWidget' IN (diff., need sugar)
# position 'int32' 'int32' IN
# 'int32' 'int32'
proc gtk_notebook_insert_page(self: ptr TNotebook, child: ptr TWidget, tab_label: ptr TWidget, position: int32): int32 {.cdecl, dynlib: lib, importc: "gtk_notebook_insert_page".}
proc insert_page*(self: Notebook, child: Widget, tab_label: Widget, position: int32): int32 {.inline.} =
  gtk_notebook_insert_page(self, child.getPointer, tab_label.getPointer, position)
# proc insert_page*(self: Notebook, child: Widget, tab_label: Widget, position: int32): int32 {.inline.} =

# gtk_notebook_insert_page_menu
# flags: {isMethod} container: Notebook
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# tab_label 'Widget' 'ptr TWidget' IN (diff., need sugar)
# menu_label 'Widget' 'ptr TWidget' IN (diff., need sugar)
# position 'int32' 'int32' IN
# 'int32' 'int32'
proc gtk_notebook_insert_page_menu(self: ptr TNotebook, child: ptr TWidget, tab_label: ptr TWidget, menu_label: ptr TWidget, position: int32): int32 {.cdecl, dynlib: lib, importc: "gtk_notebook_insert_page_menu".}
proc insert_page_menu*(self: Notebook, child: Widget, tab_label: Widget, menu_label: Widget, position: int32): int32 {.inline.} =
  gtk_notebook_insert_page_menu(self, child.getPointer, tab_label.getPointer, menu_label.getPointer, position)
# proc insert_page_menu*(self: Notebook, child: Widget, tab_label: Widget, menu_label: Widget, position: int32): int32 {.inline.} =

# gtk_notebook_next_page
# flags: {isMethod} container: Notebook
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_next_page(self: ptr TNotebook) {.cdecl, dynlib: lib, importc: "gtk_notebook_next_page".}
proc next_page*(self: Notebook) {.inline.} =
  gtk_notebook_next_page(self)
# proc next_page*(self: Notebook) {.inline.} =

# gtk_notebook_page_num
# flags: {isMethod} container: Notebook
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'int32' 'int32'
proc gtk_notebook_page_num(self: ptr TNotebook, child: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_notebook_page_num".}
proc page_num*(self: Notebook, child: Widget): int32 {.inline.} =
  gtk_notebook_page_num(self, child.getPointer)
# proc page_num*(self: Notebook, child: Widget): int32 {.inline.} =

# gtk_notebook_popup_disable
# flags: {isMethod} container: Notebook
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_popup_disable(self: ptr TNotebook) {.cdecl, dynlib: lib, importc: "gtk_notebook_popup_disable".}
proc popup_disable*(self: Notebook) {.inline.} =
  gtk_notebook_popup_disable(self)
# proc popup_disable*(self: Notebook) {.inline.} =

# gtk_notebook_popup_enable
# flags: {isMethod} container: Notebook
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_popup_enable(self: ptr TNotebook) {.cdecl, dynlib: lib, importc: "gtk_notebook_popup_enable".}
proc popup_enable*(self: Notebook) {.inline.} =
  gtk_notebook_popup_enable(self)
# proc popup_enable*(self: Notebook) {.inline.} =

# gtk_notebook_prepend_page
# flags: {isMethod} container: Notebook
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# tab_label 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'int32' 'int32'
proc gtk_notebook_prepend_page(self: ptr TNotebook, child: ptr TWidget, tab_label: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_notebook_prepend_page".}
proc prepend_page*(self: Notebook, child: Widget, tab_label: Widget): int32 {.inline.} =
  gtk_notebook_prepend_page(self, child.getPointer, tab_label.getPointer)
# proc prepend_page*(self: Notebook, child: Widget, tab_label: Widget): int32 {.inline.} =

# gtk_notebook_prepend_page_menu
# flags: {isMethod} container: Notebook
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# tab_label 'Widget' 'ptr TWidget' IN (diff., need sugar)
# menu_label 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'int32' 'int32'
proc gtk_notebook_prepend_page_menu(self: ptr TNotebook, child: ptr TWidget, tab_label: ptr TWidget, menu_label: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_notebook_prepend_page_menu".}
proc prepend_page_menu*(self: Notebook, child: Widget, tab_label: Widget, menu_label: Widget): int32 {.inline.} =
  gtk_notebook_prepend_page_menu(self, child.getPointer, tab_label.getPointer, menu_label.getPointer)
# proc prepend_page_menu*(self: Notebook, child: Widget, tab_label: Widget, menu_label: Widget): int32 {.inline.} =

# gtk_notebook_prev_page
# flags: {isMethod} container: Notebook
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_prev_page(self: ptr TNotebook) {.cdecl, dynlib: lib, importc: "gtk_notebook_prev_page".}
proc prev_page*(self: Notebook) {.inline.} =
  gtk_notebook_prev_page(self)
# proc prev_page*(self: Notebook) {.inline.} =

# gtk_notebook_remove_page
# flags: {isMethod} container: Notebook
# need sugar: is method
# page_num 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_remove_page(self: ptr TNotebook, page_num: int32) {.cdecl, dynlib: lib, importc: "gtk_notebook_remove_page".}
proc remove_page*(self: Notebook, page_num: int32) {.inline.} =
  gtk_notebook_remove_page(self, page_num)
# proc remove_page*(self: Notebook, page_num: int32) {.inline.} =

# gtk_notebook_reorder_child
# flags: {isMethod} container: Notebook
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# position 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_reorder_child(self: ptr TNotebook, child: ptr TWidget, position: int32) {.cdecl, dynlib: lib, importc: "gtk_notebook_reorder_child".}
proc reorder_child*(self: Notebook, child: Widget, position: int32) {.inline.} =
  gtk_notebook_reorder_child(self, child.getPointer, position)
# proc reorder_child*(self: Notebook, child: Widget, position: int32) {.inline.} =

# gtk_notebook_set_action_widget
# flags: {isMethod} container: Notebook
# need sugar: is method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# pack_type 'PackType' 'PackType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_set_action_widget(self: ptr TNotebook, widget: ptr TWidget, pack_type: PackType) {.cdecl, dynlib: lib, importc: "gtk_notebook_set_action_widget".}
proc set_action_widget*(self: Notebook, widget: Widget, pack_type: PackType) {.inline.} =
  gtk_notebook_set_action_widget(self, widget.getPointer, pack_type)
# proc set_action_widget*(self: Notebook, widget: Widget, pack_type: PackType) {.inline.} =

# gtk_notebook_set_current_page
# flags: {isMethod} container: Notebook
# need sugar: is method
# page_num 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_set_current_page(self: ptr TNotebook, page_num: int32) {.cdecl, dynlib: lib, importc: "gtk_notebook_set_current_page".}
proc set_current_page*(self: Notebook, page_num: int32) {.inline.} =
  gtk_notebook_set_current_page(self, page_num)
# proc set_current_page*(self: Notebook, page_num: int32) {.inline.} =

# gtk_notebook_set_group_name
# flags: {isMethod} container: Notebook
# need sugar: is method
# group_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_set_group_name(self: ptr TNotebook, group_name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_notebook_set_group_name".}
proc set_group_name*(self: Notebook, group_name: ustring) {.inline.} =
  gtk_notebook_set_group_name(self, ucstring(group_name))
# proc set_group_name*(self: Notebook, group_name: ustring) {.inline.} =

# gtk_notebook_set_menu_label
# flags: {isMethod} container: Notebook
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# menu_label 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_set_menu_label(self: ptr TNotebook, child: ptr TWidget, menu_label: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_notebook_set_menu_label".}
proc set_menu_label*(self: Notebook, child: Widget, menu_label: Widget) {.inline.} =
  gtk_notebook_set_menu_label(self, child.getPointer, menu_label.getPointer)
# proc set_menu_label*(self: Notebook, child: Widget, menu_label: Widget) {.inline.} =

# gtk_notebook_set_menu_label_text
# flags: {isMethod} container: Notebook
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# menu_text 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_set_menu_label_text(self: ptr TNotebook, child: ptr TWidget, menu_text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_notebook_set_menu_label_text".}
proc set_menu_label_text*(self: Notebook, child: Widget, menu_text: ustring) {.inline.} =
  gtk_notebook_set_menu_label_text(self, child.getPointer, ucstring(menu_text))
# proc set_menu_label_text*(self: Notebook, child: Widget, menu_text: ustring) {.inline.} =

# gtk_notebook_set_scrollable
# flags: {isMethod} container: Notebook
# need sugar: is method
# scrollable 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_set_scrollable(self: ptr TNotebook, scrollable: bool) {.cdecl, dynlib: lib, importc: "gtk_notebook_set_scrollable".}
proc set_scrollable*(self: Notebook, scrollable: bool) {.inline.} =
  gtk_notebook_set_scrollable(self, scrollable)
# proc set_scrollable*(self: Notebook, scrollable: bool) {.inline.} =

# gtk_notebook_set_show_border
# flags: {isMethod} container: Notebook
# need sugar: is method
# show_border 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_set_show_border(self: ptr TNotebook, show_border: bool) {.cdecl, dynlib: lib, importc: "gtk_notebook_set_show_border".}
proc set_show_border*(self: Notebook, show_border: bool) {.inline.} =
  gtk_notebook_set_show_border(self, show_border)
# proc set_show_border*(self: Notebook, show_border: bool) {.inline.} =

# gtk_notebook_set_show_tabs
# flags: {isMethod} container: Notebook
# need sugar: is method
# show_tabs 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_set_show_tabs(self: ptr TNotebook, show_tabs: bool) {.cdecl, dynlib: lib, importc: "gtk_notebook_set_show_tabs".}
proc set_show_tabs*(self: Notebook, show_tabs: bool) {.inline.} =
  gtk_notebook_set_show_tabs(self, show_tabs)
# proc set_show_tabs*(self: Notebook, show_tabs: bool) {.inline.} =

# gtk_notebook_set_tab_detachable
# flags: {isMethod} container: Notebook
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# detachable 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_set_tab_detachable(self: ptr TNotebook, child: ptr TWidget, detachable: bool) {.cdecl, dynlib: lib, importc: "gtk_notebook_set_tab_detachable".}
proc set_tab_detachable*(self: Notebook, child: Widget, detachable: bool) {.inline.} =
  gtk_notebook_set_tab_detachable(self, child.getPointer, detachable)
# proc set_tab_detachable*(self: Notebook, child: Widget, detachable: bool) {.inline.} =

# gtk_notebook_set_tab_label
# flags: {isMethod} container: Notebook
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# tab_label 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_set_tab_label(self: ptr TNotebook, child: ptr TWidget, tab_label: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_notebook_set_tab_label".}
proc set_tab_label*(self: Notebook, child: Widget, tab_label: Widget) {.inline.} =
  gtk_notebook_set_tab_label(self, child.getPointer, tab_label.getPointer)
# proc set_tab_label*(self: Notebook, child: Widget, tab_label: Widget) {.inline.} =

# gtk_notebook_set_tab_label_text
# flags: {isMethod} container: Notebook
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# tab_text 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_set_tab_label_text(self: ptr TNotebook, child: ptr TWidget, tab_text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_notebook_set_tab_label_text".}
proc set_tab_label_text*(self: Notebook, child: Widget, tab_text: ustring) {.inline.} =
  gtk_notebook_set_tab_label_text(self, child.getPointer, ucstring(tab_text))
# proc set_tab_label_text*(self: Notebook, child: Widget, tab_text: ustring) {.inline.} =

# gtk_notebook_set_tab_pos
# flags: {isMethod} container: Notebook
# need sugar: is method
# pos 'PositionType' 'PositionType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_set_tab_pos(self: ptr TNotebook, pos: PositionType) {.cdecl, dynlib: lib, importc: "gtk_notebook_set_tab_pos".}
proc set_tab_pos*(self: Notebook, pos: PositionType) {.inline.} =
  gtk_notebook_set_tab_pos(self, pos)
# proc set_tab_pos*(self: Notebook, pos: PositionType) {.inline.} =

# gtk_notebook_set_tab_reorderable
# flags: {isMethod} container: Notebook
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# reorderable 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_set_tab_reorderable(self: ptr TNotebook, child: ptr TWidget, reorderable: bool) {.cdecl, dynlib: lib, importc: "gtk_notebook_set_tab_reorderable".}
proc set_tab_reorderable*(self: Notebook, child: Widget, reorderable: bool) {.inline.} =
  gtk_notebook_set_tab_reorderable(self, child.getPointer, reorderable)
# proc set_tab_reorderable*(self: Notebook, child: Widget, reorderable: bool) {.inline.} =

# gtk_notebook_page_accessible_new
# flags: {isConstructor} container: NotebookPageAccessible
# need sugar: is static method
# notebook 'NotebookAccessible' 'ptr TNotebookAccessible' IN (diff., need sugar)
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'NotebookPageAccessible' 'TransferFull[TNotebookPageAccessible]' (diff., need sugar)
proc gtk_notebook_page_accessible_new(notebook: ptr TNotebookAccessible, child: ptr TWidget): TransferFull[TNotebookPageAccessible] {.cdecl, dynlib: lib, importc: "gtk_notebook_page_accessible_new".}
proc new_notebookpageaccessible*(notebook: NotebookAccessible, child: Widget): NotebookPageAccessible {.inline.} =
  wrap(gtk_notebook_page_accessible_new(notebook.getPointer, child.getPointer))
# proc new_notebookpageaccessible*(notebook: NotebookAccessible, child: Widget): NotebookPageAccessible {.inline.} =

# gtk_notebook_page_accessible_invalidate
# flags: {isMethod} container: NotebookPageAccessible
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_page_accessible_invalidate(self: ptr TNotebookPageAccessible) {.cdecl, dynlib: lib, importc: "gtk_notebook_page_accessible_invalidate".}
proc invalidate*(self: NotebookPageAccessible) {.inline.} =
  gtk_notebook_page_accessible_invalidate(self)
# proc invalidate*(self: NotebookPageAccessible) {.inline.} =

# gtk_numerable_icon_new
# flags: {} container: NumerableIcon (deprecated)
# gtk_numerable_icon_new_with_style_context
# flags: {} container: NumerableIcon (deprecated)
# gtk_numerable_icon_get_background_gicon
# flags: {isMethod} container: NumerableIcon (deprecated)
# gtk_numerable_icon_get_background_icon_name
# flags: {isMethod} container: NumerableIcon (deprecated)
# gtk_numerable_icon_get_count
# flags: {isMethod} container: NumerableIcon (deprecated)
# gtk_numerable_icon_get_label
# flags: {isMethod} container: NumerableIcon (deprecated)
# gtk_numerable_icon_get_style_context
# flags: {isMethod} container: NumerableIcon (deprecated)
# gtk_numerable_icon_set_background_gicon
# flags: {isMethod} container: NumerableIcon (deprecated)
# gtk_numerable_icon_set_background_icon_name
# flags: {isMethod} container: NumerableIcon (deprecated)
# gtk_numerable_icon_set_count
# flags: {isMethod} container: NumerableIcon (deprecated)
# gtk_numerable_icon_set_label
# flags: {isMethod} container: NumerableIcon (deprecated)
# gtk_numerable_icon_set_style_context
# flags: {isMethod} container: NumerableIcon (deprecated)
# gtk_offscreen_window_new
# flags: {isConstructor} container: OffscreenWindow
# need sugar: is static method
# 'OffscreenWindow' 'TransferNone[TOffscreenWindow]' (diff., need sugar)
proc gtk_offscreen_window_new(): TransferNone[TOffscreenWindow] {.cdecl, dynlib: lib, importc: "gtk_offscreen_window_new".}
proc new_offscreenwindow*(): OffscreenWindow {.inline.} =
  wrap(gtk_offscreen_window_new())
# proc new_offscreenwindow*(): OffscreenWindow {.inline.} =

# gtk_offscreen_window_get_pixbuf
# flags: {isMethod} container: OffscreenWindow
# need sugar: is method
# 'GdkPixbuf2.Pixbuf' 'TransferFull[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_offscreen_window_get_pixbuf(self: ptr TOffscreenWindow): TransferFull[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_offscreen_window_get_pixbuf".}
proc get_pixbuf*(self: OffscreenWindow): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_offscreen_window_get_pixbuf(self))
# proc get_pixbuf*(self: OffscreenWindow): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_offscreen_window_get_surface
# flags: {isMethod} container: OffscreenWindow
# need sugar: is method
# 'cairo1.TSurface' 'ptr cairo1.TSurface' (diff., need sugar)
proc gtk_offscreen_window_get_surface(self: ptr TOffscreenWindow): ptr cairo1.TSurface {.cdecl, dynlib: lib, importc: "gtk_offscreen_window_get_surface".}
proc get_surface*(self: OffscreenWindow): cairo1.TSurface {.inline.} =
  (gtk_offscreen_window_get_surface(self))[]
# proc get_surface*(self: OffscreenWindow): cairo1.TSurface {.inline.} =

# gtk_overlay_new
# flags: {isConstructor} container: Overlay
# need sugar: is static method
# 'Overlay' 'TransferNone[TOverlay]' (diff., need sugar)
proc gtk_overlay_new(): TransferNone[TOverlay] {.cdecl, dynlib: lib, importc: "gtk_overlay_new".}
proc new_overlay*(): Overlay {.inline.} =
  wrap(gtk_overlay_new())
# proc new_overlay*(): Overlay {.inline.} =

# gtk_overlay_add_overlay
# flags: {isMethod} container: Overlay
# need sugar: is method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_overlay_add_overlay(self: ptr TOverlay, widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_overlay_add_overlay".}
proc add_overlay*(self: Overlay, widget: Widget) {.inline.} =
  gtk_overlay_add_overlay(self, widget.getPointer)
# proc add_overlay*(self: Overlay, widget: Widget) {.inline.} =

# gtk_page_setup_new
# flags: {isConstructor} container: PageSetup
# need sugar: is static method
# 'PageSetup' 'TransferFull[TPageSetup]' (diff., need sugar)
proc gtk_page_setup_new(): TransferFull[TPageSetup] {.cdecl, dynlib: lib, importc: "gtk_page_setup_new".}
proc new_pagesetup*(): PageSetup {.inline.} =
  wrap(gtk_page_setup_new())
# proc new_pagesetup*(): PageSetup {.inline.} =

# gtk_page_setup_new_from_file
# flags: {isConstructor, throws} container: PageSetup
# can throw
# need sugar: is static method
# file_name 'string' 'cstring' IN (diff., need sugar)
# 'PageSetup' 'TransferFull[TPageSetup]' (diff., need sugar)
proc gtk_page_setup_new_from_file(file_name: cstring, error: ptr PGError=nil): TransferFull[TPageSetup] {.cdecl, dynlib: lib, importc: "gtk_page_setup_new_from_file".}
proc new_pagesetup_from_file*(file_name: string): PageSetup {.inline.} =
  wrap(gtk_page_setup_new_from_file(cstring(file_name)))
# proc new_pagesetup_from_file*(file_name: string): PageSetup {.inline.} =

# gtk_page_setup_new_from_key_file
# flags: {isConstructor, throws} container: PageSetup
# can throw
# need sugar: is static method
# key_file 'GLib2.TKeyFile' 'ptr GLib2.TKeyFile' IN (diff., need sugar)
# group_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'PageSetup' 'TransferFull[TPageSetup]' (diff., need sugar)
proc gtk_page_setup_new_from_key_file(key_file: ptr GLib2.TKeyFile, group_name: ucstring, error: ptr PGError=nil): TransferFull[TPageSetup] {.cdecl, dynlib: lib, importc: "gtk_page_setup_new_from_key_file".}
proc new_pagesetup_from_key_file*(key_file: GLib2.TKeyFile, group_name: ustring): PageSetup {.inline.} =
  wrap(gtk_page_setup_new_from_key_file(myUnsafeAddr(key_file), ucstring(group_name)))
# proc new_pagesetup_from_key_file*(key_file: GLib2.TKeyFile, group_name: ustring): PageSetup {.inline.} =

# gtk_page_setup_copy
# flags: {isMethod} container: PageSetup
# need sugar: is method
# 'PageSetup' 'TransferFull[TPageSetup]' (diff., need sugar)
proc gtk_page_setup_copy(self: ptr TPageSetup): TransferFull[TPageSetup] {.cdecl, dynlib: lib, importc: "gtk_page_setup_copy".}
proc copy*(self: PageSetup): PageSetup {.inline.} =
  wrap(gtk_page_setup_copy(self))
# proc copy*(self: PageSetup): PageSetup {.inline.} =

# gtk_page_setup_get_bottom_margin
# flags: {isMethod} container: PageSetup
# need sugar: is method
# unit 'Unit' 'Unit' IN
# 'float64' 'float64'
proc gtk_page_setup_get_bottom_margin(self: ptr TPageSetup, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_page_setup_get_bottom_margin".}
proc get_bottom_margin*(self: PageSetup, unit: Unit): float64 {.inline.} =
  gtk_page_setup_get_bottom_margin(self, unit)
# proc get_bottom_margin*(self: PageSetup, unit: Unit): float64 {.inline.} =

# gtk_page_setup_get_left_margin
# flags: {isMethod} container: PageSetup
# need sugar: is method
# unit 'Unit' 'Unit' IN
# 'float64' 'float64'
proc gtk_page_setup_get_left_margin(self: ptr TPageSetup, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_page_setup_get_left_margin".}
proc get_left_margin*(self: PageSetup, unit: Unit): float64 {.inline.} =
  gtk_page_setup_get_left_margin(self, unit)
# proc get_left_margin*(self: PageSetup, unit: Unit): float64 {.inline.} =

# gtk_page_setup_get_orientation
# flags: {isMethod} container: PageSetup
# need sugar: is method
# 'PageOrientation' 'PageOrientation'
proc gtk_page_setup_get_orientation(self: ptr TPageSetup): PageOrientation {.cdecl, dynlib: lib, importc: "gtk_page_setup_get_orientation".}
proc get_orientation*(self: PageSetup): PageOrientation {.inline.} =
  gtk_page_setup_get_orientation(self)
# proc get_orientation*(self: PageSetup): PageOrientation {.inline.} =

# gtk_page_setup_get_page_height
# flags: {isMethod} container: PageSetup
# need sugar: is method
# unit 'Unit' 'Unit' IN
# 'float64' 'float64'
proc gtk_page_setup_get_page_height(self: ptr TPageSetup, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_page_setup_get_page_height".}
proc get_page_height*(self: PageSetup, unit: Unit): float64 {.inline.} =
  gtk_page_setup_get_page_height(self, unit)
# proc get_page_height*(self: PageSetup, unit: Unit): float64 {.inline.} =

# gtk_page_setup_get_page_width
# flags: {isMethod} container: PageSetup
# need sugar: is method
# unit 'Unit' 'Unit' IN
# 'float64' 'float64'
proc gtk_page_setup_get_page_width(self: ptr TPageSetup, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_page_setup_get_page_width".}
proc get_page_width*(self: PageSetup, unit: Unit): float64 {.inline.} =
  gtk_page_setup_get_page_width(self, unit)
# proc get_page_width*(self: PageSetup, unit: Unit): float64 {.inline.} =

# gtk_page_setup_get_paper_height
# flags: {isMethod} container: PageSetup
# need sugar: is method
# unit 'Unit' 'Unit' IN
# 'float64' 'float64'
proc gtk_page_setup_get_paper_height(self: ptr TPageSetup, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_page_setup_get_paper_height".}
proc get_paper_height*(self: PageSetup, unit: Unit): float64 {.inline.} =
  gtk_page_setup_get_paper_height(self, unit)
# proc get_paper_height*(self: PageSetup, unit: Unit): float64 {.inline.} =

# gtk_page_setup_get_paper_size
# flags: {isMethod} container: PageSetup
# need sugar: is method
# 'TPaperSize' 'ptr TPaperSize' (diff., need sugar)
proc gtk_page_setup_get_paper_size(self: ptr TPageSetup): ptr TPaperSize {.cdecl, dynlib: lib, importc: "gtk_page_setup_get_paper_size".}
proc get_paper_size*(self: PageSetup): TPaperSize {.inline.} =
  (gtk_page_setup_get_paper_size(self))[]
# proc get_paper_size*(self: PageSetup): TPaperSize {.inline.} =

# gtk_page_setup_get_paper_width
# flags: {isMethod} container: PageSetup
# need sugar: is method
# unit 'Unit' 'Unit' IN
# 'float64' 'float64'
proc gtk_page_setup_get_paper_width(self: ptr TPageSetup, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_page_setup_get_paper_width".}
proc get_paper_width*(self: PageSetup, unit: Unit): float64 {.inline.} =
  gtk_page_setup_get_paper_width(self, unit)
# proc get_paper_width*(self: PageSetup, unit: Unit): float64 {.inline.} =

# gtk_page_setup_get_right_margin
# flags: {isMethod} container: PageSetup
# need sugar: is method
# unit 'Unit' 'Unit' IN
# 'float64' 'float64'
proc gtk_page_setup_get_right_margin(self: ptr TPageSetup, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_page_setup_get_right_margin".}
proc get_right_margin*(self: PageSetup, unit: Unit): float64 {.inline.} =
  gtk_page_setup_get_right_margin(self, unit)
# proc get_right_margin*(self: PageSetup, unit: Unit): float64 {.inline.} =

# gtk_page_setup_get_top_margin
# flags: {isMethod} container: PageSetup
# need sugar: is method
# unit 'Unit' 'Unit' IN
# 'float64' 'float64'
proc gtk_page_setup_get_top_margin(self: ptr TPageSetup, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_page_setup_get_top_margin".}
proc get_top_margin*(self: PageSetup, unit: Unit): float64 {.inline.} =
  gtk_page_setup_get_top_margin(self, unit)
# proc get_top_margin*(self: PageSetup, unit: Unit): float64 {.inline.} =

# gtk_page_setup_load_file
# flags: {isMethod, throws} container: PageSetup
# can throw
# need sugar: is method
# file_name 'string' 'cstring' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_page_setup_load_file(self: ptr TPageSetup, file_name: cstring, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_page_setup_load_file".}
proc load_file*(self: PageSetup, file_name: string): bool {.inline.} =
  gtk_page_setup_load_file(self, cstring(file_name))
# proc load_file*(self: PageSetup, file_name: string): bool {.inline.} =

# gtk_page_setup_load_key_file
# flags: {isMethod, throws} container: PageSetup
# can throw
# need sugar: is method
# key_file 'GLib2.TKeyFile' 'ptr GLib2.TKeyFile' IN (diff., need sugar)
# group_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_page_setup_load_key_file(self: ptr TPageSetup, key_file: ptr GLib2.TKeyFile, group_name: ucstring, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_page_setup_load_key_file".}
proc load_key_file*(self: PageSetup, key_file: GLib2.TKeyFile, group_name: ustring): bool {.inline.} =
  gtk_page_setup_load_key_file(self, myUnsafeAddr(key_file), ucstring(group_name))
# proc load_key_file*(self: PageSetup, key_file: GLib2.TKeyFile, group_name: ustring): bool {.inline.} =

# gtk_page_setup_set_bottom_margin
# flags: {isMethod} container: PageSetup
# need sugar: is method
# margin 'float64' 'float64' IN
# unit 'Unit' 'Unit' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_page_setup_set_bottom_margin(self: ptr TPageSetup, margin: float64, unit: Unit) {.cdecl, dynlib: lib, importc: "gtk_page_setup_set_bottom_margin".}
proc set_bottom_margin*(self: PageSetup, margin: float64, unit: Unit) {.inline.} =
  gtk_page_setup_set_bottom_margin(self, margin, unit)
# proc set_bottom_margin*(self: PageSetup, margin: float64, unit: Unit) {.inline.} =

# gtk_page_setup_set_left_margin
# flags: {isMethod} container: PageSetup
# need sugar: is method
# margin 'float64' 'float64' IN
# unit 'Unit' 'Unit' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_page_setup_set_left_margin(self: ptr TPageSetup, margin: float64, unit: Unit) {.cdecl, dynlib: lib, importc: "gtk_page_setup_set_left_margin".}
proc set_left_margin*(self: PageSetup, margin: float64, unit: Unit) {.inline.} =
  gtk_page_setup_set_left_margin(self, margin, unit)
# proc set_left_margin*(self: PageSetup, margin: float64, unit: Unit) {.inline.} =

# gtk_page_setup_set_orientation
# flags: {isMethod} container: PageSetup
# need sugar: is method
# orientation 'PageOrientation' 'PageOrientation' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_page_setup_set_orientation(self: ptr TPageSetup, orientation: PageOrientation) {.cdecl, dynlib: lib, importc: "gtk_page_setup_set_orientation".}
proc set_orientation*(self: PageSetup, orientation: PageOrientation) {.inline.} =
  gtk_page_setup_set_orientation(self, orientation)
# proc set_orientation*(self: PageSetup, orientation: PageOrientation) {.inline.} =

# gtk_page_setup_set_paper_size
# flags: {isMethod} container: PageSetup
# need sugar: is method
# size 'TPaperSize' 'ptr TPaperSize' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_page_setup_set_paper_size(self: ptr TPageSetup, size: ptr TPaperSize) {.cdecl, dynlib: lib, importc: "gtk_page_setup_set_paper_size".}
proc set_paper_size*(self: PageSetup, size: TPaperSize) {.inline.} =
  gtk_page_setup_set_paper_size(self, myUnsafeAddr(size))
# proc set_paper_size*(self: PageSetup, size: TPaperSize) {.inline.} =

# gtk_page_setup_set_paper_size_and_default_margins
# flags: {isMethod} container: PageSetup
# need sugar: is method
# size 'TPaperSize' 'ptr TPaperSize' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_page_setup_set_paper_size_and_default_margins(self: ptr TPageSetup, size: ptr TPaperSize) {.cdecl, dynlib: lib, importc: "gtk_page_setup_set_paper_size_and_default_margins".}
proc set_paper_size_and_default_margins*(self: PageSetup, size: TPaperSize) {.inline.} =
  gtk_page_setup_set_paper_size_and_default_margins(self, myUnsafeAddr(size))
# proc set_paper_size_and_default_margins*(self: PageSetup, size: TPaperSize) {.inline.} =

# gtk_page_setup_set_right_margin
# flags: {isMethod} container: PageSetup
# need sugar: is method
# margin 'float64' 'float64' IN
# unit 'Unit' 'Unit' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_page_setup_set_right_margin(self: ptr TPageSetup, margin: float64, unit: Unit) {.cdecl, dynlib: lib, importc: "gtk_page_setup_set_right_margin".}
proc set_right_margin*(self: PageSetup, margin: float64, unit: Unit) {.inline.} =
  gtk_page_setup_set_right_margin(self, margin, unit)
# proc set_right_margin*(self: PageSetup, margin: float64, unit: Unit) {.inline.} =

# gtk_page_setup_set_top_margin
# flags: {isMethod} container: PageSetup
# need sugar: is method
# margin 'float64' 'float64' IN
# unit 'Unit' 'Unit' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_page_setup_set_top_margin(self: ptr TPageSetup, margin: float64, unit: Unit) {.cdecl, dynlib: lib, importc: "gtk_page_setup_set_top_margin".}
proc set_top_margin*(self: PageSetup, margin: float64, unit: Unit) {.inline.} =
  gtk_page_setup_set_top_margin(self, margin, unit)
# proc set_top_margin*(self: PageSetup, margin: float64, unit: Unit) {.inline.} =

# gtk_page_setup_to_file
# flags: {isMethod, throws} container: PageSetup
# can throw
# need sugar: is method
# file_name 'string' 'cstring' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_page_setup_to_file(self: ptr TPageSetup, file_name: cstring, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_page_setup_to_file".}
proc to_file*(self: PageSetup, file_name: string): bool {.inline.} =
  gtk_page_setup_to_file(self, cstring(file_name))
# proc to_file*(self: PageSetup, file_name: string): bool {.inline.} =

# gtk_page_setup_to_key_file
# flags: {isMethod} container: PageSetup
# need sugar: is method
# key_file 'GLib2.TKeyFile' 'ptr GLib2.TKeyFile' IN (diff., need sugar)
# group_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_page_setup_to_key_file(self: ptr TPageSetup, key_file: ptr GLib2.TKeyFile, group_name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_page_setup_to_key_file".}
proc to_key_file*(self: PageSetup, key_file: GLib2.TKeyFile, group_name: ustring) {.inline.} =
  gtk_page_setup_to_key_file(self, myUnsafeAddr(key_file), ucstring(group_name))
# proc to_key_file*(self: PageSetup, key_file: GLib2.TKeyFile, group_name: ustring) {.inline.} =

# gtk_paned_new
# flags: {isConstructor} container: Paned
# need sugar: is static method
# orientation 'Orientation' 'Orientation' IN
# 'Paned' 'TransferNone[TPaned]' (diff., need sugar)
proc gtk_paned_new(orientation: Orientation): TransferNone[TPaned] {.cdecl, dynlib: lib, importc: "gtk_paned_new".}
proc new_paned*(orientation: Orientation): Paned {.inline.} =
  wrap(gtk_paned_new(orientation))
# proc new_paned*(orientation: Orientation): Paned {.inline.} =

# gtk_paned_add1
# flags: {isMethod} container: Paned
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_paned_add1(self: ptr TPaned, child: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_paned_add1".}
proc add1*(self: Paned, child: Widget) {.inline.} =
  gtk_paned_add1(self, child.getPointer)
# proc add1*(self: Paned, child: Widget) {.inline.} =

# gtk_paned_add2
# flags: {isMethod} container: Paned
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_paned_add2(self: ptr TPaned, child: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_paned_add2".}
proc add2*(self: Paned, child: Widget) {.inline.} =
  gtk_paned_add2(self, child.getPointer)
# proc add2*(self: Paned, child: Widget) {.inline.} =

# gtk_paned_get_child1
# flags: {isMethod} container: Paned
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_paned_get_child1(self: ptr TPaned): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_paned_get_child1".}
proc get_child1*(self: Paned): Widget {.inline.} =
  wrap(gtk_paned_get_child1(self))
# proc get_child1*(self: Paned): Widget {.inline.} =

# gtk_paned_get_child2
# flags: {isMethod} container: Paned
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_paned_get_child2(self: ptr TPaned): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_paned_get_child2".}
proc get_child2*(self: Paned): Widget {.inline.} =
  wrap(gtk_paned_get_child2(self))
# proc get_child2*(self: Paned): Widget {.inline.} =

# gtk_paned_get_handle_window
# flags: {isMethod} container: Paned
# need sugar: is method
# 'Gdk3.Window' 'TransferNone[Gdk3.TWindow]' (diff., need sugar)
proc gtk_paned_get_handle_window(self: ptr TPaned): TransferNone[Gdk3.TWindow] {.cdecl, dynlib: lib, importc: "gtk_paned_get_handle_window".}
proc get_handle_window*(self: Paned): Gdk3.Window {.inline.} =
  wrap(gtk_paned_get_handle_window(self))
# proc get_handle_window*(self: Paned): Gdk3.Window {.inline.} =

# gtk_paned_get_position
# flags: {isMethod} container: Paned
# need sugar: is method
# 'int32' 'int32'
proc gtk_paned_get_position(self: ptr TPaned): int32 {.cdecl, dynlib: lib, importc: "gtk_paned_get_position".}
proc get_position*(self: Paned): int32 {.inline.} =
  gtk_paned_get_position(self)
# proc get_position*(self: Paned): int32 {.inline.} =

# gtk_paned_pack1
# flags: {isMethod} container: Paned
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# resize 'bool' 'bool' IN
# shrink 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_paned_pack1(self: ptr TPaned, child: ptr TWidget, resize: bool, shrink: bool) {.cdecl, dynlib: lib, importc: "gtk_paned_pack1".}
proc pack1*(self: Paned, child: Widget, resize: bool, shrink: bool) {.inline.} =
  gtk_paned_pack1(self, child.getPointer, resize, shrink)
# proc pack1*(self: Paned, child: Widget, resize: bool, shrink: bool) {.inline.} =

# gtk_paned_pack2
# flags: {isMethod} container: Paned
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# resize 'bool' 'bool' IN
# shrink 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_paned_pack2(self: ptr TPaned, child: ptr TWidget, resize: bool, shrink: bool) {.cdecl, dynlib: lib, importc: "gtk_paned_pack2".}
proc pack2*(self: Paned, child: Widget, resize: bool, shrink: bool) {.inline.} =
  gtk_paned_pack2(self, child.getPointer, resize, shrink)
# proc pack2*(self: Paned, child: Widget, resize: bool, shrink: bool) {.inline.} =

# gtk_paned_set_position
# flags: {isMethod} container: Paned
# need sugar: is method
# position 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_paned_set_position(self: ptr TPaned, position: int32) {.cdecl, dynlib: lib, importc: "gtk_paned_set_position".}
proc set_position*(self: Paned, position: int32) {.inline.} =
  gtk_paned_set_position(self, position)
# proc set_position*(self: Paned, position: int32) {.inline.} =

# gtk_places_sidebar_new
# flags: {isConstructor} container: PlacesSidebar
# need sugar: is static method
# 'PlacesSidebar' 'TransferNone[TPlacesSidebar]' (diff., need sugar)
proc gtk_places_sidebar_new(): TransferNone[TPlacesSidebar] {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_new".}
proc new_placessidebar*(): PlacesSidebar {.inline.} =
  wrap(gtk_places_sidebar_new())
# proc new_placessidebar*(): PlacesSidebar {.inline.} =

# gtk_places_sidebar_add_shortcut
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# location 'Gio2.File' 'ptr Gio2.TFile' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_places_sidebar_add_shortcut(self: ptr TPlacesSidebar, location: ptr Gio2.TFile) {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_add_shortcut".}
proc add_shortcut*(self: PlacesSidebar, location: Gio2.File) {.inline.} =
  gtk_places_sidebar_add_shortcut(self, unwrap(location))
# proc add_shortcut*(self: PlacesSidebar, location: Gio2.File) {.inline.} =

# gtk_places_sidebar_get_local_only
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# 'bool' 'bool'
proc gtk_places_sidebar_get_local_only(self: ptr TPlacesSidebar): bool {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_get_local_only".}
proc get_local_only*(self: PlacesSidebar): bool {.inline.} =
  gtk_places_sidebar_get_local_only(self)
# proc get_local_only*(self: PlacesSidebar): bool {.inline.} =

# gtk_places_sidebar_get_location
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# 'Gio2.File' 'TransferFull[Gio2.TFile]' (diff., need sugar)
proc gtk_places_sidebar_get_location(self: ptr TPlacesSidebar): TransferFull[Gio2.TFile] {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_get_location".}
proc get_location*(self: PlacesSidebar): Gio2.File {.inline.} =
  wrap(gtk_places_sidebar_get_location(self))
# proc get_location*(self: PlacesSidebar): Gio2.File {.inline.} =

# gtk_places_sidebar_get_nth_bookmark
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# n 'int32' 'int32' IN
# 'Gio2.File' 'TransferFull[Gio2.TFile]' (diff., need sugar)
proc gtk_places_sidebar_get_nth_bookmark(self: ptr TPlacesSidebar, n: int32): TransferFull[Gio2.TFile] {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_get_nth_bookmark".}
proc get_nth_bookmark*(self: PlacesSidebar, n: int32): Gio2.File {.inline.} =
  wrap(gtk_places_sidebar_get_nth_bookmark(self, n))
# proc get_nth_bookmark*(self: PlacesSidebar, n: int32): Gio2.File {.inline.} =

# gtk_places_sidebar_get_open_flags
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# 'SPlacesOpenFlags' 'SPlacesOpenFlags'
proc gtk_places_sidebar_get_open_flags(self: ptr TPlacesSidebar): SPlacesOpenFlags {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_get_open_flags".}
proc get_open_flags*(self: PlacesSidebar): SPlacesOpenFlags {.inline.} =
  gtk_places_sidebar_get_open_flags(self)
# proc get_open_flags*(self: PlacesSidebar): SPlacesOpenFlags {.inline.} =

# gtk_places_sidebar_get_show_connect_to_server
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# 'bool' 'bool'
proc gtk_places_sidebar_get_show_connect_to_server(self: ptr TPlacesSidebar): bool {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_get_show_connect_to_server".}
proc get_show_connect_to_server*(self: PlacesSidebar): bool {.inline.} =
  gtk_places_sidebar_get_show_connect_to_server(self)
# proc get_show_connect_to_server*(self: PlacesSidebar): bool {.inline.} =

# gtk_places_sidebar_get_show_desktop
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# 'bool' 'bool'
proc gtk_places_sidebar_get_show_desktop(self: ptr TPlacesSidebar): bool {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_get_show_desktop".}
proc get_show_desktop*(self: PlacesSidebar): bool {.inline.} =
  gtk_places_sidebar_get_show_desktop(self)
# proc get_show_desktop*(self: PlacesSidebar): bool {.inline.} =

# gtk_places_sidebar_get_show_enter_location
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# 'bool' 'bool'
proc gtk_places_sidebar_get_show_enter_location(self: ptr TPlacesSidebar): bool {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_get_show_enter_location".}
proc get_show_enter_location*(self: PlacesSidebar): bool {.inline.} =
  gtk_places_sidebar_get_show_enter_location(self)
# proc get_show_enter_location*(self: PlacesSidebar): bool {.inline.} =

# gtk_places_sidebar_list_shortcuts
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# 'ptr GSLIST_TODO' 'ptr GSLIST_TODO'
proc gtk_places_sidebar_list_shortcuts(self: ptr TPlacesSidebar): ptr GSLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_list_shortcuts".}
proc list_shortcuts*(self: PlacesSidebar): ptr GSLIST_TODO {.inline.} =
  gtk_places_sidebar_list_shortcuts(self)
# proc list_shortcuts*(self: PlacesSidebar): ptr GSLIST_TODO {.inline.} =

# gtk_places_sidebar_remove_shortcut
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# location 'Gio2.File' 'ptr Gio2.TFile' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_places_sidebar_remove_shortcut(self: ptr TPlacesSidebar, location: ptr Gio2.TFile) {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_remove_shortcut".}
proc remove_shortcut*(self: PlacesSidebar, location: Gio2.File) {.inline.} =
  gtk_places_sidebar_remove_shortcut(self, unwrap(location))
# proc remove_shortcut*(self: PlacesSidebar, location: Gio2.File) {.inline.} =

# gtk_places_sidebar_set_local_only
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# local_only 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_places_sidebar_set_local_only(self: ptr TPlacesSidebar, local_only: bool) {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_set_local_only".}
proc set_local_only*(self: PlacesSidebar, local_only: bool) {.inline.} =
  gtk_places_sidebar_set_local_only(self, local_only)
# proc set_local_only*(self: PlacesSidebar, local_only: bool) {.inline.} =

# gtk_places_sidebar_set_location
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# location 'Gio2.File' 'ptr Gio2.TFile' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_places_sidebar_set_location(self: ptr TPlacesSidebar, location: ptr Gio2.TFile) {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_set_location".}
proc set_location*(self: PlacesSidebar, location: Gio2.File) {.inline.} =
  gtk_places_sidebar_set_location(self, unwrap(location))
# proc set_location*(self: PlacesSidebar, location: Gio2.File) {.inline.} =

# gtk_places_sidebar_set_open_flags
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# flags 'SPlacesOpenFlags' 'SPlacesOpenFlags' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_places_sidebar_set_open_flags(self: ptr TPlacesSidebar, flags: SPlacesOpenFlags) {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_set_open_flags".}
proc set_open_flags*(self: PlacesSidebar, flags: SPlacesOpenFlags) {.inline.} =
  gtk_places_sidebar_set_open_flags(self, flags)
# proc set_open_flags*(self: PlacesSidebar, flags: SPlacesOpenFlags) {.inline.} =

# gtk_places_sidebar_set_show_connect_to_server
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# show_connect_to_server 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_places_sidebar_set_show_connect_to_server(self: ptr TPlacesSidebar, show_connect_to_server: bool) {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_set_show_connect_to_server".}
proc set_show_connect_to_server*(self: PlacesSidebar, show_connect_to_server: bool) {.inline.} =
  gtk_places_sidebar_set_show_connect_to_server(self, show_connect_to_server)
# proc set_show_connect_to_server*(self: PlacesSidebar, show_connect_to_server: bool) {.inline.} =

# gtk_places_sidebar_set_show_desktop
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# show_desktop 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_places_sidebar_set_show_desktop(self: ptr TPlacesSidebar, show_desktop: bool) {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_set_show_desktop".}
proc set_show_desktop*(self: PlacesSidebar, show_desktop: bool) {.inline.} =
  gtk_places_sidebar_set_show_desktop(self, show_desktop)
# proc set_show_desktop*(self: PlacesSidebar, show_desktop: bool) {.inline.} =

# gtk_places_sidebar_set_show_enter_location
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# show_enter_location 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_places_sidebar_set_show_enter_location(self: ptr TPlacesSidebar, show_enter_location: bool) {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_set_show_enter_location".}
proc set_show_enter_location*(self: PlacesSidebar, show_enter_location: bool) {.inline.} =
  gtk_places_sidebar_set_show_enter_location(self, show_enter_location)
# proc set_show_enter_location*(self: PlacesSidebar, show_enter_location: bool) {.inline.} =

# gtk_popover_new
# flags: {isConstructor} container: Popover
# need sugar: is static method
# relative_to 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'Popover' 'TransferNone[TPopover]' (diff., need sugar)
proc gtk_popover_new(relative_to: ptr TWidget): TransferNone[TPopover] {.cdecl, dynlib: lib, importc: "gtk_popover_new".}
proc new_popover*(relative_to: Widget): Popover {.inline.} =
  wrap(gtk_popover_new(relative_to.getPointer))
# proc new_popover*(relative_to: Widget): Popover {.inline.} =

# gtk_popover_new_from_model
# flags: {isConstructor} container: Popover
# need sugar: is static method
# relative_to 'Widget' 'ptr TWidget' IN (diff., need sugar)
# model 'Gio2.MenuModel' 'ptr Gio2.TMenuModel' IN (diff., need sugar)
# 'Popover' 'TransferNone[TPopover]' (diff., need sugar)
proc gtk_popover_new_from_model(relative_to: ptr TWidget, model: ptr Gio2.TMenuModel): TransferNone[TPopover] {.cdecl, dynlib: lib, importc: "gtk_popover_new_from_model".}
proc new_popover_from_model*(relative_to: Widget, model: Gio2.MenuModel): Popover {.inline.} =
  wrap(gtk_popover_new_from_model(relative_to.getPointer, model.getPointer))
# proc new_popover_from_model*(relative_to: Widget, model: Gio2.MenuModel): Popover {.inline.} =

# gtk_popover_bind_model
# flags: {isMethod} container: Popover
# need sugar: is method
# model 'Gio2.MenuModel' 'ptr Gio2.TMenuModel' IN (diff., need sugar)
# action_namespace 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_popover_bind_model(self: ptr TPopover, model: ptr Gio2.TMenuModel, action_namespace: ucstring) {.cdecl, dynlib: lib, importc: "gtk_popover_bind_model".}
proc bind_model*(self: Popover, model: Gio2.MenuModel, action_namespace: ustring) {.inline.} =
  gtk_popover_bind_model(self, model.getPointer, ucstring(action_namespace))
# proc bind_model*(self: Popover, model: Gio2.MenuModel, action_namespace: ustring) {.inline.} =

# gtk_popover_get_modal
# flags: {isMethod} container: Popover
# need sugar: is method
# 'bool' 'bool'
proc gtk_popover_get_modal(self: ptr TPopover): bool {.cdecl, dynlib: lib, importc: "gtk_popover_get_modal".}
proc get_modal*(self: Popover): bool {.inline.} =
  gtk_popover_get_modal(self)
# proc get_modal*(self: Popover): bool {.inline.} =

# gtk_popover_get_pointing_to
# flags: {isMethod} container: Popover
# need sugar: is method
# rect 'var cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' OUT (diff., need sugar) caller-allocates
# 'bool' 'bool'
proc gtk_popover_get_pointing_to(self: ptr TPopover, rect: ptr cairo1.TRectangleInt): bool {.cdecl, dynlib: lib, importc: "gtk_popover_get_pointing_to".}
proc get_pointing_to*(self: Popover, rect: var cairo1.TRectangleInt): bool {.inline.} =
  gtk_popover_get_pointing_to(self, addr(rect))
# tuple-return
# rect: var cairo1.TRectangleInt
# proc get_pointing_to*(self: Popover): bool {.inline.} =

# gtk_popover_get_position
# flags: {isMethod} container: Popover
# need sugar: is method
# 'PositionType' 'PositionType'
proc gtk_popover_get_position(self: ptr TPopover): PositionType {.cdecl, dynlib: lib, importc: "gtk_popover_get_position".}
proc get_position*(self: Popover): PositionType {.inline.} =
  gtk_popover_get_position(self)
# proc get_position*(self: Popover): PositionType {.inline.} =

# gtk_popover_get_relative_to
# flags: {isMethod} container: Popover
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_popover_get_relative_to(self: ptr TPopover): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_popover_get_relative_to".}
proc get_relative_to*(self: Popover): Widget {.inline.} =
  wrap(gtk_popover_get_relative_to(self))
# proc get_relative_to*(self: Popover): Widget {.inline.} =

# gtk_popover_set_modal
# flags: {isMethod} container: Popover
# need sugar: is method
# modal 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_popover_set_modal(self: ptr TPopover, modal: bool) {.cdecl, dynlib: lib, importc: "gtk_popover_set_modal".}
proc set_modal*(self: Popover, modal: bool) {.inline.} =
  gtk_popover_set_modal(self, modal)
# proc set_modal*(self: Popover, modal: bool) {.inline.} =

# gtk_popover_set_pointing_to
# flags: {isMethod} container: Popover
# need sugar: is method
# rect 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_popover_set_pointing_to(self: ptr TPopover, rect: ptr cairo1.TRectangleInt) {.cdecl, dynlib: lib, importc: "gtk_popover_set_pointing_to".}
proc set_pointing_to*(self: Popover, rect: cairo1.TRectangleInt) {.inline.} =
  gtk_popover_set_pointing_to(self, myUnsafeAddr(rect))
# proc set_pointing_to*(self: Popover, rect: cairo1.TRectangleInt) {.inline.} =

# gtk_popover_set_position
# flags: {isMethod} container: Popover
# need sugar: is method
# position 'PositionType' 'PositionType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_popover_set_position(self: ptr TPopover, position: PositionType) {.cdecl, dynlib: lib, importc: "gtk_popover_set_position".}
proc set_position*(self: Popover, position: PositionType) {.inline.} =
  gtk_popover_set_position(self, position)
# proc set_position*(self: Popover, position: PositionType) {.inline.} =

# gtk_popover_set_relative_to
# flags: {isMethod} container: Popover
# need sugar: is method
# relative_to 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_popover_set_relative_to(self: ptr TPopover, relative_to: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_popover_set_relative_to".}
proc set_relative_to*(self: Popover, relative_to: Widget) {.inline.} =
  gtk_popover_set_relative_to(self, relative_to.getPointer)
# proc set_relative_to*(self: Popover, relative_to: Widget) {.inline.} =

# gtk_print_context_create_pango_context
# flags: {isMethod} container: PrintContext
# need sugar: is method
# 'Pango1.Context' 'TransferFull[Pango1.TContext]' (diff., need sugar)
proc gtk_print_context_create_pango_context(self: ptr TPrintContext): TransferFull[Pango1.TContext] {.cdecl, dynlib: lib, importc: "gtk_print_context_create_pango_context".}
proc create_pango_context*(self: PrintContext): Pango1.Context {.inline.} =
  wrap(gtk_print_context_create_pango_context(self))
# proc create_pango_context*(self: PrintContext): Pango1.Context {.inline.} =

# gtk_print_context_create_pango_layout
# flags: {isMethod} container: PrintContext
# need sugar: is method
# 'Pango1.Layout' 'TransferFull[Pango1.TLayout]' (diff., need sugar)
proc gtk_print_context_create_pango_layout(self: ptr TPrintContext): TransferFull[Pango1.TLayout] {.cdecl, dynlib: lib, importc: "gtk_print_context_create_pango_layout".}
proc create_pango_layout*(self: PrintContext): Pango1.Layout {.inline.} =
  wrap(gtk_print_context_create_pango_layout(self))
# proc create_pango_layout*(self: PrintContext): Pango1.Layout {.inline.} =

# gtk_print_context_get_cairo_context
# flags: {isMethod} container: PrintContext
# need sugar: is method
# 'cairo1.TContext' 'ptr cairo1.TContext' (diff., need sugar)
proc gtk_print_context_get_cairo_context(self: ptr TPrintContext): ptr cairo1.TContext {.cdecl, dynlib: lib, importc: "gtk_print_context_get_cairo_context".}
proc get_cairo_context*(self: PrintContext): cairo1.TContext {.inline.} =
  (gtk_print_context_get_cairo_context(self))[]
# proc get_cairo_context*(self: PrintContext): cairo1.TContext {.inline.} =

# gtk_print_context_get_dpi_x
# flags: {isMethod} container: PrintContext
# need sugar: is method
# 'float64' 'float64'
proc gtk_print_context_get_dpi_x(self: ptr TPrintContext): float64 {.cdecl, dynlib: lib, importc: "gtk_print_context_get_dpi_x".}
proc get_dpi_x*(self: PrintContext): float64 {.inline.} =
  gtk_print_context_get_dpi_x(self)
# proc get_dpi_x*(self: PrintContext): float64 {.inline.} =

# gtk_print_context_get_dpi_y
# flags: {isMethod} container: PrintContext
# need sugar: is method
# 'float64' 'float64'
proc gtk_print_context_get_dpi_y(self: ptr TPrintContext): float64 {.cdecl, dynlib: lib, importc: "gtk_print_context_get_dpi_y".}
proc get_dpi_y*(self: PrintContext): float64 {.inline.} =
  gtk_print_context_get_dpi_y(self)
# proc get_dpi_y*(self: PrintContext): float64 {.inline.} =

# gtk_print_context_get_hard_margins
# flags: {isMethod} container: PrintContext
# need sugar: is method
# top 'var float64' 'ptr float64' OUT (diff., need sugar)
# bottom 'var float64' 'ptr float64' OUT (diff., need sugar)
# left 'var float64' 'ptr float64' OUT (diff., need sugar)
# right 'var float64' 'ptr float64' OUT (diff., need sugar)
# 'bool' 'bool'
proc gtk_print_context_get_hard_margins(self: ptr TPrintContext, top: ptr float64, bottom: ptr float64, left: ptr float64, right: ptr float64): bool {.cdecl, dynlib: lib, importc: "gtk_print_context_get_hard_margins".}
proc get_hard_margins*(self: PrintContext, top: var float64, bottom: var float64, left: var float64, right: var float64): bool {.inline.} =
  gtk_print_context_get_hard_margins(self, addr(top), addr(bottom), addr(left), addr(right))
# tuple-return
# top: var float64
# bottom: var float64
# left: var float64
# right: var float64
# proc get_hard_margins*(self: PrintContext): bool {.inline.} =

# gtk_print_context_get_height
# flags: {isMethod} container: PrintContext
# need sugar: is method
# 'float64' 'float64'
proc gtk_print_context_get_height(self: ptr TPrintContext): float64 {.cdecl, dynlib: lib, importc: "gtk_print_context_get_height".}
proc get_height*(self: PrintContext): float64 {.inline.} =
  gtk_print_context_get_height(self)
# proc get_height*(self: PrintContext): float64 {.inline.} =

# gtk_print_context_get_page_setup
# flags: {isMethod} container: PrintContext
# need sugar: is method
# 'PageSetup' 'TransferNone[TPageSetup]' (diff., need sugar)
proc gtk_print_context_get_page_setup(self: ptr TPrintContext): TransferNone[TPageSetup] {.cdecl, dynlib: lib, importc: "gtk_print_context_get_page_setup".}
proc get_page_setup*(self: PrintContext): PageSetup {.inline.} =
  wrap(gtk_print_context_get_page_setup(self))
# proc get_page_setup*(self: PrintContext): PageSetup {.inline.} =

# gtk_print_context_get_pango_fontmap
# flags: {isMethod} container: PrintContext
# need sugar: is method
# 'Pango1.FontMap' 'TransferNone[Pango1.TFontMap]' (diff., need sugar)
proc gtk_print_context_get_pango_fontmap(self: ptr TPrintContext): TransferNone[Pango1.TFontMap] {.cdecl, dynlib: lib, importc: "gtk_print_context_get_pango_fontmap".}
proc get_pango_fontmap*(self: PrintContext): Pango1.FontMap {.inline.} =
  wrap(gtk_print_context_get_pango_fontmap(self))
# proc get_pango_fontmap*(self: PrintContext): Pango1.FontMap {.inline.} =

# gtk_print_context_get_width
# flags: {isMethod} container: PrintContext
# need sugar: is method
# 'float64' 'float64'
proc gtk_print_context_get_width(self: ptr TPrintContext): float64 {.cdecl, dynlib: lib, importc: "gtk_print_context_get_width".}
proc get_width*(self: PrintContext): float64 {.inline.} =
  gtk_print_context_get_width(self)
# proc get_width*(self: PrintContext): float64 {.inline.} =

# gtk_print_context_set_cairo_context
# flags: {isMethod} container: PrintContext
# need sugar: is method
# cr 'cairo1.TContext' 'ptr cairo1.TContext' IN (diff., need sugar)
# dpi_x 'float64' 'float64' IN
# dpi_y 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_context_set_cairo_context(self: ptr TPrintContext, cr: ptr cairo1.TContext, dpi_x: float64, dpi_y: float64) {.cdecl, dynlib: lib, importc: "gtk_print_context_set_cairo_context".}
proc set_cairo_context*(self: PrintContext, cr: cairo1.TContext, dpi_x: float64, dpi_y: float64) {.inline.} =
  gtk_print_context_set_cairo_context(self, myUnsafeAddr(cr), dpi_x, dpi_y)
# proc set_cairo_context*(self: PrintContext, cr: cairo1.TContext, dpi_x: float64, dpi_y: float64) {.inline.} =

# gtk_print_operation_new
# flags: {isConstructor} container: PrintOperation
# need sugar: is static method
# 'PrintOperation' 'TransferFull[TPrintOperation]' (diff., need sugar)
proc gtk_print_operation_new(): TransferFull[TPrintOperation] {.cdecl, dynlib: lib, importc: "gtk_print_operation_new".}
proc new_printoperation*(): PrintOperation {.inline.} =
  wrap(gtk_print_operation_new())
# proc new_printoperation*(): PrintOperation {.inline.} =

# gtk_print_operation_cancel
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_cancel(self: ptr TPrintOperation) {.cdecl, dynlib: lib, importc: "gtk_print_operation_cancel".}
proc cancel*(self: PrintOperation) {.inline.} =
  gtk_print_operation_cancel(self)
# proc cancel*(self: PrintOperation) {.inline.} =

# gtk_print_operation_draw_page_finish
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_draw_page_finish(self: ptr TPrintOperation) {.cdecl, dynlib: lib, importc: "gtk_print_operation_draw_page_finish".}
proc draw_page_finish*(self: PrintOperation) {.inline.} =
  gtk_print_operation_draw_page_finish(self)
# proc draw_page_finish*(self: PrintOperation) {.inline.} =

# gtk_print_operation_get_default_page_setup
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# 'PageSetup' 'TransferNone[TPageSetup]' (diff., need sugar)
proc gtk_print_operation_get_default_page_setup(self: ptr TPrintOperation): TransferNone[TPageSetup] {.cdecl, dynlib: lib, importc: "gtk_print_operation_get_default_page_setup".}
proc get_default_page_setup*(self: PrintOperation): PageSetup {.inline.} =
  wrap(gtk_print_operation_get_default_page_setup(self))
# proc get_default_page_setup*(self: PrintOperation): PageSetup {.inline.} =

# gtk_print_operation_get_embed_page_setup
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# 'bool' 'bool'
proc gtk_print_operation_get_embed_page_setup(self: ptr TPrintOperation): bool {.cdecl, dynlib: lib, importc: "gtk_print_operation_get_embed_page_setup".}
proc get_embed_page_setup*(self: PrintOperation): bool {.inline.} =
  gtk_print_operation_get_embed_page_setup(self)
# proc get_embed_page_setup*(self: PrintOperation): bool {.inline.} =

# gtk_print_operation_get_error
# flags: {isMethod, throws} container: PrintOperation
# can throw
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_get_error(self: ptr TPrintOperation, error: ptr PGError=nil) {.cdecl, dynlib: lib, importc: "gtk_print_operation_get_error".}
proc get_error*(self: PrintOperation) {.inline.} =
  gtk_print_operation_get_error(self)
# proc get_error*(self: PrintOperation) {.inline.} =

# gtk_print_operation_get_has_selection
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# 'bool' 'bool'
proc gtk_print_operation_get_has_selection(self: ptr TPrintOperation): bool {.cdecl, dynlib: lib, importc: "gtk_print_operation_get_has_selection".}
proc get_has_selection*(self: PrintOperation): bool {.inline.} =
  gtk_print_operation_get_has_selection(self)
# proc get_has_selection*(self: PrintOperation): bool {.inline.} =

# gtk_print_operation_get_n_pages_to_print
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# 'int32' 'int32'
proc gtk_print_operation_get_n_pages_to_print(self: ptr TPrintOperation): int32 {.cdecl, dynlib: lib, importc: "gtk_print_operation_get_n_pages_to_print".}
proc get_n_pages_to_print*(self: PrintOperation): int32 {.inline.} =
  gtk_print_operation_get_n_pages_to_print(self)
# proc get_n_pages_to_print*(self: PrintOperation): int32 {.inline.} =

# gtk_print_operation_get_print_settings
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# 'PrintSettings' 'TransferNone[TPrintSettings]' (diff., need sugar)
proc gtk_print_operation_get_print_settings(self: ptr TPrintOperation): TransferNone[TPrintSettings] {.cdecl, dynlib: lib, importc: "gtk_print_operation_get_print_settings".}
proc get_print_settings*(self: PrintOperation): PrintSettings {.inline.} =
  wrap(gtk_print_operation_get_print_settings(self))
# proc get_print_settings*(self: PrintOperation): PrintSettings {.inline.} =

# gtk_print_operation_get_status
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# 'PrintStatus' 'PrintStatus'
proc gtk_print_operation_get_status(self: ptr TPrintOperation): PrintStatus {.cdecl, dynlib: lib, importc: "gtk_print_operation_get_status".}
proc get_status*(self: PrintOperation): PrintStatus {.inline.} =
  gtk_print_operation_get_status(self)
# proc get_status*(self: PrintOperation): PrintStatus {.inline.} =

# gtk_print_operation_get_status_string
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_print_operation_get_status_string(self: ptr TPrintOperation): ucstring {.cdecl, dynlib: lib, importc: "gtk_print_operation_get_status_string".}
proc get_status_string*(self: PrintOperation): ustring {.inline.} =
  ustring($(gtk_print_operation_get_status_string(self)))
# proc get_status_string*(self: PrintOperation): ustring {.inline.} =

# gtk_print_operation_get_support_selection
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# 'bool' 'bool'
proc gtk_print_operation_get_support_selection(self: ptr TPrintOperation): bool {.cdecl, dynlib: lib, importc: "gtk_print_operation_get_support_selection".}
proc get_support_selection*(self: PrintOperation): bool {.inline.} =
  gtk_print_operation_get_support_selection(self)
# proc get_support_selection*(self: PrintOperation): bool {.inline.} =

# gtk_print_operation_is_finished
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# 'bool' 'bool'
proc gtk_print_operation_is_finished(self: ptr TPrintOperation): bool {.cdecl, dynlib: lib, importc: "gtk_print_operation_is_finished".}
proc is_finished*(self: PrintOperation): bool {.inline.} =
  gtk_print_operation_is_finished(self)
# proc is_finished*(self: PrintOperation): bool {.inline.} =

# gtk_print_operation_run
# flags: {isMethod, throws} container: PrintOperation
# can throw
# need sugar: is method
# action 'PrintOperationAction' 'PrintOperationAction' IN
# parent 'Window' 'ptr TWindow' IN (diff., need sugar)
# 'PrintOperationResult' 'PrintOperationResult'
proc gtk_print_operation_run(self: ptr TPrintOperation, action: PrintOperationAction, parent: ptr TWindow, error: ptr PGError=nil): PrintOperationResult {.cdecl, dynlib: lib, importc: "gtk_print_operation_run".}
proc run*(self: PrintOperation, action: PrintOperationAction, parent: Window): PrintOperationResult {.inline.} =
  gtk_print_operation_run(self, action, parent.getPointer)
# proc run*(self: PrintOperation, action: PrintOperationAction, parent: Window): PrintOperationResult {.inline.} =

# gtk_print_operation_set_allow_async
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# allow_async 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_allow_async(self: ptr TPrintOperation, allow_async: bool) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_allow_async".}
proc set_allow_async*(self: PrintOperation, allow_async: bool) {.inline.} =
  gtk_print_operation_set_allow_async(self, allow_async)
# proc set_allow_async*(self: PrintOperation, allow_async: bool) {.inline.} =

# gtk_print_operation_set_current_page
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# current_page 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_current_page(self: ptr TPrintOperation, current_page: int32) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_current_page".}
proc set_current_page*(self: PrintOperation, current_page: int32) {.inline.} =
  gtk_print_operation_set_current_page(self, current_page)
# proc set_current_page*(self: PrintOperation, current_page: int32) {.inline.} =

# gtk_print_operation_set_custom_tab_label
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_custom_tab_label(self: ptr TPrintOperation, label: ucstring) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_custom_tab_label".}
proc set_custom_tab_label*(self: PrintOperation, label: ustring) {.inline.} =
  gtk_print_operation_set_custom_tab_label(self, ucstring(label))
# proc set_custom_tab_label*(self: PrintOperation, label: ustring) {.inline.} =

# gtk_print_operation_set_default_page_setup
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# default_page_setup 'PageSetup' 'ptr TPageSetup' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_default_page_setup(self: ptr TPrintOperation, default_page_setup: ptr TPageSetup) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_default_page_setup".}
proc set_default_page_setup*(self: PrintOperation, default_page_setup: PageSetup) {.inline.} =
  gtk_print_operation_set_default_page_setup(self, default_page_setup.getPointer)
# proc set_default_page_setup*(self: PrintOperation, default_page_setup: PageSetup) {.inline.} =

# gtk_print_operation_set_defer_drawing
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_defer_drawing(self: ptr TPrintOperation) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_defer_drawing".}
proc set_defer_drawing*(self: PrintOperation) {.inline.} =
  gtk_print_operation_set_defer_drawing(self)
# proc set_defer_drawing*(self: PrintOperation) {.inline.} =

# gtk_print_operation_set_embed_page_setup
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# embed 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_embed_page_setup(self: ptr TPrintOperation, embed: bool) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_embed_page_setup".}
proc set_embed_page_setup*(self: PrintOperation, embed: bool) {.inline.} =
  gtk_print_operation_set_embed_page_setup(self, embed)
# proc set_embed_page_setup*(self: PrintOperation, embed: bool) {.inline.} =

# gtk_print_operation_set_export_filename
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# filename 'string' 'cstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_export_filename(self: ptr TPrintOperation, filename: cstring) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_export_filename".}
proc set_export_filename*(self: PrintOperation, filename: string) {.inline.} =
  gtk_print_operation_set_export_filename(self, cstring(filename))
# proc set_export_filename*(self: PrintOperation, filename: string) {.inline.} =

# gtk_print_operation_set_has_selection
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# has_selection 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_has_selection(self: ptr TPrintOperation, has_selection: bool) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_has_selection".}
proc set_has_selection*(self: PrintOperation, has_selection: bool) {.inline.} =
  gtk_print_operation_set_has_selection(self, has_selection)
# proc set_has_selection*(self: PrintOperation, has_selection: bool) {.inline.} =

# gtk_print_operation_set_job_name
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# job_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_job_name(self: ptr TPrintOperation, job_name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_job_name".}
proc set_job_name*(self: PrintOperation, job_name: ustring) {.inline.} =
  gtk_print_operation_set_job_name(self, ucstring(job_name))
# proc set_job_name*(self: PrintOperation, job_name: ustring) {.inline.} =

# gtk_print_operation_set_n_pages
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# n_pages 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_n_pages(self: ptr TPrintOperation, n_pages: int32) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_n_pages".}
proc set_n_pages*(self: PrintOperation, n_pages: int32) {.inline.} =
  gtk_print_operation_set_n_pages(self, n_pages)
# proc set_n_pages*(self: PrintOperation, n_pages: int32) {.inline.} =

# gtk_print_operation_set_print_settings
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# print_settings 'PrintSettings' 'ptr TPrintSettings' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_print_settings(self: ptr TPrintOperation, print_settings: ptr TPrintSettings) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_print_settings".}
proc set_print_settings*(self: PrintOperation, print_settings: PrintSettings) {.inline.} =
  gtk_print_operation_set_print_settings(self, print_settings.getPointer)
# proc set_print_settings*(self: PrintOperation, print_settings: PrintSettings) {.inline.} =

# gtk_print_operation_set_show_progress
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# show_progress 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_show_progress(self: ptr TPrintOperation, show_progress: bool) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_show_progress".}
proc set_show_progress*(self: PrintOperation, show_progress: bool) {.inline.} =
  gtk_print_operation_set_show_progress(self, show_progress)
# proc set_show_progress*(self: PrintOperation, show_progress: bool) {.inline.} =

# gtk_print_operation_set_support_selection
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# support_selection 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_support_selection(self: ptr TPrintOperation, support_selection: bool) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_support_selection".}
proc set_support_selection*(self: PrintOperation, support_selection: bool) {.inline.} =
  gtk_print_operation_set_support_selection(self, support_selection)
# proc set_support_selection*(self: PrintOperation, support_selection: bool) {.inline.} =

# gtk_print_operation_set_track_print_status
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# track_status 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_track_print_status(self: ptr TPrintOperation, track_status: bool) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_track_print_status".}
proc set_track_print_status*(self: PrintOperation, track_status: bool) {.inline.} =
  gtk_print_operation_set_track_print_status(self, track_status)
# proc set_track_print_status*(self: PrintOperation, track_status: bool) {.inline.} =

# gtk_print_operation_set_unit
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# unit 'Unit' 'Unit' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_unit(self: ptr TPrintOperation, unit: Unit) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_unit".}
proc set_unit*(self: PrintOperation, unit: Unit) {.inline.} =
  gtk_print_operation_set_unit(self, unit)
# proc set_unit*(self: PrintOperation, unit: Unit) {.inline.} =

# gtk_print_operation_set_use_full_page
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# full_page 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_use_full_page(self: ptr TPrintOperation, full_page: bool) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_use_full_page".}
proc set_use_full_page*(self: PrintOperation, full_page: bool) {.inline.} =
  gtk_print_operation_set_use_full_page(self, full_page)
# proc set_use_full_page*(self: PrintOperation, full_page: bool) {.inline.} =

# gtk_print_settings_new
# flags: {isConstructor} container: PrintSettings
# need sugar: is static method
# 'PrintSettings' 'TransferFull[TPrintSettings]' (diff., need sugar)
proc gtk_print_settings_new(): TransferFull[TPrintSettings] {.cdecl, dynlib: lib, importc: "gtk_print_settings_new".}
proc new_printsettings*(): PrintSettings {.inline.} =
  wrap(gtk_print_settings_new())
# proc new_printsettings*(): PrintSettings {.inline.} =

# gtk_print_settings_new_from_file
# flags: {isConstructor, throws} container: PrintSettings
# can throw
# need sugar: is static method
# file_name 'string' 'cstring' IN (diff., need sugar)
# 'PrintSettings' 'TransferFull[TPrintSettings]' (diff., need sugar)
proc gtk_print_settings_new_from_file(file_name: cstring, error: ptr PGError=nil): TransferFull[TPrintSettings] {.cdecl, dynlib: lib, importc: "gtk_print_settings_new_from_file".}
proc new_printsettings_from_file*(file_name: string): PrintSettings {.inline.} =
  wrap(gtk_print_settings_new_from_file(cstring(file_name)))
# proc new_printsettings_from_file*(file_name: string): PrintSettings {.inline.} =

# gtk_print_settings_new_from_key_file
# flags: {isConstructor, throws} container: PrintSettings
# can throw
# need sugar: is static method
# key_file 'GLib2.TKeyFile' 'ptr GLib2.TKeyFile' IN (diff., need sugar)
# group_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'PrintSettings' 'TransferFull[TPrintSettings]' (diff., need sugar)
proc gtk_print_settings_new_from_key_file(key_file: ptr GLib2.TKeyFile, group_name: ucstring, error: ptr PGError=nil): TransferFull[TPrintSettings] {.cdecl, dynlib: lib, importc: "gtk_print_settings_new_from_key_file".}
proc new_printsettings_from_key_file*(key_file: GLib2.TKeyFile, group_name: ustring): PrintSettings {.inline.} =
  wrap(gtk_print_settings_new_from_key_file(myUnsafeAddr(key_file), ucstring(group_name)))
# proc new_printsettings_from_key_file*(key_file: GLib2.TKeyFile, group_name: ustring): PrintSettings {.inline.} =

# gtk_print_settings_copy
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# 'PrintSettings' 'TransferFull[TPrintSettings]' (diff., need sugar)
proc gtk_print_settings_copy(self: ptr TPrintSettings): TransferFull[TPrintSettings] {.cdecl, dynlib: lib, importc: "gtk_print_settings_copy".}
proc copy*(self: PrintSettings): PrintSettings {.inline.} =
  wrap(gtk_print_settings_copy(self))
# proc copy*(self: PrintSettings): PrintSettings {.inline.} =

# gtk_print_settings_foreach
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# func 'pointer' 'pointer' IN
# user_data 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_foreach(self: ptr TPrintSettings, func_x: pointer, user_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_print_settings_foreach".}
proc foreach*(self: PrintSettings, func_x: pointer, user_data: pointer) {.inline.} =
  gtk_print_settings_foreach(self, func_x, user_data)
# proc foreach*(self: PrintSettings, func_x: pointer, user_data: pointer) {.inline.} =

# gtk_print_settings_get
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# key 'ustring' 'ucstring' IN (diff., need sugar)
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_print_settings_get(self: ptr TPrintSettings, key: ucstring): ucstring {.cdecl, dynlib: lib, importc: "gtk_print_settings_get".}
proc get*(self: PrintSettings, key: ustring): ustring {.inline.} =
  ustring($(gtk_print_settings_get(self, ucstring(key))))
# proc get*(self: PrintSettings, key: ustring): ustring {.inline.} =

# gtk_print_settings_get_bool
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# key 'ustring' 'ucstring' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_print_settings_get_bool(self: ptr TPrintSettings, key: ucstring): bool {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_bool".}
proc get_bool*(self: PrintSettings, key: ustring): bool {.inline.} =
  gtk_print_settings_get_bool(self, ucstring(key))
# proc get_bool*(self: PrintSettings, key: ustring): bool {.inline.} =

# gtk_print_settings_get_collate
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# 'bool' 'bool'
proc gtk_print_settings_get_collate(self: ptr TPrintSettings): bool {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_collate".}
proc get_collate*(self: PrintSettings): bool {.inline.} =
  gtk_print_settings_get_collate(self)
# proc get_collate*(self: PrintSettings): bool {.inline.} =

# gtk_print_settings_get_default_source
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_print_settings_get_default_source(self: ptr TPrintSettings): ucstring {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_default_source".}
proc get_default_source*(self: PrintSettings): ustring {.inline.} =
  ustring($(gtk_print_settings_get_default_source(self)))
# proc get_default_source*(self: PrintSettings): ustring {.inline.} =

# gtk_print_settings_get_dither
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_print_settings_get_dither(self: ptr TPrintSettings): ucstring {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_dither".}
proc get_dither*(self: PrintSettings): ustring {.inline.} =
  ustring($(gtk_print_settings_get_dither(self)))
# proc get_dither*(self: PrintSettings): ustring {.inline.} =

# gtk_print_settings_get_double
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# key 'ustring' 'ucstring' IN (diff., need sugar)
# 'float64' 'float64'
proc gtk_print_settings_get_double(self: ptr TPrintSettings, key: ucstring): float64 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_double".}
proc get_double*(self: PrintSettings, key: ustring): float64 {.inline.} =
  gtk_print_settings_get_double(self, ucstring(key))
# proc get_double*(self: PrintSettings, key: ustring): float64 {.inline.} =

# gtk_print_settings_get_double_with_default
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# key 'ustring' 'ucstring' IN (diff., need sugar)
# def 'float64' 'float64' IN
# 'float64' 'float64'
proc gtk_print_settings_get_double_with_default(self: ptr TPrintSettings, key: ucstring, def: float64): float64 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_double_with_default".}
proc get_double_with_default*(self: PrintSettings, key: ustring, def: float64): float64 {.inline.} =
  gtk_print_settings_get_double_with_default(self, ucstring(key), def)
# proc get_double_with_default*(self: PrintSettings, key: ustring, def: float64): float64 {.inline.} =

# gtk_print_settings_get_duplex
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# 'PrintDuplex' 'PrintDuplex'
proc gtk_print_settings_get_duplex(self: ptr TPrintSettings): PrintDuplex {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_duplex".}
proc get_duplex*(self: PrintSettings): PrintDuplex {.inline.} =
  gtk_print_settings_get_duplex(self)
# proc get_duplex*(self: PrintSettings): PrintDuplex {.inline.} =

# gtk_print_settings_get_finishings
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_print_settings_get_finishings(self: ptr TPrintSettings): ucstring {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_finishings".}
proc get_finishings*(self: PrintSettings): ustring {.inline.} =
  ustring($(gtk_print_settings_get_finishings(self)))
# proc get_finishings*(self: PrintSettings): ustring {.inline.} =

# gtk_print_settings_get_int
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# key 'ustring' 'ucstring' IN (diff., need sugar)
# 'int32' 'int32'
proc gtk_print_settings_get_int(self: ptr TPrintSettings, key: ucstring): int32 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_int".}
proc get_int*(self: PrintSettings, key: ustring): int32 {.inline.} =
  gtk_print_settings_get_int(self, ucstring(key))
# proc get_int*(self: PrintSettings, key: ustring): int32 {.inline.} =

# gtk_print_settings_get_int_with_default
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# key 'ustring' 'ucstring' IN (diff., need sugar)
# def 'int32' 'int32' IN
# 'int32' 'int32'
proc gtk_print_settings_get_int_with_default(self: ptr TPrintSettings, key: ucstring, def: int32): int32 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_int_with_default".}
proc get_int_with_default*(self: PrintSettings, key: ustring, def: int32): int32 {.inline.} =
  gtk_print_settings_get_int_with_default(self, ucstring(key), def)
# proc get_int_with_default*(self: PrintSettings, key: ustring, def: int32): int32 {.inline.} =

# gtk_print_settings_get_length
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# key 'ustring' 'ucstring' IN (diff., need sugar)
# unit 'Unit' 'Unit' IN
# 'float64' 'float64'
proc gtk_print_settings_get_length(self: ptr TPrintSettings, key: ucstring, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_length".}
proc get_length*(self: PrintSettings, key: ustring, unit: Unit): float64 {.inline.} =
  gtk_print_settings_get_length(self, ucstring(key), unit)
# proc get_length*(self: PrintSettings, key: ustring, unit: Unit): float64 {.inline.} =

# gtk_print_settings_get_media_type
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_print_settings_get_media_type(self: ptr TPrintSettings): ucstring {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_media_type".}
proc get_media_type*(self: PrintSettings): ustring {.inline.} =
  ustring($(gtk_print_settings_get_media_type(self)))
# proc get_media_type*(self: PrintSettings): ustring {.inline.} =

# gtk_print_settings_get_n_copies
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# 'int32' 'int32'
proc gtk_print_settings_get_n_copies(self: ptr TPrintSettings): int32 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_n_copies".}
proc get_n_copies*(self: PrintSettings): int32 {.inline.} =
  gtk_print_settings_get_n_copies(self)
# proc get_n_copies*(self: PrintSettings): int32 {.inline.} =

# gtk_print_settings_get_number_up
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# 'int32' 'int32'
proc gtk_print_settings_get_number_up(self: ptr TPrintSettings): int32 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_number_up".}
proc get_number_up*(self: PrintSettings): int32 {.inline.} =
  gtk_print_settings_get_number_up(self)
# proc get_number_up*(self: PrintSettings): int32 {.inline.} =

# gtk_print_settings_get_number_up_layout
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# 'NumberUpLayout' 'NumberUpLayout'
proc gtk_print_settings_get_number_up_layout(self: ptr TPrintSettings): NumberUpLayout {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_number_up_layout".}
proc get_number_up_layout*(self: PrintSettings): NumberUpLayout {.inline.} =
  gtk_print_settings_get_number_up_layout(self)
# proc get_number_up_layout*(self: PrintSettings): NumberUpLayout {.inline.} =

# gtk_print_settings_get_orientation
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# 'PageOrientation' 'PageOrientation'
proc gtk_print_settings_get_orientation(self: ptr TPrintSettings): PageOrientation {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_orientation".}
proc get_orientation*(self: PrintSettings): PageOrientation {.inline.} =
  gtk_print_settings_get_orientation(self)
# proc get_orientation*(self: PrintSettings): PageOrientation {.inline.} =

# gtk_print_settings_get_output_bin
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_print_settings_get_output_bin(self: ptr TPrintSettings): ucstring {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_output_bin".}
proc get_output_bin*(self: PrintSettings): ustring {.inline.} =
  ustring($(gtk_print_settings_get_output_bin(self)))
# proc get_output_bin*(self: PrintSettings): ustring {.inline.} =

# gtk_print_settings_get_page_ranges
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# num_ranges 'var int32' 'ptr int32' OUT (diff., need sugar)
# 'zeroTerminatedArray[TPageRange]' 'zeroTerminatedArray[TPageRange]'
proc gtk_print_settings_get_page_ranges(self: ptr TPrintSettings, num_ranges: ptr int32): zeroTerminatedArray[TPageRange] {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_page_ranges".}
proc get_page_ranges*(self: PrintSettings, num_ranges: var int32): zeroTerminatedArray[TPageRange] {.inline.} =
  gtk_print_settings_get_page_ranges(self, addr(num_ranges))
# tuple-return
# num_ranges: var int32
# proc get_page_ranges*(self: PrintSettings): zeroTerminatedArray[TPageRange] {.inline.} =

# gtk_print_settings_get_page_set
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# 'PageSet' 'PageSet'
proc gtk_print_settings_get_page_set(self: ptr TPrintSettings): PageSet {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_page_set".}
proc get_page_set*(self: PrintSettings): PageSet {.inline.} =
  gtk_print_settings_get_page_set(self)
# proc get_page_set*(self: PrintSettings): PageSet {.inline.} =

# gtk_print_settings_get_paper_height
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# unit 'Unit' 'Unit' IN
# 'float64' 'float64'
proc gtk_print_settings_get_paper_height(self: ptr TPrintSettings, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_paper_height".}
proc get_paper_height*(self: PrintSettings, unit: Unit): float64 {.inline.} =
  gtk_print_settings_get_paper_height(self, unit)
# proc get_paper_height*(self: PrintSettings, unit: Unit): float64 {.inline.} =

# gtk_print_settings_get_paper_size
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# 'TPaperSize' 'ptr TPaperSize' (diff., need sugar)
proc gtk_print_settings_get_paper_size(self: ptr TPrintSettings): ptr TPaperSize {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_paper_size".}
proc get_paper_size*(self: PrintSettings): TPaperSize {.inline.} =
  (gtk_print_settings_get_paper_size(self))[]
# proc get_paper_size*(self: PrintSettings): TPaperSize {.inline.} =

# gtk_print_settings_get_paper_width
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# unit 'Unit' 'Unit' IN
# 'float64' 'float64'
proc gtk_print_settings_get_paper_width(self: ptr TPrintSettings, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_paper_width".}
proc get_paper_width*(self: PrintSettings, unit: Unit): float64 {.inline.} =
  gtk_print_settings_get_paper_width(self, unit)
# proc get_paper_width*(self: PrintSettings, unit: Unit): float64 {.inline.} =

# gtk_print_settings_get_print_pages
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# 'PrintPages' 'PrintPages'
proc gtk_print_settings_get_print_pages(self: ptr TPrintSettings): PrintPages {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_print_pages".}
proc get_print_pages*(self: PrintSettings): PrintPages {.inline.} =
  gtk_print_settings_get_print_pages(self)
# proc get_print_pages*(self: PrintSettings): PrintPages {.inline.} =

# gtk_print_settings_get_printer
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_print_settings_get_printer(self: ptr TPrintSettings): ucstring {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_printer".}
proc get_printer*(self: PrintSettings): ustring {.inline.} =
  ustring($(gtk_print_settings_get_printer(self)))
# proc get_printer*(self: PrintSettings): ustring {.inline.} =

# gtk_print_settings_get_printer_lpi
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# 'float64' 'float64'
proc gtk_print_settings_get_printer_lpi(self: ptr TPrintSettings): float64 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_printer_lpi".}
proc get_printer_lpi*(self: PrintSettings): float64 {.inline.} =
  gtk_print_settings_get_printer_lpi(self)
# proc get_printer_lpi*(self: PrintSettings): float64 {.inline.} =

# gtk_print_settings_get_quality
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# 'PrintQuality' 'PrintQuality'
proc gtk_print_settings_get_quality(self: ptr TPrintSettings): PrintQuality {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_quality".}
proc get_quality*(self: PrintSettings): PrintQuality {.inline.} =
  gtk_print_settings_get_quality(self)
# proc get_quality*(self: PrintSettings): PrintQuality {.inline.} =

# gtk_print_settings_get_resolution
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# 'int32' 'int32'
proc gtk_print_settings_get_resolution(self: ptr TPrintSettings): int32 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_resolution".}
proc get_resolution*(self: PrintSettings): int32 {.inline.} =
  gtk_print_settings_get_resolution(self)
# proc get_resolution*(self: PrintSettings): int32 {.inline.} =

# gtk_print_settings_get_resolution_x
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# 'int32' 'int32'
proc gtk_print_settings_get_resolution_x(self: ptr TPrintSettings): int32 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_resolution_x".}
proc get_resolution_x*(self: PrintSettings): int32 {.inline.} =
  gtk_print_settings_get_resolution_x(self)
# proc get_resolution_x*(self: PrintSettings): int32 {.inline.} =

# gtk_print_settings_get_resolution_y
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# 'int32' 'int32'
proc gtk_print_settings_get_resolution_y(self: ptr TPrintSettings): int32 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_resolution_y".}
proc get_resolution_y*(self: PrintSettings): int32 {.inline.} =
  gtk_print_settings_get_resolution_y(self)
# proc get_resolution_y*(self: PrintSettings): int32 {.inline.} =

# gtk_print_settings_get_reverse
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# 'bool' 'bool'
proc gtk_print_settings_get_reverse(self: ptr TPrintSettings): bool {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_reverse".}
proc get_reverse*(self: PrintSettings): bool {.inline.} =
  gtk_print_settings_get_reverse(self)
# proc get_reverse*(self: PrintSettings): bool {.inline.} =

# gtk_print_settings_get_scale
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# 'float64' 'float64'
proc gtk_print_settings_get_scale(self: ptr TPrintSettings): float64 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_scale".}
proc get_scale*(self: PrintSettings): float64 {.inline.} =
  gtk_print_settings_get_scale(self)
# proc get_scale*(self: PrintSettings): float64 {.inline.} =

# gtk_print_settings_get_use_color
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# 'bool' 'bool'
proc gtk_print_settings_get_use_color(self: ptr TPrintSettings): bool {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_use_color".}
proc get_use_color*(self: PrintSettings): bool {.inline.} =
  gtk_print_settings_get_use_color(self)
# proc get_use_color*(self: PrintSettings): bool {.inline.} =

# gtk_print_settings_has_key
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# key 'ustring' 'ucstring' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_print_settings_has_key(self: ptr TPrintSettings, key: ucstring): bool {.cdecl, dynlib: lib, importc: "gtk_print_settings_has_key".}
proc has_key*(self: PrintSettings, key: ustring): bool {.inline.} =
  gtk_print_settings_has_key(self, ucstring(key))
# proc has_key*(self: PrintSettings, key: ustring): bool {.inline.} =

# gtk_print_settings_load_file
# flags: {isMethod, throws} container: PrintSettings
# can throw
# need sugar: is method
# file_name 'string' 'cstring' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_print_settings_load_file(self: ptr TPrintSettings, file_name: cstring, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_print_settings_load_file".}
proc load_file*(self: PrintSettings, file_name: string): bool {.inline.} =
  gtk_print_settings_load_file(self, cstring(file_name))
# proc load_file*(self: PrintSettings, file_name: string): bool {.inline.} =

# gtk_print_settings_load_key_file
# flags: {isMethod, throws} container: PrintSettings
# can throw
# need sugar: is method
# key_file 'GLib2.TKeyFile' 'ptr GLib2.TKeyFile' IN (diff., need sugar)
# group_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_print_settings_load_key_file(self: ptr TPrintSettings, key_file: ptr GLib2.TKeyFile, group_name: ucstring, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_print_settings_load_key_file".}
proc load_key_file*(self: PrintSettings, key_file: GLib2.TKeyFile, group_name: ustring): bool {.inline.} =
  gtk_print_settings_load_key_file(self, myUnsafeAddr(key_file), ucstring(group_name))
# proc load_key_file*(self: PrintSettings, key_file: GLib2.TKeyFile, group_name: ustring): bool {.inline.} =

# gtk_print_settings_set
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# key 'ustring' 'ucstring' IN (diff., need sugar)
# value 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set(self: ptr TPrintSettings, key: ucstring, value: ucstring) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set".}
proc set*(self: PrintSettings, key: ustring, value: ustring) {.inline.} =
  gtk_print_settings_set(self, ucstring(key), ucstring(value))
# proc set*(self: PrintSettings, key: ustring, value: ustring) {.inline.} =

# gtk_print_settings_set_bool
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# key 'ustring' 'ucstring' IN (diff., need sugar)
# value 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_bool(self: ptr TPrintSettings, key: ucstring, value: bool) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_bool".}
proc set_bool*(self: PrintSettings, key: ustring, value: bool) {.inline.} =
  gtk_print_settings_set_bool(self, ucstring(key), value)
# proc set_bool*(self: PrintSettings, key: ustring, value: bool) {.inline.} =

# gtk_print_settings_set_collate
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# collate 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_collate(self: ptr TPrintSettings, collate: bool) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_collate".}
proc set_collate*(self: PrintSettings, collate: bool) {.inline.} =
  gtk_print_settings_set_collate(self, collate)
# proc set_collate*(self: PrintSettings, collate: bool) {.inline.} =

# gtk_print_settings_set_default_source
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# default_source 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_default_source(self: ptr TPrintSettings, default_source: ucstring) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_default_source".}
proc set_default_source*(self: PrintSettings, default_source: ustring) {.inline.} =
  gtk_print_settings_set_default_source(self, ucstring(default_source))
# proc set_default_source*(self: PrintSettings, default_source: ustring) {.inline.} =

# gtk_print_settings_set_dither
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# dither 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_dither(self: ptr TPrintSettings, dither: ucstring) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_dither".}
proc set_dither*(self: PrintSettings, dither: ustring) {.inline.} =
  gtk_print_settings_set_dither(self, ucstring(dither))
# proc set_dither*(self: PrintSettings, dither: ustring) {.inline.} =

# gtk_print_settings_set_double
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# key 'ustring' 'ucstring' IN (diff., need sugar)
# value 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_double(self: ptr TPrintSettings, key: ucstring, value: float64) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_double".}
proc set_double*(self: PrintSettings, key: ustring, value: float64) {.inline.} =
  gtk_print_settings_set_double(self, ucstring(key), value)
# proc set_double*(self: PrintSettings, key: ustring, value: float64) {.inline.} =

# gtk_print_settings_set_duplex
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# duplex 'PrintDuplex' 'PrintDuplex' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_duplex(self: ptr TPrintSettings, duplex: PrintDuplex) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_duplex".}
proc set_duplex*(self: PrintSettings, duplex: PrintDuplex) {.inline.} =
  gtk_print_settings_set_duplex(self, duplex)
# proc set_duplex*(self: PrintSettings, duplex: PrintDuplex) {.inline.} =

# gtk_print_settings_set_finishings
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# finishings 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_finishings(self: ptr TPrintSettings, finishings: ucstring) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_finishings".}
proc set_finishings*(self: PrintSettings, finishings: ustring) {.inline.} =
  gtk_print_settings_set_finishings(self, ucstring(finishings))
# proc set_finishings*(self: PrintSettings, finishings: ustring) {.inline.} =

# gtk_print_settings_set_int
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# key 'ustring' 'ucstring' IN (diff., need sugar)
# value 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_int(self: ptr TPrintSettings, key: ucstring, value: int32) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_int".}
proc set_int*(self: PrintSettings, key: ustring, value: int32) {.inline.} =
  gtk_print_settings_set_int(self, ucstring(key), value)
# proc set_int*(self: PrintSettings, key: ustring, value: int32) {.inline.} =

# gtk_print_settings_set_length
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# key 'ustring' 'ucstring' IN (diff., need sugar)
# value 'float64' 'float64' IN
# unit 'Unit' 'Unit' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_length(self: ptr TPrintSettings, key: ucstring, value: float64, unit: Unit) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_length".}
proc set_length*(self: PrintSettings, key: ustring, value: float64, unit: Unit) {.inline.} =
  gtk_print_settings_set_length(self, ucstring(key), value, unit)
# proc set_length*(self: PrintSettings, key: ustring, value: float64, unit: Unit) {.inline.} =

# gtk_print_settings_set_media_type
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# media_type 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_media_type(self: ptr TPrintSettings, media_type: ucstring) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_media_type".}
proc set_media_type*(self: PrintSettings, media_type: ustring) {.inline.} =
  gtk_print_settings_set_media_type(self, ucstring(media_type))
# proc set_media_type*(self: PrintSettings, media_type: ustring) {.inline.} =

# gtk_print_settings_set_n_copies
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# num_copies 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_n_copies(self: ptr TPrintSettings, num_copies: int32) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_n_copies".}
proc set_n_copies*(self: PrintSettings, num_copies: int32) {.inline.} =
  gtk_print_settings_set_n_copies(self, num_copies)
# proc set_n_copies*(self: PrintSettings, num_copies: int32) {.inline.} =

# gtk_print_settings_set_number_up
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# number_up 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_number_up(self: ptr TPrintSettings, number_up: int32) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_number_up".}
proc set_number_up*(self: PrintSettings, number_up: int32) {.inline.} =
  gtk_print_settings_set_number_up(self, number_up)
# proc set_number_up*(self: PrintSettings, number_up: int32) {.inline.} =

# gtk_print_settings_set_number_up_layout
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# number_up_layout 'NumberUpLayout' 'NumberUpLayout' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_number_up_layout(self: ptr TPrintSettings, number_up_layout: NumberUpLayout) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_number_up_layout".}
proc set_number_up_layout*(self: PrintSettings, number_up_layout: NumberUpLayout) {.inline.} =
  gtk_print_settings_set_number_up_layout(self, number_up_layout)
# proc set_number_up_layout*(self: PrintSettings, number_up_layout: NumberUpLayout) {.inline.} =

# gtk_print_settings_set_orientation
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# orientation 'PageOrientation' 'PageOrientation' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_orientation(self: ptr TPrintSettings, orientation: PageOrientation) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_orientation".}
proc set_orientation*(self: PrintSettings, orientation: PageOrientation) {.inline.} =
  gtk_print_settings_set_orientation(self, orientation)
# proc set_orientation*(self: PrintSettings, orientation: PageOrientation) {.inline.} =

# gtk_print_settings_set_output_bin
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# output_bin 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_output_bin(self: ptr TPrintSettings, output_bin: ucstring) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_output_bin".}
proc set_output_bin*(self: PrintSettings, output_bin: ustring) {.inline.} =
  gtk_print_settings_set_output_bin(self, ucstring(output_bin))
# proc set_output_bin*(self: PrintSettings, output_bin: ustring) {.inline.} =

# gtk_print_settings_set_page_ranges
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# page_ranges 'var openarray[TPageRange]' 'openarray[TPageRange]' IN (diff., need sugar) array lengthArg: 1
# num_ranges 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_page_ranges(self: ptr TPrintSettings, page_ranges: openarray[TPageRange], num_ranges: int32) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_page_ranges".}
proc set_page_ranges*(self: PrintSettings, page_ranges: var openarray[TPageRange]) {.inline.} =
  gtk_print_settings_set_page_ranges(self, page_ranges, page_ranges.len.int32)
# proc set_page_ranges*(self: PrintSettings, page_ranges: var openarray[TPageRange]) {.inline.} =

# gtk_print_settings_set_page_set
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# page_set 'PageSet' 'PageSet' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_page_set(self: ptr TPrintSettings, page_set: PageSet) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_page_set".}
proc set_page_set*(self: PrintSettings, page_set: PageSet) {.inline.} =
  gtk_print_settings_set_page_set(self, page_set)
# proc set_page_set*(self: PrintSettings, page_set: PageSet) {.inline.} =

# gtk_print_settings_set_paper_height
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# height 'float64' 'float64' IN
# unit 'Unit' 'Unit' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_paper_height(self: ptr TPrintSettings, height: float64, unit: Unit) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_paper_height".}
proc set_paper_height*(self: PrintSettings, height: float64, unit: Unit) {.inline.} =
  gtk_print_settings_set_paper_height(self, height, unit)
# proc set_paper_height*(self: PrintSettings, height: float64, unit: Unit) {.inline.} =

# gtk_print_settings_set_paper_size
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# paper_size 'TPaperSize' 'ptr TPaperSize' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_paper_size(self: ptr TPrintSettings, paper_size: ptr TPaperSize) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_paper_size".}
proc set_paper_size*(self: PrintSettings, paper_size: TPaperSize) {.inline.} =
  gtk_print_settings_set_paper_size(self, myUnsafeAddr(paper_size))
# proc set_paper_size*(self: PrintSettings, paper_size: TPaperSize) {.inline.} =

# gtk_print_settings_set_paper_width
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# width 'float64' 'float64' IN
# unit 'Unit' 'Unit' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_paper_width(self: ptr TPrintSettings, width: float64, unit: Unit) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_paper_width".}
proc set_paper_width*(self: PrintSettings, width: float64, unit: Unit) {.inline.} =
  gtk_print_settings_set_paper_width(self, width, unit)
# proc set_paper_width*(self: PrintSettings, width: float64, unit: Unit) {.inline.} =

# gtk_print_settings_set_print_pages
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# pages 'PrintPages' 'PrintPages' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_print_pages(self: ptr TPrintSettings, pages: PrintPages) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_print_pages".}
proc set_print_pages*(self: PrintSettings, pages: PrintPages) {.inline.} =
  gtk_print_settings_set_print_pages(self, pages)
# proc set_print_pages*(self: PrintSettings, pages: PrintPages) {.inline.} =

# gtk_print_settings_set_printer
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# printer 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_printer(self: ptr TPrintSettings, printer: ucstring) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_printer".}
proc set_printer*(self: PrintSettings, printer: ustring) {.inline.} =
  gtk_print_settings_set_printer(self, ucstring(printer))
# proc set_printer*(self: PrintSettings, printer: ustring) {.inline.} =

# gtk_print_settings_set_printer_lpi
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# lpi 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_printer_lpi(self: ptr TPrintSettings, lpi: float64) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_printer_lpi".}
proc set_printer_lpi*(self: PrintSettings, lpi: float64) {.inline.} =
  gtk_print_settings_set_printer_lpi(self, lpi)
# proc set_printer_lpi*(self: PrintSettings, lpi: float64) {.inline.} =

# gtk_print_settings_set_quality
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# quality 'PrintQuality' 'PrintQuality' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_quality(self: ptr TPrintSettings, quality: PrintQuality) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_quality".}
proc set_quality*(self: PrintSettings, quality: PrintQuality) {.inline.} =
  gtk_print_settings_set_quality(self, quality)
# proc set_quality*(self: PrintSettings, quality: PrintQuality) {.inline.} =

# gtk_print_settings_set_resolution
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# resolution 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_resolution(self: ptr TPrintSettings, resolution: int32) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_resolution".}
proc set_resolution*(self: PrintSettings, resolution: int32) {.inline.} =
  gtk_print_settings_set_resolution(self, resolution)
# proc set_resolution*(self: PrintSettings, resolution: int32) {.inline.} =

# gtk_print_settings_set_resolution_xy
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# resolution_x 'int32' 'int32' IN
# resolution_y 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_resolution_xy(self: ptr TPrintSettings, resolution_x: int32, resolution_y: int32) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_resolution_xy".}
proc set_resolution_xy*(self: PrintSettings, resolution_x: int32, resolution_y: int32) {.inline.} =
  gtk_print_settings_set_resolution_xy(self, resolution_x, resolution_y)
# proc set_resolution_xy*(self: PrintSettings, resolution_x: int32, resolution_y: int32) {.inline.} =

# gtk_print_settings_set_reverse
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# reverse 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_reverse(self: ptr TPrintSettings, reverse: bool) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_reverse".}
proc set_reverse*(self: PrintSettings, reverse: bool) {.inline.} =
  gtk_print_settings_set_reverse(self, reverse)
# proc set_reverse*(self: PrintSettings, reverse: bool) {.inline.} =

# gtk_print_settings_set_scale
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# scale 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_scale(self: ptr TPrintSettings, scale: float64) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_scale".}
proc set_scale*(self: PrintSettings, scale: float64) {.inline.} =
  gtk_print_settings_set_scale(self, scale)
# proc set_scale*(self: PrintSettings, scale: float64) {.inline.} =

# gtk_print_settings_set_use_color
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# use_color 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_use_color(self: ptr TPrintSettings, use_color: bool) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_use_color".}
proc set_use_color*(self: PrintSettings, use_color: bool) {.inline.} =
  gtk_print_settings_set_use_color(self, use_color)
# proc set_use_color*(self: PrintSettings, use_color: bool) {.inline.} =

# gtk_print_settings_to_file
# flags: {isMethod, throws} container: PrintSettings
# can throw
# need sugar: is method
# file_name 'string' 'cstring' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_print_settings_to_file(self: ptr TPrintSettings, file_name: cstring, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_print_settings_to_file".}
proc to_file*(self: PrintSettings, file_name: string): bool {.inline.} =
  gtk_print_settings_to_file(self, cstring(file_name))
# proc to_file*(self: PrintSettings, file_name: string): bool {.inline.} =

# gtk_print_settings_to_key_file
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# key_file 'GLib2.TKeyFile' 'ptr GLib2.TKeyFile' IN (diff., need sugar)
# group_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_to_key_file(self: ptr TPrintSettings, key_file: ptr GLib2.TKeyFile, group_name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_print_settings_to_key_file".}
proc to_key_file*(self: PrintSettings, key_file: GLib2.TKeyFile, group_name: ustring) {.inline.} =
  gtk_print_settings_to_key_file(self, myUnsafeAddr(key_file), ucstring(group_name))
# proc to_key_file*(self: PrintSettings, key_file: GLib2.TKeyFile, group_name: ustring) {.inline.} =

# gtk_print_settings_unset
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# key 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_unset(self: ptr TPrintSettings, key: ucstring) {.cdecl, dynlib: lib, importc: "gtk_print_settings_unset".}
proc unset*(self: PrintSettings, key: ustring) {.inline.} =
  gtk_print_settings_unset(self, ucstring(key))
# proc unset*(self: PrintSettings, key: ustring) {.inline.} =

# gtk_progress_bar_new
# flags: {isConstructor} container: ProgressBar
# need sugar: is static method
# 'ProgressBar' 'TransferNone[TProgressBar]' (diff., need sugar)
proc gtk_progress_bar_new(): TransferNone[TProgressBar] {.cdecl, dynlib: lib, importc: "gtk_progress_bar_new".}
proc new_progressbar*(): ProgressBar {.inline.} =
  wrap(gtk_progress_bar_new())
# proc new_progressbar*(): ProgressBar {.inline.} =

# gtk_progress_bar_get_ellipsize
# flags: {isMethod} container: ProgressBar
# need sugar: is method
# 'Pango1.EllipsizeMode' 'Pango1.EllipsizeMode'
proc gtk_progress_bar_get_ellipsize(self: ptr TProgressBar): Pango1.EllipsizeMode {.cdecl, dynlib: lib, importc: "gtk_progress_bar_get_ellipsize".}
proc get_ellipsize*(self: ProgressBar): Pango1.EllipsizeMode {.inline.} =
  gtk_progress_bar_get_ellipsize(self)
# proc get_ellipsize*(self: ProgressBar): Pango1.EllipsizeMode {.inline.} =

# gtk_progress_bar_get_fraction
# flags: {isMethod} container: ProgressBar
# need sugar: is method
# 'float64' 'float64'
proc gtk_progress_bar_get_fraction(self: ptr TProgressBar): float64 {.cdecl, dynlib: lib, importc: "gtk_progress_bar_get_fraction".}
proc get_fraction*(self: ProgressBar): float64 {.inline.} =
  gtk_progress_bar_get_fraction(self)
# proc get_fraction*(self: ProgressBar): float64 {.inline.} =

# gtk_progress_bar_get_inverted
# flags: {isMethod} container: ProgressBar
# need sugar: is method
# 'bool' 'bool'
proc gtk_progress_bar_get_inverted(self: ptr TProgressBar): bool {.cdecl, dynlib: lib, importc: "gtk_progress_bar_get_inverted".}
proc get_inverted*(self: ProgressBar): bool {.inline.} =
  gtk_progress_bar_get_inverted(self)
# proc get_inverted*(self: ProgressBar): bool {.inline.} =

# gtk_progress_bar_get_pulse_step
# flags: {isMethod} container: ProgressBar
# need sugar: is method
# 'float64' 'float64'
proc gtk_progress_bar_get_pulse_step(self: ptr TProgressBar): float64 {.cdecl, dynlib: lib, importc: "gtk_progress_bar_get_pulse_step".}
proc get_pulse_step*(self: ProgressBar): float64 {.inline.} =
  gtk_progress_bar_get_pulse_step(self)
# proc get_pulse_step*(self: ProgressBar): float64 {.inline.} =

# gtk_progress_bar_get_show_text
# flags: {isMethod} container: ProgressBar
# need sugar: is method
# 'bool' 'bool'
proc gtk_progress_bar_get_show_text(self: ptr TProgressBar): bool {.cdecl, dynlib: lib, importc: "gtk_progress_bar_get_show_text".}
proc get_show_text*(self: ProgressBar): bool {.inline.} =
  gtk_progress_bar_get_show_text(self)
# proc get_show_text*(self: ProgressBar): bool {.inline.} =

# gtk_progress_bar_get_text
# flags: {isMethod} container: ProgressBar
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_progress_bar_get_text(self: ptr TProgressBar): ucstring {.cdecl, dynlib: lib, importc: "gtk_progress_bar_get_text".}
proc get_text*(self: ProgressBar): ustring {.inline.} =
  ustring($(gtk_progress_bar_get_text(self)))
# proc get_text*(self: ProgressBar): ustring {.inline.} =

# gtk_progress_bar_pulse
# flags: {isMethod} container: ProgressBar
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_progress_bar_pulse(self: ptr TProgressBar) {.cdecl, dynlib: lib, importc: "gtk_progress_bar_pulse".}
proc pulse*(self: ProgressBar) {.inline.} =
  gtk_progress_bar_pulse(self)
# proc pulse*(self: ProgressBar) {.inline.} =

# gtk_progress_bar_set_ellipsize
# flags: {isMethod} container: ProgressBar
# need sugar: is method
# mode 'Pango1.EllipsizeMode' 'Pango1.EllipsizeMode' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_progress_bar_set_ellipsize(self: ptr TProgressBar, mode: Pango1.EllipsizeMode) {.cdecl, dynlib: lib, importc: "gtk_progress_bar_set_ellipsize".}
proc set_ellipsize*(self: ProgressBar, mode: Pango1.EllipsizeMode) {.inline.} =
  gtk_progress_bar_set_ellipsize(self, mode)
# proc set_ellipsize*(self: ProgressBar, mode: Pango1.EllipsizeMode) {.inline.} =

# gtk_progress_bar_set_fraction
# flags: {isMethod} container: ProgressBar
# need sugar: is method
# fraction 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_progress_bar_set_fraction(self: ptr TProgressBar, fraction: float64) {.cdecl, dynlib: lib, importc: "gtk_progress_bar_set_fraction".}
proc set_fraction*(self: ProgressBar, fraction: float64) {.inline.} =
  gtk_progress_bar_set_fraction(self, fraction)
# proc set_fraction*(self: ProgressBar, fraction: float64) {.inline.} =

# gtk_progress_bar_set_inverted
# flags: {isMethod} container: ProgressBar
# need sugar: is method
# inverted 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_progress_bar_set_inverted(self: ptr TProgressBar, inverted: bool) {.cdecl, dynlib: lib, importc: "gtk_progress_bar_set_inverted".}
proc set_inverted*(self: ProgressBar, inverted: bool) {.inline.} =
  gtk_progress_bar_set_inverted(self, inverted)
# proc set_inverted*(self: ProgressBar, inverted: bool) {.inline.} =

# gtk_progress_bar_set_pulse_step
# flags: {isMethod} container: ProgressBar
# need sugar: is method
# fraction 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_progress_bar_set_pulse_step(self: ptr TProgressBar, fraction: float64) {.cdecl, dynlib: lib, importc: "gtk_progress_bar_set_pulse_step".}
proc set_pulse_step*(self: ProgressBar, fraction: float64) {.inline.} =
  gtk_progress_bar_set_pulse_step(self, fraction)
# proc set_pulse_step*(self: ProgressBar, fraction: float64) {.inline.} =

# gtk_progress_bar_set_show_text
# flags: {isMethod} container: ProgressBar
# need sugar: is method
# show_text 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_progress_bar_set_show_text(self: ptr TProgressBar, show_text: bool) {.cdecl, dynlib: lib, importc: "gtk_progress_bar_set_show_text".}
proc set_show_text*(self: ProgressBar, show_text: bool) {.inline.} =
  gtk_progress_bar_set_show_text(self, show_text)
# proc set_show_text*(self: ProgressBar, show_text: bool) {.inline.} =

# gtk_progress_bar_set_text
# flags: {isMethod} container: ProgressBar
# need sugar: is method
# text 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_progress_bar_set_text(self: ptr TProgressBar, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_progress_bar_set_text".}
proc set_text*(self: ProgressBar, text: ustring) {.inline.} =
  gtk_progress_bar_set_text(self, ucstring(text))
# proc set_text*(self: ProgressBar, text: ustring) {.inline.} =

# gtk_radio_action_new
# flags: {isConstructor} container: RadioAction (deprecated)
# gtk_radio_action_get_current_value
# flags: {isMethod} container: RadioAction (deprecated)
# gtk_radio_action_get_group
# flags: {isMethod} container: RadioAction (deprecated)
# gtk_radio_action_join_group
# flags: {isMethod} container: RadioAction (deprecated)
# gtk_radio_action_set_current_value
# flags: {isMethod} container: RadioAction (deprecated)
# gtk_radio_action_set_group
# flags: {isMethod} container: RadioAction (deprecated)
# gtk_radio_button_new
# flags: {isConstructor} container: RadioButton
# need sugar: is static method
# group 'ptr GSLIST_TODO' 'ptr GSLIST_TODO' IN
# 'RadioButton' 'TransferNone[TRadioButton]' (diff., need sugar)
proc gtk_radio_button_new(group: ptr GSLIST_TODO): TransferNone[TRadioButton] {.cdecl, dynlib: lib, importc: "gtk_radio_button_new".}
proc new_radiobutton*(group: ptr GSLIST_TODO): RadioButton {.inline.} =
  wrap(gtk_radio_button_new(group))
# proc new_radiobutton*(group: ptr GSLIST_TODO): RadioButton {.inline.} =

# gtk_radio_button_new_from_widget
# flags: {isConstructor} container: RadioButton
# need sugar: is static method
# radio_group_member 'RadioButton' 'ptr TRadioButton' IN (diff., need sugar)
# 'RadioButton' 'TransferNone[TRadioButton]' (diff., need sugar)
proc gtk_radio_button_new_from_widget(radio_group_member: ptr TRadioButton): TransferNone[TRadioButton] {.cdecl, dynlib: lib, importc: "gtk_radio_button_new_from_widget".}
proc new_radiobutton_from_widget*(radio_group_member: RadioButton): RadioButton {.inline.} =
  wrap(gtk_radio_button_new_from_widget(radio_group_member.getPointer))
# proc new_radiobutton_from_widget*(radio_group_member: RadioButton): RadioButton {.inline.} =

# gtk_radio_button_new_with_label
# flags: {isConstructor} container: RadioButton
# need sugar: is static method
# group 'ptr GSLIST_TODO' 'ptr GSLIST_TODO' IN
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'RadioButton' 'TransferNone[TRadioButton]' (diff., need sugar)
proc gtk_radio_button_new_with_label(group: ptr GSLIST_TODO, label: ucstring): TransferNone[TRadioButton] {.cdecl, dynlib: lib, importc: "gtk_radio_button_new_with_label".}
proc new_radiobutton_with_label*(group: ptr GSLIST_TODO, label: ustring): RadioButton {.inline.} =
  wrap(gtk_radio_button_new_with_label(group, ucstring(label)))
# proc new_radiobutton_with_label*(group: ptr GSLIST_TODO, label: ustring): RadioButton {.inline.} =

# gtk_radio_button_new_with_label_from_widget
# flags: {isConstructor} container: RadioButton
# need sugar: is static method
# radio_group_member 'RadioButton' 'ptr TRadioButton' IN (diff., need sugar)
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'RadioButton' 'TransferNone[TRadioButton]' (diff., need sugar)
proc gtk_radio_button_new_with_label_from_widget(radio_group_member: ptr TRadioButton, label: ucstring): TransferNone[TRadioButton] {.cdecl, dynlib: lib, importc: "gtk_radio_button_new_with_label_from_widget".}
proc new_radiobutton_with_label_from_widget*(radio_group_member: RadioButton, label: ustring): RadioButton {.inline.} =
  wrap(gtk_radio_button_new_with_label_from_widget(radio_group_member.getPointer, ucstring(label)))
# proc new_radiobutton_with_label_from_widget*(radio_group_member: RadioButton, label: ustring): RadioButton {.inline.} =

# gtk_radio_button_new_with_mnemonic
# flags: {isConstructor} container: RadioButton
# need sugar: is static method
# group 'ptr GSLIST_TODO' 'ptr GSLIST_TODO' IN
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'RadioButton' 'TransferNone[TRadioButton]' (diff., need sugar)
proc gtk_radio_button_new_with_mnemonic(group: ptr GSLIST_TODO, label: ucstring): TransferNone[TRadioButton] {.cdecl, dynlib: lib, importc: "gtk_radio_button_new_with_mnemonic".}
proc new_radiobutton_with_mnemonic*(group: ptr GSLIST_TODO, label: ustring): RadioButton {.inline.} =
  wrap(gtk_radio_button_new_with_mnemonic(group, ucstring(label)))
# proc new_radiobutton_with_mnemonic*(group: ptr GSLIST_TODO, label: ustring): RadioButton {.inline.} =

# gtk_radio_button_new_with_mnemonic_from_widget
# flags: {isConstructor} container: RadioButton
# need sugar: is static method
# radio_group_member 'RadioButton' 'ptr TRadioButton' IN (diff., need sugar)
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'RadioButton' 'TransferNone[TRadioButton]' (diff., need sugar)
proc gtk_radio_button_new_with_mnemonic_from_widget(radio_group_member: ptr TRadioButton, label: ucstring): TransferNone[TRadioButton] {.cdecl, dynlib: lib, importc: "gtk_radio_button_new_with_mnemonic_from_widget".}
proc new_radiobutton_with_mnemonic_from_widget*(radio_group_member: RadioButton, label: ustring): RadioButton {.inline.} =
  wrap(gtk_radio_button_new_with_mnemonic_from_widget(radio_group_member.getPointer, ucstring(label)))
# proc new_radiobutton_with_mnemonic_from_widget*(radio_group_member: RadioButton, label: ustring): RadioButton {.inline.} =

# gtk_radio_button_get_group
# flags: {isMethod} container: RadioButton
# need sugar: is method
# 'ptr GSLIST_TODO' 'ptr GSLIST_TODO'
proc gtk_radio_button_get_group(self: ptr TRadioButton): ptr GSLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_radio_button_get_group".}
proc get_group*(self: RadioButton): ptr GSLIST_TODO {.inline.} =
  gtk_radio_button_get_group(self)
# proc get_group*(self: RadioButton): ptr GSLIST_TODO {.inline.} =

# gtk_radio_button_join_group
# flags: {isMethod} container: RadioButton
# need sugar: is method
# group_source 'RadioButton' 'ptr TRadioButton' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_radio_button_join_group(self: ptr TRadioButton, group_source: ptr TRadioButton) {.cdecl, dynlib: lib, importc: "gtk_radio_button_join_group".}
proc join_group*(self: RadioButton, group_source: RadioButton) {.inline.} =
  gtk_radio_button_join_group(self, group_source.getPointer)
# proc join_group*(self: RadioButton, group_source: RadioButton) {.inline.} =

# gtk_radio_button_set_group
# flags: {isMethod} container: RadioButton
# need sugar: is method
# group 'ptr GSLIST_TODO' 'ptr GSLIST_TODO' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_radio_button_set_group(self: ptr TRadioButton, group: ptr GSLIST_TODO) {.cdecl, dynlib: lib, importc: "gtk_radio_button_set_group".}
proc set_group*(self: RadioButton, group: ptr GSLIST_TODO) {.inline.} =
  gtk_radio_button_set_group(self, group)
# proc set_group*(self: RadioButton, group: ptr GSLIST_TODO) {.inline.} =

# gtk_radio_menu_item_new
# flags: {isConstructor} container: RadioMenuItem
# need sugar: is static method
# group 'ptr GSLIST_TODO' 'ptr GSLIST_TODO' IN
# 'RadioMenuItem' 'TransferNone[TRadioMenuItem]' (diff., need sugar)
proc gtk_radio_menu_item_new(group: ptr GSLIST_TODO): TransferNone[TRadioMenuItem] {.cdecl, dynlib: lib, importc: "gtk_radio_menu_item_new".}
proc new_radiomenuitem*(group: ptr GSLIST_TODO): RadioMenuItem {.inline.} =
  wrap(gtk_radio_menu_item_new(group))
# proc new_radiomenuitem*(group: ptr GSLIST_TODO): RadioMenuItem {.inline.} =

# gtk_radio_menu_item_new_from_widget
# flags: {isConstructor} container: RadioMenuItem
# need sugar: is static method
# group 'RadioMenuItem' 'ptr TRadioMenuItem' IN (diff., need sugar)
# 'RadioMenuItem' 'TransferNone[TRadioMenuItem]' (diff., need sugar)
proc gtk_radio_menu_item_new_from_widget(group: ptr TRadioMenuItem): TransferNone[TRadioMenuItem] {.cdecl, dynlib: lib, importc: "gtk_radio_menu_item_new_from_widget".}
proc new_radiomenuitem_from_widget*(group: RadioMenuItem): RadioMenuItem {.inline.} =
  wrap(gtk_radio_menu_item_new_from_widget(group.getPointer))
# proc new_radiomenuitem_from_widget*(group: RadioMenuItem): RadioMenuItem {.inline.} =

# gtk_radio_menu_item_new_with_label
# flags: {isConstructor} container: RadioMenuItem
# need sugar: is static method
# group 'ptr GSLIST_TODO' 'ptr GSLIST_TODO' IN
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'RadioMenuItem' 'TransferNone[TRadioMenuItem]' (diff., need sugar)
proc gtk_radio_menu_item_new_with_label(group: ptr GSLIST_TODO, label: ucstring): TransferNone[TRadioMenuItem] {.cdecl, dynlib: lib, importc: "gtk_radio_menu_item_new_with_label".}
proc new_radiomenuitem_with_label*(group: ptr GSLIST_TODO, label: ustring): RadioMenuItem {.inline.} =
  wrap(gtk_radio_menu_item_new_with_label(group, ucstring(label)))
# proc new_radiomenuitem_with_label*(group: ptr GSLIST_TODO, label: ustring): RadioMenuItem {.inline.} =

# gtk_radio_menu_item_new_with_label_from_widget
# flags: {isConstructor} container: RadioMenuItem
# need sugar: is static method
# group 'RadioMenuItem' 'ptr TRadioMenuItem' IN (diff., need sugar)
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'RadioMenuItem' 'TransferNone[TRadioMenuItem]' (diff., need sugar)
proc gtk_radio_menu_item_new_with_label_from_widget(group: ptr TRadioMenuItem, label: ucstring): TransferNone[TRadioMenuItem] {.cdecl, dynlib: lib, importc: "gtk_radio_menu_item_new_with_label_from_widget".}
proc new_radiomenuitem_with_label_from_widget*(group: RadioMenuItem, label: ustring): RadioMenuItem {.inline.} =
  wrap(gtk_radio_menu_item_new_with_label_from_widget(group.getPointer, ucstring(label)))
# proc new_radiomenuitem_with_label_from_widget*(group: RadioMenuItem, label: ustring): RadioMenuItem {.inline.} =

# gtk_radio_menu_item_new_with_mnemonic
# flags: {isConstructor} container: RadioMenuItem
# need sugar: is static method
# group 'ptr GSLIST_TODO' 'ptr GSLIST_TODO' IN
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'RadioMenuItem' 'TransferNone[TRadioMenuItem]' (diff., need sugar)
proc gtk_radio_menu_item_new_with_mnemonic(group: ptr GSLIST_TODO, label: ucstring): TransferNone[TRadioMenuItem] {.cdecl, dynlib: lib, importc: "gtk_radio_menu_item_new_with_mnemonic".}
proc new_radiomenuitem_with_mnemonic*(group: ptr GSLIST_TODO, label: ustring): RadioMenuItem {.inline.} =
  wrap(gtk_radio_menu_item_new_with_mnemonic(group, ucstring(label)))
# proc new_radiomenuitem_with_mnemonic*(group: ptr GSLIST_TODO, label: ustring): RadioMenuItem {.inline.} =

# gtk_radio_menu_item_new_with_mnemonic_from_widget
# flags: {isConstructor} container: RadioMenuItem
# need sugar: is static method
# group 'RadioMenuItem' 'ptr TRadioMenuItem' IN (diff., need sugar)
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'RadioMenuItem' 'TransferNone[TRadioMenuItem]' (diff., need sugar)
proc gtk_radio_menu_item_new_with_mnemonic_from_widget(group: ptr TRadioMenuItem, label: ucstring): TransferNone[TRadioMenuItem] {.cdecl, dynlib: lib, importc: "gtk_radio_menu_item_new_with_mnemonic_from_widget".}
proc new_radiomenuitem_with_mnemonic_from_widget*(group: RadioMenuItem, label: ustring): RadioMenuItem {.inline.} =
  wrap(gtk_radio_menu_item_new_with_mnemonic_from_widget(group.getPointer, ucstring(label)))
# proc new_radiomenuitem_with_mnemonic_from_widget*(group: RadioMenuItem, label: ustring): RadioMenuItem {.inline.} =

# gtk_radio_menu_item_get_group
# flags: {isMethod} container: RadioMenuItem
# need sugar: is method
# 'ptr GSLIST_TODO' 'ptr GSLIST_TODO'
proc gtk_radio_menu_item_get_group(self: ptr TRadioMenuItem): ptr GSLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_radio_menu_item_get_group".}
proc get_group*(self: RadioMenuItem): ptr GSLIST_TODO {.inline.} =
  gtk_radio_menu_item_get_group(self)
# proc get_group*(self: RadioMenuItem): ptr GSLIST_TODO {.inline.} =

# gtk_radio_menu_item_set_group
# flags: {isMethod} container: RadioMenuItem
# need sugar: is method
# group 'ptr GSLIST_TODO' 'ptr GSLIST_TODO' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_radio_menu_item_set_group(self: ptr TRadioMenuItem, group: ptr GSLIST_TODO) {.cdecl, dynlib: lib, importc: "gtk_radio_menu_item_set_group".}
proc set_group*(self: RadioMenuItem, group: ptr GSLIST_TODO) {.inline.} =
  gtk_radio_menu_item_set_group(self, group)
# proc set_group*(self: RadioMenuItem, group: ptr GSLIST_TODO) {.inline.} =

# gtk_radio_tool_button_new
# flags: {isConstructor} container: RadioToolButton
# need sugar: is static method
# group 'ptr GSLIST_TODO' 'ptr GSLIST_TODO' IN
# 'RadioToolButton' 'TransferNone[TRadioToolButton]' (diff., need sugar)
proc gtk_radio_tool_button_new(group: ptr GSLIST_TODO): TransferNone[TRadioToolButton] {.cdecl, dynlib: lib, importc: "gtk_radio_tool_button_new".}
proc new_radiotoolbutton*(group: ptr GSLIST_TODO): RadioToolButton {.inline.} =
  wrap(gtk_radio_tool_button_new(group))
# proc new_radiotoolbutton*(group: ptr GSLIST_TODO): RadioToolButton {.inline.} =

# gtk_radio_tool_button_new_from_stock
# flags: {isConstructor} container: RadioToolButton (deprecated)
# gtk_radio_tool_button_new_from_widget
# flags: {isConstructor} container: RadioToolButton
# need sugar: is static method
# group 'RadioToolButton' 'ptr TRadioToolButton' IN (diff., need sugar)
# 'RadioToolButton' 'TransferNone[TRadioToolButton]' (diff., need sugar)
proc gtk_radio_tool_button_new_from_widget(group: ptr TRadioToolButton): TransferNone[TRadioToolButton] {.cdecl, dynlib: lib, importc: "gtk_radio_tool_button_new_from_widget".}
proc new_radiotoolbutton_from_widget*(group: RadioToolButton): RadioToolButton {.inline.} =
  wrap(gtk_radio_tool_button_new_from_widget(group.getPointer))
# proc new_radiotoolbutton_from_widget*(group: RadioToolButton): RadioToolButton {.inline.} =

# gtk_radio_tool_button_new_with_stock_from_widget
# flags: {isConstructor} container: RadioToolButton (deprecated)
# gtk_radio_tool_button_get_group
# flags: {isMethod} container: RadioToolButton
# need sugar: is method
# 'ptr GSLIST_TODO' 'ptr GSLIST_TODO'
proc gtk_radio_tool_button_get_group(self: ptr TRadioToolButton): ptr GSLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_radio_tool_button_get_group".}
proc get_group*(self: RadioToolButton): ptr GSLIST_TODO {.inline.} =
  gtk_radio_tool_button_get_group(self)
# proc get_group*(self: RadioToolButton): ptr GSLIST_TODO {.inline.} =

# gtk_radio_tool_button_set_group
# flags: {isMethod} container: RadioToolButton
# need sugar: is method
# group 'ptr GSLIST_TODO' 'ptr GSLIST_TODO' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_radio_tool_button_set_group(self: ptr TRadioToolButton, group: ptr GSLIST_TODO) {.cdecl, dynlib: lib, importc: "gtk_radio_tool_button_set_group".}
proc set_group*(self: RadioToolButton, group: ptr GSLIST_TODO) {.inline.} =
  gtk_radio_tool_button_set_group(self, group)
# proc set_group*(self: RadioToolButton, group: ptr GSLIST_TODO) {.inline.} =

# gtk_range_get_adjustment
# flags: {isMethod} container: Range
# need sugar: is method
# 'Adjustment' 'TransferNone[TAdjustment]' (diff., need sugar)
proc gtk_range_get_adjustment(self: ptr TRange): TransferNone[TAdjustment] {.cdecl, dynlib: lib, importc: "gtk_range_get_adjustment".}
proc get_adjustment*(self: Range): Adjustment {.inline.} =
  wrap(gtk_range_get_adjustment(self))
# proc get_adjustment*(self: Range): Adjustment {.inline.} =

# gtk_range_get_fill_level
# flags: {isMethod} container: Range
# need sugar: is method
# 'float64' 'float64'
proc gtk_range_get_fill_level(self: ptr TRange): float64 {.cdecl, dynlib: lib, importc: "gtk_range_get_fill_level".}
proc get_fill_level*(self: Range): float64 {.inline.} =
  gtk_range_get_fill_level(self)
# proc get_fill_level*(self: Range): float64 {.inline.} =

# gtk_range_get_flippable
# flags: {isMethod} container: Range
# need sugar: is method
# 'bool' 'bool'
proc gtk_range_get_flippable(self: ptr TRange): bool {.cdecl, dynlib: lib, importc: "gtk_range_get_flippable".}
proc get_flippable*(self: Range): bool {.inline.} =
  gtk_range_get_flippable(self)
# proc get_flippable*(self: Range): bool {.inline.} =

# gtk_range_get_inverted
# flags: {isMethod} container: Range
# need sugar: is method
# 'bool' 'bool'
proc gtk_range_get_inverted(self: ptr TRange): bool {.cdecl, dynlib: lib, importc: "gtk_range_get_inverted".}
proc get_inverted*(self: Range): bool {.inline.} =
  gtk_range_get_inverted(self)
# proc get_inverted*(self: Range): bool {.inline.} =

# gtk_range_get_lower_stepper_sensitivity
# flags: {isMethod} container: Range
# need sugar: is method
# 'SensitivityType' 'SensitivityType'
proc gtk_range_get_lower_stepper_sensitivity(self: ptr TRange): SensitivityType {.cdecl, dynlib: lib, importc: "gtk_range_get_lower_stepper_sensitivity".}
proc get_lower_stepper_sensitivity*(self: Range): SensitivityType {.inline.} =
  gtk_range_get_lower_stepper_sensitivity(self)
# proc get_lower_stepper_sensitivity*(self: Range): SensitivityType {.inline.} =

# gtk_range_get_min_slider_size
# flags: {isMethod} container: Range
# need sugar: is method
# 'int32' 'int32'
proc gtk_range_get_min_slider_size(self: ptr TRange): int32 {.cdecl, dynlib: lib, importc: "gtk_range_get_min_slider_size".}
proc get_min_slider_size*(self: Range): int32 {.inline.} =
  gtk_range_get_min_slider_size(self)
# proc get_min_slider_size*(self: Range): int32 {.inline.} =

# gtk_range_get_range_rect
# flags: {isMethod} container: Range
# need sugar: is method
# range_rect 'var cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_range_get_range_rect(self: ptr TRange, range_rect: ptr cairo1.TRectangleInt) {.cdecl, dynlib: lib, importc: "gtk_range_get_range_rect".}
proc get_range_rect*(self: Range, range_rect: var cairo1.TRectangleInt) {.inline.} =
  gtk_range_get_range_rect(self, addr(range_rect))
# tuple-return
# range_rect: var cairo1.TRectangleInt
# proc get_range_rect*(self: Range) {.inline.} =

# gtk_range_get_restrict_to_fill_level
# flags: {isMethod} container: Range
# need sugar: is method
# 'bool' 'bool'
proc gtk_range_get_restrict_to_fill_level(self: ptr TRange): bool {.cdecl, dynlib: lib, importc: "gtk_range_get_restrict_to_fill_level".}
proc get_restrict_to_fill_level*(self: Range): bool {.inline.} =
  gtk_range_get_restrict_to_fill_level(self)
# proc get_restrict_to_fill_level*(self: Range): bool {.inline.} =

# gtk_range_get_round_digits
# flags: {isMethod} container: Range
# need sugar: is method
# 'int32' 'int32'
proc gtk_range_get_round_digits(self: ptr TRange): int32 {.cdecl, dynlib: lib, importc: "gtk_range_get_round_digits".}
proc get_round_digits*(self: Range): int32 {.inline.} =
  gtk_range_get_round_digits(self)
# proc get_round_digits*(self: Range): int32 {.inline.} =

# gtk_range_get_show_fill_level
# flags: {isMethod} container: Range
# need sugar: is method
# 'bool' 'bool'
proc gtk_range_get_show_fill_level(self: ptr TRange): bool {.cdecl, dynlib: lib, importc: "gtk_range_get_show_fill_level".}
proc get_show_fill_level*(self: Range): bool {.inline.} =
  gtk_range_get_show_fill_level(self)
# proc get_show_fill_level*(self: Range): bool {.inline.} =

# gtk_range_get_slider_range
# flags: {isMethod} container: Range
# need sugar: is method
# slider_start 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# slider_end 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_range_get_slider_range(self: ptr TRange, slider_start: ptr int32, slider_end: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_range_get_slider_range".}
proc get_slider_range*(self: Range, slider_start: var int32, slider_end: var int32) {.inline.} =
  gtk_range_get_slider_range(self, addr(slider_start), addr(slider_end))
# tuple-return
# slider_start: var int32
# slider_end: var int32
# proc get_slider_range*(self: Range) {.inline.} =

# gtk_range_get_slider_size_fixed
# flags: {isMethod} container: Range
# need sugar: is method
# 'bool' 'bool'
proc gtk_range_get_slider_size_fixed(self: ptr TRange): bool {.cdecl, dynlib: lib, importc: "gtk_range_get_slider_size_fixed".}
proc get_slider_size_fixed*(self: Range): bool {.inline.} =
  gtk_range_get_slider_size_fixed(self)
# proc get_slider_size_fixed*(self: Range): bool {.inline.} =

# gtk_range_get_upper_stepper_sensitivity
# flags: {isMethod} container: Range
# need sugar: is method
# 'SensitivityType' 'SensitivityType'
proc gtk_range_get_upper_stepper_sensitivity(self: ptr TRange): SensitivityType {.cdecl, dynlib: lib, importc: "gtk_range_get_upper_stepper_sensitivity".}
proc get_upper_stepper_sensitivity*(self: Range): SensitivityType {.inline.} =
  gtk_range_get_upper_stepper_sensitivity(self)
# proc get_upper_stepper_sensitivity*(self: Range): SensitivityType {.inline.} =

# gtk_range_get_value
# flags: {isMethod} container: Range
# need sugar: is method
# 'float64' 'float64'
proc gtk_range_get_value(self: ptr TRange): float64 {.cdecl, dynlib: lib, importc: "gtk_range_get_value".}
proc get_value*(self: Range): float64 {.inline.} =
  gtk_range_get_value(self)
# proc get_value*(self: Range): float64 {.inline.} =

# gtk_range_set_adjustment
# flags: {isMethod} container: Range
# need sugar: is method
# adjustment 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_adjustment(self: ptr TRange, adjustment: ptr TAdjustment) {.cdecl, dynlib: lib, importc: "gtk_range_set_adjustment".}
proc set_adjustment*(self: Range, adjustment: Adjustment) {.inline.} =
  gtk_range_set_adjustment(self, adjustment.getPointer)
# proc set_adjustment*(self: Range, adjustment: Adjustment) {.inline.} =

# gtk_range_set_fill_level
# flags: {isMethod} container: Range
# need sugar: is method
# fill_level 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_fill_level(self: ptr TRange, fill_level: float64) {.cdecl, dynlib: lib, importc: "gtk_range_set_fill_level".}
proc set_fill_level*(self: Range, fill_level: float64) {.inline.} =
  gtk_range_set_fill_level(self, fill_level)
# proc set_fill_level*(self: Range, fill_level: float64) {.inline.} =

# gtk_range_set_flippable
# flags: {isMethod} container: Range
# need sugar: is method
# flippable 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_flippable(self: ptr TRange, flippable: bool) {.cdecl, dynlib: lib, importc: "gtk_range_set_flippable".}
proc set_flippable*(self: Range, flippable: bool) {.inline.} =
  gtk_range_set_flippable(self, flippable)
# proc set_flippable*(self: Range, flippable: bool) {.inline.} =

# gtk_range_set_increments
# flags: {isMethod} container: Range
# need sugar: is method
# step 'float64' 'float64' IN
# page 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_increments(self: ptr TRange, step: float64, page: float64) {.cdecl, dynlib: lib, importc: "gtk_range_set_increments".}
proc set_increments*(self: Range, step: float64, page: float64) {.inline.} =
  gtk_range_set_increments(self, step, page)
# proc set_increments*(self: Range, step: float64, page: float64) {.inline.} =

# gtk_range_set_inverted
# flags: {isMethod} container: Range
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_inverted(self: ptr TRange, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_range_set_inverted".}
proc set_inverted*(self: Range, setting: bool) {.inline.} =
  gtk_range_set_inverted(self, setting)
# proc set_inverted*(self: Range, setting: bool) {.inline.} =

# gtk_range_set_lower_stepper_sensitivity
# flags: {isMethod} container: Range
# need sugar: is method
# sensitivity 'SensitivityType' 'SensitivityType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_lower_stepper_sensitivity(self: ptr TRange, sensitivity: SensitivityType) {.cdecl, dynlib: lib, importc: "gtk_range_set_lower_stepper_sensitivity".}
proc set_lower_stepper_sensitivity*(self: Range, sensitivity: SensitivityType) {.inline.} =
  gtk_range_set_lower_stepper_sensitivity(self, sensitivity)
# proc set_lower_stepper_sensitivity*(self: Range, sensitivity: SensitivityType) {.inline.} =

# gtk_range_set_min_slider_size
# flags: {isMethod} container: Range
# need sugar: is method
# min_size 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_min_slider_size(self: ptr TRange, min_size: int32) {.cdecl, dynlib: lib, importc: "gtk_range_set_min_slider_size".}
proc set_min_slider_size*(self: Range, min_size: int32) {.inline.} =
  gtk_range_set_min_slider_size(self, min_size)
# proc set_min_slider_size*(self: Range, min_size: int32) {.inline.} =

# gtk_range_set_range
# flags: {isMethod} container: Range
# need sugar: is method
# min 'float64' 'float64' IN
# max 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_range(self: ptr TRange, min: float64, max: float64) {.cdecl, dynlib: lib, importc: "gtk_range_set_range".}
proc set_range*(self: Range, min: float64, max: float64) {.inline.} =
  gtk_range_set_range(self, min, max)
# proc set_range*(self: Range, min: float64, max: float64) {.inline.} =

# gtk_range_set_restrict_to_fill_level
# flags: {isMethod} container: Range
# need sugar: is method
# restrict_to_fill_level 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_restrict_to_fill_level(self: ptr TRange, restrict_to_fill_level: bool) {.cdecl, dynlib: lib, importc: "gtk_range_set_restrict_to_fill_level".}
proc set_restrict_to_fill_level*(self: Range, restrict_to_fill_level: bool) {.inline.} =
  gtk_range_set_restrict_to_fill_level(self, restrict_to_fill_level)
# proc set_restrict_to_fill_level*(self: Range, restrict_to_fill_level: bool) {.inline.} =

# gtk_range_set_round_digits
# flags: {isMethod} container: Range
# need sugar: is method
# round_digits 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_round_digits(self: ptr TRange, round_digits: int32) {.cdecl, dynlib: lib, importc: "gtk_range_set_round_digits".}
proc set_round_digits*(self: Range, round_digits: int32) {.inline.} =
  gtk_range_set_round_digits(self, round_digits)
# proc set_round_digits*(self: Range, round_digits: int32) {.inline.} =

# gtk_range_set_show_fill_level
# flags: {isMethod} container: Range
# need sugar: is method
# show_fill_level 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_show_fill_level(self: ptr TRange, show_fill_level: bool) {.cdecl, dynlib: lib, importc: "gtk_range_set_show_fill_level".}
proc set_show_fill_level*(self: Range, show_fill_level: bool) {.inline.} =
  gtk_range_set_show_fill_level(self, show_fill_level)
# proc set_show_fill_level*(self: Range, show_fill_level: bool) {.inline.} =

# gtk_range_set_slider_size_fixed
# flags: {isMethod} container: Range
# need sugar: is method
# size_fixed 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_slider_size_fixed(self: ptr TRange, size_fixed: bool) {.cdecl, dynlib: lib, importc: "gtk_range_set_slider_size_fixed".}
proc set_slider_size_fixed*(self: Range, size_fixed: bool) {.inline.} =
  gtk_range_set_slider_size_fixed(self, size_fixed)
# proc set_slider_size_fixed*(self: Range, size_fixed: bool) {.inline.} =

# gtk_range_set_upper_stepper_sensitivity
# flags: {isMethod} container: Range
# need sugar: is method
# sensitivity 'SensitivityType' 'SensitivityType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_upper_stepper_sensitivity(self: ptr TRange, sensitivity: SensitivityType) {.cdecl, dynlib: lib, importc: "gtk_range_set_upper_stepper_sensitivity".}
proc set_upper_stepper_sensitivity*(self: Range, sensitivity: SensitivityType) {.inline.} =
  gtk_range_set_upper_stepper_sensitivity(self, sensitivity)
# proc set_upper_stepper_sensitivity*(self: Range, sensitivity: SensitivityType) {.inline.} =

# gtk_range_set_value
# flags: {isMethod} container: Range
# need sugar: is method
# value 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_value(self: ptr TRange, value: float64) {.cdecl, dynlib: lib, importc: "gtk_range_set_value".}
proc set_value*(self: Range, value: float64) {.inline.} =
  gtk_range_set_value(self, value)
# proc set_value*(self: Range, value: float64) {.inline.} =

# gtk_rc_style_new
# flags: {isConstructor} container: RcStyle (deprecated)
# gtk_rc_style_copy
# flags: {isMethod} container: RcStyle (deprecated)
# gtk_recent_action_new
# flags: {isConstructor} container: RecentAction (deprecated)
# gtk_recent_action_new_for_manager
# flags: {isConstructor} container: RecentAction (deprecated)
# gtk_recent_action_get_show_numbers
# flags: {isMethod} container: RecentAction (deprecated)
# gtk_recent_action_set_show_numbers
# flags: {isMethod} container: RecentAction (deprecated)
# gtk_recent_chooser_menu_new
# flags: {isConstructor} container: RecentChooserMenu
# need sugar: is static method
# 'RecentChooserMenu' 'TransferNone[TRecentChooserMenu]' (diff., need sugar)
proc gtk_recent_chooser_menu_new(): TransferNone[TRecentChooserMenu] {.cdecl, dynlib: lib, importc: "gtk_recent_chooser_menu_new".}
proc new_recentchoosermenu*(): RecentChooserMenu {.inline.} =
  wrap(gtk_recent_chooser_menu_new())
# proc new_recentchoosermenu*(): RecentChooserMenu {.inline.} =

# gtk_recent_chooser_menu_new_for_manager
# flags: {isConstructor} container: RecentChooserMenu
# need sugar: is static method
# manager 'RecentManager' 'ptr TRecentManager' IN (diff., need sugar)
# 'RecentChooserMenu' 'TransferNone[TRecentChooserMenu]' (diff., need sugar)
proc gtk_recent_chooser_menu_new_for_manager(manager: ptr TRecentManager): TransferNone[TRecentChooserMenu] {.cdecl, dynlib: lib, importc: "gtk_recent_chooser_menu_new_for_manager".}
proc new_recentchoosermenu_for_manager*(manager: RecentManager): RecentChooserMenu {.inline.} =
  wrap(gtk_recent_chooser_menu_new_for_manager(manager.getPointer))
# proc new_recentchoosermenu_for_manager*(manager: RecentManager): RecentChooserMenu {.inline.} =

# gtk_recent_chooser_menu_get_show_numbers
# flags: {isMethod} container: RecentChooserMenu
# need sugar: is method
# 'bool' 'bool'
proc gtk_recent_chooser_menu_get_show_numbers(self: ptr TRecentChooserMenu): bool {.cdecl, dynlib: lib, importc: "gtk_recent_chooser_menu_get_show_numbers".}
proc get_show_numbers*(self: RecentChooserMenu): bool {.inline.} =
  gtk_recent_chooser_menu_get_show_numbers(self)
# proc get_show_numbers*(self: RecentChooserMenu): bool {.inline.} =

# gtk_recent_chooser_menu_set_show_numbers
# flags: {isMethod} container: RecentChooserMenu
# need sugar: is method
# show_numbers 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_recent_chooser_menu_set_show_numbers(self: ptr TRecentChooserMenu, show_numbers: bool) {.cdecl, dynlib: lib, importc: "gtk_recent_chooser_menu_set_show_numbers".}
proc set_show_numbers*(self: RecentChooserMenu, show_numbers: bool) {.inline.} =
  gtk_recent_chooser_menu_set_show_numbers(self, show_numbers)
# proc set_show_numbers*(self: RecentChooserMenu, show_numbers: bool) {.inline.} =

# gtk_recent_chooser_widget_new
# flags: {isConstructor} container: RecentChooserWidget
# need sugar: is static method
# 'RecentChooserWidget' 'TransferNone[TRecentChooserWidget]' (diff., need sugar)
proc gtk_recent_chooser_widget_new(): TransferNone[TRecentChooserWidget] {.cdecl, dynlib: lib, importc: "gtk_recent_chooser_widget_new".}
proc new_recentchooserwidget*(): RecentChooserWidget {.inline.} =
  wrap(gtk_recent_chooser_widget_new())
# proc new_recentchooserwidget*(): RecentChooserWidget {.inline.} =

# gtk_recent_chooser_widget_new_for_manager
# flags: {isConstructor} container: RecentChooserWidget
# need sugar: is static method
# manager 'RecentManager' 'ptr TRecentManager' IN (diff., need sugar)
# 'RecentChooserWidget' 'TransferNone[TRecentChooserWidget]' (diff., need sugar)
proc gtk_recent_chooser_widget_new_for_manager(manager: ptr TRecentManager): TransferNone[TRecentChooserWidget] {.cdecl, dynlib: lib, importc: "gtk_recent_chooser_widget_new_for_manager".}
proc new_recentchooserwidget_for_manager*(manager: RecentManager): RecentChooserWidget {.inline.} =
  wrap(gtk_recent_chooser_widget_new_for_manager(manager.getPointer))
# proc new_recentchooserwidget_for_manager*(manager: RecentManager): RecentChooserWidget {.inline.} =

# gtk_recent_filter_new
# flags: {isConstructor} container: RecentFilter
# need sugar: is static method
# 'RecentFilter' 'TransferNone[TRecentFilter]' (diff., need sugar)
proc gtk_recent_filter_new(): TransferNone[TRecentFilter] {.cdecl, dynlib: lib, importc: "gtk_recent_filter_new".}
proc new_recentfilter*(): RecentFilter {.inline.} =
  wrap(gtk_recent_filter_new())
# proc new_recentfilter*(): RecentFilter {.inline.} =

# gtk_recent_filter_add_age
# flags: {isMethod} container: RecentFilter
# need sugar: is method
# days 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_recent_filter_add_age(self: ptr TRecentFilter, days: int32) {.cdecl, dynlib: lib, importc: "gtk_recent_filter_add_age".}
proc add_age*(self: RecentFilter, days: int32) {.inline.} =
  gtk_recent_filter_add_age(self, days)
# proc add_age*(self: RecentFilter, days: int32) {.inline.} =

# gtk_recent_filter_add_application
# flags: {isMethod} container: RecentFilter
# need sugar: is method
# application 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_recent_filter_add_application(self: ptr TRecentFilter, application: ucstring) {.cdecl, dynlib: lib, importc: "gtk_recent_filter_add_application".}
proc add_application*(self: RecentFilter, application: ustring) {.inline.} =
  gtk_recent_filter_add_application(self, ucstring(application))
# proc add_application*(self: RecentFilter, application: ustring) {.inline.} =

# gtk_recent_filter_add_custom
# flags: {isMethod} container: RecentFilter
# need sugar: is method
# needed 'SRecentFilterFlags' 'SRecentFilterFlags' IN
# func 'pointer' 'pointer' IN
# data 'pointer' 'pointer' IN
# data_destroy 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_recent_filter_add_custom(self: ptr TRecentFilter, needed: SRecentFilterFlags, func_x: pointer, data: pointer, data_destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_recent_filter_add_custom".}
proc add_custom*(self: RecentFilter, needed: SRecentFilterFlags, func_x: pointer, data: pointer, data_destroy: pointer) {.inline.} =
  gtk_recent_filter_add_custom(self, needed, func_x, data, data_destroy)
# proc add_custom*(self: RecentFilter, needed: SRecentFilterFlags, func_x: pointer, data: pointer, data_destroy: pointer) {.inline.} =

# gtk_recent_filter_add_group
# flags: {isMethod} container: RecentFilter
# need sugar: is method
# group 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_recent_filter_add_group(self: ptr TRecentFilter, group: ucstring) {.cdecl, dynlib: lib, importc: "gtk_recent_filter_add_group".}
proc add_group*(self: RecentFilter, group: ustring) {.inline.} =
  gtk_recent_filter_add_group(self, ucstring(group))
# proc add_group*(self: RecentFilter, group: ustring) {.inline.} =

# gtk_recent_filter_add_mime_type
# flags: {isMethod} container: RecentFilter
# need sugar: is method
# mime_type 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_recent_filter_add_mime_type(self: ptr TRecentFilter, mime_type: ucstring) {.cdecl, dynlib: lib, importc: "gtk_recent_filter_add_mime_type".}
proc add_mime_type*(self: RecentFilter, mime_type: ustring) {.inline.} =
  gtk_recent_filter_add_mime_type(self, ucstring(mime_type))
# proc add_mime_type*(self: RecentFilter, mime_type: ustring) {.inline.} =

# gtk_recent_filter_add_pattern
# flags: {isMethod} container: RecentFilter
# need sugar: is method
# pattern 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_recent_filter_add_pattern(self: ptr TRecentFilter, pattern: ucstring) {.cdecl, dynlib: lib, importc: "gtk_recent_filter_add_pattern".}
proc add_pattern*(self: RecentFilter, pattern: ustring) {.inline.} =
  gtk_recent_filter_add_pattern(self, ucstring(pattern))
# proc add_pattern*(self: RecentFilter, pattern: ustring) {.inline.} =

# gtk_recent_filter_add_pixbuf_formats
# flags: {isMethod} container: RecentFilter
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_recent_filter_add_pixbuf_formats(self: ptr TRecentFilter) {.cdecl, dynlib: lib, importc: "gtk_recent_filter_add_pixbuf_formats".}
proc add_pixbuf_formats*(self: RecentFilter) {.inline.} =
  gtk_recent_filter_add_pixbuf_formats(self)
# proc add_pixbuf_formats*(self: RecentFilter) {.inline.} =

# gtk_recent_filter_filter
# flags: {isMethod} container: RecentFilter
# need sugar: is method
# filter_info 'TRecentFilterInfo' 'ptr TRecentFilterInfo' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_recent_filter_filter(self: ptr TRecentFilter, filter_info: ptr TRecentFilterInfo): bool {.cdecl, dynlib: lib, importc: "gtk_recent_filter_filter".}
proc filter*(self: RecentFilter, filter_info: TRecentFilterInfo): bool {.inline.} =
  gtk_recent_filter_filter(self, myUnsafeAddr(filter_info))
# proc filter*(self: RecentFilter, filter_info: TRecentFilterInfo): bool {.inline.} =

# gtk_recent_filter_get_name
# flags: {isMethod} container: RecentFilter
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_recent_filter_get_name(self: ptr TRecentFilter): ucstring {.cdecl, dynlib: lib, importc: "gtk_recent_filter_get_name".}
proc get_name*(self: RecentFilter): ustring {.inline.} =
  ustring($(gtk_recent_filter_get_name(self)))
# proc get_name*(self: RecentFilter): ustring {.inline.} =

# gtk_recent_filter_get_needed
# flags: {isMethod} container: RecentFilter
# need sugar: is method
# 'SRecentFilterFlags' 'SRecentFilterFlags'
proc gtk_recent_filter_get_needed(self: ptr TRecentFilter): SRecentFilterFlags {.cdecl, dynlib: lib, importc: "gtk_recent_filter_get_needed".}
proc get_needed*(self: RecentFilter): SRecentFilterFlags {.inline.} =
  gtk_recent_filter_get_needed(self)
# proc get_needed*(self: RecentFilter): SRecentFilterFlags {.inline.} =

# gtk_recent_filter_set_name
# flags: {isMethod} container: RecentFilter
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_recent_filter_set_name(self: ptr TRecentFilter, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_recent_filter_set_name".}
proc set_name*(self: RecentFilter, name: ustring) {.inline.} =
  gtk_recent_filter_set_name(self, ucstring(name))
# proc set_name*(self: RecentFilter, name: ustring) {.inline.} =

# gtk_recent_manager_new
# flags: {isConstructor} container: RecentManager
# need sugar: is static method
# 'RecentManager' 'TransferFull[TRecentManager]' (diff., need sugar)
proc gtk_recent_manager_new(): TransferFull[TRecentManager] {.cdecl, dynlib: lib, importc: "gtk_recent_manager_new".}
proc new_recentmanager*(): RecentManager {.inline.} =
  wrap(gtk_recent_manager_new())
# proc new_recentmanager*(): RecentManager {.inline.} =

# gtk_recent_manager_get_default
# flags: {} container: RecentManager
# need sugar: is static method
# 'RecentManager' 'TransferNone[TRecentManager]' (diff., need sugar)
proc gtk_recent_manager_get_default(): TransferNone[TRecentManager] {.cdecl, dynlib: lib, importc: "gtk_recent_manager_get_default".}
template get_default*(klass_parameter: typedesc[RecentManager]): RecentManager =
  wrap(gtk_recent_manager_get_default())
# template get_default*(klass_parameter: typedesc[RecentManager]): RecentManager =

# gtk_recent_manager_add_full
# flags: {isMethod} container: RecentManager
# need sugar: is method
# uri 'ustring' 'ucstring' IN (diff., need sugar)
# recent_data 'TRecentData' 'ptr TRecentData' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_recent_manager_add_full(self: ptr TRecentManager, uri: ucstring, recent_data: ptr TRecentData): bool {.cdecl, dynlib: lib, importc: "gtk_recent_manager_add_full".}
proc add_full*(self: RecentManager, uri: ustring, recent_data: TRecentData): bool {.inline.} =
  gtk_recent_manager_add_full(self, ucstring(uri), myUnsafeAddr(recent_data))
# proc add_full*(self: RecentManager, uri: ustring, recent_data: TRecentData): bool {.inline.} =

# gtk_recent_manager_add_item
# flags: {isMethod} container: RecentManager
# need sugar: is method
# uri 'ustring' 'ucstring' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_recent_manager_add_item(self: ptr TRecentManager, uri: ucstring): bool {.cdecl, dynlib: lib, importc: "gtk_recent_manager_add_item".}
proc add_item*(self: RecentManager, uri: ustring): bool {.inline.} =
  gtk_recent_manager_add_item(self, ucstring(uri))
# proc add_item*(self: RecentManager, uri: ustring): bool {.inline.} =

# gtk_recent_manager_get_items
# flags: {isMethod} container: RecentManager
# need sugar: is method
# 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_recent_manager_get_items(self: ptr TRecentManager): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_recent_manager_get_items".}
proc get_items*(self: RecentManager): ptr GLIST_TODO {.inline.} =
  gtk_recent_manager_get_items(self)
# proc get_items*(self: RecentManager): ptr GLIST_TODO {.inline.} =

# gtk_recent_manager_has_item
# flags: {isMethod} container: RecentManager
# need sugar: is method
# uri 'ustring' 'ucstring' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_recent_manager_has_item(self: ptr TRecentManager, uri: ucstring): bool {.cdecl, dynlib: lib, importc: "gtk_recent_manager_has_item".}
proc has_item*(self: RecentManager, uri: ustring): bool {.inline.} =
  gtk_recent_manager_has_item(self, ucstring(uri))
# proc has_item*(self: RecentManager, uri: ustring): bool {.inline.} =

# gtk_recent_manager_lookup_item
# flags: {isMethod, throws} container: RecentManager
# can throw
# need sugar: is method
# uri 'ustring' 'ucstring' IN (diff., need sugar)
# 'TRecentInfo' 'ptr TRecentInfo' (diff., need sugar)
proc gtk_recent_manager_lookup_item(self: ptr TRecentManager, uri: ucstring, error: ptr PGError=nil): ptr TRecentInfo {.cdecl, dynlib: lib, importc: "gtk_recent_manager_lookup_item".}
proc lookup_item*(self: RecentManager, uri: ustring): TRecentInfo {.inline.} =
  (gtk_recent_manager_lookup_item(self, ucstring(uri)))[]
# proc lookup_item*(self: RecentManager, uri: ustring): TRecentInfo {.inline.} =

# gtk_recent_manager_move_item
# flags: {isMethod, throws} container: RecentManager
# can throw
# need sugar: is method
# uri 'ustring' 'ucstring' IN (diff., need sugar)
# new_uri 'ustring' 'ucstring' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_recent_manager_move_item(self: ptr TRecentManager, uri: ucstring, new_uri: ucstring, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_recent_manager_move_item".}
proc move_item*(self: RecentManager, uri: ustring, new_uri: ustring): bool {.inline.} =
  gtk_recent_manager_move_item(self, ucstring(uri), ucstring(new_uri))
# proc move_item*(self: RecentManager, uri: ustring, new_uri: ustring): bool {.inline.} =

# gtk_recent_manager_purge_items
# flags: {isMethod, throws} container: RecentManager
# can throw
# need sugar: is method
# 'int32' 'int32'
proc gtk_recent_manager_purge_items(self: ptr TRecentManager, error: ptr PGError=nil): int32 {.cdecl, dynlib: lib, importc: "gtk_recent_manager_purge_items".}
proc purge_items*(self: RecentManager): int32 {.inline.} =
  gtk_recent_manager_purge_items(self)
# proc purge_items*(self: RecentManager): int32 {.inline.} =

# gtk_recent_manager_remove_item
# flags: {isMethod, throws} container: RecentManager
# can throw
# need sugar: is method
# uri 'ustring' 'ucstring' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_recent_manager_remove_item(self: ptr TRecentManager, uri: ucstring, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_recent_manager_remove_item".}
proc remove_item*(self: RecentManager, uri: ustring): bool {.inline.} =
  gtk_recent_manager_remove_item(self, ucstring(uri))
# proc remove_item*(self: RecentManager, uri: ustring): bool {.inline.} =

# gtk_renderer_cell_accessible_new
# flags: {isConstructor} container: RendererCellAccessible
# need sugar: is static method
# renderer 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# 'RendererCellAccessible' 'TransferFull[TRendererCellAccessible]' (diff., need sugar)
proc gtk_renderer_cell_accessible_new(renderer: ptr TCellRenderer): TransferFull[TRendererCellAccessible] {.cdecl, dynlib: lib, importc: "gtk_renderer_cell_accessible_new".}
proc new_renderercellaccessible*(renderer: CellRenderer): RendererCellAccessible {.inline.} =
  wrap(gtk_renderer_cell_accessible_new(renderer.getPointer))
# proc new_renderercellaccessible*(renderer: CellRenderer): RendererCellAccessible {.inline.} =

# gtk_revealer_new
# flags: {isConstructor} container: Revealer
# need sugar: is static method
# 'Revealer' 'TransferNone[TRevealer]' (diff., need sugar)
proc gtk_revealer_new(): TransferNone[TRevealer] {.cdecl, dynlib: lib, importc: "gtk_revealer_new".}
proc new_revealer*(): Revealer {.inline.} =
  wrap(gtk_revealer_new())
# proc new_revealer*(): Revealer {.inline.} =

# gtk_revealer_get_child_revealed
# flags: {isMethod} container: Revealer
# need sugar: is method
# 'bool' 'bool'
proc gtk_revealer_get_child_revealed(self: ptr TRevealer): bool {.cdecl, dynlib: lib, importc: "gtk_revealer_get_child_revealed".}
proc get_child_revealed*(self: Revealer): bool {.inline.} =
  gtk_revealer_get_child_revealed(self)
# proc get_child_revealed*(self: Revealer): bool {.inline.} =

# gtk_revealer_get_reveal_child
# flags: {isMethod} container: Revealer
# need sugar: is method
# 'bool' 'bool'
proc gtk_revealer_get_reveal_child(self: ptr TRevealer): bool {.cdecl, dynlib: lib, importc: "gtk_revealer_get_reveal_child".}
proc get_reveal_child*(self: Revealer): bool {.inline.} =
  gtk_revealer_get_reveal_child(self)
# proc get_reveal_child*(self: Revealer): bool {.inline.} =

# gtk_revealer_get_transition_duration
# flags: {isMethod} container: Revealer
# need sugar: is method
# 'uint32' 'uint32'
proc gtk_revealer_get_transition_duration(self: ptr TRevealer): uint32 {.cdecl, dynlib: lib, importc: "gtk_revealer_get_transition_duration".}
proc get_transition_duration*(self: Revealer): uint32 {.inline.} =
  gtk_revealer_get_transition_duration(self)
# proc get_transition_duration*(self: Revealer): uint32 {.inline.} =

# gtk_revealer_get_transition_type
# flags: {isMethod} container: Revealer
# need sugar: is method
# 'RevealerTransitionType' 'RevealerTransitionType'
proc gtk_revealer_get_transition_type(self: ptr TRevealer): RevealerTransitionType {.cdecl, dynlib: lib, importc: "gtk_revealer_get_transition_type".}
proc get_transition_type*(self: Revealer): RevealerTransitionType {.inline.} =
  gtk_revealer_get_transition_type(self)
# proc get_transition_type*(self: Revealer): RevealerTransitionType {.inline.} =

# gtk_revealer_set_reveal_child
# flags: {isMethod} container: Revealer
# need sugar: is method
# reveal_child 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_revealer_set_reveal_child(self: ptr TRevealer, reveal_child: bool) {.cdecl, dynlib: lib, importc: "gtk_revealer_set_reveal_child".}
proc set_reveal_child*(self: Revealer, reveal_child: bool) {.inline.} =
  gtk_revealer_set_reveal_child(self, reveal_child)
# proc set_reveal_child*(self: Revealer, reveal_child: bool) {.inline.} =

# gtk_revealer_set_transition_duration
# flags: {isMethod} container: Revealer
# need sugar: is method
# duration 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_revealer_set_transition_duration(self: ptr TRevealer, duration: uint32) {.cdecl, dynlib: lib, importc: "gtk_revealer_set_transition_duration".}
proc set_transition_duration*(self: Revealer, duration: uint32) {.inline.} =
  gtk_revealer_set_transition_duration(self, duration)
# proc set_transition_duration*(self: Revealer, duration: uint32) {.inline.} =

# gtk_revealer_set_transition_type
# flags: {isMethod} container: Revealer
# need sugar: is method
# transition 'RevealerTransitionType' 'RevealerTransitionType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_revealer_set_transition_type(self: ptr TRevealer, transition: RevealerTransitionType) {.cdecl, dynlib: lib, importc: "gtk_revealer_set_transition_type".}
proc set_transition_type*(self: Revealer, transition: RevealerTransitionType) {.inline.} =
  gtk_revealer_set_transition_type(self, transition)
# proc set_transition_type*(self: Revealer, transition: RevealerTransitionType) {.inline.} =

# gtk_scale_new
# flags: {isConstructor} container: Scale
# need sugar: is static method
# orientation 'Orientation' 'Orientation' IN
# adjustment 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# 'Scale' 'TransferNone[TScale]' (diff., need sugar)
proc gtk_scale_new(orientation: Orientation, adjustment: ptr TAdjustment): TransferNone[TScale] {.cdecl, dynlib: lib, importc: "gtk_scale_new".}
proc new_scale*(orientation: Orientation, adjustment: Adjustment): Scale {.inline.} =
  wrap(gtk_scale_new(orientation, adjustment.getPointer))
# proc new_scale*(orientation: Orientation, adjustment: Adjustment): Scale {.inline.} =

# gtk_scale_new_with_range
# flags: {isConstructor} container: Scale
# need sugar: is static method
# orientation 'Orientation' 'Orientation' IN
# min 'float64' 'float64' IN
# max 'float64' 'float64' IN
# step 'float64' 'float64' IN
# 'Scale' 'TransferNone[TScale]' (diff., need sugar)
proc gtk_scale_new_with_range(orientation: Orientation, min: float64, max: float64, step: float64): TransferNone[TScale] {.cdecl, dynlib: lib, importc: "gtk_scale_new_with_range".}
proc new_scale_with_range*(orientation: Orientation, min: float64, max: float64, step: float64): Scale {.inline.} =
  wrap(gtk_scale_new_with_range(orientation, min, max, step))
# proc new_scale_with_range*(orientation: Orientation, min: float64, max: float64, step: float64): Scale {.inline.} =

# gtk_scale_add_mark
# flags: {isMethod} container: Scale
# need sugar: is method
# value 'float64' 'float64' IN
# position 'PositionType' 'PositionType' IN
# markup 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_scale_add_mark(self: ptr TScale, value: float64, position: PositionType, markup: ucstring) {.cdecl, dynlib: lib, importc: "gtk_scale_add_mark".}
proc add_mark*(self: Scale, value: float64, position: PositionType, markup: ustring) {.inline.} =
  gtk_scale_add_mark(self, value, position, ucstring(markup))
# proc add_mark*(self: Scale, value: float64, position: PositionType, markup: ustring) {.inline.} =

# gtk_scale_clear_marks
# flags: {isMethod} container: Scale
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_scale_clear_marks(self: ptr TScale) {.cdecl, dynlib: lib, importc: "gtk_scale_clear_marks".}
proc clear_marks*(self: Scale) {.inline.} =
  gtk_scale_clear_marks(self)
# proc clear_marks*(self: Scale) {.inline.} =

# gtk_scale_get_digits
# flags: {isMethod} container: Scale
# need sugar: is method
# 'int32' 'int32'
proc gtk_scale_get_digits(self: ptr TScale): int32 {.cdecl, dynlib: lib, importc: "gtk_scale_get_digits".}
proc get_digits*(self: Scale): int32 {.inline.} =
  gtk_scale_get_digits(self)
# proc get_digits*(self: Scale): int32 {.inline.} =

# gtk_scale_get_draw_value
# flags: {isMethod} container: Scale
# need sugar: is method
# 'bool' 'bool'
proc gtk_scale_get_draw_value(self: ptr TScale): bool {.cdecl, dynlib: lib, importc: "gtk_scale_get_draw_value".}
proc get_draw_value*(self: Scale): bool {.inline.} =
  gtk_scale_get_draw_value(self)
# proc get_draw_value*(self: Scale): bool {.inline.} =

# gtk_scale_get_has_origin
# flags: {isMethod} container: Scale
# need sugar: is method
# 'bool' 'bool'
proc gtk_scale_get_has_origin(self: ptr TScale): bool {.cdecl, dynlib: lib, importc: "gtk_scale_get_has_origin".}
proc get_has_origin*(self: Scale): bool {.inline.} =
  gtk_scale_get_has_origin(self)
# proc get_has_origin*(self: Scale): bool {.inline.} =

# gtk_scale_get_layout
# flags: {isMethod} container: Scale
# need sugar: is method
# 'Pango1.Layout' 'TransferNone[Pango1.TLayout]' (diff., need sugar)
proc gtk_scale_get_layout(self: ptr TScale): TransferNone[Pango1.TLayout] {.cdecl, dynlib: lib, importc: "gtk_scale_get_layout".}
proc get_layout*(self: Scale): Pango1.Layout {.inline.} =
  wrap(gtk_scale_get_layout(self))
# proc get_layout*(self: Scale): Pango1.Layout {.inline.} =

# gtk_scale_get_layout_offsets
# flags: {isMethod} container: Scale
# need sugar: is method
# x 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# y 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_scale_get_layout_offsets(self: ptr TScale, x: ptr int32, y: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_scale_get_layout_offsets".}
proc get_layout_offsets*(self: Scale, x: var int32, y: var int32) {.inline.} =
  gtk_scale_get_layout_offsets(self, addr(x), addr(y))
# tuple-return
# x: var int32
# y: var int32
# proc get_layout_offsets*(self: Scale) {.inline.} =

# gtk_scale_get_value_pos
# flags: {isMethod} container: Scale
# need sugar: is method
# 'PositionType' 'PositionType'
proc gtk_scale_get_value_pos(self: ptr TScale): PositionType {.cdecl, dynlib: lib, importc: "gtk_scale_get_value_pos".}
proc get_value_pos*(self: Scale): PositionType {.inline.} =
  gtk_scale_get_value_pos(self)
# proc get_value_pos*(self: Scale): PositionType {.inline.} =

# gtk_scale_set_digits
# flags: {isMethod} container: Scale
# need sugar: is method
# digits 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_scale_set_digits(self: ptr TScale, digits: int32) {.cdecl, dynlib: lib, importc: "gtk_scale_set_digits".}
proc set_digits*(self: Scale, digits: int32) {.inline.} =
  gtk_scale_set_digits(self, digits)
# proc set_digits*(self: Scale, digits: int32) {.inline.} =

# gtk_scale_set_draw_value
# flags: {isMethod} container: Scale
# need sugar: is method
# draw_value 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_scale_set_draw_value(self: ptr TScale, draw_value: bool) {.cdecl, dynlib: lib, importc: "gtk_scale_set_draw_value".}
proc set_draw_value*(self: Scale, draw_value: bool) {.inline.} =
  gtk_scale_set_draw_value(self, draw_value)
# proc set_draw_value*(self: Scale, draw_value: bool) {.inline.} =

# gtk_scale_set_has_origin
# flags: {isMethod} container: Scale
# need sugar: is method
# has_origin 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_scale_set_has_origin(self: ptr TScale, has_origin: bool) {.cdecl, dynlib: lib, importc: "gtk_scale_set_has_origin".}
proc set_has_origin*(self: Scale, has_origin: bool) {.inline.} =
  gtk_scale_set_has_origin(self, has_origin)
# proc set_has_origin*(self: Scale, has_origin: bool) {.inline.} =

# gtk_scale_set_value_pos
# flags: {isMethod} container: Scale
# need sugar: is method
# pos 'PositionType' 'PositionType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_scale_set_value_pos(self: ptr TScale, pos: PositionType) {.cdecl, dynlib: lib, importc: "gtk_scale_set_value_pos".}
proc set_value_pos*(self: Scale, pos: PositionType) {.inline.} =
  gtk_scale_set_value_pos(self, pos)
# proc set_value_pos*(self: Scale, pos: PositionType) {.inline.} =

# gtk_scale_button_new
# flags: {isConstructor} container: ScaleButton
# need sugar: is static method
# size 'int32' 'int32' IN
# min 'float64' 'float64' IN
# max 'float64' 'float64' IN
# step 'float64' 'float64' IN
# icons 'uncheckedArray[ucstring]' 'uncheckedArray[ucstring]' IN array zero-terminated
# 'ScaleButton' 'TransferNone[TScaleButton]' (diff., need sugar)
proc gtk_scale_button_new(size: int32, min: float64, max: float64, step: float64, icons: uncheckedArray[ucstring]): TransferNone[TScaleButton] {.cdecl, dynlib: lib, importc: "gtk_scale_button_new".}
proc new_scalebutton*(size: int32, min: float64, max: float64, step: float64, icons: uncheckedArray[ucstring]): ScaleButton {.inline.} =
  wrap(gtk_scale_button_new(size, min, max, step, icons))
# proc new_scalebutton*(size: int32, min: float64, max: float64, step: float64, icons: uncheckedArray[ucstring]): ScaleButton {.inline.} =

# gtk_scale_button_get_adjustment
# flags: {isMethod} container: ScaleButton
# need sugar: is method
# 'Adjustment' 'TransferNone[TAdjustment]' (diff., need sugar)
proc gtk_scale_button_get_adjustment(self: ptr TScaleButton): TransferNone[TAdjustment] {.cdecl, dynlib: lib, importc: "gtk_scale_button_get_adjustment".}
proc get_adjustment*(self: ScaleButton): Adjustment {.inline.} =
  wrap(gtk_scale_button_get_adjustment(self))
# proc get_adjustment*(self: ScaleButton): Adjustment {.inline.} =

# gtk_scale_button_get_minus_button
# flags: {isMethod} container: ScaleButton
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_scale_button_get_minus_button(self: ptr TScaleButton): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_scale_button_get_minus_button".}
proc get_minus_button*(self: ScaleButton): Widget {.inline.} =
  wrap(gtk_scale_button_get_minus_button(self))
# proc get_minus_button*(self: ScaleButton): Widget {.inline.} =

# gtk_scale_button_get_plus_button
# flags: {isMethod} container: ScaleButton
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_scale_button_get_plus_button(self: ptr TScaleButton): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_scale_button_get_plus_button".}
proc get_plus_button*(self: ScaleButton): Widget {.inline.} =
  wrap(gtk_scale_button_get_plus_button(self))
# proc get_plus_button*(self: ScaleButton): Widget {.inline.} =

# gtk_scale_button_get_popup
# flags: {isMethod} container: ScaleButton
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_scale_button_get_popup(self: ptr TScaleButton): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_scale_button_get_popup".}
proc get_popup*(self: ScaleButton): Widget {.inline.} =
  wrap(gtk_scale_button_get_popup(self))
# proc get_popup*(self: ScaleButton): Widget {.inline.} =

# gtk_scale_button_get_value
# flags: {isMethod} container: ScaleButton
# need sugar: is method
# 'float64' 'float64'
proc gtk_scale_button_get_value(self: ptr TScaleButton): float64 {.cdecl, dynlib: lib, importc: "gtk_scale_button_get_value".}
proc get_value*(self: ScaleButton): float64 {.inline.} =
  gtk_scale_button_get_value(self)
# proc get_value*(self: ScaleButton): float64 {.inline.} =

# gtk_scale_button_set_adjustment
# flags: {isMethod} container: ScaleButton
# need sugar: is method
# adjustment 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_scale_button_set_adjustment(self: ptr TScaleButton, adjustment: ptr TAdjustment) {.cdecl, dynlib: lib, importc: "gtk_scale_button_set_adjustment".}
proc set_adjustment*(self: ScaleButton, adjustment: Adjustment) {.inline.} =
  gtk_scale_button_set_adjustment(self, adjustment.getPointer)
# proc set_adjustment*(self: ScaleButton, adjustment: Adjustment) {.inline.} =

# gtk_scale_button_set_icons
# flags: {isMethod} container: ScaleButton
# need sugar: is method
# icons 'uncheckedArray[ucstring]' 'uncheckedArray[ucstring]' IN array zero-terminated
# 'VOID_TODO' 'VOID_TODO'
proc gtk_scale_button_set_icons(self: ptr TScaleButton, icons: uncheckedArray[ucstring]) {.cdecl, dynlib: lib, importc: "gtk_scale_button_set_icons".}
proc set_icons*(self: ScaleButton, icons: uncheckedArray[ucstring]) {.inline.} =
  gtk_scale_button_set_icons(self, icons)
# proc set_icons*(self: ScaleButton, icons: uncheckedArray[ucstring]) {.inline.} =

# gtk_scale_button_set_value
# flags: {isMethod} container: ScaleButton
# need sugar: is method
# value 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_scale_button_set_value(self: ptr TScaleButton, value: float64) {.cdecl, dynlib: lib, importc: "gtk_scale_button_set_value".}
proc set_value*(self: ScaleButton, value: float64) {.inline.} =
  gtk_scale_button_set_value(self, value)
# proc set_value*(self: ScaleButton, value: float64) {.inline.} =

# gtk_scrollbar_new
# flags: {isConstructor} container: Scrollbar
# need sugar: is static method
# orientation 'Orientation' 'Orientation' IN
# adjustment 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# 'Scrollbar' 'TransferNone[TScrollbar]' (diff., need sugar)
proc gtk_scrollbar_new(orientation: Orientation, adjustment: ptr TAdjustment): TransferNone[TScrollbar] {.cdecl, dynlib: lib, importc: "gtk_scrollbar_new".}
proc new_scrollbar*(orientation: Orientation, adjustment: Adjustment): Scrollbar {.inline.} =
  wrap(gtk_scrollbar_new(orientation, adjustment.getPointer))
# proc new_scrollbar*(orientation: Orientation, adjustment: Adjustment): Scrollbar {.inline.} =

# gtk_scrolled_window_new
# flags: {isConstructor} container: ScrolledWindow
# need sugar: is static method
# hadjustment 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# vadjustment 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# 'ScrolledWindow' 'TransferNone[TScrolledWindow]' (diff., need sugar)
proc gtk_scrolled_window_new(hadjustment: ptr TAdjustment, vadjustment: ptr TAdjustment): TransferNone[TScrolledWindow] {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_new".}
proc new_scrolledwindow*(hadjustment: Adjustment, vadjustment: Adjustment): ScrolledWindow {.inline.} =
  wrap(gtk_scrolled_window_new(hadjustment.getPointer, vadjustment.getPointer))
# proc new_scrolledwindow*(hadjustment: Adjustment, vadjustment: Adjustment): ScrolledWindow {.inline.} =

# gtk_scrolled_window_add_with_viewport
# flags: {isMethod} container: ScrolledWindow (deprecated)
# gtk_scrolled_window_get_capture_button_press
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# 'bool' 'bool'
proc gtk_scrolled_window_get_capture_button_press(self: ptr TScrolledWindow): bool {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_get_capture_button_press".}
proc get_capture_button_press*(self: ScrolledWindow): bool {.inline.} =
  gtk_scrolled_window_get_capture_button_press(self)
# proc get_capture_button_press*(self: ScrolledWindow): bool {.inline.} =

# gtk_scrolled_window_get_hadjustment
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# 'Adjustment' 'TransferNone[TAdjustment]' (diff., need sugar)
proc gtk_scrolled_window_get_hadjustment(self: ptr TScrolledWindow): TransferNone[TAdjustment] {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_get_hadjustment".}
proc get_hadjustment*(self: ScrolledWindow): Adjustment {.inline.} =
  wrap(gtk_scrolled_window_get_hadjustment(self))
# proc get_hadjustment*(self: ScrolledWindow): Adjustment {.inline.} =

# gtk_scrolled_window_get_hscrollbar
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_scrolled_window_get_hscrollbar(self: ptr TScrolledWindow): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_get_hscrollbar".}
proc get_hscrollbar*(self: ScrolledWindow): Widget {.inline.} =
  wrap(gtk_scrolled_window_get_hscrollbar(self))
# proc get_hscrollbar*(self: ScrolledWindow): Widget {.inline.} =

# gtk_scrolled_window_get_kinetic_scrolling
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# 'bool' 'bool'
proc gtk_scrolled_window_get_kinetic_scrolling(self: ptr TScrolledWindow): bool {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_get_kinetic_scrolling".}
proc get_kinetic_scrolling*(self: ScrolledWindow): bool {.inline.} =
  gtk_scrolled_window_get_kinetic_scrolling(self)
# proc get_kinetic_scrolling*(self: ScrolledWindow): bool {.inline.} =

# gtk_scrolled_window_get_min_content_height
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# 'int32' 'int32'
proc gtk_scrolled_window_get_min_content_height(self: ptr TScrolledWindow): int32 {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_get_min_content_height".}
proc get_min_content_height*(self: ScrolledWindow): int32 {.inline.} =
  gtk_scrolled_window_get_min_content_height(self)
# proc get_min_content_height*(self: ScrolledWindow): int32 {.inline.} =

# gtk_scrolled_window_get_min_content_width
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# 'int32' 'int32'
proc gtk_scrolled_window_get_min_content_width(self: ptr TScrolledWindow): int32 {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_get_min_content_width".}
proc get_min_content_width*(self: ScrolledWindow): int32 {.inline.} =
  gtk_scrolled_window_get_min_content_width(self)
# proc get_min_content_width*(self: ScrolledWindow): int32 {.inline.} =

# gtk_scrolled_window_get_placement
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# 'CornerType' 'CornerType'
proc gtk_scrolled_window_get_placement(self: ptr TScrolledWindow): CornerType {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_get_placement".}
proc get_placement*(self: ScrolledWindow): CornerType {.inline.} =
  gtk_scrolled_window_get_placement(self)
# proc get_placement*(self: ScrolledWindow): CornerType {.inline.} =

# gtk_scrolled_window_get_policy
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# hscrollbar_policy 'PolicyType' 'PolicyType' OUT optional
# vscrollbar_policy 'PolicyType' 'PolicyType' OUT optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_scrolled_window_get_policy(self: ptr TScrolledWindow, hscrollbar_policy: PolicyType, vscrollbar_policy: PolicyType) {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_get_policy".}
proc get_policy*(self: ScrolledWindow, hscrollbar_policy: PolicyType, vscrollbar_policy: PolicyType) {.inline.} =
  gtk_scrolled_window_get_policy(self, hscrollbar_policy, vscrollbar_policy)
# tuple-return
# hscrollbar_policy: PolicyType
# vscrollbar_policy: PolicyType
# proc get_policy*(self: ScrolledWindow) {.inline.} =

# gtk_scrolled_window_get_shadow_type
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# 'ShadowType' 'ShadowType'
proc gtk_scrolled_window_get_shadow_type(self: ptr TScrolledWindow): ShadowType {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_get_shadow_type".}
proc get_shadow_type*(self: ScrolledWindow): ShadowType {.inline.} =
  gtk_scrolled_window_get_shadow_type(self)
# proc get_shadow_type*(self: ScrolledWindow): ShadowType {.inline.} =

# gtk_scrolled_window_get_vadjustment
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# 'Adjustment' 'TransferNone[TAdjustment]' (diff., need sugar)
proc gtk_scrolled_window_get_vadjustment(self: ptr TScrolledWindow): TransferNone[TAdjustment] {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_get_vadjustment".}
proc get_vadjustment*(self: ScrolledWindow): Adjustment {.inline.} =
  wrap(gtk_scrolled_window_get_vadjustment(self))
# proc get_vadjustment*(self: ScrolledWindow): Adjustment {.inline.} =

# gtk_scrolled_window_get_vscrollbar
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_scrolled_window_get_vscrollbar(self: ptr TScrolledWindow): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_get_vscrollbar".}
proc get_vscrollbar*(self: ScrolledWindow): Widget {.inline.} =
  wrap(gtk_scrolled_window_get_vscrollbar(self))
# proc get_vscrollbar*(self: ScrolledWindow): Widget {.inline.} =

# gtk_scrolled_window_set_capture_button_press
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# capture_button_press 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_scrolled_window_set_capture_button_press(self: ptr TScrolledWindow, capture_button_press: bool) {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_set_capture_button_press".}
proc set_capture_button_press*(self: ScrolledWindow, capture_button_press: bool) {.inline.} =
  gtk_scrolled_window_set_capture_button_press(self, capture_button_press)
# proc set_capture_button_press*(self: ScrolledWindow, capture_button_press: bool) {.inline.} =

# gtk_scrolled_window_set_hadjustment
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# hadjustment 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_scrolled_window_set_hadjustment(self: ptr TScrolledWindow, hadjustment: ptr TAdjustment) {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_set_hadjustment".}
proc set_hadjustment*(self: ScrolledWindow, hadjustment: Adjustment) {.inline.} =
  gtk_scrolled_window_set_hadjustment(self, hadjustment.getPointer)
# proc set_hadjustment*(self: ScrolledWindow, hadjustment: Adjustment) {.inline.} =

# gtk_scrolled_window_set_kinetic_scrolling
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# kinetic_scrolling 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_scrolled_window_set_kinetic_scrolling(self: ptr TScrolledWindow, kinetic_scrolling: bool) {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_set_kinetic_scrolling".}
proc set_kinetic_scrolling*(self: ScrolledWindow, kinetic_scrolling: bool) {.inline.} =
  gtk_scrolled_window_set_kinetic_scrolling(self, kinetic_scrolling)
# proc set_kinetic_scrolling*(self: ScrolledWindow, kinetic_scrolling: bool) {.inline.} =

# gtk_scrolled_window_set_min_content_height
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# height 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_scrolled_window_set_min_content_height(self: ptr TScrolledWindow, height: int32) {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_set_min_content_height".}
proc set_min_content_height*(self: ScrolledWindow, height: int32) {.inline.} =
  gtk_scrolled_window_set_min_content_height(self, height)
# proc set_min_content_height*(self: ScrolledWindow, height: int32) {.inline.} =

# gtk_scrolled_window_set_min_content_width
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# width 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_scrolled_window_set_min_content_width(self: ptr TScrolledWindow, width: int32) {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_set_min_content_width".}
proc set_min_content_width*(self: ScrolledWindow, width: int32) {.inline.} =
  gtk_scrolled_window_set_min_content_width(self, width)
# proc set_min_content_width*(self: ScrolledWindow, width: int32) {.inline.} =

# gtk_scrolled_window_set_placement
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# window_placement 'CornerType' 'CornerType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_scrolled_window_set_placement(self: ptr TScrolledWindow, window_placement: CornerType) {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_set_placement".}
proc set_placement*(self: ScrolledWindow, window_placement: CornerType) {.inline.} =
  gtk_scrolled_window_set_placement(self, window_placement)
# proc set_placement*(self: ScrolledWindow, window_placement: CornerType) {.inline.} =

# gtk_scrolled_window_set_policy
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# hscrollbar_policy 'PolicyType' 'PolicyType' IN
# vscrollbar_policy 'PolicyType' 'PolicyType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_scrolled_window_set_policy(self: ptr TScrolledWindow, hscrollbar_policy: PolicyType, vscrollbar_policy: PolicyType) {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_set_policy".}
proc set_policy*(self: ScrolledWindow, hscrollbar_policy: PolicyType, vscrollbar_policy: PolicyType) {.inline.} =
  gtk_scrolled_window_set_policy(self, hscrollbar_policy, vscrollbar_policy)
# proc set_policy*(self: ScrolledWindow, hscrollbar_policy: PolicyType, vscrollbar_policy: PolicyType) {.inline.} =

# gtk_scrolled_window_set_shadow_type
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# type 'ShadowType' 'ShadowType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_scrolled_window_set_shadow_type(self: ptr TScrolledWindow, type_x: ShadowType) {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_set_shadow_type".}
proc set_shadow_type*(self: ScrolledWindow, type_x: ShadowType) {.inline.} =
  gtk_scrolled_window_set_shadow_type(self, type_x)
# proc set_shadow_type*(self: ScrolledWindow, type_x: ShadowType) {.inline.} =

# gtk_scrolled_window_set_vadjustment
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# vadjustment 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_scrolled_window_set_vadjustment(self: ptr TScrolledWindow, vadjustment: ptr TAdjustment) {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_set_vadjustment".}
proc set_vadjustment*(self: ScrolledWindow, vadjustment: Adjustment) {.inline.} =
  gtk_scrolled_window_set_vadjustment(self, vadjustment.getPointer)
# proc set_vadjustment*(self: ScrolledWindow, vadjustment: Adjustment) {.inline.} =

# gtk_scrolled_window_unset_placement
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_scrolled_window_unset_placement(self: ptr TScrolledWindow) {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_unset_placement".}
proc unset_placement*(self: ScrolledWindow) {.inline.} =
  gtk_scrolled_window_unset_placement(self)
# proc unset_placement*(self: ScrolledWindow) {.inline.} =

# gtk_search_bar_new
# flags: {isConstructor} container: SearchBar
# need sugar: is static method
# 'SearchBar' 'TransferNone[TSearchBar]' (diff., need sugar)
proc gtk_search_bar_new(): TransferNone[TSearchBar] {.cdecl, dynlib: lib, importc: "gtk_search_bar_new".}
proc new_searchbar*(): SearchBar {.inline.} =
  wrap(gtk_search_bar_new())
# proc new_searchbar*(): SearchBar {.inline.} =

# gtk_search_bar_connect_entry
# flags: {isMethod} container: SearchBar
# need sugar: is method
# entry 'Entry' 'ptr TEntry' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_search_bar_connect_entry(self: ptr TSearchBar, entry: ptr TEntry) {.cdecl, dynlib: lib, importc: "gtk_search_bar_connect_entry".}
proc connect_entry*(self: SearchBar, entry: Entry) {.inline.} =
  gtk_search_bar_connect_entry(self, entry.getPointer)
# proc connect_entry*(self: SearchBar, entry: Entry) {.inline.} =

# gtk_search_bar_get_search_mode
# flags: {isMethod} container: SearchBar
# need sugar: is method
# 'bool' 'bool'
proc gtk_search_bar_get_search_mode(self: ptr TSearchBar): bool {.cdecl, dynlib: lib, importc: "gtk_search_bar_get_search_mode".}
proc get_search_mode*(self: SearchBar): bool {.inline.} =
  gtk_search_bar_get_search_mode(self)
# proc get_search_mode*(self: SearchBar): bool {.inline.} =

# gtk_search_bar_get_show_close_button
# flags: {isMethod} container: SearchBar
# need sugar: is method
# 'bool' 'bool'
proc gtk_search_bar_get_show_close_button(self: ptr TSearchBar): bool {.cdecl, dynlib: lib, importc: "gtk_search_bar_get_show_close_button".}
proc get_show_close_button*(self: SearchBar): bool {.inline.} =
  gtk_search_bar_get_show_close_button(self)
# proc get_show_close_button*(self: SearchBar): bool {.inline.} =

# gtk_search_bar_handle_event
# flags: {isMethod} container: SearchBar
# need sugar: is method
# event 'Gdk3.TEvent' 'ptr Gdk3.TEvent' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_search_bar_handle_event(self: ptr TSearchBar, event: ptr Gdk3.TEvent): bool {.cdecl, dynlib: lib, importc: "gtk_search_bar_handle_event".}
proc handle_event*(self: SearchBar, event: Gdk3.TEvent): bool {.inline.} =
  gtk_search_bar_handle_event(self, myUnsafeAddr(event))
# proc handle_event*(self: SearchBar, event: Gdk3.TEvent): bool {.inline.} =

# gtk_search_bar_set_search_mode
# flags: {isMethod} container: SearchBar
# need sugar: is method
# search_mode 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_search_bar_set_search_mode(self: ptr TSearchBar, search_mode: bool) {.cdecl, dynlib: lib, importc: "gtk_search_bar_set_search_mode".}
proc set_search_mode*(self: SearchBar, search_mode: bool) {.inline.} =
  gtk_search_bar_set_search_mode(self, search_mode)
# proc set_search_mode*(self: SearchBar, search_mode: bool) {.inline.} =

# gtk_search_bar_set_show_close_button
# flags: {isMethod} container: SearchBar
# need sugar: is method
# visible 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_search_bar_set_show_close_button(self: ptr TSearchBar, visible: bool) {.cdecl, dynlib: lib, importc: "gtk_search_bar_set_show_close_button".}
proc set_show_close_button*(self: SearchBar, visible: bool) {.inline.} =
  gtk_search_bar_set_show_close_button(self, visible)
# proc set_show_close_button*(self: SearchBar, visible: bool) {.inline.} =

# gtk_search_entry_new
# flags: {isConstructor} container: SearchEntry
# need sugar: is static method
# 'SearchEntry' 'TransferNone[TSearchEntry]' (diff., need sugar)
proc gtk_search_entry_new(): TransferNone[TSearchEntry] {.cdecl, dynlib: lib, importc: "gtk_search_entry_new".}
proc new_searchentry*(): SearchEntry {.inline.} =
  wrap(gtk_search_entry_new())
# proc new_searchentry*(): SearchEntry {.inline.} =

# gtk_separator_new
# flags: {isConstructor} container: Separator
# need sugar: is static method
# orientation 'Orientation' 'Orientation' IN
# 'Separator' 'TransferNone[TSeparator]' (diff., need sugar)
proc gtk_separator_new(orientation: Orientation): TransferNone[TSeparator] {.cdecl, dynlib: lib, importc: "gtk_separator_new".}
proc new_separator*(orientation: Orientation): Separator {.inline.} =
  wrap(gtk_separator_new(orientation))
# proc new_separator*(orientation: Orientation): Separator {.inline.} =

# gtk_separator_menu_item_new
# flags: {isConstructor} container: SeparatorMenuItem
# need sugar: is static method
# 'SeparatorMenuItem' 'TransferNone[TSeparatorMenuItem]' (diff., need sugar)
proc gtk_separator_menu_item_new(): TransferNone[TSeparatorMenuItem] {.cdecl, dynlib: lib, importc: "gtk_separator_menu_item_new".}
proc new_separatormenuitem*(): SeparatorMenuItem {.inline.} =
  wrap(gtk_separator_menu_item_new())
# proc new_separatormenuitem*(): SeparatorMenuItem {.inline.} =

# gtk_separator_tool_item_new
# flags: {isConstructor} container: SeparatorToolItem
# need sugar: is static method
# 'SeparatorToolItem' 'TransferNone[TSeparatorToolItem]' (diff., need sugar)
proc gtk_separator_tool_item_new(): TransferNone[TSeparatorToolItem] {.cdecl, dynlib: lib, importc: "gtk_separator_tool_item_new".}
proc new_separatortoolitem*(): SeparatorToolItem {.inline.} =
  wrap(gtk_separator_tool_item_new())
# proc new_separatortoolitem*(): SeparatorToolItem {.inline.} =

# gtk_separator_tool_item_get_draw
# flags: {isMethod} container: SeparatorToolItem
# need sugar: is method
# 'bool' 'bool'
proc gtk_separator_tool_item_get_draw(self: ptr TSeparatorToolItem): bool {.cdecl, dynlib: lib, importc: "gtk_separator_tool_item_get_draw".}
proc get_draw*(self: SeparatorToolItem): bool {.inline.} =
  gtk_separator_tool_item_get_draw(self)
# proc get_draw*(self: SeparatorToolItem): bool {.inline.} =

# gtk_separator_tool_item_set_draw
# flags: {isMethod} container: SeparatorToolItem
# need sugar: is method
# draw 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_separator_tool_item_set_draw(self: ptr TSeparatorToolItem, draw: bool) {.cdecl, dynlib: lib, importc: "gtk_separator_tool_item_set_draw".}
proc set_draw*(self: SeparatorToolItem, draw: bool) {.inline.} =
  gtk_separator_tool_item_set_draw(self, draw)
# proc set_draw*(self: SeparatorToolItem, draw: bool) {.inline.} =

# gtk_settings_get_default
# flags: {} container: Settings
# need sugar: is static method
# 'Settings' 'TransferNone[TSettings]' (diff., need sugar)
proc gtk_settings_get_default(): TransferNone[TSettings] {.cdecl, dynlib: lib, importc: "gtk_settings_get_default".}
template get_default*(klass_parameter: typedesc[Settings]): Settings =
  wrap(gtk_settings_get_default())
# template get_default*(klass_parameter: typedesc[Settings]): Settings =

# gtk_settings_get_for_screen
# flags: {} container: Settings
# need sugar: is static method
# screen 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# 'Settings' 'TransferNone[TSettings]' (diff., need sugar)
proc gtk_settings_get_for_screen(screen: ptr Gdk3.TScreen): TransferNone[TSettings] {.cdecl, dynlib: lib, importc: "gtk_settings_get_for_screen".}
template get_for_screen*(klass_parameter: typedesc[Settings], screen: Gdk3.Screen): Settings =
  wrap(gtk_settings_get_for_screen(screen.getPointer))
# template get_for_screen*(klass_parameter: typedesc[Settings], screen: Gdk3.Screen): Settings =

# gtk_settings_install_property
# flags: {} container: Settings
# need sugar: is static method
# pspec 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_settings_install_property(pspec: ptr GObject2.TParamSpec) {.cdecl, dynlib: lib, importc: "gtk_settings_install_property".}
template install_property*(klass_parameter: typedesc[Settings], pspec: GObject2.ParamSpec) =
  gtk_settings_install_property(pspec.getPointer)
# template install_property*(klass_parameter: typedesc[Settings], pspec: GObject2.ParamSpec) =

# gtk_settings_install_property_parser
# flags: {} container: Settings
# need sugar: is static method
# pspec 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# parser 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_settings_install_property_parser(pspec: ptr GObject2.TParamSpec, parser: pointer) {.cdecl, dynlib: lib, importc: "gtk_settings_install_property_parser".}
template install_property_parser*(klass_parameter: typedesc[Settings], pspec: GObject2.ParamSpec, parser: pointer) =
  gtk_settings_install_property_parser(pspec.getPointer, parser)
# template install_property_parser*(klass_parameter: typedesc[Settings], pspec: GObject2.ParamSpec, parser: pointer) =

# gtk_settings_set_double_property
# flags: {isMethod} container: Settings
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# v_double 'float64' 'float64' IN
# origin 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_settings_set_double_property(self: ptr TSettings, name: ucstring, v_double: float64, origin: ucstring) {.cdecl, dynlib: lib, importc: "gtk_settings_set_double_property".}
proc set_double_property*(self: Settings, name: ustring, v_double: float64, origin: ustring) {.inline.} =
  gtk_settings_set_double_property(self, ucstring(name), v_double, ucstring(origin))
# proc set_double_property*(self: Settings, name: ustring, v_double: float64, origin: ustring) {.inline.} =

# gtk_settings_set_long_property
# flags: {isMethod} container: Settings
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# v_long 'int32' 'int32' IN
# origin 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_settings_set_long_property(self: ptr TSettings, name: ucstring, v_long: int32, origin: ucstring) {.cdecl, dynlib: lib, importc: "gtk_settings_set_long_property".}
proc set_long_property*(self: Settings, name: ustring, v_long: int32, origin: ustring) {.inline.} =
  gtk_settings_set_long_property(self, ucstring(name), v_long, ucstring(origin))
# proc set_long_property*(self: Settings, name: ustring, v_long: int32, origin: ustring) {.inline.} =

# gtk_settings_set_property_value
# flags: {isMethod} container: Settings
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# svalue 'TSettingsValue' 'ptr TSettingsValue' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_settings_set_property_value(self: ptr TSettings, name: ucstring, svalue: ptr TSettingsValue) {.cdecl, dynlib: lib, importc: "gtk_settings_set_property_value".}
proc set_property_value*(self: Settings, name: ustring, svalue: TSettingsValue) {.inline.} =
  gtk_settings_set_property_value(self, ucstring(name), myUnsafeAddr(svalue))
# proc set_property_value*(self: Settings, name: ustring, svalue: TSettingsValue) {.inline.} =

# gtk_settings_set_string_property
# flags: {isMethod} container: Settings
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# v_string 'ustring' 'ucstring' IN (diff., need sugar)
# origin 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_settings_set_string_property(self: ptr TSettings, name: ucstring, v_string: ucstring, origin: ucstring) {.cdecl, dynlib: lib, importc: "gtk_settings_set_string_property".}
proc set_string_property*(self: Settings, name: ustring, v_string: ustring, origin: ustring) {.inline.} =
  gtk_settings_set_string_property(self, ucstring(name), ucstring(v_string), ucstring(origin))
# proc set_string_property*(self: Settings, name: ustring, v_string: ustring, origin: ustring) {.inline.} =

# gtk_size_group_new
# flags: {isConstructor} container: SizeGroup
# need sugar: is static method
# mode 'SizeGroupMode' 'SizeGroupMode' IN
# 'SizeGroup' 'TransferFull[TSizeGroup]' (diff., need sugar)
proc gtk_size_group_new(mode: SizeGroupMode): TransferFull[TSizeGroup] {.cdecl, dynlib: lib, importc: "gtk_size_group_new".}
proc new_sizegroup*(mode: SizeGroupMode): SizeGroup {.inline.} =
  wrap(gtk_size_group_new(mode))
# proc new_sizegroup*(mode: SizeGroupMode): SizeGroup {.inline.} =

# gtk_size_group_add_widget
# flags: {isMethod} container: SizeGroup
# need sugar: is method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_size_group_add_widget(self: ptr TSizeGroup, widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_size_group_add_widget".}
proc add_widget*(self: SizeGroup, widget: Widget) {.inline.} =
  gtk_size_group_add_widget(self, widget.getPointer)
# proc add_widget*(self: SizeGroup, widget: Widget) {.inline.} =

# gtk_size_group_get_ignore_hidden
# flags: {isMethod} container: SizeGroup
# need sugar: is method
# 'bool' 'bool'
proc gtk_size_group_get_ignore_hidden(self: ptr TSizeGroup): bool {.cdecl, dynlib: lib, importc: "gtk_size_group_get_ignore_hidden".}
proc get_ignore_hidden*(self: SizeGroup): bool {.inline.} =
  gtk_size_group_get_ignore_hidden(self)
# proc get_ignore_hidden*(self: SizeGroup): bool {.inline.} =

# gtk_size_group_get_mode
# flags: {isMethod} container: SizeGroup
# need sugar: is method
# 'SizeGroupMode' 'SizeGroupMode'
proc gtk_size_group_get_mode(self: ptr TSizeGroup): SizeGroupMode {.cdecl, dynlib: lib, importc: "gtk_size_group_get_mode".}
proc get_mode*(self: SizeGroup): SizeGroupMode {.inline.} =
  gtk_size_group_get_mode(self)
# proc get_mode*(self: SizeGroup): SizeGroupMode {.inline.} =

# gtk_size_group_get_widgets
# flags: {isMethod} container: SizeGroup
# need sugar: is method
# 'ptr GSLIST_TODO' 'ptr GSLIST_TODO'
proc gtk_size_group_get_widgets(self: ptr TSizeGroup): ptr GSLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_size_group_get_widgets".}
proc get_widgets*(self: SizeGroup): ptr GSLIST_TODO {.inline.} =
  gtk_size_group_get_widgets(self)
# proc get_widgets*(self: SizeGroup): ptr GSLIST_TODO {.inline.} =

# gtk_size_group_remove_widget
# flags: {isMethod} container: SizeGroup
# need sugar: is method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_size_group_remove_widget(self: ptr TSizeGroup, widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_size_group_remove_widget".}
proc remove_widget*(self: SizeGroup, widget: Widget) {.inline.} =
  gtk_size_group_remove_widget(self, widget.getPointer)
# proc remove_widget*(self: SizeGroup, widget: Widget) {.inline.} =

# gtk_size_group_set_ignore_hidden
# flags: {isMethod} container: SizeGroup
# need sugar: is method
# ignore_hidden 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_size_group_set_ignore_hidden(self: ptr TSizeGroup, ignore_hidden: bool) {.cdecl, dynlib: lib, importc: "gtk_size_group_set_ignore_hidden".}
proc set_ignore_hidden*(self: SizeGroup, ignore_hidden: bool) {.inline.} =
  gtk_size_group_set_ignore_hidden(self, ignore_hidden)
# proc set_ignore_hidden*(self: SizeGroup, ignore_hidden: bool) {.inline.} =

# gtk_size_group_set_mode
# flags: {isMethod} container: SizeGroup
# need sugar: is method
# mode 'SizeGroupMode' 'SizeGroupMode' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_size_group_set_mode(self: ptr TSizeGroup, mode: SizeGroupMode) {.cdecl, dynlib: lib, importc: "gtk_size_group_set_mode".}
proc set_mode*(self: SizeGroup, mode: SizeGroupMode) {.inline.} =
  gtk_size_group_set_mode(self, mode)
# proc set_mode*(self: SizeGroup, mode: SizeGroupMode) {.inline.} =

# gtk_spin_button_new
# flags: {isConstructor} container: SpinButton
# need sugar: is static method
# adjustment 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# climb_rate 'float64' 'float64' IN
# digits 'uint32' 'uint32' IN
# 'SpinButton' 'TransferNone[TSpinButton]' (diff., need sugar)
proc gtk_spin_button_new(adjustment: ptr TAdjustment, climb_rate: float64, digits: uint32): TransferNone[TSpinButton] {.cdecl, dynlib: lib, importc: "gtk_spin_button_new".}
proc new_spinbutton*(adjustment: Adjustment, climb_rate: float64, digits: uint32): SpinButton {.inline.} =
  wrap(gtk_spin_button_new(adjustment.getPointer, climb_rate, digits))
# proc new_spinbutton*(adjustment: Adjustment, climb_rate: float64, digits: uint32): SpinButton {.inline.} =

# gtk_spin_button_new_with_range
# flags: {isConstructor} container: SpinButton
# need sugar: is static method
# min 'float64' 'float64' IN
# max 'float64' 'float64' IN
# step 'float64' 'float64' IN
# 'SpinButton' 'TransferNone[TSpinButton]' (diff., need sugar)
proc gtk_spin_button_new_with_range(min: float64, max: float64, step: float64): TransferNone[TSpinButton] {.cdecl, dynlib: lib, importc: "gtk_spin_button_new_with_range".}
proc new_spinbutton_with_range*(min: float64, max: float64, step: float64): SpinButton {.inline.} =
  wrap(gtk_spin_button_new_with_range(min, max, step))
# proc new_spinbutton_with_range*(min: float64, max: float64, step: float64): SpinButton {.inline.} =

# gtk_spin_button_configure
# flags: {isMethod} container: SpinButton
# need sugar: is method
# adjustment 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# climb_rate 'float64' 'float64' IN
# digits 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_configure(self: ptr TSpinButton, adjustment: ptr TAdjustment, climb_rate: float64, digits: uint32) {.cdecl, dynlib: lib, importc: "gtk_spin_button_configure".}
proc configure*(self: SpinButton, adjustment: Adjustment, climb_rate: float64, digits: uint32) {.inline.} =
  gtk_spin_button_configure(self, adjustment.getPointer, climb_rate, digits)
# proc configure*(self: SpinButton, adjustment: Adjustment, climb_rate: float64, digits: uint32) {.inline.} =

# gtk_spin_button_get_adjustment
# flags: {isMethod} container: SpinButton
# need sugar: is method
# 'Adjustment' 'TransferNone[TAdjustment]' (diff., need sugar)
proc gtk_spin_button_get_adjustment(self: ptr TSpinButton): TransferNone[TAdjustment] {.cdecl, dynlib: lib, importc: "gtk_spin_button_get_adjustment".}
proc get_adjustment*(self: SpinButton): Adjustment {.inline.} =
  wrap(gtk_spin_button_get_adjustment(self))
# proc get_adjustment*(self: SpinButton): Adjustment {.inline.} =

# gtk_spin_button_get_digits
# flags: {isMethod} container: SpinButton
# need sugar: is method
# 'uint32' 'uint32'
proc gtk_spin_button_get_digits(self: ptr TSpinButton): uint32 {.cdecl, dynlib: lib, importc: "gtk_spin_button_get_digits".}
proc get_digits*(self: SpinButton): uint32 {.inline.} =
  gtk_spin_button_get_digits(self)
# proc get_digits*(self: SpinButton): uint32 {.inline.} =

# gtk_spin_button_get_increments
# flags: {isMethod} container: SpinButton
# need sugar: is method
# step 'var float64' 'ptr float64' OUT (diff., need sugar) optional
# page 'var float64' 'ptr float64' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_get_increments(self: ptr TSpinButton, step: ptr float64, page: ptr float64) {.cdecl, dynlib: lib, importc: "gtk_spin_button_get_increments".}
proc get_increments*(self: SpinButton, step: var float64, page: var float64) {.inline.} =
  gtk_spin_button_get_increments(self, addr(step), addr(page))
# tuple-return
# step: var float64
# page: var float64
# proc get_increments*(self: SpinButton) {.inline.} =

# gtk_spin_button_get_numeric
# flags: {isMethod} container: SpinButton
# need sugar: is method
# 'bool' 'bool'
proc gtk_spin_button_get_numeric(self: ptr TSpinButton): bool {.cdecl, dynlib: lib, importc: "gtk_spin_button_get_numeric".}
proc get_numeric*(self: SpinButton): bool {.inline.} =
  gtk_spin_button_get_numeric(self)
# proc get_numeric*(self: SpinButton): bool {.inline.} =

# gtk_spin_button_get_range
# flags: {isMethod} container: SpinButton
# need sugar: is method
# min 'var float64' 'ptr float64' OUT (diff., need sugar) optional
# max 'var float64' 'ptr float64' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_get_range(self: ptr TSpinButton, min: ptr float64, max: ptr float64) {.cdecl, dynlib: lib, importc: "gtk_spin_button_get_range".}
proc get_range*(self: SpinButton, min: var float64, max: var float64) {.inline.} =
  gtk_spin_button_get_range(self, addr(min), addr(max))
# tuple-return
# min: var float64
# max: var float64
# proc get_range*(self: SpinButton) {.inline.} =

# gtk_spin_button_get_snap_to_ticks
# flags: {isMethod} container: SpinButton
# need sugar: is method
# 'bool' 'bool'
proc gtk_spin_button_get_snap_to_ticks(self: ptr TSpinButton): bool {.cdecl, dynlib: lib, importc: "gtk_spin_button_get_snap_to_ticks".}
proc get_snap_to_ticks*(self: SpinButton): bool {.inline.} =
  gtk_spin_button_get_snap_to_ticks(self)
# proc get_snap_to_ticks*(self: SpinButton): bool {.inline.} =

# gtk_spin_button_get_update_policy
# flags: {isMethod} container: SpinButton
# need sugar: is method
# 'SpinButtonUpdatePolicy' 'SpinButtonUpdatePolicy'
proc gtk_spin_button_get_update_policy(self: ptr TSpinButton): SpinButtonUpdatePolicy {.cdecl, dynlib: lib, importc: "gtk_spin_button_get_update_policy".}
proc get_update_policy*(self: SpinButton): SpinButtonUpdatePolicy {.inline.} =
  gtk_spin_button_get_update_policy(self)
# proc get_update_policy*(self: SpinButton): SpinButtonUpdatePolicy {.inline.} =

# gtk_spin_button_get_value
# flags: {isMethod} container: SpinButton
# need sugar: is method
# 'float64' 'float64'
proc gtk_spin_button_get_value(self: ptr TSpinButton): float64 {.cdecl, dynlib: lib, importc: "gtk_spin_button_get_value".}
proc get_value*(self: SpinButton): float64 {.inline.} =
  gtk_spin_button_get_value(self)
# proc get_value*(self: SpinButton): float64 {.inline.} =

# gtk_spin_button_get_value_as_int
# flags: {isMethod} container: SpinButton
# need sugar: is method
# 'int32' 'int32'
proc gtk_spin_button_get_value_as_int(self: ptr TSpinButton): int32 {.cdecl, dynlib: lib, importc: "gtk_spin_button_get_value_as_int".}
proc get_value_as_int*(self: SpinButton): int32 {.inline.} =
  gtk_spin_button_get_value_as_int(self)
# proc get_value_as_int*(self: SpinButton): int32 {.inline.} =

# gtk_spin_button_get_wrap
# flags: {isMethod} container: SpinButton
# need sugar: is method
# 'bool' 'bool'
proc gtk_spin_button_get_wrap(self: ptr TSpinButton): bool {.cdecl, dynlib: lib, importc: "gtk_spin_button_get_wrap".}
proc get_wrap*(self: SpinButton): bool {.inline.} =
  gtk_spin_button_get_wrap(self)
# proc get_wrap*(self: SpinButton): bool {.inline.} =

# gtk_spin_button_set_adjustment
# flags: {isMethod} container: SpinButton
# need sugar: is method
# adjustment 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_set_adjustment(self: ptr TSpinButton, adjustment: ptr TAdjustment) {.cdecl, dynlib: lib, importc: "gtk_spin_button_set_adjustment".}
proc set_adjustment*(self: SpinButton, adjustment: Adjustment) {.inline.} =
  gtk_spin_button_set_adjustment(self, adjustment.getPointer)
# proc set_adjustment*(self: SpinButton, adjustment: Adjustment) {.inline.} =

# gtk_spin_button_set_digits
# flags: {isMethod} container: SpinButton
# need sugar: is method
# digits 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_set_digits(self: ptr TSpinButton, digits: uint32) {.cdecl, dynlib: lib, importc: "gtk_spin_button_set_digits".}
proc set_digits*(self: SpinButton, digits: uint32) {.inline.} =
  gtk_spin_button_set_digits(self, digits)
# proc set_digits*(self: SpinButton, digits: uint32) {.inline.} =

# gtk_spin_button_set_increments
# flags: {isMethod} container: SpinButton
# need sugar: is method
# step 'float64' 'float64' IN
# page 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_set_increments(self: ptr TSpinButton, step: float64, page: float64) {.cdecl, dynlib: lib, importc: "gtk_spin_button_set_increments".}
proc set_increments*(self: SpinButton, step: float64, page: float64) {.inline.} =
  gtk_spin_button_set_increments(self, step, page)
# proc set_increments*(self: SpinButton, step: float64, page: float64) {.inline.} =

# gtk_spin_button_set_numeric
# flags: {isMethod} container: SpinButton
# need sugar: is method
# numeric 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_set_numeric(self: ptr TSpinButton, numeric: bool) {.cdecl, dynlib: lib, importc: "gtk_spin_button_set_numeric".}
proc set_numeric*(self: SpinButton, numeric: bool) {.inline.} =
  gtk_spin_button_set_numeric(self, numeric)
# proc set_numeric*(self: SpinButton, numeric: bool) {.inline.} =

# gtk_spin_button_set_range
# flags: {isMethod} container: SpinButton
# need sugar: is method
# min 'float64' 'float64' IN
# max 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_set_range(self: ptr TSpinButton, min: float64, max: float64) {.cdecl, dynlib: lib, importc: "gtk_spin_button_set_range".}
proc set_range*(self: SpinButton, min: float64, max: float64) {.inline.} =
  gtk_spin_button_set_range(self, min, max)
# proc set_range*(self: SpinButton, min: float64, max: float64) {.inline.} =

# gtk_spin_button_set_snap_to_ticks
# flags: {isMethod} container: SpinButton
# need sugar: is method
# snap_to_ticks 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_set_snap_to_ticks(self: ptr TSpinButton, snap_to_ticks: bool) {.cdecl, dynlib: lib, importc: "gtk_spin_button_set_snap_to_ticks".}
proc set_snap_to_ticks*(self: SpinButton, snap_to_ticks: bool) {.inline.} =
  gtk_spin_button_set_snap_to_ticks(self, snap_to_ticks)
# proc set_snap_to_ticks*(self: SpinButton, snap_to_ticks: bool) {.inline.} =

# gtk_spin_button_set_update_policy
# flags: {isMethod} container: SpinButton
# need sugar: is method
# policy 'SpinButtonUpdatePolicy' 'SpinButtonUpdatePolicy' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_set_update_policy(self: ptr TSpinButton, policy: SpinButtonUpdatePolicy) {.cdecl, dynlib: lib, importc: "gtk_spin_button_set_update_policy".}
proc set_update_policy*(self: SpinButton, policy: SpinButtonUpdatePolicy) {.inline.} =
  gtk_spin_button_set_update_policy(self, policy)
# proc set_update_policy*(self: SpinButton, policy: SpinButtonUpdatePolicy) {.inline.} =

# gtk_spin_button_set_value
# flags: {isMethod} container: SpinButton
# need sugar: is method
# value 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_set_value(self: ptr TSpinButton, value: float64) {.cdecl, dynlib: lib, importc: "gtk_spin_button_set_value".}
proc set_value*(self: SpinButton, value: float64) {.inline.} =
  gtk_spin_button_set_value(self, value)
# proc set_value*(self: SpinButton, value: float64) {.inline.} =

# gtk_spin_button_set_wrap
# flags: {isMethod} container: SpinButton
# need sugar: is method
# wrap 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_set_wrap(self: ptr TSpinButton, wrap: bool) {.cdecl, dynlib: lib, importc: "gtk_spin_button_set_wrap".}
proc set_wrap*(self: SpinButton, wrap: bool) {.inline.} =
  gtk_spin_button_set_wrap(self, wrap)
# proc set_wrap*(self: SpinButton, wrap: bool) {.inline.} =

# gtk_spin_button_spin
# flags: {isMethod} container: SpinButton
# need sugar: is method
# direction 'SpinType' 'SpinType' IN
# increment 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_spin(self: ptr TSpinButton, direction: SpinType, increment: float64) {.cdecl, dynlib: lib, importc: "gtk_spin_button_spin".}
proc spin*(self: SpinButton, direction: SpinType, increment: float64) {.inline.} =
  gtk_spin_button_spin(self, direction, increment)
# proc spin*(self: SpinButton, direction: SpinType, increment: float64) {.inline.} =

# gtk_spin_button_update
# flags: {isMethod} container: SpinButton
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_update(self: ptr TSpinButton) {.cdecl, dynlib: lib, importc: "gtk_spin_button_update".}
proc update*(self: SpinButton) {.inline.} =
  gtk_spin_button_update(self)
# proc update*(self: SpinButton) {.inline.} =

# gtk_spinner_new
# flags: {isConstructor} container: Spinner
# need sugar: is static method
# 'Spinner' 'TransferNone[TSpinner]' (diff., need sugar)
proc gtk_spinner_new(): TransferNone[TSpinner] {.cdecl, dynlib: lib, importc: "gtk_spinner_new".}
proc new_spinner*(): Spinner {.inline.} =
  wrap(gtk_spinner_new())
# proc new_spinner*(): Spinner {.inline.} =

# gtk_spinner_start
# flags: {isMethod} container: Spinner
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_spinner_start(self: ptr TSpinner) {.cdecl, dynlib: lib, importc: "gtk_spinner_start".}
proc start*(self: Spinner) {.inline.} =
  gtk_spinner_start(self)
# proc start*(self: Spinner) {.inline.} =

# gtk_spinner_stop
# flags: {isMethod} container: Spinner
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_spinner_stop(self: ptr TSpinner) {.cdecl, dynlib: lib, importc: "gtk_spinner_stop".}
proc stop*(self: Spinner) {.inline.} =
  gtk_spinner_stop(self)
# proc stop*(self: Spinner) {.inline.} =

# gtk_stack_new
# flags: {isConstructor} container: Stack
# need sugar: is static method
# 'Stack' 'TransferNone[TStack]' (diff., need sugar)
proc gtk_stack_new(): TransferNone[TStack] {.cdecl, dynlib: lib, importc: "gtk_stack_new".}
proc new_stack*(): Stack {.inline.} =
  wrap(gtk_stack_new())
# proc new_stack*(): Stack {.inline.} =

# gtk_stack_add_named
# flags: {isMethod} container: Stack
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_stack_add_named(self: ptr TStack, child: ptr TWidget, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_stack_add_named".}
proc add_named*(self: Stack, child: Widget, name: ustring) {.inline.} =
  gtk_stack_add_named(self, child.getPointer, ucstring(name))
# proc add_named*(self: Stack, child: Widget, name: ustring) {.inline.} =

# gtk_stack_add_titled
# flags: {isMethod} container: Stack
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# name 'ustring' 'ucstring' IN (diff., need sugar)
# title 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_stack_add_titled(self: ptr TStack, child: ptr TWidget, name: ucstring, title: ucstring) {.cdecl, dynlib: lib, importc: "gtk_stack_add_titled".}
proc add_titled*(self: Stack, child: Widget, name: ustring, title: ustring) {.inline.} =
  gtk_stack_add_titled(self, child.getPointer, ucstring(name), ucstring(title))
# proc add_titled*(self: Stack, child: Widget, name: ustring, title: ustring) {.inline.} =

# gtk_stack_get_child_by_name
# flags: {isMethod} container: Stack
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_stack_get_child_by_name(self: ptr TStack, name: ucstring): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_stack_get_child_by_name".}
proc get_child_by_name*(self: Stack, name: ustring): Widget {.inline.} =
  wrap(gtk_stack_get_child_by_name(self, ucstring(name)))
# proc get_child_by_name*(self: Stack, name: ustring): Widget {.inline.} =

# gtk_stack_get_homogeneous
# flags: {isMethod} container: Stack
# need sugar: is method
# 'bool' 'bool'
proc gtk_stack_get_homogeneous(self: ptr TStack): bool {.cdecl, dynlib: lib, importc: "gtk_stack_get_homogeneous".}
proc get_homogeneous*(self: Stack): bool {.inline.} =
  gtk_stack_get_homogeneous(self)
# proc get_homogeneous*(self: Stack): bool {.inline.} =

# gtk_stack_get_transition_duration
# flags: {isMethod} container: Stack
# need sugar: is method
# 'uint32' 'uint32'
proc gtk_stack_get_transition_duration(self: ptr TStack): uint32 {.cdecl, dynlib: lib, importc: "gtk_stack_get_transition_duration".}
proc get_transition_duration*(self: Stack): uint32 {.inline.} =
  gtk_stack_get_transition_duration(self)
# proc get_transition_duration*(self: Stack): uint32 {.inline.} =

# gtk_stack_get_transition_running
# flags: {isMethod} container: Stack
# need sugar: is method
# 'bool' 'bool'
proc gtk_stack_get_transition_running(self: ptr TStack): bool {.cdecl, dynlib: lib, importc: "gtk_stack_get_transition_running".}
proc get_transition_running*(self: Stack): bool {.inline.} =
  gtk_stack_get_transition_running(self)
# proc get_transition_running*(self: Stack): bool {.inline.} =

# gtk_stack_get_transition_type
# flags: {isMethod} container: Stack
# need sugar: is method
# 'StackTransitionType' 'StackTransitionType'
proc gtk_stack_get_transition_type(self: ptr TStack): StackTransitionType {.cdecl, dynlib: lib, importc: "gtk_stack_get_transition_type".}
proc get_transition_type*(self: Stack): StackTransitionType {.inline.} =
  gtk_stack_get_transition_type(self)
# proc get_transition_type*(self: Stack): StackTransitionType {.inline.} =

# gtk_stack_get_visible_child
# flags: {isMethod} container: Stack
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_stack_get_visible_child(self: ptr TStack): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_stack_get_visible_child".}
proc get_visible_child*(self: Stack): Widget {.inline.} =
  wrap(gtk_stack_get_visible_child(self))
# proc get_visible_child*(self: Stack): Widget {.inline.} =

# gtk_stack_get_visible_child_name
# flags: {isMethod} container: Stack
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_stack_get_visible_child_name(self: ptr TStack): ucstring {.cdecl, dynlib: lib, importc: "gtk_stack_get_visible_child_name".}
proc get_visible_child_name*(self: Stack): ustring {.inline.} =
  ustring($(gtk_stack_get_visible_child_name(self)))
# proc get_visible_child_name*(self: Stack): ustring {.inline.} =

# gtk_stack_set_homogeneous
# flags: {isMethod} container: Stack
# need sugar: is method
# homogeneous 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_stack_set_homogeneous(self: ptr TStack, homogeneous: bool) {.cdecl, dynlib: lib, importc: "gtk_stack_set_homogeneous".}
proc set_homogeneous*(self: Stack, homogeneous: bool) {.inline.} =
  gtk_stack_set_homogeneous(self, homogeneous)
# proc set_homogeneous*(self: Stack, homogeneous: bool) {.inline.} =

# gtk_stack_set_transition_duration
# flags: {isMethod} container: Stack
# need sugar: is method
# duration 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_stack_set_transition_duration(self: ptr TStack, duration: uint32) {.cdecl, dynlib: lib, importc: "gtk_stack_set_transition_duration".}
proc set_transition_duration*(self: Stack, duration: uint32) {.inline.} =
  gtk_stack_set_transition_duration(self, duration)
# proc set_transition_duration*(self: Stack, duration: uint32) {.inline.} =

# gtk_stack_set_transition_type
# flags: {isMethod} container: Stack
# need sugar: is method
# transition 'StackTransitionType' 'StackTransitionType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_stack_set_transition_type(self: ptr TStack, transition: StackTransitionType) {.cdecl, dynlib: lib, importc: "gtk_stack_set_transition_type".}
proc set_transition_type*(self: Stack, transition: StackTransitionType) {.inline.} =
  gtk_stack_set_transition_type(self, transition)
# proc set_transition_type*(self: Stack, transition: StackTransitionType) {.inline.} =

# gtk_stack_set_visible_child
# flags: {isMethod} container: Stack
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_stack_set_visible_child(self: ptr TStack, child: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_stack_set_visible_child".}
proc set_visible_child*(self: Stack, child: Widget) {.inline.} =
  gtk_stack_set_visible_child(self, child.getPointer)
# proc set_visible_child*(self: Stack, child: Widget) {.inline.} =

# gtk_stack_set_visible_child_full
# flags: {isMethod} container: Stack
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# transition 'StackTransitionType' 'StackTransitionType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_stack_set_visible_child_full(self: ptr TStack, name: ucstring, transition: StackTransitionType) {.cdecl, dynlib: lib, importc: "gtk_stack_set_visible_child_full".}
proc set_visible_child_full*(self: Stack, name: ustring, transition: StackTransitionType) {.inline.} =
  gtk_stack_set_visible_child_full(self, ucstring(name), transition)
# proc set_visible_child_full*(self: Stack, name: ustring, transition: StackTransitionType) {.inline.} =

# gtk_stack_set_visible_child_name
# flags: {isMethod} container: Stack
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_stack_set_visible_child_name(self: ptr TStack, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_stack_set_visible_child_name".}
proc set_visible_child_name*(self: Stack, name: ustring) {.inline.} =
  gtk_stack_set_visible_child_name(self, ucstring(name))
# proc set_visible_child_name*(self: Stack, name: ustring) {.inline.} =

# gtk_stack_switcher_new
# flags: {isConstructor} container: StackSwitcher
# need sugar: is static method
# 'StackSwitcher' 'TransferNone[TStackSwitcher]' (diff., need sugar)
proc gtk_stack_switcher_new(): TransferNone[TStackSwitcher] {.cdecl, dynlib: lib, importc: "gtk_stack_switcher_new".}
proc new_stackswitcher*(): StackSwitcher {.inline.} =
  wrap(gtk_stack_switcher_new())
# proc new_stackswitcher*(): StackSwitcher {.inline.} =

# gtk_stack_switcher_get_stack
# flags: {isMethod} container: StackSwitcher
# need sugar: is method
# 'Stack' 'TransferNone[TStack]' (diff., need sugar)
proc gtk_stack_switcher_get_stack(self: ptr TStackSwitcher): TransferNone[TStack] {.cdecl, dynlib: lib, importc: "gtk_stack_switcher_get_stack".}
proc get_stack*(self: StackSwitcher): Stack {.inline.} =
  wrap(gtk_stack_switcher_get_stack(self))
# proc get_stack*(self: StackSwitcher): Stack {.inline.} =

# gtk_stack_switcher_set_stack
# flags: {isMethod} container: StackSwitcher
# need sugar: is method
# stack 'Stack' 'ptr TStack' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_stack_switcher_set_stack(self: ptr TStackSwitcher, stack: ptr TStack) {.cdecl, dynlib: lib, importc: "gtk_stack_switcher_set_stack".}
proc set_stack*(self: StackSwitcher, stack: Stack) {.inline.} =
  gtk_stack_switcher_set_stack(self, stack.getPointer)
# proc set_stack*(self: StackSwitcher, stack: Stack) {.inline.} =

# gtk_status_icon_new
# flags: {isConstructor} container: StatusIcon (deprecated)
# gtk_status_icon_new_from_file
# flags: {isConstructor} container: StatusIcon (deprecated)
# gtk_status_icon_new_from_gicon
# flags: {isConstructor} container: StatusIcon (deprecated)
# gtk_status_icon_new_from_icon_name
# flags: {isConstructor} container: StatusIcon (deprecated)
# gtk_status_icon_new_from_pixbuf
# flags: {isConstructor} container: StatusIcon (deprecated)
# gtk_status_icon_new_from_stock
# flags: {isConstructor} container: StatusIcon (deprecated)
# gtk_status_icon_position_menu
# flags: {} container: StatusIcon (deprecated)
# gtk_status_icon_get_geometry
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_get_gicon
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_get_has_tooltip
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_get_icon_name
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_get_pixbuf
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_get_screen
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_get_size
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_get_stock
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_get_storage_type
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_get_title
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_get_tooltip_markup
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_get_tooltip_text
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_get_visible
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_get_x11_window_id
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_is_embedded
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_set_from_file
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_set_from_gicon
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_set_from_icon_name
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_set_from_pixbuf
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_set_from_stock
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_set_has_tooltip
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_set_name
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_set_screen
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_set_title
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_set_tooltip_markup
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_set_tooltip_text
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_set_visible
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_statusbar_new
# flags: {isConstructor} container: Statusbar
# need sugar: is static method
# 'Statusbar' 'TransferNone[TStatusbar]' (diff., need sugar)
proc gtk_statusbar_new(): TransferNone[TStatusbar] {.cdecl, dynlib: lib, importc: "gtk_statusbar_new".}
proc new_statusbar*(): Statusbar {.inline.} =
  wrap(gtk_statusbar_new())
# proc new_statusbar*(): Statusbar {.inline.} =

# gtk_statusbar_get_context_id
# flags: {isMethod} container: Statusbar
# need sugar: is method
# context_description 'ustring' 'ucstring' IN (diff., need sugar)
# 'uint32' 'uint32'
proc gtk_statusbar_get_context_id(self: ptr TStatusbar, context_description: ucstring): uint32 {.cdecl, dynlib: lib, importc: "gtk_statusbar_get_context_id".}
proc get_context_id*(self: Statusbar, context_description: ustring): uint32 {.inline.} =
  gtk_statusbar_get_context_id(self, ucstring(context_description))
# proc get_context_id*(self: Statusbar, context_description: ustring): uint32 {.inline.} =

# gtk_statusbar_get_message_area
# flags: {isMethod} container: Statusbar
# need sugar: is method
# 'Box' 'TransferNone[TBox]' (diff., need sugar)
proc gtk_statusbar_get_message_area(self: ptr TStatusbar): TransferNone[TBox] {.cdecl, dynlib: lib, importc: "gtk_statusbar_get_message_area".}
proc get_message_area*(self: Statusbar): Box {.inline.} =
  wrap(gtk_statusbar_get_message_area(self))
# proc get_message_area*(self: Statusbar): Box {.inline.} =

# gtk_statusbar_pop
# flags: {isMethod} container: Statusbar
# need sugar: is method
# context_id 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_statusbar_pop(self: ptr TStatusbar, context_id: uint32) {.cdecl, dynlib: lib, importc: "gtk_statusbar_pop".}
proc pop*(self: Statusbar, context_id: uint32) {.inline.} =
  gtk_statusbar_pop(self, context_id)
# proc pop*(self: Statusbar, context_id: uint32) {.inline.} =

# gtk_statusbar_push
# flags: {isMethod} container: Statusbar
# need sugar: is method
# context_id 'uint32' 'uint32' IN
# text 'ustring' 'ucstring' IN (diff., need sugar)
# 'uint32' 'uint32'
proc gtk_statusbar_push(self: ptr TStatusbar, context_id: uint32, text: ucstring): uint32 {.cdecl, dynlib: lib, importc: "gtk_statusbar_push".}
proc push*(self: Statusbar, context_id: uint32, text: ustring): uint32 {.inline.} =
  gtk_statusbar_push(self, context_id, ucstring(text))
# proc push*(self: Statusbar, context_id: uint32, text: ustring): uint32 {.inline.} =

# gtk_statusbar_remove
# flags: {isMethod} container: Statusbar
# need sugar: is method
# context_id 'uint32' 'uint32' IN
# message_id 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_statusbar_remove(self: ptr TStatusbar, context_id: uint32, message_id: uint32) {.cdecl, dynlib: lib, importc: "gtk_statusbar_remove".}
proc remove*(self: Statusbar, context_id: uint32, message_id: uint32) {.inline.} =
  gtk_statusbar_remove(self, context_id, message_id)
# proc remove*(self: Statusbar, context_id: uint32, message_id: uint32) {.inline.} =

# gtk_statusbar_remove_all
# flags: {isMethod} container: Statusbar
# need sugar: is method
# context_id 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_statusbar_remove_all(self: ptr TStatusbar, context_id: uint32) {.cdecl, dynlib: lib, importc: "gtk_statusbar_remove_all".}
proc remove_all*(self: Statusbar, context_id: uint32) {.inline.} =
  gtk_statusbar_remove_all(self, context_id)
# proc remove_all*(self: Statusbar, context_id: uint32) {.inline.} =

# gtk_style_new
# flags: {isConstructor} container: Style (deprecated)
# gtk_style_apply_default_background
# flags: {isMethod} container: Style (deprecated)
# gtk_style_copy
# flags: {isMethod} container: Style (deprecated)
# gtk_style_detach
# flags: {isMethod} container: Style (deprecated)
# gtk_style_get_style_property
# flags: {isMethod} container: Style
# need sugar: is method
# widget_type 'GType' 'GType' IN
# property_name 'ustring' 'ucstring' IN (diff., need sugar)
# value 'var GObject2.TValue' 'ptr GObject2.TValue' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_get_style_property(self: ptr TStyle, widget_type: GType, property_name: ucstring, value: ptr GObject2.TValue) {.cdecl, dynlib: lib, importc: "gtk_style_get_style_property".}
proc get_style_property*(self: Style, widget_type: GType, property_name: ustring, value: var GObject2.TValue) {.inline.} =
  gtk_style_get_style_property(self, widget_type, ucstring(property_name), addr(value))
# tuple-return
# value: var GObject2.TValue
# proc get_style_property*(self: Style, widget_type: GType, property_name: ustring) {.inline.} =

# gtk_style_has_context
# flags: {isMethod} container: Style
# need sugar: is method
# 'bool' 'bool'
proc gtk_style_has_context(self: ptr TStyle): bool {.cdecl, dynlib: lib, importc: "gtk_style_has_context".}
proc has_context*(self: Style): bool {.inline.} =
  gtk_style_has_context(self)
# proc has_context*(self: Style): bool {.inline.} =

# gtk_style_lookup_color
# flags: {isMethod} container: Style (deprecated)
# gtk_style_lookup_icon_set
# flags: {isMethod} container: Style (deprecated)
# gtk_style_render_icon
# flags: {isMethod} container: Style (deprecated)
# gtk_style_set_background
# flags: {isMethod} container: Style (deprecated)
# gtk_style_context_new
# flags: {isConstructor} container: StyleContext
# need sugar: is static method
# 'StyleContext' 'TransferFull[TStyleContext]' (diff., need sugar)
proc gtk_style_context_new(): TransferFull[TStyleContext] {.cdecl, dynlib: lib, importc: "gtk_style_context_new".}
proc new_stylecontext*(): StyleContext {.inline.} =
  wrap(gtk_style_context_new())
# proc new_stylecontext*(): StyleContext {.inline.} =

# gtk_style_context_add_provider_for_screen
# flags: {} container: StyleContext
# need sugar: is static method
# screen 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# provider 'StyleProvider' 'ptr TStyleProvider' IN (diff., need sugar)
# priority 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_add_provider_for_screen(screen: ptr Gdk3.TScreen, provider: ptr TStyleProvider, priority: uint32) {.cdecl, dynlib: lib, importc: "gtk_style_context_add_provider_for_screen".}
template add_provider_for_screen*(klass_parameter: typedesc[StyleContext], screen: Gdk3.Screen, provider: StyleProvider, priority: uint32) =
  gtk_style_context_add_provider_for_screen(screen.getPointer, unwrap(provider), priority)
# template add_provider_for_screen*(klass_parameter: typedesc[StyleContext], screen: Gdk3.Screen, provider: StyleProvider, priority: uint32) =

# gtk_style_context_remove_provider_for_screen
# flags: {} container: StyleContext
# need sugar: is static method
# screen 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# provider 'StyleProvider' 'ptr TStyleProvider' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_remove_provider_for_screen(screen: ptr Gdk3.TScreen, provider: ptr TStyleProvider) {.cdecl, dynlib: lib, importc: "gtk_style_context_remove_provider_for_screen".}
template remove_provider_for_screen*(klass_parameter: typedesc[StyleContext], screen: Gdk3.Screen, provider: StyleProvider) =
  gtk_style_context_remove_provider_for_screen(screen.getPointer, unwrap(provider))
# template remove_provider_for_screen*(klass_parameter: typedesc[StyleContext], screen: Gdk3.Screen, provider: StyleProvider) =

# gtk_style_context_reset_widgets
# flags: {} container: StyleContext
# need sugar: is static method
# screen 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_reset_widgets(screen: ptr Gdk3.TScreen) {.cdecl, dynlib: lib, importc: "gtk_style_context_reset_widgets".}
template reset_widgets*(klass_parameter: typedesc[StyleContext], screen: Gdk3.Screen) =
  gtk_style_context_reset_widgets(screen.getPointer)
# template reset_widgets*(klass_parameter: typedesc[StyleContext], screen: Gdk3.Screen) =

# gtk_style_context_add_class
# flags: {isMethod} container: StyleContext
# need sugar: is method
# class_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_add_class(self: ptr TStyleContext, class_name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_style_context_add_class".}
proc add_class*(self: StyleContext, class_name: ustring) {.inline.} =
  gtk_style_context_add_class(self, ucstring(class_name))
# proc add_class*(self: StyleContext, class_name: ustring) {.inline.} =

# gtk_style_context_add_provider
# flags: {isMethod} container: StyleContext
# need sugar: is method
# provider 'StyleProvider' 'ptr TStyleProvider' IN (diff., need sugar)
# priority 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_add_provider(self: ptr TStyleContext, provider: ptr TStyleProvider, priority: uint32) {.cdecl, dynlib: lib, importc: "gtk_style_context_add_provider".}
proc add_provider*(self: StyleContext, provider: StyleProvider, priority: uint32) {.inline.} =
  gtk_style_context_add_provider(self, unwrap(provider), priority)
# proc add_provider*(self: StyleContext, provider: StyleProvider, priority: uint32) {.inline.} =

# gtk_style_context_add_region
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_cancel_animations
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_get_background_color
# flags: {isMethod} container: StyleContext
# need sugar: is method
# state 'SStateFlags' 'SStateFlags' IN
# color 'var Gdk3.TRGBA' 'ptr Gdk3.TRGBA' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_get_background_color(self: ptr TStyleContext, state: SStateFlags, color: ptr Gdk3.TRGBA) {.cdecl, dynlib: lib, importc: "gtk_style_context_get_background_color".}
proc get_background_color*(self: StyleContext, state: SStateFlags, color: var Gdk3.TRGBA) {.inline.} =
  gtk_style_context_get_background_color(self, state, addr(color))
# tuple-return
# color: var Gdk3.TRGBA
# proc get_background_color*(self: StyleContext, state: SStateFlags) {.inline.} =

# gtk_style_context_get_border
# flags: {isMethod} container: StyleContext
# need sugar: is method
# state 'SStateFlags' 'SStateFlags' IN
# border 'var TBorder' 'ptr TBorder' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_get_border(self: ptr TStyleContext, state: SStateFlags, border: ptr TBorder) {.cdecl, dynlib: lib, importc: "gtk_style_context_get_border".}
proc get_border*(self: StyleContext, state: SStateFlags, border: var TBorder) {.inline.} =
  gtk_style_context_get_border(self, state, addr(border))
# tuple-return
# border: var TBorder
# proc get_border*(self: StyleContext, state: SStateFlags) {.inline.} =

# gtk_style_context_get_border_color
# flags: {isMethod} container: StyleContext
# need sugar: is method
# state 'SStateFlags' 'SStateFlags' IN
# color 'var Gdk3.TRGBA' 'ptr Gdk3.TRGBA' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_get_border_color(self: ptr TStyleContext, state: SStateFlags, color: ptr Gdk3.TRGBA) {.cdecl, dynlib: lib, importc: "gtk_style_context_get_border_color".}
proc get_border_color*(self: StyleContext, state: SStateFlags, color: var Gdk3.TRGBA) {.inline.} =
  gtk_style_context_get_border_color(self, state, addr(color))
# tuple-return
# color: var Gdk3.TRGBA
# proc get_border_color*(self: StyleContext, state: SStateFlags) {.inline.} =

# gtk_style_context_get_color
# flags: {isMethod} container: StyleContext
# need sugar: is method
# state 'SStateFlags' 'SStateFlags' IN
# color 'var Gdk3.TRGBA' 'ptr Gdk3.TRGBA' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_get_color(self: ptr TStyleContext, state: SStateFlags, color: ptr Gdk3.TRGBA) {.cdecl, dynlib: lib, importc: "gtk_style_context_get_color".}
proc get_color*(self: StyleContext, state: SStateFlags, color: var Gdk3.TRGBA) {.inline.} =
  gtk_style_context_get_color(self, state, addr(color))
# tuple-return
# color: var Gdk3.TRGBA
# proc get_color*(self: StyleContext, state: SStateFlags) {.inline.} =

# gtk_style_context_get_direction
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_get_font
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_get_frame_clock
# flags: {isMethod} container: StyleContext
# need sugar: is method
# 'Gdk3.FrameClock' 'TransferNone[Gdk3.TFrameClock]' (diff., need sugar)
proc gtk_style_context_get_frame_clock(self: ptr TStyleContext): TransferNone[Gdk3.TFrameClock] {.cdecl, dynlib: lib, importc: "gtk_style_context_get_frame_clock".}
proc get_frame_clock*(self: StyleContext): Gdk3.FrameClock {.inline.} =
  wrap(gtk_style_context_get_frame_clock(self))
# proc get_frame_clock*(self: StyleContext): Gdk3.FrameClock {.inline.} =

# gtk_style_context_get_junction_sides
# flags: {isMethod} container: StyleContext
# need sugar: is method
# 'SJunctionSides' 'SJunctionSides'
proc gtk_style_context_get_junction_sides(self: ptr TStyleContext): SJunctionSides {.cdecl, dynlib: lib, importc: "gtk_style_context_get_junction_sides".}
proc get_junction_sides*(self: StyleContext): SJunctionSides {.inline.} =
  gtk_style_context_get_junction_sides(self)
# proc get_junction_sides*(self: StyleContext): SJunctionSides {.inline.} =

# gtk_style_context_get_margin
# flags: {isMethod} container: StyleContext
# need sugar: is method
# state 'SStateFlags' 'SStateFlags' IN
# margin 'var TBorder' 'ptr TBorder' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_get_margin(self: ptr TStyleContext, state: SStateFlags, margin: ptr TBorder) {.cdecl, dynlib: lib, importc: "gtk_style_context_get_margin".}
proc get_margin*(self: StyleContext, state: SStateFlags, margin: var TBorder) {.inline.} =
  gtk_style_context_get_margin(self, state, addr(margin))
# tuple-return
# margin: var TBorder
# proc get_margin*(self: StyleContext, state: SStateFlags) {.inline.} =

# gtk_style_context_get_padding
# flags: {isMethod} container: StyleContext
# need sugar: is method
# state 'SStateFlags' 'SStateFlags' IN
# padding 'var TBorder' 'ptr TBorder' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_get_padding(self: ptr TStyleContext, state: SStateFlags, padding: ptr TBorder) {.cdecl, dynlib: lib, importc: "gtk_style_context_get_padding".}
proc get_padding*(self: StyleContext, state: SStateFlags, padding: var TBorder) {.inline.} =
  gtk_style_context_get_padding(self, state, addr(padding))
# tuple-return
# padding: var TBorder
# proc get_padding*(self: StyleContext, state: SStateFlags) {.inline.} =

# gtk_style_context_get_parent
# flags: {isMethod} container: StyleContext
# need sugar: is method
# 'StyleContext' 'TransferNone[TStyleContext]' (diff., need sugar)
proc gtk_style_context_get_parent(self: ptr TStyleContext): TransferNone[TStyleContext] {.cdecl, dynlib: lib, importc: "gtk_style_context_get_parent".}
proc get_parent*(self: StyleContext): StyleContext {.inline.} =
  wrap(gtk_style_context_get_parent(self))
# proc get_parent*(self: StyleContext): StyleContext {.inline.} =

# gtk_style_context_get_path
# flags: {isMethod} container: StyleContext
# need sugar: is method
# 'TWidgetPath' 'ptr TWidgetPath' (diff., need sugar)
proc gtk_style_context_get_path(self: ptr TStyleContext): ptr TWidgetPath {.cdecl, dynlib: lib, importc: "gtk_style_context_get_path".}
proc get_path*(self: StyleContext): TWidgetPath {.inline.} =
  (gtk_style_context_get_path(self))[]
# proc get_path*(self: StyleContext): TWidgetPath {.inline.} =

# gtk_style_context_get_property
# flags: {isMethod} container: StyleContext
# need sugar: is method
# property 'ustring' 'ucstring' IN (diff., need sugar)
# state 'SStateFlags' 'SStateFlags' IN
# value 'var GObject2.TValue' 'ptr GObject2.TValue' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_get_property(self: ptr TStyleContext, property: ucstring, state: SStateFlags, value: ptr GObject2.TValue) {.cdecl, dynlib: lib, importc: "gtk_style_context_get_property".}
proc get_property*(self: StyleContext, property: ustring, state: SStateFlags, value: var GObject2.TValue) {.inline.} =
  gtk_style_context_get_property(self, ucstring(property), state, addr(value))
# tuple-return
# value: var GObject2.TValue
# proc get_property*(self: StyleContext, property: ustring, state: SStateFlags) {.inline.} =

# gtk_style_context_get_scale
# flags: {isMethod} container: StyleContext
# need sugar: is method
# 'int32' 'int32'
proc gtk_style_context_get_scale(self: ptr TStyleContext): int32 {.cdecl, dynlib: lib, importc: "gtk_style_context_get_scale".}
proc get_scale*(self: StyleContext): int32 {.inline.} =
  gtk_style_context_get_scale(self)
# proc get_scale*(self: StyleContext): int32 {.inline.} =

# gtk_style_context_get_screen
# flags: {isMethod} container: StyleContext
# need sugar: is method
# 'Gdk3.Screen' 'TransferNone[Gdk3.TScreen]' (diff., need sugar)
proc gtk_style_context_get_screen(self: ptr TStyleContext): TransferNone[Gdk3.TScreen] {.cdecl, dynlib: lib, importc: "gtk_style_context_get_screen".}
proc get_screen*(self: StyleContext): Gdk3.Screen {.inline.} =
  wrap(gtk_style_context_get_screen(self))
# proc get_screen*(self: StyleContext): Gdk3.Screen {.inline.} =

# gtk_style_context_get_section
# flags: {isMethod} container: StyleContext
# need sugar: is method
# property 'ustring' 'ucstring' IN (diff., need sugar)
# 'TCssSection' 'ptr TCssSection' (diff., need sugar)
proc gtk_style_context_get_section(self: ptr TStyleContext, property: ucstring): ptr TCssSection {.cdecl, dynlib: lib, importc: "gtk_style_context_get_section".}
proc get_section*(self: StyleContext, property: ustring): TCssSection {.inline.} =
  (gtk_style_context_get_section(self, ucstring(property)))[]
# proc get_section*(self: StyleContext, property: ustring): TCssSection {.inline.} =

# gtk_style_context_get_state
# flags: {isMethod} container: StyleContext
# need sugar: is method
# 'SStateFlags' 'SStateFlags'
proc gtk_style_context_get_state(self: ptr TStyleContext): SStateFlags {.cdecl, dynlib: lib, importc: "gtk_style_context_get_state".}
proc get_state*(self: StyleContext): SStateFlags {.inline.} =
  gtk_style_context_get_state(self)
# proc get_state*(self: StyleContext): SStateFlags {.inline.} =

# gtk_style_context_get_style_property
# flags: {isMethod} container: StyleContext
# need sugar: is method
# property_name 'ustring' 'ucstring' IN (diff., need sugar)
# value 'GObject2.TValue' 'ptr GObject2.TValue' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_get_style_property(self: ptr TStyleContext, property_name: ucstring, value: ptr GObject2.TValue) {.cdecl, dynlib: lib, importc: "gtk_style_context_get_style_property".}
proc get_style_property*(self: StyleContext, property_name: ustring, value: GObject2.TValue) {.inline.} =
  gtk_style_context_get_style_property(self, ucstring(property_name), myUnsafeAddr(value))
# proc get_style_property*(self: StyleContext, property_name: ustring, value: GObject2.TValue) {.inline.} =

# gtk_style_context_has_class
# flags: {isMethod} container: StyleContext
# need sugar: is method
# class_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_style_context_has_class(self: ptr TStyleContext, class_name: ucstring): bool {.cdecl, dynlib: lib, importc: "gtk_style_context_has_class".}
proc has_class*(self: StyleContext, class_name: ustring): bool {.inline.} =
  gtk_style_context_has_class(self, ucstring(class_name))
# proc has_class*(self: StyleContext, class_name: ustring): bool {.inline.} =

# gtk_style_context_has_region
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_invalidate
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_list_classes
# flags: {isMethod} container: StyleContext
# need sugar: is method
# 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_style_context_list_classes(self: ptr TStyleContext): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_style_context_list_classes".}
proc list_classes*(self: StyleContext): ptr GLIST_TODO {.inline.} =
  gtk_style_context_list_classes(self)
# proc list_classes*(self: StyleContext): ptr GLIST_TODO {.inline.} =

# gtk_style_context_list_regions
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_lookup_color
# flags: {isMethod} container: StyleContext
# need sugar: is method
# color_name 'ustring' 'ucstring' IN (diff., need sugar)
# color 'var Gdk3.TRGBA' 'ptr Gdk3.TRGBA' OUT (diff., need sugar) caller-allocates
# 'bool' 'bool'
proc gtk_style_context_lookup_color(self: ptr TStyleContext, color_name: ucstring, color: ptr Gdk3.TRGBA): bool {.cdecl, dynlib: lib, importc: "gtk_style_context_lookup_color".}
proc lookup_color*(self: StyleContext, color_name: ustring, color: var Gdk3.TRGBA): bool {.inline.} =
  gtk_style_context_lookup_color(self, ucstring(color_name), addr(color))
# tuple-return
# color: var Gdk3.TRGBA
# proc lookup_color*(self: StyleContext, color_name: ustring): bool {.inline.} =

# gtk_style_context_lookup_icon_set
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_notify_state_change
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_pop_animatable_region
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_push_animatable_region
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_remove_class
# flags: {isMethod} container: StyleContext
# need sugar: is method
# class_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_remove_class(self: ptr TStyleContext, class_name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_style_context_remove_class".}
proc remove_class*(self: StyleContext, class_name: ustring) {.inline.} =
  gtk_style_context_remove_class(self, ucstring(class_name))
# proc remove_class*(self: StyleContext, class_name: ustring) {.inline.} =

# gtk_style_context_remove_provider
# flags: {isMethod} container: StyleContext
# need sugar: is method
# provider 'StyleProvider' 'ptr TStyleProvider' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_remove_provider(self: ptr TStyleContext, provider: ptr TStyleProvider) {.cdecl, dynlib: lib, importc: "gtk_style_context_remove_provider".}
proc remove_provider*(self: StyleContext, provider: StyleProvider) {.inline.} =
  gtk_style_context_remove_provider(self, unwrap(provider))
# proc remove_provider*(self: StyleContext, provider: StyleProvider) {.inline.} =

# gtk_style_context_remove_region
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_restore
# flags: {isMethod} container: StyleContext
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_restore(self: ptr TStyleContext) {.cdecl, dynlib: lib, importc: "gtk_style_context_restore".}
proc restore*(self: StyleContext) {.inline.} =
  gtk_style_context_restore(self)
# proc restore*(self: StyleContext) {.inline.} =

# gtk_style_context_save
# flags: {isMethod} container: StyleContext
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_save(self: ptr TStyleContext) {.cdecl, dynlib: lib, importc: "gtk_style_context_save".}
proc save*(self: StyleContext) {.inline.} =
  gtk_style_context_save(self)
# proc save*(self: StyleContext) {.inline.} =

# gtk_style_context_scroll_animations
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_set_background
# flags: {isMethod} container: StyleContext
# need sugar: is method
# window 'Gdk3.Window' 'ptr Gdk3.TWindow' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_set_background(self: ptr TStyleContext, window: ptr Gdk3.TWindow) {.cdecl, dynlib: lib, importc: "gtk_style_context_set_background".}
proc set_background*(self: StyleContext, window: Gdk3.Window) {.inline.} =
  gtk_style_context_set_background(self, window.getPointer)
# proc set_background*(self: StyleContext, window: Gdk3.Window) {.inline.} =

# gtk_style_context_set_direction
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_set_frame_clock
# flags: {isMethod} container: StyleContext
# need sugar: is method
# frame_clock 'Gdk3.FrameClock' 'ptr Gdk3.TFrameClock' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_set_frame_clock(self: ptr TStyleContext, frame_clock: ptr Gdk3.TFrameClock) {.cdecl, dynlib: lib, importc: "gtk_style_context_set_frame_clock".}
proc set_frame_clock*(self: StyleContext, frame_clock: Gdk3.FrameClock) {.inline.} =
  gtk_style_context_set_frame_clock(self, frame_clock.getPointer)
# proc set_frame_clock*(self: StyleContext, frame_clock: Gdk3.FrameClock) {.inline.} =

# gtk_style_context_set_junction_sides
# flags: {isMethod} container: StyleContext
# need sugar: is method
# sides 'SJunctionSides' 'SJunctionSides' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_set_junction_sides(self: ptr TStyleContext, sides: SJunctionSides) {.cdecl, dynlib: lib, importc: "gtk_style_context_set_junction_sides".}
proc set_junction_sides*(self: StyleContext, sides: SJunctionSides) {.inline.} =
  gtk_style_context_set_junction_sides(self, sides)
# proc set_junction_sides*(self: StyleContext, sides: SJunctionSides) {.inline.} =

# gtk_style_context_set_parent
# flags: {isMethod} container: StyleContext
# need sugar: is method
# parent 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_set_parent(self: ptr TStyleContext, parent: ptr TStyleContext) {.cdecl, dynlib: lib, importc: "gtk_style_context_set_parent".}
proc set_parent*(self: StyleContext, parent: StyleContext) {.inline.} =
  gtk_style_context_set_parent(self, parent.getPointer)
# proc set_parent*(self: StyleContext, parent: StyleContext) {.inline.} =

# gtk_style_context_set_path
# flags: {isMethod} container: StyleContext
# need sugar: is method
# path 'TWidgetPath' 'ptr TWidgetPath' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_set_path(self: ptr TStyleContext, path: ptr TWidgetPath) {.cdecl, dynlib: lib, importc: "gtk_style_context_set_path".}
proc set_path*(self: StyleContext, path: TWidgetPath) {.inline.} =
  gtk_style_context_set_path(self, myUnsafeAddr(path))
# proc set_path*(self: StyleContext, path: TWidgetPath) {.inline.} =

# gtk_style_context_set_scale
# flags: {isMethod} container: StyleContext
# need sugar: is method
# scale 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_set_scale(self: ptr TStyleContext, scale: int32) {.cdecl, dynlib: lib, importc: "gtk_style_context_set_scale".}
proc set_scale*(self: StyleContext, scale: int32) {.inline.} =
  gtk_style_context_set_scale(self, scale)
# proc set_scale*(self: StyleContext, scale: int32) {.inline.} =

# gtk_style_context_set_screen
# flags: {isMethod} container: StyleContext
# need sugar: is method
# screen 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_set_screen(self: ptr TStyleContext, screen: ptr Gdk3.TScreen) {.cdecl, dynlib: lib, importc: "gtk_style_context_set_screen".}
proc set_screen*(self: StyleContext, screen: Gdk3.Screen) {.inline.} =
  gtk_style_context_set_screen(self, screen.getPointer)
# proc set_screen*(self: StyleContext, screen: Gdk3.Screen) {.inline.} =

# gtk_style_context_set_state
# flags: {isMethod} container: StyleContext
# need sugar: is method
# flags 'SStateFlags' 'SStateFlags' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_set_state(self: ptr TStyleContext, flags: SStateFlags) {.cdecl, dynlib: lib, importc: "gtk_style_context_set_state".}
proc set_state*(self: StyleContext, flags: SStateFlags) {.inline.} =
  gtk_style_context_set_state(self, flags)
# proc set_state*(self: StyleContext, flags: SStateFlags) {.inline.} =

# gtk_style_context_state_is_running
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_properties_new
# flags: {isConstructor} container: StyleProperties
# need sugar: is static method
# 'StyleProperties' 'TransferFull[TStyleProperties]' (diff., need sugar)
proc gtk_style_properties_new(): TransferFull[TStyleProperties] {.cdecl, dynlib: lib, importc: "gtk_style_properties_new".}
proc new_styleproperties*(): StyleProperties {.inline.} =
  wrap(gtk_style_properties_new())
# proc new_styleproperties*(): StyleProperties {.inline.} =

# gtk_style_properties_clear
# flags: {isMethod} container: StyleProperties
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_properties_clear(self: ptr TStyleProperties) {.cdecl, dynlib: lib, importc: "gtk_style_properties_clear".}
proc clear*(self: StyleProperties) {.inline.} =
  gtk_style_properties_clear(self)
# proc clear*(self: StyleProperties) {.inline.} =

# gtk_style_properties_get_property
# flags: {isMethod} container: StyleProperties
# need sugar: is method
# property 'ustring' 'ucstring' IN (diff., need sugar)
# state 'SStateFlags' 'SStateFlags' IN
# value 'var GObject2.TValue' 'ptr GObject2.TValue' OUT (diff., need sugar) caller-allocates
# 'bool' 'bool'
proc gtk_style_properties_get_property(self: ptr TStyleProperties, property: ucstring, state: SStateFlags, value: ptr GObject2.TValue): bool {.cdecl, dynlib: lib, importc: "gtk_style_properties_get_property".}
proc get_property*(self: StyleProperties, property: ustring, state: SStateFlags, value: var GObject2.TValue): bool {.inline.} =
  gtk_style_properties_get_property(self, ucstring(property), state, addr(value))
# tuple-return
# value: var GObject2.TValue
# proc get_property*(self: StyleProperties, property: ustring, state: SStateFlags): bool {.inline.} =

# gtk_style_properties_lookup_color
# flags: {isMethod} container: StyleProperties (deprecated)
# gtk_style_properties_map_color
# flags: {isMethod} container: StyleProperties (deprecated)
# gtk_style_properties_merge
# flags: {isMethod} container: StyleProperties
# need sugar: is method
# props_to_merge 'StyleProperties' 'ptr TStyleProperties' IN (diff., need sugar)
# replace 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_properties_merge(self: ptr TStyleProperties, props_to_merge: ptr TStyleProperties, replace: bool) {.cdecl, dynlib: lib, importc: "gtk_style_properties_merge".}
proc merge*(self: StyleProperties, props_to_merge: StyleProperties, replace: bool) {.inline.} =
  gtk_style_properties_merge(self, props_to_merge.getPointer, replace)
# proc merge*(self: StyleProperties, props_to_merge: StyleProperties, replace: bool) {.inline.} =

# gtk_style_properties_set_property
# flags: {isMethod} container: StyleProperties
# need sugar: is method
# property 'ustring' 'ucstring' IN (diff., need sugar)
# state 'SStateFlags' 'SStateFlags' IN
# value 'GObject2.TValue' 'ptr GObject2.TValue' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_properties_set_property(self: ptr TStyleProperties, property: ucstring, state: SStateFlags, value: ptr GObject2.TValue) {.cdecl, dynlib: lib, importc: "gtk_style_properties_set_property".}
proc set_property*(self: StyleProperties, property: ustring, state: SStateFlags, value: GObject2.TValue) {.inline.} =
  gtk_style_properties_set_property(self, ucstring(property), state, myUnsafeAddr(value))
# proc set_property*(self: StyleProperties, property: ustring, state: SStateFlags, value: GObject2.TValue) {.inline.} =

# gtk_style_properties_unset_property
# flags: {isMethod} container: StyleProperties
# need sugar: is method
# property 'ustring' 'ucstring' IN (diff., need sugar)
# state 'SStateFlags' 'SStateFlags' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_style_properties_unset_property(self: ptr TStyleProperties, property: ucstring, state: SStateFlags) {.cdecl, dynlib: lib, importc: "gtk_style_properties_unset_property".}
proc unset_property*(self: StyleProperties, property: ustring, state: SStateFlags) {.inline.} =
  gtk_style_properties_unset_property(self, ucstring(property), state)
# proc unset_property*(self: StyleProperties, property: ustring, state: SStateFlags) {.inline.} =

# gtk_switch_new
# flags: {isConstructor} container: Switch
# need sugar: is static method
# 'Switch' 'TransferNone[TSwitch]' (diff., need sugar)
proc gtk_switch_new(): TransferNone[TSwitch] {.cdecl, dynlib: lib, importc: "gtk_switch_new".}
proc new_switch*(): Switch {.inline.} =
  wrap(gtk_switch_new())
# proc new_switch*(): Switch {.inline.} =

# gtk_switch_get_active
# flags: {isMethod} container: Switch
# need sugar: is method
# 'bool' 'bool'
proc gtk_switch_get_active(self: ptr TSwitch): bool {.cdecl, dynlib: lib, importc: "gtk_switch_get_active".}
proc get_active*(self: Switch): bool {.inline.} =
  gtk_switch_get_active(self)
# proc get_active*(self: Switch): bool {.inline.} =

# gtk_switch_get_state
# flags: {isMethod} container: Switch
# need sugar: is method
# 'bool' 'bool'
proc gtk_switch_get_state(self: ptr TSwitch): bool {.cdecl, dynlib: lib, importc: "gtk_switch_get_state".}
proc get_state*(self: Switch): bool {.inline.} =
  gtk_switch_get_state(self)
# proc get_state*(self: Switch): bool {.inline.} =

# gtk_switch_set_active
# flags: {isMethod} container: Switch
# need sugar: is method
# is_active 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_switch_set_active(self: ptr TSwitch, is_active: bool) {.cdecl, dynlib: lib, importc: "gtk_switch_set_active".}
proc set_active*(self: Switch, is_active: bool) {.inline.} =
  gtk_switch_set_active(self, is_active)
# proc set_active*(self: Switch, is_active: bool) {.inline.} =

# gtk_switch_set_state
# flags: {isMethod} container: Switch
# need sugar: is method
# state 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_switch_set_state(self: ptr TSwitch, state: bool) {.cdecl, dynlib: lib, importc: "gtk_switch_set_state".}
proc set_state*(self: Switch, state: bool) {.inline.} =
  gtk_switch_set_state(self, state)
# proc set_state*(self: Switch, state: bool) {.inline.} =

# gtk_table_new
# flags: {isConstructor} container: Table (deprecated)
# gtk_table_attach
# flags: {isMethod} container: Table (deprecated)
# gtk_table_attach_defaults
# flags: {isMethod} container: Table (deprecated)
# gtk_table_get_col_spacing
# flags: {isMethod} container: Table (deprecated)
# gtk_table_get_default_col_spacing
# flags: {isMethod} container: Table (deprecated)
# gtk_table_get_default_row_spacing
# flags: {isMethod} container: Table (deprecated)
# gtk_table_get_homogeneous
# flags: {isMethod} container: Table (deprecated)
# gtk_table_get_row_spacing
# flags: {isMethod} container: Table (deprecated)
# gtk_table_get_size
# flags: {isMethod} container: Table (deprecated)
# gtk_table_resize
# flags: {isMethod} container: Table (deprecated)
# gtk_table_set_col_spacing
# flags: {isMethod} container: Table (deprecated)
# gtk_table_set_col_spacings
# flags: {isMethod} container: Table (deprecated)
# gtk_table_set_homogeneous
# flags: {isMethod} container: Table (deprecated)
# gtk_table_set_row_spacing
# flags: {isMethod} container: Table (deprecated)
# gtk_table_set_row_spacings
# flags: {isMethod} container: Table (deprecated)
# gtk_tearoff_menu_item_new
# flags: {isConstructor} container: TearoffMenuItem (deprecated)
# gtk_text_buffer_new
# flags: {isConstructor} container: TextBuffer
# need sugar: is static method
# table 'TextTagTable' 'ptr TTextTagTable' IN (diff., need sugar)
# 'TextBuffer' 'TransferFull[TTextBuffer]' (diff., need sugar)
proc gtk_text_buffer_new(table: ptr TTextTagTable): TransferFull[TTextBuffer] {.cdecl, dynlib: lib, importc: "gtk_text_buffer_new".}
proc new_textbuffer*(table: TextTagTable): TextBuffer {.inline.} =
  wrap(gtk_text_buffer_new(table.getPointer))
# proc new_textbuffer*(table: TextTagTable): TextBuffer {.inline.} =

# gtk_text_buffer_add_mark
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# mark 'TextMark' 'ptr TTextMark' IN (diff., need sugar)
# where 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_add_mark(self: ptr TTextBuffer, mark: ptr TTextMark, where: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_add_mark".}
proc add_mark*(self: TextBuffer, mark: TextMark, where: TTextIter) {.inline.} =
  gtk_text_buffer_add_mark(self, mark.getPointer, myUnsafeAddr(where))
# proc add_mark*(self: TextBuffer, mark: TextMark, where: TTextIter) {.inline.} =

# gtk_text_buffer_add_selection_clipboard
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# clipboard 'Clipboard' 'ptr TClipboard' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_add_selection_clipboard(self: ptr TTextBuffer, clipboard: ptr TClipboard) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_add_selection_clipboard".}
proc add_selection_clipboard*(self: TextBuffer, clipboard: Clipboard) {.inline.} =
  gtk_text_buffer_add_selection_clipboard(self, clipboard.getPointer)
# proc add_selection_clipboard*(self: TextBuffer, clipboard: Clipboard) {.inline.} =

# gtk_text_buffer_apply_tag
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# tag 'TextTag' 'ptr TTextTag' IN (diff., need sugar)
# start 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# end 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_apply_tag(self: ptr TTextBuffer, tag: ptr TTextTag, start: ptr TTextIter, end_x: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_apply_tag".}
proc apply_tag*(self: TextBuffer, tag: TextTag, start: TTextIter, end_x: TTextIter) {.inline.} =
  gtk_text_buffer_apply_tag(self, tag.getPointer, myUnsafeAddr(start), myUnsafeAddr(end_x))
# proc apply_tag*(self: TextBuffer, tag: TextTag, start: TTextIter, end_x: TTextIter) {.inline.} =

# gtk_text_buffer_apply_tag_by_name
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# start 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# end 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_apply_tag_by_name(self: ptr TTextBuffer, name: ucstring, start: ptr TTextIter, end_x: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_apply_tag_by_name".}
proc apply_tag_by_name*(self: TextBuffer, name: ustring, start: TTextIter, end_x: TTextIter) {.inline.} =
  gtk_text_buffer_apply_tag_by_name(self, ucstring(name), myUnsafeAddr(start), myUnsafeAddr(end_x))
# proc apply_tag_by_name*(self: TextBuffer, name: ustring, start: TTextIter, end_x: TTextIter) {.inline.} =

# gtk_text_buffer_backspace
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# iter 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# interactive 'bool' 'bool' IN
# default_editable 'bool' 'bool' IN
# 'bool' 'bool'
proc gtk_text_buffer_backspace(self: ptr TTextBuffer, iter: ptr TTextIter, interactive: bool, default_editable: bool): bool {.cdecl, dynlib: lib, importc: "gtk_text_buffer_backspace".}
proc backspace*(self: TextBuffer, iter: TTextIter, interactive: bool, default_editable: bool): bool {.inline.} =
  gtk_text_buffer_backspace(self, myUnsafeAddr(iter), interactive, default_editable)
# proc backspace*(self: TextBuffer, iter: TTextIter, interactive: bool, default_editable: bool): bool {.inline.} =

# gtk_text_buffer_begin_user_action
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_begin_user_action(self: ptr TTextBuffer) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_begin_user_action".}
proc begin_user_action*(self: TextBuffer) {.inline.} =
  gtk_text_buffer_begin_user_action(self)
# proc begin_user_action*(self: TextBuffer) {.inline.} =

# gtk_text_buffer_copy_clipboard
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# clipboard 'Clipboard' 'ptr TClipboard' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_copy_clipboard(self: ptr TTextBuffer, clipboard: ptr TClipboard) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_copy_clipboard".}
proc copy_clipboard*(self: TextBuffer, clipboard: Clipboard) {.inline.} =
  gtk_text_buffer_copy_clipboard(self, clipboard.getPointer)
# proc copy_clipboard*(self: TextBuffer, clipboard: Clipboard) {.inline.} =

# gtk_text_buffer_create_child_anchor
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# iter 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'TextChildAnchor' 'TransferNone[TTextChildAnchor]' (diff., need sugar)
proc gtk_text_buffer_create_child_anchor(self: ptr TTextBuffer, iter: ptr TTextIter): TransferNone[TTextChildAnchor] {.cdecl, dynlib: lib, importc: "gtk_text_buffer_create_child_anchor".}
proc create_child_anchor*(self: TextBuffer, iter: TTextIter): TextChildAnchor {.inline.} =
  wrap(gtk_text_buffer_create_child_anchor(self, myUnsafeAddr(iter)))
# proc create_child_anchor*(self: TextBuffer, iter: TTextIter): TextChildAnchor {.inline.} =

# gtk_text_buffer_create_mark
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# mark_name 'ustring' 'ucstring' IN (diff., need sugar)
# where 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# left_gravity 'bool' 'bool' IN
# 'TextMark' 'TransferNone[TTextMark]' (diff., need sugar)
proc gtk_text_buffer_create_mark(self: ptr TTextBuffer, mark_name: ucstring, where: ptr TTextIter, left_gravity: bool): TransferNone[TTextMark] {.cdecl, dynlib: lib, importc: "gtk_text_buffer_create_mark".}
proc create_mark*(self: TextBuffer, mark_name: ustring, where: TTextIter, left_gravity: bool): TextMark {.inline.} =
  wrap(gtk_text_buffer_create_mark(self, ucstring(mark_name), myUnsafeAddr(where), left_gravity))
# proc create_mark*(self: TextBuffer, mark_name: ustring, where: TTextIter, left_gravity: bool): TextMark {.inline.} =

# gtk_text_buffer_cut_clipboard
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# clipboard 'Clipboard' 'ptr TClipboard' IN (diff., need sugar)
# default_editable 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_cut_clipboard(self: ptr TTextBuffer, clipboard: ptr TClipboard, default_editable: bool) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_cut_clipboard".}
proc cut_clipboard*(self: TextBuffer, clipboard: Clipboard, default_editable: bool) {.inline.} =
  gtk_text_buffer_cut_clipboard(self, clipboard.getPointer, default_editable)
# proc cut_clipboard*(self: TextBuffer, clipboard: Clipboard, default_editable: bool) {.inline.} =

# gtk_text_buffer_delete
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# start 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# end 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_delete(self: ptr TTextBuffer, start: ptr TTextIter, end_x: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_delete".}
proc delete*(self: TextBuffer, start: TTextIter, end_x: TTextIter) {.inline.} =
  gtk_text_buffer_delete(self, myUnsafeAddr(start), myUnsafeAddr(end_x))
# proc delete*(self: TextBuffer, start: TTextIter, end_x: TTextIter) {.inline.} =

# gtk_text_buffer_delete_interactive
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# start_iter 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# end_iter 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# default_editable 'bool' 'bool' IN
# 'bool' 'bool'
proc gtk_text_buffer_delete_interactive(self: ptr TTextBuffer, start_iter: ptr TTextIter, end_iter: ptr TTextIter, default_editable: bool): bool {.cdecl, dynlib: lib, importc: "gtk_text_buffer_delete_interactive".}
proc delete_interactive*(self: TextBuffer, start_iter: TTextIter, end_iter: TTextIter, default_editable: bool): bool {.inline.} =
  gtk_text_buffer_delete_interactive(self, myUnsafeAddr(start_iter), myUnsafeAddr(end_iter), default_editable)
# proc delete_interactive*(self: TextBuffer, start_iter: TTextIter, end_iter: TTextIter, default_editable: bool): bool {.inline.} =

# gtk_text_buffer_delete_mark
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# mark 'TextMark' 'ptr TTextMark' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_delete_mark(self: ptr TTextBuffer, mark: ptr TTextMark) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_delete_mark".}
proc delete_mark*(self: TextBuffer, mark: TextMark) {.inline.} =
  gtk_text_buffer_delete_mark(self, mark.getPointer)
# proc delete_mark*(self: TextBuffer, mark: TextMark) {.inline.} =

# gtk_text_buffer_delete_mark_by_name
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_delete_mark_by_name(self: ptr TTextBuffer, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_delete_mark_by_name".}
proc delete_mark_by_name*(self: TextBuffer, name: ustring) {.inline.} =
  gtk_text_buffer_delete_mark_by_name(self, ucstring(name))
# proc delete_mark_by_name*(self: TextBuffer, name: ustring) {.inline.} =

# gtk_text_buffer_delete_selection
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# interactive 'bool' 'bool' IN
# default_editable 'bool' 'bool' IN
# 'bool' 'bool'
proc gtk_text_buffer_delete_selection(self: ptr TTextBuffer, interactive: bool, default_editable: bool): bool {.cdecl, dynlib: lib, importc: "gtk_text_buffer_delete_selection".}
proc delete_selection*(self: TextBuffer, interactive: bool, default_editable: bool): bool {.inline.} =
  gtk_text_buffer_delete_selection(self, interactive, default_editable)
# proc delete_selection*(self: TextBuffer, interactive: bool, default_editable: bool): bool {.inline.} =

# gtk_text_buffer_deserialize
# flags: {isMethod, throws} container: TextBuffer
# can throw
# need sugar: is method
# content_buffer 'TextBuffer' 'ptr TTextBuffer' IN (diff., need sugar)
# format 'Gdk3.TAtom' 'ptr Gdk3.TAtom' IN (diff., need sugar)
# iter 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# data 'string' 'cstring' IN (diff., need sugar) array lengthArg: 4
# length 'uint32' 'uint32' IN
# 'bool' 'bool'
proc gtk_text_buffer_deserialize(self: ptr TTextBuffer, content_buffer: ptr TTextBuffer, format: ptr Gdk3.TAtom, iter: ptr TTextIter, data: cstring, length: uint32, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_text_buffer_deserialize".}
proc deserialize*(self: TextBuffer, content_buffer: TextBuffer, format: Gdk3.TAtom, iter: TTextIter, data: string): bool {.inline.} =
  gtk_text_buffer_deserialize(self, content_buffer.getPointer, myUnsafeAddr(format), myUnsafeAddr(iter), cstring(data), data.len.uint32)
# proc deserialize*(self: TextBuffer, content_buffer: TextBuffer, format: Gdk3.TAtom, iter: TTextIter, data: string): bool {.inline.} =

# gtk_text_buffer_deserialize_get_can_create_tags
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# format 'Gdk3.TAtom' 'ptr Gdk3.TAtom' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_text_buffer_deserialize_get_can_create_tags(self: ptr TTextBuffer, format: ptr Gdk3.TAtom): bool {.cdecl, dynlib: lib, importc: "gtk_text_buffer_deserialize_get_can_create_tags".}
proc deserialize_get_can_create_tags*(self: TextBuffer, format: Gdk3.TAtom): bool {.inline.} =
  gtk_text_buffer_deserialize_get_can_create_tags(self, myUnsafeAddr(format))
# proc deserialize_get_can_create_tags*(self: TextBuffer, format: Gdk3.TAtom): bool {.inline.} =

# gtk_text_buffer_deserialize_set_can_create_tags
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# format 'Gdk3.TAtom' 'ptr Gdk3.TAtom' IN (diff., need sugar)
# can_create_tags 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_deserialize_set_can_create_tags(self: ptr TTextBuffer, format: ptr Gdk3.TAtom, can_create_tags: bool) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_deserialize_set_can_create_tags".}
proc deserialize_set_can_create_tags*(self: TextBuffer, format: Gdk3.TAtom, can_create_tags: bool) {.inline.} =
  gtk_text_buffer_deserialize_set_can_create_tags(self, myUnsafeAddr(format), can_create_tags)
# proc deserialize_set_can_create_tags*(self: TextBuffer, format: Gdk3.TAtom, can_create_tags: bool) {.inline.} =

# gtk_text_buffer_end_user_action
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_end_user_action(self: ptr TTextBuffer) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_end_user_action".}
proc end_user_action*(self: TextBuffer) {.inline.} =
  gtk_text_buffer_end_user_action(self)
# proc end_user_action*(self: TextBuffer) {.inline.} =

# gtk_text_buffer_get_bounds
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# start 'var TTextIter' 'ptr TTextIter' OUT (diff., need sugar) caller-allocates
# end 'var TTextIter' 'ptr TTextIter' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_get_bounds(self: ptr TTextBuffer, start: ptr TTextIter, end_x: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_bounds".}
proc get_bounds*(self: TextBuffer, start: var TTextIter, end_x: var TTextIter) {.inline.} =
  gtk_text_buffer_get_bounds(self, addr(start), addr(end_x))
# tuple-return
# start: var TTextIter
# end: var TTextIter
# proc get_bounds*(self: TextBuffer) {.inline.} =

# gtk_text_buffer_get_char_count
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# 'int32' 'int32'
proc gtk_text_buffer_get_char_count(self: ptr TTextBuffer): int32 {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_char_count".}
proc get_char_count*(self: TextBuffer): int32 {.inline.} =
  gtk_text_buffer_get_char_count(self)
# proc get_char_count*(self: TextBuffer): int32 {.inline.} =

# gtk_text_buffer_get_copy_target_list
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# 'TTargetList' 'ptr TTargetList' (diff., need sugar)
proc gtk_text_buffer_get_copy_target_list(self: ptr TTextBuffer): ptr TTargetList {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_copy_target_list".}
proc get_copy_target_list*(self: TextBuffer): TTargetList {.inline.} =
  (gtk_text_buffer_get_copy_target_list(self))[]
# proc get_copy_target_list*(self: TextBuffer): TTargetList {.inline.} =

# gtk_text_buffer_get_deserialize_formats
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# n_formats 'var int32' 'ptr int32' OUT (diff., need sugar)
# 'zeroTerminatedArray[ptr Gdk3.TAtom]' 'zeroTerminatedArray[ptr Gdk3.TAtom]'
proc gtk_text_buffer_get_deserialize_formats(self: ptr TTextBuffer, n_formats: ptr int32): zeroTerminatedArray[ptr Gdk3.TAtom] {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_deserialize_formats".}
proc get_deserialize_formats*(self: TextBuffer, n_formats: var int32): zeroTerminatedArray[ptr Gdk3.TAtom] {.inline.} =
  gtk_text_buffer_get_deserialize_formats(self, addr(n_formats))
# tuple-return
# n_formats: var int32
# proc get_deserialize_formats*(self: TextBuffer): zeroTerminatedArray[ptr Gdk3.TAtom] {.inline.} =

# gtk_text_buffer_get_end_iter
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# iter 'var TTextIter' 'ptr TTextIter' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_get_end_iter(self: ptr TTextBuffer, iter: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_end_iter".}
proc get_end_iter*(self: TextBuffer, iter: var TTextIter) {.inline.} =
  gtk_text_buffer_get_end_iter(self, addr(iter))
# tuple-return
# iter: var TTextIter
# proc get_end_iter*(self: TextBuffer) {.inline.} =

# gtk_text_buffer_get_has_selection
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_buffer_get_has_selection(self: ptr TTextBuffer): bool {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_has_selection".}
proc get_has_selection*(self: TextBuffer): bool {.inline.} =
  gtk_text_buffer_get_has_selection(self)
# proc get_has_selection*(self: TextBuffer): bool {.inline.} =

# gtk_text_buffer_get_insert
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# 'TextMark' 'TransferNone[TTextMark]' (diff., need sugar)
proc gtk_text_buffer_get_insert(self: ptr TTextBuffer): TransferNone[TTextMark] {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_insert".}
proc get_insert*(self: TextBuffer): TextMark {.inline.} =
  wrap(gtk_text_buffer_get_insert(self))
# proc get_insert*(self: TextBuffer): TextMark {.inline.} =

# gtk_text_buffer_get_iter_at_child_anchor
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# iter 'var TTextIter' 'ptr TTextIter' OUT (diff., need sugar) caller-allocates
# anchor 'TextChildAnchor' 'ptr TTextChildAnchor' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_get_iter_at_child_anchor(self: ptr TTextBuffer, iter: ptr TTextIter, anchor: ptr TTextChildAnchor) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_iter_at_child_anchor".}
proc get_iter_at_child_anchor*(self: TextBuffer, iter: var TTextIter, anchor: TextChildAnchor) {.inline.} =
  gtk_text_buffer_get_iter_at_child_anchor(self, addr(iter), anchor.getPointer)
# tuple-return
# iter: var TTextIter
# proc get_iter_at_child_anchor*(self: TextBuffer, anchor: TextChildAnchor) {.inline.} =

# gtk_text_buffer_get_iter_at_line
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# iter 'var TTextIter' 'ptr TTextIter' OUT (diff., need sugar) caller-allocates
# line_number 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_get_iter_at_line(self: ptr TTextBuffer, iter: ptr TTextIter, line_number: int32) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_iter_at_line".}
proc get_iter_at_line*(self: TextBuffer, iter: var TTextIter, line_number: int32) {.inline.} =
  gtk_text_buffer_get_iter_at_line(self, addr(iter), line_number)
# tuple-return
# iter: var TTextIter
# proc get_iter_at_line*(self: TextBuffer, line_number: int32) {.inline.} =

# gtk_text_buffer_get_iter_at_line_index
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# iter 'var TTextIter' 'ptr TTextIter' OUT (diff., need sugar) caller-allocates
# line_number 'int32' 'int32' IN
# byte_index 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_get_iter_at_line_index(self: ptr TTextBuffer, iter: ptr TTextIter, line_number: int32, byte_index: int32) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_iter_at_line_index".}
proc get_iter_at_line_index*(self: TextBuffer, iter: var TTextIter, line_number: int32, byte_index: int32) {.inline.} =
  gtk_text_buffer_get_iter_at_line_index(self, addr(iter), line_number, byte_index)
# tuple-return
# iter: var TTextIter
# proc get_iter_at_line_index*(self: TextBuffer, line_number: int32, byte_index: int32) {.inline.} =

# gtk_text_buffer_get_iter_at_line_offset
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# iter 'var TTextIter' 'ptr TTextIter' OUT (diff., need sugar) caller-allocates
# line_number 'int32' 'int32' IN
# char_offset 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_get_iter_at_line_offset(self: ptr TTextBuffer, iter: ptr TTextIter, line_number: int32, char_offset: int32) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_iter_at_line_offset".}
proc get_iter_at_line_offset*(self: TextBuffer, iter: var TTextIter, line_number: int32, char_offset: int32) {.inline.} =
  gtk_text_buffer_get_iter_at_line_offset(self, addr(iter), line_number, char_offset)
# tuple-return
# iter: var TTextIter
# proc get_iter_at_line_offset*(self: TextBuffer, line_number: int32, char_offset: int32) {.inline.} =

# gtk_text_buffer_get_iter_at_mark
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# iter 'var TTextIter' 'ptr TTextIter' OUT (diff., need sugar) caller-allocates
# mark 'TextMark' 'ptr TTextMark' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_get_iter_at_mark(self: ptr TTextBuffer, iter: ptr TTextIter, mark: ptr TTextMark) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_iter_at_mark".}
proc get_iter_at_mark*(self: TextBuffer, iter: var TTextIter, mark: TextMark) {.inline.} =
  gtk_text_buffer_get_iter_at_mark(self, addr(iter), mark.getPointer)
# tuple-return
# iter: var TTextIter
# proc get_iter_at_mark*(self: TextBuffer, mark: TextMark) {.inline.} =

# gtk_text_buffer_get_iter_at_offset
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# iter 'var TTextIter' 'ptr TTextIter' OUT (diff., need sugar) caller-allocates
# char_offset 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_get_iter_at_offset(self: ptr TTextBuffer, iter: ptr TTextIter, char_offset: int32) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_iter_at_offset".}
proc get_iter_at_offset*(self: TextBuffer, iter: var TTextIter, char_offset: int32) {.inline.} =
  gtk_text_buffer_get_iter_at_offset(self, addr(iter), char_offset)
# tuple-return
# iter: var TTextIter
# proc get_iter_at_offset*(self: TextBuffer, char_offset: int32) {.inline.} =

# gtk_text_buffer_get_line_count
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# 'int32' 'int32'
proc gtk_text_buffer_get_line_count(self: ptr TTextBuffer): int32 {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_line_count".}
proc get_line_count*(self: TextBuffer): int32 {.inline.} =
  gtk_text_buffer_get_line_count(self)
# proc get_line_count*(self: TextBuffer): int32 {.inline.} =

# gtk_text_buffer_get_mark
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# 'TextMark' 'TransferNone[TTextMark]' (diff., need sugar)
proc gtk_text_buffer_get_mark(self: ptr TTextBuffer, name: ucstring): TransferNone[TTextMark] {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_mark".}
proc get_mark*(self: TextBuffer, name: ustring): TextMark {.inline.} =
  wrap(gtk_text_buffer_get_mark(self, ucstring(name)))
# proc get_mark*(self: TextBuffer, name: ustring): TextMark {.inline.} =

# gtk_text_buffer_get_modified
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_buffer_get_modified(self: ptr TTextBuffer): bool {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_modified".}
proc get_modified*(self: TextBuffer): bool {.inline.} =
  gtk_text_buffer_get_modified(self)
# proc get_modified*(self: TextBuffer): bool {.inline.} =

# gtk_text_buffer_get_paste_target_list
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# 'TTargetList' 'ptr TTargetList' (diff., need sugar)
proc gtk_text_buffer_get_paste_target_list(self: ptr TTextBuffer): ptr TTargetList {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_paste_target_list".}
proc get_paste_target_list*(self: TextBuffer): TTargetList {.inline.} =
  (gtk_text_buffer_get_paste_target_list(self))[]
# proc get_paste_target_list*(self: TextBuffer): TTargetList {.inline.} =

# gtk_text_buffer_get_selection_bound
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# 'TextMark' 'TransferNone[TTextMark]' (diff., need sugar)
proc gtk_text_buffer_get_selection_bound(self: ptr TTextBuffer): TransferNone[TTextMark] {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_selection_bound".}
proc get_selection_bound*(self: TextBuffer): TextMark {.inline.} =
  wrap(gtk_text_buffer_get_selection_bound(self))
# proc get_selection_bound*(self: TextBuffer): TextMark {.inline.} =

# gtk_text_buffer_get_selection_bounds
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# start 'var TTextIter' 'ptr TTextIter' OUT (diff., need sugar) caller-allocates
# end 'var TTextIter' 'ptr TTextIter' OUT (diff., need sugar) caller-allocates
# 'bool' 'bool'
proc gtk_text_buffer_get_selection_bounds(self: ptr TTextBuffer, start: ptr TTextIter, end_x: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_selection_bounds".}
proc get_selection_bounds*(self: TextBuffer, start: var TTextIter, end_x: var TTextIter): bool {.inline.} =
  gtk_text_buffer_get_selection_bounds(self, addr(start), addr(end_x))
# tuple-return
# start: var TTextIter
# end: var TTextIter
# proc get_selection_bounds*(self: TextBuffer): bool {.inline.} =

# gtk_text_buffer_get_serialize_formats
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# n_formats 'var int32' 'ptr int32' OUT (diff., need sugar)
# 'zeroTerminatedArray[ptr Gdk3.TAtom]' 'zeroTerminatedArray[ptr Gdk3.TAtom]'
proc gtk_text_buffer_get_serialize_formats(self: ptr TTextBuffer, n_formats: ptr int32): zeroTerminatedArray[ptr Gdk3.TAtom] {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_serialize_formats".}
proc get_serialize_formats*(self: TextBuffer, n_formats: var int32): zeroTerminatedArray[ptr Gdk3.TAtom] {.inline.} =
  gtk_text_buffer_get_serialize_formats(self, addr(n_formats))
# tuple-return
# n_formats: var int32
# proc get_serialize_formats*(self: TextBuffer): zeroTerminatedArray[ptr Gdk3.TAtom] {.inline.} =

# gtk_text_buffer_get_slice
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# start 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# end 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# include_hidden_chars 'bool' 'bool' IN
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_text_buffer_get_slice(self: ptr TTextBuffer, start: ptr TTextIter, end_x: ptr TTextIter, include_hidden_chars: bool): ucstring {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_slice".}
proc get_slice*(self: TextBuffer, start: TTextIter, end_x: TTextIter, include_hidden_chars: bool): ustring {.inline.} =
  ustring($(gtk_text_buffer_get_slice(self, myUnsafeAddr(start), myUnsafeAddr(end_x), include_hidden_chars)))
# proc get_slice*(self: TextBuffer, start: TTextIter, end_x: TTextIter, include_hidden_chars: bool): ustring {.inline.} =

# gtk_text_buffer_get_start_iter
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# iter 'var TTextIter' 'ptr TTextIter' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_get_start_iter(self: ptr TTextBuffer, iter: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_start_iter".}
proc get_start_iter*(self: TextBuffer, iter: var TTextIter) {.inline.} =
  gtk_text_buffer_get_start_iter(self, addr(iter))
# tuple-return
# iter: var TTextIter
# proc get_start_iter*(self: TextBuffer) {.inline.} =

# gtk_text_buffer_get_tag_table
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# 'TextTagTable' 'TransferNone[TTextTagTable]' (diff., need sugar)
proc gtk_text_buffer_get_tag_table(self: ptr TTextBuffer): TransferNone[TTextTagTable] {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_tag_table".}
proc get_tag_table*(self: TextBuffer): TextTagTable {.inline.} =
  wrap(gtk_text_buffer_get_tag_table(self))
# proc get_tag_table*(self: TextBuffer): TextTagTable {.inline.} =

# gtk_text_buffer_get_text
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# start 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# end 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# include_hidden_chars 'bool' 'bool' IN
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_text_buffer_get_text(self: ptr TTextBuffer, start: ptr TTextIter, end_x: ptr TTextIter, include_hidden_chars: bool): ucstring {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_text".}
proc get_text*(self: TextBuffer, start: TTextIter, end_x: TTextIter, include_hidden_chars: bool): ustring {.inline.} =
  ustring($(gtk_text_buffer_get_text(self, myUnsafeAddr(start), myUnsafeAddr(end_x), include_hidden_chars)))
# proc get_text*(self: TextBuffer, start: TTextIter, end_x: TTextIter, include_hidden_chars: bool): ustring {.inline.} =

# gtk_text_buffer_insert
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# iter 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# text 'ustring' 'ucstring' IN (diff., need sugar)
# len 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_insert(self: ptr TTextBuffer, iter: ptr TTextIter, text: ucstring, len: int32) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_insert".}
proc insert*(self: TextBuffer, iter: TTextIter, text: ustring, len: int32) {.inline.} =
  gtk_text_buffer_insert(self, myUnsafeAddr(iter), ucstring(text), len)
# proc insert*(self: TextBuffer, iter: TTextIter, text: ustring, len: int32) {.inline.} =

# gtk_text_buffer_insert_at_cursor
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# text 'ustring' 'ucstring' IN (diff., need sugar)
# len 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_insert_at_cursor(self: ptr TTextBuffer, text: ucstring, len: int32) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_insert_at_cursor".}
proc insert_at_cursor*(self: TextBuffer, text: ustring, len: int32) {.inline.} =
  gtk_text_buffer_insert_at_cursor(self, ucstring(text), len)
# proc insert_at_cursor*(self: TextBuffer, text: ustring, len: int32) {.inline.} =

# gtk_text_buffer_insert_child_anchor
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# iter 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# anchor 'TextChildAnchor' 'ptr TTextChildAnchor' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_insert_child_anchor(self: ptr TTextBuffer, iter: ptr TTextIter, anchor: ptr TTextChildAnchor) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_insert_child_anchor".}
proc insert_child_anchor*(self: TextBuffer, iter: TTextIter, anchor: TextChildAnchor) {.inline.} =
  gtk_text_buffer_insert_child_anchor(self, myUnsafeAddr(iter), anchor.getPointer)
# proc insert_child_anchor*(self: TextBuffer, iter: TTextIter, anchor: TextChildAnchor) {.inline.} =

# gtk_text_buffer_insert_interactive
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# iter 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# text 'ustring' 'ucstring' IN (diff., need sugar)
# len 'int32' 'int32' IN
# default_editable 'bool' 'bool' IN
# 'bool' 'bool'
proc gtk_text_buffer_insert_interactive(self: ptr TTextBuffer, iter: ptr TTextIter, text: ucstring, len: int32, default_editable: bool): bool {.cdecl, dynlib: lib, importc: "gtk_text_buffer_insert_interactive".}
proc insert_interactive*(self: TextBuffer, iter: TTextIter, text: ustring, len: int32, default_editable: bool): bool {.inline.} =
  gtk_text_buffer_insert_interactive(self, myUnsafeAddr(iter), ucstring(text), len, default_editable)
# proc insert_interactive*(self: TextBuffer, iter: TTextIter, text: ustring, len: int32, default_editable: bool): bool {.inline.} =

# gtk_text_buffer_insert_interactive_at_cursor
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# text 'ustring' 'ucstring' IN (diff., need sugar)
# len 'int32' 'int32' IN
# default_editable 'bool' 'bool' IN
# 'bool' 'bool'
proc gtk_text_buffer_insert_interactive_at_cursor(self: ptr TTextBuffer, text: ucstring, len: int32, default_editable: bool): bool {.cdecl, dynlib: lib, importc: "gtk_text_buffer_insert_interactive_at_cursor".}
proc insert_interactive_at_cursor*(self: TextBuffer, text: ustring, len: int32, default_editable: bool): bool {.inline.} =
  gtk_text_buffer_insert_interactive_at_cursor(self, ucstring(text), len, default_editable)
# proc insert_interactive_at_cursor*(self: TextBuffer, text: ustring, len: int32, default_editable: bool): bool {.inline.} =

# gtk_text_buffer_insert_pixbuf
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# iter 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# pixbuf 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_insert_pixbuf(self: ptr TTextBuffer, iter: ptr TTextIter, pixbuf: ptr GdkPixbuf2.TPixbuf) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_insert_pixbuf".}
proc insert_pixbuf*(self: TextBuffer, iter: TTextIter, pixbuf: GdkPixbuf2.Pixbuf) {.inline.} =
  gtk_text_buffer_insert_pixbuf(self, myUnsafeAddr(iter), pixbuf.getPointer)
# proc insert_pixbuf*(self: TextBuffer, iter: TTextIter, pixbuf: GdkPixbuf2.Pixbuf) {.inline.} =

# gtk_text_buffer_insert_range
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# iter 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# start 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# end 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_insert_range(self: ptr TTextBuffer, iter: ptr TTextIter, start: ptr TTextIter, end_x: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_insert_range".}
proc insert_range*(self: TextBuffer, iter: TTextIter, start: TTextIter, end_x: TTextIter) {.inline.} =
  gtk_text_buffer_insert_range(self, myUnsafeAddr(iter), myUnsafeAddr(start), myUnsafeAddr(end_x))
# proc insert_range*(self: TextBuffer, iter: TTextIter, start: TTextIter, end_x: TTextIter) {.inline.} =

# gtk_text_buffer_insert_range_interactive
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# iter 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# start 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# end 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# default_editable 'bool' 'bool' IN
# 'bool' 'bool'
proc gtk_text_buffer_insert_range_interactive(self: ptr TTextBuffer, iter: ptr TTextIter, start: ptr TTextIter, end_x: ptr TTextIter, default_editable: bool): bool {.cdecl, dynlib: lib, importc: "gtk_text_buffer_insert_range_interactive".}
proc insert_range_interactive*(self: TextBuffer, iter: TTextIter, start: TTextIter, end_x: TTextIter, default_editable: bool): bool {.inline.} =
  gtk_text_buffer_insert_range_interactive(self, myUnsafeAddr(iter), myUnsafeAddr(start), myUnsafeAddr(end_x), default_editable)
# proc insert_range_interactive*(self: TextBuffer, iter: TTextIter, start: TTextIter, end_x: TTextIter, default_editable: bool): bool {.inline.} =

# gtk_text_buffer_move_mark
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# mark 'TextMark' 'ptr TTextMark' IN (diff., need sugar)
# where 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_move_mark(self: ptr TTextBuffer, mark: ptr TTextMark, where: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_move_mark".}
proc move_mark*(self: TextBuffer, mark: TextMark, where: TTextIter) {.inline.} =
  gtk_text_buffer_move_mark(self, mark.getPointer, myUnsafeAddr(where))
# proc move_mark*(self: TextBuffer, mark: TextMark, where: TTextIter) {.inline.} =

# gtk_text_buffer_move_mark_by_name
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# where 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_move_mark_by_name(self: ptr TTextBuffer, name: ucstring, where: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_move_mark_by_name".}
proc move_mark_by_name*(self: TextBuffer, name: ustring, where: TTextIter) {.inline.} =
  gtk_text_buffer_move_mark_by_name(self, ucstring(name), myUnsafeAddr(where))
# proc move_mark_by_name*(self: TextBuffer, name: ustring, where: TTextIter) {.inline.} =

# gtk_text_buffer_paste_clipboard
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# clipboard 'Clipboard' 'ptr TClipboard' IN (diff., need sugar)
# override_location 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# default_editable 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_paste_clipboard(self: ptr TTextBuffer, clipboard: ptr TClipboard, override_location: ptr TTextIter, default_editable: bool) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_paste_clipboard".}
proc paste_clipboard*(self: TextBuffer, clipboard: Clipboard, override_location: TTextIter, default_editable: bool) {.inline.} =
  gtk_text_buffer_paste_clipboard(self, clipboard.getPointer, myUnsafeAddr(override_location), default_editable)
# proc paste_clipboard*(self: TextBuffer, clipboard: Clipboard, override_location: TTextIter, default_editable: bool) {.inline.} =

# gtk_text_buffer_place_cursor
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# where 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_place_cursor(self: ptr TTextBuffer, where: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_place_cursor".}
proc place_cursor*(self: TextBuffer, where: TTextIter) {.inline.} =
  gtk_text_buffer_place_cursor(self, myUnsafeAddr(where))
# proc place_cursor*(self: TextBuffer, where: TTextIter) {.inline.} =

# gtk_text_buffer_register_deserialize_format
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# mime_type 'ustring' 'ucstring' IN (diff., need sugar)
# function 'pointer' 'pointer' IN
# user_data 'pointer' 'pointer' IN
# user_data_destroy 'pointer' 'pointer' IN
# 'Gdk3.TAtom' 'ptr Gdk3.TAtom' (diff., need sugar)
proc gtk_text_buffer_register_deserialize_format(self: ptr TTextBuffer, mime_type: ucstring, function: pointer, user_data: pointer, user_data_destroy: pointer): ptr Gdk3.TAtom {.cdecl, dynlib: lib, importc: "gtk_text_buffer_register_deserialize_format".}
proc register_deserialize_format*(self: TextBuffer, mime_type: ustring, function: pointer, user_data: pointer, user_data_destroy: pointer): Gdk3.TAtom {.inline.} =
  (gtk_text_buffer_register_deserialize_format(self, ucstring(mime_type), function, user_data, user_data_destroy))[]
# proc register_deserialize_format*(self: TextBuffer, mime_type: ustring, function: pointer, user_data: pointer, user_data_destroy: pointer): Gdk3.TAtom {.inline.} =

# gtk_text_buffer_register_deserialize_tagset
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# tagset_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'Gdk3.TAtom' 'ptr Gdk3.TAtom' (diff., need sugar)
proc gtk_text_buffer_register_deserialize_tagset(self: ptr TTextBuffer, tagset_name: ucstring): ptr Gdk3.TAtom {.cdecl, dynlib: lib, importc: "gtk_text_buffer_register_deserialize_tagset".}
proc register_deserialize_tagset*(self: TextBuffer, tagset_name: ustring): Gdk3.TAtom {.inline.} =
  (gtk_text_buffer_register_deserialize_tagset(self, ucstring(tagset_name)))[]
# proc register_deserialize_tagset*(self: TextBuffer, tagset_name: ustring): Gdk3.TAtom {.inline.} =

# gtk_text_buffer_register_serialize_format
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# mime_type 'ustring' 'ucstring' IN (diff., need sugar)
# function 'pointer' 'pointer' IN
# user_data 'pointer' 'pointer' IN
# user_data_destroy 'pointer' 'pointer' IN
# 'Gdk3.TAtom' 'ptr Gdk3.TAtom' (diff., need sugar)
proc gtk_text_buffer_register_serialize_format(self: ptr TTextBuffer, mime_type: ucstring, function: pointer, user_data: pointer, user_data_destroy: pointer): ptr Gdk3.TAtom {.cdecl, dynlib: lib, importc: "gtk_text_buffer_register_serialize_format".}
proc register_serialize_format*(self: TextBuffer, mime_type: ustring, function: pointer, user_data: pointer, user_data_destroy: pointer): Gdk3.TAtom {.inline.} =
  (gtk_text_buffer_register_serialize_format(self, ucstring(mime_type), function, user_data, user_data_destroy))[]
# proc register_serialize_format*(self: TextBuffer, mime_type: ustring, function: pointer, user_data: pointer, user_data_destroy: pointer): Gdk3.TAtom {.inline.} =

# gtk_text_buffer_register_serialize_tagset
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# tagset_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'Gdk3.TAtom' 'ptr Gdk3.TAtom' (diff., need sugar)
proc gtk_text_buffer_register_serialize_tagset(self: ptr TTextBuffer, tagset_name: ucstring): ptr Gdk3.TAtom {.cdecl, dynlib: lib, importc: "gtk_text_buffer_register_serialize_tagset".}
proc register_serialize_tagset*(self: TextBuffer, tagset_name: ustring): Gdk3.TAtom {.inline.} =
  (gtk_text_buffer_register_serialize_tagset(self, ucstring(tagset_name)))[]
# proc register_serialize_tagset*(self: TextBuffer, tagset_name: ustring): Gdk3.TAtom {.inline.} =

# gtk_text_buffer_remove_all_tags
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# start 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# end 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_remove_all_tags(self: ptr TTextBuffer, start: ptr TTextIter, end_x: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_remove_all_tags".}
proc remove_all_tags*(self: TextBuffer, start: TTextIter, end_x: TTextIter) {.inline.} =
  gtk_text_buffer_remove_all_tags(self, myUnsafeAddr(start), myUnsafeAddr(end_x))
# proc remove_all_tags*(self: TextBuffer, start: TTextIter, end_x: TTextIter) {.inline.} =

# gtk_text_buffer_remove_selection_clipboard
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# clipboard 'Clipboard' 'ptr TClipboard' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_remove_selection_clipboard(self: ptr TTextBuffer, clipboard: ptr TClipboard) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_remove_selection_clipboard".}
proc remove_selection_clipboard*(self: TextBuffer, clipboard: Clipboard) {.inline.} =
  gtk_text_buffer_remove_selection_clipboard(self, clipboard.getPointer)
# proc remove_selection_clipboard*(self: TextBuffer, clipboard: Clipboard) {.inline.} =

# gtk_text_buffer_remove_tag
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# tag 'TextTag' 'ptr TTextTag' IN (diff., need sugar)
# start 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# end 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_remove_tag(self: ptr TTextBuffer, tag: ptr TTextTag, start: ptr TTextIter, end_x: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_remove_tag".}
proc remove_tag*(self: TextBuffer, tag: TextTag, start: TTextIter, end_x: TTextIter) {.inline.} =
  gtk_text_buffer_remove_tag(self, tag.getPointer, myUnsafeAddr(start), myUnsafeAddr(end_x))
# proc remove_tag*(self: TextBuffer, tag: TextTag, start: TTextIter, end_x: TTextIter) {.inline.} =

# gtk_text_buffer_remove_tag_by_name
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# start 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# end 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_remove_tag_by_name(self: ptr TTextBuffer, name: ucstring, start: ptr TTextIter, end_x: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_remove_tag_by_name".}
proc remove_tag_by_name*(self: TextBuffer, name: ustring, start: TTextIter, end_x: TTextIter) {.inline.} =
  gtk_text_buffer_remove_tag_by_name(self, ucstring(name), myUnsafeAddr(start), myUnsafeAddr(end_x))
# proc remove_tag_by_name*(self: TextBuffer, name: ustring, start: TTextIter, end_x: TTextIter) {.inline.} =

# gtk_text_buffer_select_range
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# ins 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# bound 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_select_range(self: ptr TTextBuffer, ins: ptr TTextIter, bound: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_select_range".}
proc select_range*(self: TextBuffer, ins: TTextIter, bound: TTextIter) {.inline.} =
  gtk_text_buffer_select_range(self, myUnsafeAddr(ins), myUnsafeAddr(bound))
# proc select_range*(self: TextBuffer, ins: TTextIter, bound: TTextIter) {.inline.} =

# gtk_text_buffer_serialize
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# content_buffer 'TextBuffer' 'ptr TTextBuffer' IN (diff., need sugar)
# format 'Gdk3.TAtom' 'ptr Gdk3.TAtom' IN (diff., need sugar)
# start 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# end 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# length 'var uint32' 'ptr uint32' OUT (diff., need sugar)
# 'string' 'cstring' (diff., need sugar)
proc gtk_text_buffer_serialize(self: ptr TTextBuffer, content_buffer: ptr TTextBuffer, format: ptr Gdk3.TAtom, start: ptr TTextIter, end_x: ptr TTextIter, length: ptr uint32): cstring {.cdecl, dynlib: lib, importc: "gtk_text_buffer_serialize".}
proc serialize*(self: TextBuffer, content_buffer: TextBuffer, format: Gdk3.TAtom, start: TTextIter, end_x: TTextIter, length: var uint32): string {.inline.} =
  $(gtk_text_buffer_serialize(self, content_buffer.getPointer, myUnsafeAddr(format), myUnsafeAddr(start), myUnsafeAddr(end_x), addr(length)))
# tuple-return
# length: var uint32
# proc serialize*(self: TextBuffer, content_buffer: TextBuffer, format: Gdk3.TAtom, start: TTextIter, end_x: TTextIter): string {.inline.} =

# gtk_text_buffer_set_modified
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_set_modified(self: ptr TTextBuffer, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_set_modified".}
proc set_modified*(self: TextBuffer, setting: bool) {.inline.} =
  gtk_text_buffer_set_modified(self, setting)
# proc set_modified*(self: TextBuffer, setting: bool) {.inline.} =

# gtk_text_buffer_set_text
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# text 'ustring' 'ucstring' IN (diff., need sugar)
# len 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_set_text(self: ptr TTextBuffer, text: ucstring, len: int32) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_set_text".}
proc set_text*(self: TextBuffer, text: ustring, len: int32) {.inline.} =
  gtk_text_buffer_set_text(self, ucstring(text), len)
# proc set_text*(self: TextBuffer, text: ustring, len: int32) {.inline.} =

# gtk_text_buffer_unregister_deserialize_format
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# format 'Gdk3.TAtom' 'ptr Gdk3.TAtom' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_unregister_deserialize_format(self: ptr TTextBuffer, format: ptr Gdk3.TAtom) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_unregister_deserialize_format".}
proc unregister_deserialize_format*(self: TextBuffer, format: Gdk3.TAtom) {.inline.} =
  gtk_text_buffer_unregister_deserialize_format(self, myUnsafeAddr(format))
# proc unregister_deserialize_format*(self: TextBuffer, format: Gdk3.TAtom) {.inline.} =

# gtk_text_buffer_unregister_serialize_format
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# format 'Gdk3.TAtom' 'ptr Gdk3.TAtom' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_unregister_serialize_format(self: ptr TTextBuffer, format: ptr Gdk3.TAtom) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_unregister_serialize_format".}
proc unregister_serialize_format*(self: TextBuffer, format: Gdk3.TAtom) {.inline.} =
  gtk_text_buffer_unregister_serialize_format(self, myUnsafeAddr(format))
# proc unregister_serialize_format*(self: TextBuffer, format: Gdk3.TAtom) {.inline.} =

# gtk_text_child_anchor_new
# flags: {isConstructor} container: TextChildAnchor
# need sugar: is static method
# 'TextChildAnchor' 'TransferFull[TTextChildAnchor]' (diff., need sugar)
proc gtk_text_child_anchor_new(): TransferFull[TTextChildAnchor] {.cdecl, dynlib: lib, importc: "gtk_text_child_anchor_new".}
proc new_textchildanchor*(): TextChildAnchor {.inline.} =
  wrap(gtk_text_child_anchor_new())
# proc new_textchildanchor*(): TextChildAnchor {.inline.} =

# gtk_text_child_anchor_get_deleted
# flags: {isMethod} container: TextChildAnchor
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_child_anchor_get_deleted(self: ptr TTextChildAnchor): bool {.cdecl, dynlib: lib, importc: "gtk_text_child_anchor_get_deleted".}
proc get_deleted*(self: TextChildAnchor): bool {.inline.} =
  gtk_text_child_anchor_get_deleted(self)
# proc get_deleted*(self: TextChildAnchor): bool {.inline.} =

# gtk_text_child_anchor_get_widgets
# flags: {isMethod} container: TextChildAnchor
# need sugar: is method
# 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_text_child_anchor_get_widgets(self: ptr TTextChildAnchor): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_text_child_anchor_get_widgets".}
proc get_widgets*(self: TextChildAnchor): ptr GLIST_TODO {.inline.} =
  gtk_text_child_anchor_get_widgets(self)
# proc get_widgets*(self: TextChildAnchor): ptr GLIST_TODO {.inline.} =

# gtk_text_mark_new
# flags: {isConstructor} container: TextMark
# need sugar: is static method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# left_gravity 'bool' 'bool' IN
# 'TextMark' 'TransferFull[TTextMark]' (diff., need sugar)
proc gtk_text_mark_new(name: ucstring, left_gravity: bool): TransferFull[TTextMark] {.cdecl, dynlib: lib, importc: "gtk_text_mark_new".}
proc new_textmark*(name: ustring, left_gravity: bool): TextMark {.inline.} =
  wrap(gtk_text_mark_new(ucstring(name), left_gravity))
# proc new_textmark*(name: ustring, left_gravity: bool): TextMark {.inline.} =

# gtk_text_mark_get_buffer
# flags: {isMethod} container: TextMark
# need sugar: is method
# 'TextBuffer' 'TransferNone[TTextBuffer]' (diff., need sugar)
proc gtk_text_mark_get_buffer(self: ptr TTextMark): TransferNone[TTextBuffer] {.cdecl, dynlib: lib, importc: "gtk_text_mark_get_buffer".}
proc get_buffer*(self: TextMark): TextBuffer {.inline.} =
  wrap(gtk_text_mark_get_buffer(self))
# proc get_buffer*(self: TextMark): TextBuffer {.inline.} =

# gtk_text_mark_get_deleted
# flags: {isMethod} container: TextMark
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_mark_get_deleted(self: ptr TTextMark): bool {.cdecl, dynlib: lib, importc: "gtk_text_mark_get_deleted".}
proc get_deleted*(self: TextMark): bool {.inline.} =
  gtk_text_mark_get_deleted(self)
# proc get_deleted*(self: TextMark): bool {.inline.} =

# gtk_text_mark_get_left_gravity
# flags: {isMethod} container: TextMark
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_mark_get_left_gravity(self: ptr TTextMark): bool {.cdecl, dynlib: lib, importc: "gtk_text_mark_get_left_gravity".}
proc get_left_gravity*(self: TextMark): bool {.inline.} =
  gtk_text_mark_get_left_gravity(self)
# proc get_left_gravity*(self: TextMark): bool {.inline.} =

# gtk_text_mark_get_name
# flags: {isMethod} container: TextMark
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_text_mark_get_name(self: ptr TTextMark): ucstring {.cdecl, dynlib: lib, importc: "gtk_text_mark_get_name".}
proc get_name*(self: TextMark): ustring {.inline.} =
  ustring($(gtk_text_mark_get_name(self)))
# proc get_name*(self: TextMark): ustring {.inline.} =

# gtk_text_mark_get_visible
# flags: {isMethod} container: TextMark
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_mark_get_visible(self: ptr TTextMark): bool {.cdecl, dynlib: lib, importc: "gtk_text_mark_get_visible".}
proc get_visible*(self: TextMark): bool {.inline.} =
  gtk_text_mark_get_visible(self)
# proc get_visible*(self: TextMark): bool {.inline.} =

# gtk_text_mark_set_visible
# flags: {isMethod} container: TextMark
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_mark_set_visible(self: ptr TTextMark, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_text_mark_set_visible".}
proc set_visible*(self: TextMark, setting: bool) {.inline.} =
  gtk_text_mark_set_visible(self, setting)
# proc set_visible*(self: TextMark, setting: bool) {.inline.} =

# gtk_text_tag_new
# flags: {isConstructor} container: TextTag
# need sugar: is static method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# 'TextTag' 'TransferFull[TTextTag]' (diff., need sugar)
proc gtk_text_tag_new(name: ucstring): TransferFull[TTextTag] {.cdecl, dynlib: lib, importc: "gtk_text_tag_new".}
proc new_texttag*(name: ustring): TextTag {.inline.} =
  wrap(gtk_text_tag_new(ucstring(name)))
# proc new_texttag*(name: ustring): TextTag {.inline.} =

# gtk_text_tag_event
# flags: {isMethod} container: TextTag
# need sugar: is method
# event_object 'GObject2.Object' 'ptr GObject2.TObject' IN (diff., need sugar)
# event 'Gdk3.TEvent' 'ptr Gdk3.TEvent' IN (diff., need sugar)
# iter 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_text_tag_event(self: ptr TTextTag, event_object: ptr GObject2.TObject, event: ptr Gdk3.TEvent, iter: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_tag_event".}
proc event*(self: TextTag, event_object: GObject2.Object, event: Gdk3.TEvent, iter: TTextIter): bool {.inline.} =
  gtk_text_tag_event(self, event_object.getPointer, myUnsafeAddr(event), myUnsafeAddr(iter))
# proc event*(self: TextTag, event_object: GObject2.Object, event: Gdk3.TEvent, iter: TTextIter): bool {.inline.} =

# gtk_text_tag_get_priority
# flags: {isMethod} container: TextTag
# need sugar: is method
# 'int32' 'int32'
proc gtk_text_tag_get_priority(self: ptr TTextTag): int32 {.cdecl, dynlib: lib, importc: "gtk_text_tag_get_priority".}
proc get_priority*(self: TextTag): int32 {.inline.} =
  gtk_text_tag_get_priority(self)
# proc get_priority*(self: TextTag): int32 {.inline.} =

# gtk_text_tag_set_priority
# flags: {isMethod} container: TextTag
# need sugar: is method
# priority 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_tag_set_priority(self: ptr TTextTag, priority: int32) {.cdecl, dynlib: lib, importc: "gtk_text_tag_set_priority".}
proc set_priority*(self: TextTag, priority: int32) {.inline.} =
  gtk_text_tag_set_priority(self, priority)
# proc set_priority*(self: TextTag, priority: int32) {.inline.} =

# gtk_text_tag_table_new
# flags: {isConstructor} container: TextTagTable
# need sugar: is static method
# 'TextTagTable' 'TransferFull[TTextTagTable]' (diff., need sugar)
proc gtk_text_tag_table_new(): TransferFull[TTextTagTable] {.cdecl, dynlib: lib, importc: "gtk_text_tag_table_new".}
proc new_texttagtable*(): TextTagTable {.inline.} =
  wrap(gtk_text_tag_table_new())
# proc new_texttagtable*(): TextTagTable {.inline.} =

# gtk_text_tag_table_add
# flags: {isMethod} container: TextTagTable
# need sugar: is method
# tag 'TextTag' 'ptr TTextTag' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_text_tag_table_add(self: ptr TTextTagTable, tag: ptr TTextTag): bool {.cdecl, dynlib: lib, importc: "gtk_text_tag_table_add".}
proc add*(self: TextTagTable, tag: TextTag): bool {.inline.} =
  gtk_text_tag_table_add(self, tag.getPointer)
# proc add*(self: TextTagTable, tag: TextTag): bool {.inline.} =

# gtk_text_tag_table_foreach
# flags: {isMethod} container: TextTagTable
# need sugar: is method
# func 'pointer' 'pointer' IN
# data 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_tag_table_foreach(self: ptr TTextTagTable, func_x: pointer, data: pointer) {.cdecl, dynlib: lib, importc: "gtk_text_tag_table_foreach".}
proc foreach*(self: TextTagTable, func_x: pointer, data: pointer) {.inline.} =
  gtk_text_tag_table_foreach(self, func_x, data)
# proc foreach*(self: TextTagTable, func_x: pointer, data: pointer) {.inline.} =

# gtk_text_tag_table_get_size
# flags: {isMethod} container: TextTagTable
# need sugar: is method
# 'int32' 'int32'
proc gtk_text_tag_table_get_size(self: ptr TTextTagTable): int32 {.cdecl, dynlib: lib, importc: "gtk_text_tag_table_get_size".}
proc get_size*(self: TextTagTable): int32 {.inline.} =
  gtk_text_tag_table_get_size(self)
# proc get_size*(self: TextTagTable): int32 {.inline.} =

# gtk_text_tag_table_lookup
# flags: {isMethod} container: TextTagTable
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# 'TextTag' 'TransferNone[TTextTag]' (diff., need sugar)
proc gtk_text_tag_table_lookup(self: ptr TTextTagTable, name: ucstring): TransferNone[TTextTag] {.cdecl, dynlib: lib, importc: "gtk_text_tag_table_lookup".}
proc lookup*(self: TextTagTable, name: ustring): TextTag {.inline.} =
  wrap(gtk_text_tag_table_lookup(self, ucstring(name)))
# proc lookup*(self: TextTagTable, name: ustring): TextTag {.inline.} =

# gtk_text_tag_table_remove
# flags: {isMethod} container: TextTagTable
# need sugar: is method
# tag 'TextTag' 'ptr TTextTag' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_tag_table_remove(self: ptr TTextTagTable, tag: ptr TTextTag) {.cdecl, dynlib: lib, importc: "gtk_text_tag_table_remove".}
proc remove*(self: TextTagTable, tag: TextTag) {.inline.} =
  gtk_text_tag_table_remove(self, tag.getPointer)
# proc remove*(self: TextTagTable, tag: TextTag) {.inline.} =

# gtk_text_view_new
# flags: {isConstructor} container: TextView
# need sugar: is static method
# 'TextView' 'TransferNone[TTextView]' (diff., need sugar)
proc gtk_text_view_new(): TransferNone[TTextView] {.cdecl, dynlib: lib, importc: "gtk_text_view_new".}
proc new_textview*(): TextView {.inline.} =
  wrap(gtk_text_view_new())
# proc new_textview*(): TextView {.inline.} =

# gtk_text_view_new_with_buffer
# flags: {isConstructor} container: TextView
# need sugar: is static method
# buffer 'TextBuffer' 'ptr TTextBuffer' IN (diff., need sugar)
# 'TextView' 'TransferNone[TTextView]' (diff., need sugar)
proc gtk_text_view_new_with_buffer(buffer: ptr TTextBuffer): TransferNone[TTextView] {.cdecl, dynlib: lib, importc: "gtk_text_view_new_with_buffer".}
proc new_textview_with_buffer*(buffer: TextBuffer): TextView {.inline.} =
  wrap(gtk_text_view_new_with_buffer(buffer.getPointer))
# proc new_textview_with_buffer*(buffer: TextBuffer): TextView {.inline.} =

# gtk_text_view_add_child_at_anchor
# flags: {isMethod} container: TextView
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# anchor 'TextChildAnchor' 'ptr TTextChildAnchor' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_add_child_at_anchor(self: ptr TTextView, child: ptr TWidget, anchor: ptr TTextChildAnchor) {.cdecl, dynlib: lib, importc: "gtk_text_view_add_child_at_anchor".}
proc add_child_at_anchor*(self: TextView, child: Widget, anchor: TextChildAnchor) {.inline.} =
  gtk_text_view_add_child_at_anchor(self, child.getPointer, anchor.getPointer)
# proc add_child_at_anchor*(self: TextView, child: Widget, anchor: TextChildAnchor) {.inline.} =

# gtk_text_view_add_child_in_window
# flags: {isMethod} container: TextView
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# which_window 'TextWindowType' 'TextWindowType' IN
# xpos 'int32' 'int32' IN
# ypos 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_add_child_in_window(self: ptr TTextView, child: ptr TWidget, which_window: TextWindowType, xpos: int32, ypos: int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_add_child_in_window".}
proc add_child_in_window*(self: TextView, child: Widget, which_window: TextWindowType, xpos: int32, ypos: int32) {.inline.} =
  gtk_text_view_add_child_in_window(self, child.getPointer, which_window, xpos, ypos)
# proc add_child_in_window*(self: TextView, child: Widget, which_window: TextWindowType, xpos: int32, ypos: int32) {.inline.} =

# gtk_text_view_backward_display_line
# flags: {isMethod} container: TextView
# need sugar: is method
# iter 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_text_view_backward_display_line(self: ptr TTextView, iter: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_backward_display_line".}
proc backward_display_line*(self: TextView, iter: TTextIter): bool {.inline.} =
  gtk_text_view_backward_display_line(self, myUnsafeAddr(iter))
# proc backward_display_line*(self: TextView, iter: TTextIter): bool {.inline.} =

# gtk_text_view_backward_display_line_start
# flags: {isMethod} container: TextView
# need sugar: is method
# iter 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_text_view_backward_display_line_start(self: ptr TTextView, iter: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_backward_display_line_start".}
proc backward_display_line_start*(self: TextView, iter: TTextIter): bool {.inline.} =
  gtk_text_view_backward_display_line_start(self, myUnsafeAddr(iter))
# proc backward_display_line_start*(self: TextView, iter: TTextIter): bool {.inline.} =

# gtk_text_view_buffer_to_window_coords
# flags: {isMethod} container: TextView
# need sugar: is method
# win 'TextWindowType' 'TextWindowType' IN
# buffer_x 'int32' 'int32' IN
# buffer_y 'int32' 'int32' IN
# window_x 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# window_y 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_buffer_to_window_coords(self: ptr TTextView, win: TextWindowType, buffer_x: int32, buffer_y: int32, window_x: ptr int32, window_y: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_buffer_to_window_coords".}
proc buffer_to_window_coords*(self: TextView, win: TextWindowType, buffer_x: int32, buffer_y: int32, window_x: var int32, window_y: var int32) {.inline.} =
  gtk_text_view_buffer_to_window_coords(self, win, buffer_x, buffer_y, addr(window_x), addr(window_y))
# tuple-return
# window_x: var int32
# window_y: var int32
# proc buffer_to_window_coords*(self: TextView, win: TextWindowType, buffer_x: int32, buffer_y: int32) {.inline.} =

# gtk_text_view_forward_display_line
# flags: {isMethod} container: TextView
# need sugar: is method
# iter 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_text_view_forward_display_line(self: ptr TTextView, iter: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_forward_display_line".}
proc forward_display_line*(self: TextView, iter: TTextIter): bool {.inline.} =
  gtk_text_view_forward_display_line(self, myUnsafeAddr(iter))
# proc forward_display_line*(self: TextView, iter: TTextIter): bool {.inline.} =

# gtk_text_view_forward_display_line_end
# flags: {isMethod} container: TextView
# need sugar: is method
# iter 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_text_view_forward_display_line_end(self: ptr TTextView, iter: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_forward_display_line_end".}
proc forward_display_line_end*(self: TextView, iter: TTextIter): bool {.inline.} =
  gtk_text_view_forward_display_line_end(self, myUnsafeAddr(iter))
# proc forward_display_line_end*(self: TextView, iter: TTextIter): bool {.inline.} =

# gtk_text_view_get_accepts_tab
# flags: {isMethod} container: TextView
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_view_get_accepts_tab(self: ptr TTextView): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_get_accepts_tab".}
proc get_accepts_tab*(self: TextView): bool {.inline.} =
  gtk_text_view_get_accepts_tab(self)
# proc get_accepts_tab*(self: TextView): bool {.inline.} =

# gtk_text_view_get_border_window_size
# flags: {isMethod} container: TextView
# need sugar: is method
# type 'TextWindowType' 'TextWindowType' IN
# 'int32' 'int32'
proc gtk_text_view_get_border_window_size(self: ptr TTextView, type_x: TextWindowType): int32 {.cdecl, dynlib: lib, importc: "gtk_text_view_get_border_window_size".}
proc get_border_window_size*(self: TextView, type_x: TextWindowType): int32 {.inline.} =
  gtk_text_view_get_border_window_size(self, type_x)
# proc get_border_window_size*(self: TextView, type_x: TextWindowType): int32 {.inline.} =

# gtk_text_view_get_buffer
# flags: {isMethod} container: TextView
# need sugar: is method
# 'TextBuffer' 'TransferNone[TTextBuffer]' (diff., need sugar)
proc gtk_text_view_get_buffer(self: ptr TTextView): TransferNone[TTextBuffer] {.cdecl, dynlib: lib, importc: "gtk_text_view_get_buffer".}
proc get_buffer*(self: TextView): TextBuffer {.inline.} =
  wrap(gtk_text_view_get_buffer(self))
# proc get_buffer*(self: TextView): TextBuffer {.inline.} =

# gtk_text_view_get_cursor_locations
# flags: {isMethod} container: TextView
# need sugar: is method
# iter 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# strong 'var cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' OUT (diff., need sugar) caller-allocates optional
# weak 'var cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' OUT (diff., need sugar) caller-allocates optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_get_cursor_locations(self: ptr TTextView, iter: ptr TTextIter, strong: ptr cairo1.TRectangleInt, weak: ptr cairo1.TRectangleInt) {.cdecl, dynlib: lib, importc: "gtk_text_view_get_cursor_locations".}
proc get_cursor_locations*(self: TextView, iter: TTextIter, strong: var cairo1.TRectangleInt, weak: var cairo1.TRectangleInt) {.inline.} =
  gtk_text_view_get_cursor_locations(self, myUnsafeAddr(iter), addr(strong), addr(weak))
# tuple-return
# strong: var cairo1.TRectangleInt
# weak: var cairo1.TRectangleInt
# proc get_cursor_locations*(self: TextView, iter: TTextIter) {.inline.} =

# gtk_text_view_get_cursor_visible
# flags: {isMethod} container: TextView
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_view_get_cursor_visible(self: ptr TTextView): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_get_cursor_visible".}
proc get_cursor_visible*(self: TextView): bool {.inline.} =
  gtk_text_view_get_cursor_visible(self)
# proc get_cursor_visible*(self: TextView): bool {.inline.} =

# gtk_text_view_get_default_attributes
# flags: {isMethod} container: TextView
# need sugar: is method
# 'TTextAttributes' 'ptr TTextAttributes' (diff., need sugar)
proc gtk_text_view_get_default_attributes(self: ptr TTextView): ptr TTextAttributes {.cdecl, dynlib: lib, importc: "gtk_text_view_get_default_attributes".}
proc get_default_attributes*(self: TextView): TTextAttributes {.inline.} =
  (gtk_text_view_get_default_attributes(self))[]
# proc get_default_attributes*(self: TextView): TTextAttributes {.inline.} =

# gtk_text_view_get_editable
# flags: {isMethod} container: TextView
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_view_get_editable(self: ptr TTextView): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_get_editable".}
proc get_editable*(self: TextView): bool {.inline.} =
  gtk_text_view_get_editable(self)
# proc get_editable*(self: TextView): bool {.inline.} =

# gtk_text_view_get_hadjustment
# flags: {isMethod} container: TextView (deprecated)
# gtk_text_view_get_indent
# flags: {isMethod} container: TextView
# need sugar: is method
# 'int32' 'int32'
proc gtk_text_view_get_indent(self: ptr TTextView): int32 {.cdecl, dynlib: lib, importc: "gtk_text_view_get_indent".}
proc get_indent*(self: TextView): int32 {.inline.} =
  gtk_text_view_get_indent(self)
# proc get_indent*(self: TextView): int32 {.inline.} =

# gtk_text_view_get_input_hints
# flags: {isMethod} container: TextView
# need sugar: is method
# 'SInputHints' 'SInputHints'
proc gtk_text_view_get_input_hints(self: ptr TTextView): SInputHints {.cdecl, dynlib: lib, importc: "gtk_text_view_get_input_hints".}
proc get_input_hints*(self: TextView): SInputHints {.inline.} =
  gtk_text_view_get_input_hints(self)
# proc get_input_hints*(self: TextView): SInputHints {.inline.} =

# gtk_text_view_get_input_purpose
# flags: {isMethod} container: TextView
# need sugar: is method
# 'InputPurpose' 'InputPurpose'
proc gtk_text_view_get_input_purpose(self: ptr TTextView): InputPurpose {.cdecl, dynlib: lib, importc: "gtk_text_view_get_input_purpose".}
proc get_input_purpose*(self: TextView): InputPurpose {.inline.} =
  gtk_text_view_get_input_purpose(self)
# proc get_input_purpose*(self: TextView): InputPurpose {.inline.} =

# gtk_text_view_get_iter_at_location
# flags: {isMethod} container: TextView
# need sugar: is method
# iter 'var TTextIter' 'ptr TTextIter' OUT (diff., need sugar) caller-allocates
# x 'int32' 'int32' IN
# y 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_get_iter_at_location(self: ptr TTextView, iter: ptr TTextIter, x: int32, y: int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_get_iter_at_location".}
proc get_iter_at_location*(self: TextView, iter: var TTextIter, x: int32, y: int32) {.inline.} =
  gtk_text_view_get_iter_at_location(self, addr(iter), x, y)
# tuple-return
# iter: var TTextIter
# proc get_iter_at_location*(self: TextView, x: int32, y: int32) {.inline.} =

# gtk_text_view_get_iter_at_position
# flags: {isMethod} container: TextView
# need sugar: is method
# iter 'var TTextIter' 'ptr TTextIter' OUT (diff., need sugar) caller-allocates
# trailing 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# x 'int32' 'int32' IN
# y 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_get_iter_at_position(self: ptr TTextView, iter: ptr TTextIter, trailing: ptr int32, x: int32, y: int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_get_iter_at_position".}
proc get_iter_at_position*(self: TextView, iter: var TTextIter, trailing: var int32, x: int32, y: int32) {.inline.} =
  gtk_text_view_get_iter_at_position(self, addr(iter), addr(trailing), x, y)
# tuple-return
# iter: var TTextIter
# trailing: var int32
# proc get_iter_at_position*(self: TextView, x: int32, y: int32) {.inline.} =

# gtk_text_view_get_iter_location
# flags: {isMethod} container: TextView
# need sugar: is method
# iter 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# location 'var cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_get_iter_location(self: ptr TTextView, iter: ptr TTextIter, location: ptr cairo1.TRectangleInt) {.cdecl, dynlib: lib, importc: "gtk_text_view_get_iter_location".}
proc get_iter_location*(self: TextView, iter: TTextIter, location: var cairo1.TRectangleInt) {.inline.} =
  gtk_text_view_get_iter_location(self, myUnsafeAddr(iter), addr(location))
# tuple-return
# location: var cairo1.TRectangleInt
# proc get_iter_location*(self: TextView, iter: TTextIter) {.inline.} =

# gtk_text_view_get_justification
# flags: {isMethod} container: TextView
# need sugar: is method
# 'Justification' 'Justification'
proc gtk_text_view_get_justification(self: ptr TTextView): Justification {.cdecl, dynlib: lib, importc: "gtk_text_view_get_justification".}
proc get_justification*(self: TextView): Justification {.inline.} =
  gtk_text_view_get_justification(self)
# proc get_justification*(self: TextView): Justification {.inline.} =

# gtk_text_view_get_left_margin
# flags: {isMethod} container: TextView
# need sugar: is method
# 'int32' 'int32'
proc gtk_text_view_get_left_margin(self: ptr TTextView): int32 {.cdecl, dynlib: lib, importc: "gtk_text_view_get_left_margin".}
proc get_left_margin*(self: TextView): int32 {.inline.} =
  gtk_text_view_get_left_margin(self)
# proc get_left_margin*(self: TextView): int32 {.inline.} =

# gtk_text_view_get_line_at_y
# flags: {isMethod} container: TextView
# need sugar: is method
# target_iter 'var TTextIter' 'ptr TTextIter' OUT (diff., need sugar) caller-allocates
# y 'int32' 'int32' IN
# line_top 'var int32' 'ptr int32' OUT (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_get_line_at_y(self: ptr TTextView, target_iter: ptr TTextIter, y: int32, line_top: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_get_line_at_y".}
proc get_line_at_y*(self: TextView, target_iter: var TTextIter, y: int32, line_top: var int32) {.inline.} =
  gtk_text_view_get_line_at_y(self, addr(target_iter), y, addr(line_top))
# tuple-return
# target_iter: var TTextIter
# line_top: var int32
# proc get_line_at_y*(self: TextView, y: int32) {.inline.} =

# gtk_text_view_get_line_yrange
# flags: {isMethod} container: TextView
# need sugar: is method
# iter 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# y 'var int32' 'ptr int32' OUT (diff., need sugar)
# height 'var int32' 'ptr int32' OUT (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_get_line_yrange(self: ptr TTextView, iter: ptr TTextIter, y: ptr int32, height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_get_line_yrange".}
proc get_line_yrange*(self: TextView, iter: TTextIter, y: var int32, height: var int32) {.inline.} =
  gtk_text_view_get_line_yrange(self, myUnsafeAddr(iter), addr(y), addr(height))
# tuple-return
# y: var int32
# height: var int32
# proc get_line_yrange*(self: TextView, iter: TTextIter) {.inline.} =

# gtk_text_view_get_overwrite
# flags: {isMethod} container: TextView
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_view_get_overwrite(self: ptr TTextView): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_get_overwrite".}
proc get_overwrite*(self: TextView): bool {.inline.} =
  gtk_text_view_get_overwrite(self)
# proc get_overwrite*(self: TextView): bool {.inline.} =

# gtk_text_view_get_pixels_above_lines
# flags: {isMethod} container: TextView
# need sugar: is method
# 'int32' 'int32'
proc gtk_text_view_get_pixels_above_lines(self: ptr TTextView): int32 {.cdecl, dynlib: lib, importc: "gtk_text_view_get_pixels_above_lines".}
proc get_pixels_above_lines*(self: TextView): int32 {.inline.} =
  gtk_text_view_get_pixels_above_lines(self)
# proc get_pixels_above_lines*(self: TextView): int32 {.inline.} =

# gtk_text_view_get_pixels_below_lines
# flags: {isMethod} container: TextView
# need sugar: is method
# 'int32' 'int32'
proc gtk_text_view_get_pixels_below_lines(self: ptr TTextView): int32 {.cdecl, dynlib: lib, importc: "gtk_text_view_get_pixels_below_lines".}
proc get_pixels_below_lines*(self: TextView): int32 {.inline.} =
  gtk_text_view_get_pixels_below_lines(self)
# proc get_pixels_below_lines*(self: TextView): int32 {.inline.} =

# gtk_text_view_get_pixels_inside_wrap
# flags: {isMethod} container: TextView
# need sugar: is method
# 'int32' 'int32'
proc gtk_text_view_get_pixels_inside_wrap(self: ptr TTextView): int32 {.cdecl, dynlib: lib, importc: "gtk_text_view_get_pixels_inside_wrap".}
proc get_pixels_inside_wrap*(self: TextView): int32 {.inline.} =
  gtk_text_view_get_pixels_inside_wrap(self)
# proc get_pixels_inside_wrap*(self: TextView): int32 {.inline.} =

# gtk_text_view_get_right_margin
# flags: {isMethod} container: TextView
# need sugar: is method
# 'int32' 'int32'
proc gtk_text_view_get_right_margin(self: ptr TTextView): int32 {.cdecl, dynlib: lib, importc: "gtk_text_view_get_right_margin".}
proc get_right_margin*(self: TextView): int32 {.inline.} =
  gtk_text_view_get_right_margin(self)
# proc get_right_margin*(self: TextView): int32 {.inline.} =

# gtk_text_view_get_tabs
# flags: {isMethod} container: TextView
# need sugar: is method
# 'Pango1.TTabArray' 'ptr Pango1.TTabArray' (diff., need sugar)
proc gtk_text_view_get_tabs(self: ptr TTextView): ptr Pango1.TTabArray {.cdecl, dynlib: lib, importc: "gtk_text_view_get_tabs".}
proc get_tabs*(self: TextView): Pango1.TTabArray {.inline.} =
  (gtk_text_view_get_tabs(self))[]
# proc get_tabs*(self: TextView): Pango1.TTabArray {.inline.} =

# gtk_text_view_get_vadjustment
# flags: {isMethod} container: TextView (deprecated)
# gtk_text_view_get_visible_rect
# flags: {isMethod} container: TextView
# need sugar: is method
# visible_rect 'var cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_get_visible_rect(self: ptr TTextView, visible_rect: ptr cairo1.TRectangleInt) {.cdecl, dynlib: lib, importc: "gtk_text_view_get_visible_rect".}
proc get_visible_rect*(self: TextView, visible_rect: var cairo1.TRectangleInt) {.inline.} =
  gtk_text_view_get_visible_rect(self, addr(visible_rect))
# tuple-return
# visible_rect: var cairo1.TRectangleInt
# proc get_visible_rect*(self: TextView) {.inline.} =

# gtk_text_view_get_window
# flags: {isMethod} container: TextView
# need sugar: is method
# win 'TextWindowType' 'TextWindowType' IN
# 'Gdk3.Window' 'TransferNone[Gdk3.TWindow]' (diff., need sugar)
proc gtk_text_view_get_window(self: ptr TTextView, win: TextWindowType): TransferNone[Gdk3.TWindow] {.cdecl, dynlib: lib, importc: "gtk_text_view_get_window".}
proc get_window*(self: TextView, win: TextWindowType): Gdk3.Window {.inline.} =
  wrap(gtk_text_view_get_window(self, win))
# proc get_window*(self: TextView, win: TextWindowType): Gdk3.Window {.inline.} =

# gtk_text_view_get_window_type
# flags: {isMethod} container: TextView
# need sugar: is method
# window 'Gdk3.Window' 'ptr Gdk3.TWindow' IN (diff., need sugar)
# 'TextWindowType' 'TextWindowType'
proc gtk_text_view_get_window_type(self: ptr TTextView, window: ptr Gdk3.TWindow): TextWindowType {.cdecl, dynlib: lib, importc: "gtk_text_view_get_window_type".}
proc get_window_type*(self: TextView, window: Gdk3.Window): TextWindowType {.inline.} =
  gtk_text_view_get_window_type(self, window.getPointer)
# proc get_window_type*(self: TextView, window: Gdk3.Window): TextWindowType {.inline.} =

# gtk_text_view_get_wrap_mode
# flags: {isMethod} container: TextView
# need sugar: is method
# 'WrapMode' 'WrapMode'
proc gtk_text_view_get_wrap_mode(self: ptr TTextView): WrapMode {.cdecl, dynlib: lib, importc: "gtk_text_view_get_wrap_mode".}
proc get_wrap_mode*(self: TextView): WrapMode {.inline.} =
  gtk_text_view_get_wrap_mode(self)
# proc get_wrap_mode*(self: TextView): WrapMode {.inline.} =

# gtk_text_view_im_context_filter_keypress
# flags: {isMethod} container: TextView
# need sugar: is method
# event 'Gdk3.TEventKey' 'ptr Gdk3.TEventKey' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_text_view_im_context_filter_keypress(self: ptr TTextView, event: ptr Gdk3.TEventKey): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_im_context_filter_keypress".}
proc im_context_filter_keypress*(self: TextView, event: Gdk3.TEventKey): bool {.inline.} =
  gtk_text_view_im_context_filter_keypress(self, myUnsafeAddr(event))
# proc im_context_filter_keypress*(self: TextView, event: Gdk3.TEventKey): bool {.inline.} =

# gtk_text_view_move_child
# flags: {isMethod} container: TextView
# need sugar: is method
# child 'Widget' 'ptr TWidget' IN (diff., need sugar)
# xpos 'int32' 'int32' IN
# ypos 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_move_child(self: ptr TTextView, child: ptr TWidget, xpos: int32, ypos: int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_move_child".}
proc move_child*(self: TextView, child: Widget, xpos: int32, ypos: int32) {.inline.} =
  gtk_text_view_move_child(self, child.getPointer, xpos, ypos)
# proc move_child*(self: TextView, child: Widget, xpos: int32, ypos: int32) {.inline.} =

# gtk_text_view_move_mark_onscreen
# flags: {isMethod} container: TextView
# need sugar: is method
# mark 'TextMark' 'ptr TTextMark' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_text_view_move_mark_onscreen(self: ptr TTextView, mark: ptr TTextMark): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_move_mark_onscreen".}
proc move_mark_onscreen*(self: TextView, mark: TextMark): bool {.inline.} =
  gtk_text_view_move_mark_onscreen(self, mark.getPointer)
# proc move_mark_onscreen*(self: TextView, mark: TextMark): bool {.inline.} =

# gtk_text_view_move_visually
# flags: {isMethod} container: TextView
# need sugar: is method
# iter 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# count 'int32' 'int32' IN
# 'bool' 'bool'
proc gtk_text_view_move_visually(self: ptr TTextView, iter: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_move_visually".}
proc move_visually*(self: TextView, iter: TTextIter, count: int32): bool {.inline.} =
  gtk_text_view_move_visually(self, myUnsafeAddr(iter), count)
# proc move_visually*(self: TextView, iter: TTextIter, count: int32): bool {.inline.} =

# gtk_text_view_place_cursor_onscreen
# flags: {isMethod} container: TextView
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_view_place_cursor_onscreen(self: ptr TTextView): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_place_cursor_onscreen".}
proc place_cursor_onscreen*(self: TextView): bool {.inline.} =
  gtk_text_view_place_cursor_onscreen(self)
# proc place_cursor_onscreen*(self: TextView): bool {.inline.} =

# gtk_text_view_reset_im_context
# flags: {isMethod} container: TextView
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_reset_im_context(self: ptr TTextView) {.cdecl, dynlib: lib, importc: "gtk_text_view_reset_im_context".}
proc reset_im_context*(self: TextView) {.inline.} =
  gtk_text_view_reset_im_context(self)
# proc reset_im_context*(self: TextView) {.inline.} =

# gtk_text_view_scroll_mark_onscreen
# flags: {isMethod} container: TextView
# need sugar: is method
# mark 'TextMark' 'ptr TTextMark' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_scroll_mark_onscreen(self: ptr TTextView, mark: ptr TTextMark) {.cdecl, dynlib: lib, importc: "gtk_text_view_scroll_mark_onscreen".}
proc scroll_mark_onscreen*(self: TextView, mark: TextMark) {.inline.} =
  gtk_text_view_scroll_mark_onscreen(self, mark.getPointer)
# proc scroll_mark_onscreen*(self: TextView, mark: TextMark) {.inline.} =

# gtk_text_view_scroll_to_iter
# flags: {isMethod} container: TextView
# need sugar: is method
# iter 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# within_margin 'float64' 'float64' IN
# use_align 'bool' 'bool' IN
# xalign 'float64' 'float64' IN
# yalign 'float64' 'float64' IN
# 'bool' 'bool'
proc gtk_text_view_scroll_to_iter(self: ptr TTextView, iter: ptr TTextIter, within_margin: float64, use_align: bool, xalign: float64, yalign: float64): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_scroll_to_iter".}
proc scroll_to_iter*(self: TextView, iter: TTextIter, within_margin: float64, use_align: bool, xalign: float64, yalign: float64): bool {.inline.} =
  gtk_text_view_scroll_to_iter(self, myUnsafeAddr(iter), within_margin, use_align, xalign, yalign)
# proc scroll_to_iter*(self: TextView, iter: TTextIter, within_margin: float64, use_align: bool, xalign: float64, yalign: float64): bool {.inline.} =

# gtk_text_view_scroll_to_mark
# flags: {isMethod} container: TextView
# need sugar: is method
# mark 'TextMark' 'ptr TTextMark' IN (diff., need sugar)
# within_margin 'float64' 'float64' IN
# use_align 'bool' 'bool' IN
# xalign 'float64' 'float64' IN
# yalign 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_scroll_to_mark(self: ptr TTextView, mark: ptr TTextMark, within_margin: float64, use_align: bool, xalign: float64, yalign: float64) {.cdecl, dynlib: lib, importc: "gtk_text_view_scroll_to_mark".}
proc scroll_to_mark*(self: TextView, mark: TextMark, within_margin: float64, use_align: bool, xalign: float64, yalign: float64) {.inline.} =
  gtk_text_view_scroll_to_mark(self, mark.getPointer, within_margin, use_align, xalign, yalign)
# proc scroll_to_mark*(self: TextView, mark: TextMark, within_margin: float64, use_align: bool, xalign: float64, yalign: float64) {.inline.} =

# gtk_text_view_set_accepts_tab
# flags: {isMethod} container: TextView
# need sugar: is method
# accepts_tab 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_accepts_tab(self: ptr TTextView, accepts_tab: bool) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_accepts_tab".}
proc set_accepts_tab*(self: TextView, accepts_tab: bool) {.inline.} =
  gtk_text_view_set_accepts_tab(self, accepts_tab)
# proc set_accepts_tab*(self: TextView, accepts_tab: bool) {.inline.} =

# gtk_text_view_set_border_window_size
# flags: {isMethod} container: TextView
# need sugar: is method
# type 'TextWindowType' 'TextWindowType' IN
# size 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_border_window_size(self: ptr TTextView, type_x: TextWindowType, size: int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_border_window_size".}
proc set_border_window_size*(self: TextView, type_x: TextWindowType, size: int32) {.inline.} =
  gtk_text_view_set_border_window_size(self, type_x, size)
# proc set_border_window_size*(self: TextView, type_x: TextWindowType, size: int32) {.inline.} =

# gtk_text_view_set_buffer
# flags: {isMethod} container: TextView
# need sugar: is method
# buffer 'TextBuffer' 'ptr TTextBuffer' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_buffer(self: ptr TTextView, buffer: ptr TTextBuffer) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_buffer".}
proc set_buffer*(self: TextView, buffer: TextBuffer) {.inline.} =
  gtk_text_view_set_buffer(self, buffer.getPointer)
# proc set_buffer*(self: TextView, buffer: TextBuffer) {.inline.} =

# gtk_text_view_set_cursor_visible
# flags: {isMethod} container: TextView
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_cursor_visible(self: ptr TTextView, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_cursor_visible".}
proc set_cursor_visible*(self: TextView, setting: bool) {.inline.} =
  gtk_text_view_set_cursor_visible(self, setting)
# proc set_cursor_visible*(self: TextView, setting: bool) {.inline.} =

# gtk_text_view_set_editable
# flags: {isMethod} container: TextView
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_editable(self: ptr TTextView, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_editable".}
proc set_editable*(self: TextView, setting: bool) {.inline.} =
  gtk_text_view_set_editable(self, setting)
# proc set_editable*(self: TextView, setting: bool) {.inline.} =

# gtk_text_view_set_indent
# flags: {isMethod} container: TextView
# need sugar: is method
# indent 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_indent(self: ptr TTextView, indent: int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_indent".}
proc set_indent*(self: TextView, indent: int32) {.inline.} =
  gtk_text_view_set_indent(self, indent)
# proc set_indent*(self: TextView, indent: int32) {.inline.} =

# gtk_text_view_set_input_hints
# flags: {isMethod} container: TextView
# need sugar: is method
# hints 'SInputHints' 'SInputHints' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_input_hints(self: ptr TTextView, hints: SInputHints) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_input_hints".}
proc set_input_hints*(self: TextView, hints: SInputHints) {.inline.} =
  gtk_text_view_set_input_hints(self, hints)
# proc set_input_hints*(self: TextView, hints: SInputHints) {.inline.} =

# gtk_text_view_set_input_purpose
# flags: {isMethod} container: TextView
# need sugar: is method
# purpose 'InputPurpose' 'InputPurpose' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_input_purpose(self: ptr TTextView, purpose: InputPurpose) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_input_purpose".}
proc set_input_purpose*(self: TextView, purpose: InputPurpose) {.inline.} =
  gtk_text_view_set_input_purpose(self, purpose)
# proc set_input_purpose*(self: TextView, purpose: InputPurpose) {.inline.} =

# gtk_text_view_set_justification
# flags: {isMethod} container: TextView
# need sugar: is method
# justification 'Justification' 'Justification' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_justification(self: ptr TTextView, justification: Justification) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_justification".}
proc set_justification*(self: TextView, justification: Justification) {.inline.} =
  gtk_text_view_set_justification(self, justification)
# proc set_justification*(self: TextView, justification: Justification) {.inline.} =

# gtk_text_view_set_left_margin
# flags: {isMethod} container: TextView
# need sugar: is method
# left_margin 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_left_margin(self: ptr TTextView, left_margin: int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_left_margin".}
proc set_left_margin*(self: TextView, left_margin: int32) {.inline.} =
  gtk_text_view_set_left_margin(self, left_margin)
# proc set_left_margin*(self: TextView, left_margin: int32) {.inline.} =

# gtk_text_view_set_overwrite
# flags: {isMethod} container: TextView
# need sugar: is method
# overwrite 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_overwrite(self: ptr TTextView, overwrite: bool) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_overwrite".}
proc set_overwrite*(self: TextView, overwrite: bool) {.inline.} =
  gtk_text_view_set_overwrite(self, overwrite)
# proc set_overwrite*(self: TextView, overwrite: bool) {.inline.} =

# gtk_text_view_set_pixels_above_lines
# flags: {isMethod} container: TextView
# need sugar: is method
# pixels_above_lines 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_pixels_above_lines(self: ptr TTextView, pixels_above_lines: int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_pixels_above_lines".}
proc set_pixels_above_lines*(self: TextView, pixels_above_lines: int32) {.inline.} =
  gtk_text_view_set_pixels_above_lines(self, pixels_above_lines)
# proc set_pixels_above_lines*(self: TextView, pixels_above_lines: int32) {.inline.} =

# gtk_text_view_set_pixels_below_lines
# flags: {isMethod} container: TextView
# need sugar: is method
# pixels_below_lines 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_pixels_below_lines(self: ptr TTextView, pixels_below_lines: int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_pixels_below_lines".}
proc set_pixels_below_lines*(self: TextView, pixels_below_lines: int32) {.inline.} =
  gtk_text_view_set_pixels_below_lines(self, pixels_below_lines)
# proc set_pixels_below_lines*(self: TextView, pixels_below_lines: int32) {.inline.} =

# gtk_text_view_set_pixels_inside_wrap
# flags: {isMethod} container: TextView
# need sugar: is method
# pixels_inside_wrap 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_pixels_inside_wrap(self: ptr TTextView, pixels_inside_wrap: int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_pixels_inside_wrap".}
proc set_pixels_inside_wrap*(self: TextView, pixels_inside_wrap: int32) {.inline.} =
  gtk_text_view_set_pixels_inside_wrap(self, pixels_inside_wrap)
# proc set_pixels_inside_wrap*(self: TextView, pixels_inside_wrap: int32) {.inline.} =

# gtk_text_view_set_right_margin
# flags: {isMethod} container: TextView
# need sugar: is method
# right_margin 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_right_margin(self: ptr TTextView, right_margin: int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_right_margin".}
proc set_right_margin*(self: TextView, right_margin: int32) {.inline.} =
  gtk_text_view_set_right_margin(self, right_margin)
# proc set_right_margin*(self: TextView, right_margin: int32) {.inline.} =

# gtk_text_view_set_tabs
# flags: {isMethod} container: TextView
# need sugar: is method
# tabs 'Pango1.TTabArray' 'ptr Pango1.TTabArray' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_tabs(self: ptr TTextView, tabs: ptr Pango1.TTabArray) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_tabs".}
proc set_tabs*(self: TextView, tabs: Pango1.TTabArray) {.inline.} =
  gtk_text_view_set_tabs(self, myUnsafeAddr(tabs))
# proc set_tabs*(self: TextView, tabs: Pango1.TTabArray) {.inline.} =

# gtk_text_view_set_wrap_mode
# flags: {isMethod} container: TextView
# need sugar: is method
# wrap_mode 'WrapMode' 'WrapMode' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_wrap_mode(self: ptr TTextView, wrap_mode: WrapMode) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_wrap_mode".}
proc set_wrap_mode*(self: TextView, wrap_mode: WrapMode) {.inline.} =
  gtk_text_view_set_wrap_mode(self, wrap_mode)
# proc set_wrap_mode*(self: TextView, wrap_mode: WrapMode) {.inline.} =

# gtk_text_view_starts_display_line
# flags: {isMethod} container: TextView
# need sugar: is method
# iter 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_text_view_starts_display_line(self: ptr TTextView, iter: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_starts_display_line".}
proc starts_display_line*(self: TextView, iter: TTextIter): bool {.inline.} =
  gtk_text_view_starts_display_line(self, myUnsafeAddr(iter))
# proc starts_display_line*(self: TextView, iter: TTextIter): bool {.inline.} =

# gtk_text_view_window_to_buffer_coords
# flags: {isMethod} container: TextView
# need sugar: is method
# win 'TextWindowType' 'TextWindowType' IN
# window_x 'int32' 'int32' IN
# window_y 'int32' 'int32' IN
# buffer_x 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# buffer_y 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_window_to_buffer_coords(self: ptr TTextView, win: TextWindowType, window_x: int32, window_y: int32, buffer_x: ptr int32, buffer_y: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_window_to_buffer_coords".}
proc window_to_buffer_coords*(self: TextView, win: TextWindowType, window_x: int32, window_y: int32, buffer_x: var int32, buffer_y: var int32) {.inline.} =
  gtk_text_view_window_to_buffer_coords(self, win, window_x, window_y, addr(buffer_x), addr(buffer_y))
# tuple-return
# buffer_x: var int32
# buffer_y: var int32
# proc window_to_buffer_coords*(self: TextView, win: TextWindowType, window_x: int32, window_y: int32) {.inline.} =

# gtk_theming_engine_load
# flags: {} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_background_color
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_border
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_border_color
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_color
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_direction
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_font
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_junction_sides
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_margin
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_padding
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_path
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_property
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_screen
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_state
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_style_property
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_has_class
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_has_region
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_lookup_color
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_state_is_running
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_toggle_action_new
# flags: {isConstructor} container: ToggleAction (deprecated)
# gtk_toggle_action_get_active
# flags: {isMethod} container: ToggleAction (deprecated)
# gtk_toggle_action_get_draw_as_radio
# flags: {isMethod} container: ToggleAction (deprecated)
# gtk_toggle_action_set_active
# flags: {isMethod} container: ToggleAction (deprecated)
# gtk_toggle_action_set_draw_as_radio
# flags: {isMethod} container: ToggleAction (deprecated)
# gtk_toggle_action_toggled
# flags: {isMethod} container: ToggleAction (deprecated)
# gtk_toggle_button_new
# flags: {isConstructor} container: ToggleButton
# need sugar: is static method
# 'ToggleButton' 'TransferNone[TToggleButton]' (diff., need sugar)
proc gtk_toggle_button_new(): TransferNone[TToggleButton] {.cdecl, dynlib: lib, importc: "gtk_toggle_button_new".}
proc new_togglebutton*(): ToggleButton {.inline.} =
  wrap(gtk_toggle_button_new())
# proc new_togglebutton*(): ToggleButton {.inline.} =

# gtk_toggle_button_new_with_label
# flags: {isConstructor} container: ToggleButton
# need sugar: is static method
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'ToggleButton' 'TransferNone[TToggleButton]' (diff., need sugar)
proc gtk_toggle_button_new_with_label(label: ucstring): TransferNone[TToggleButton] {.cdecl, dynlib: lib, importc: "gtk_toggle_button_new_with_label".}
proc new_togglebutton_with_label*(label: ustring): ToggleButton {.inline.} =
  wrap(gtk_toggle_button_new_with_label(ucstring(label)))
# proc new_togglebutton_with_label*(label: ustring): ToggleButton {.inline.} =

# gtk_toggle_button_new_with_mnemonic
# flags: {isConstructor} container: ToggleButton
# need sugar: is static method
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'ToggleButton' 'TransferNone[TToggleButton]' (diff., need sugar)
proc gtk_toggle_button_new_with_mnemonic(label: ucstring): TransferNone[TToggleButton] {.cdecl, dynlib: lib, importc: "gtk_toggle_button_new_with_mnemonic".}
proc new_togglebutton_with_mnemonic*(label: ustring): ToggleButton {.inline.} =
  wrap(gtk_toggle_button_new_with_mnemonic(ucstring(label)))
# proc new_togglebutton_with_mnemonic*(label: ustring): ToggleButton {.inline.} =

# gtk_toggle_button_get_active
# flags: {isMethod} container: ToggleButton
# need sugar: is method
# 'bool' 'bool'
proc gtk_toggle_button_get_active(self: ptr TToggleButton): bool {.cdecl, dynlib: lib, importc: "gtk_toggle_button_get_active".}
proc get_active*(self: ToggleButton): bool {.inline.} =
  gtk_toggle_button_get_active(self)
# proc get_active*(self: ToggleButton): bool {.inline.} =

# gtk_toggle_button_get_inconsistent
# flags: {isMethod} container: ToggleButton
# need sugar: is method
# 'bool' 'bool'
proc gtk_toggle_button_get_inconsistent(self: ptr TToggleButton): bool {.cdecl, dynlib: lib, importc: "gtk_toggle_button_get_inconsistent".}
proc get_inconsistent*(self: ToggleButton): bool {.inline.} =
  gtk_toggle_button_get_inconsistent(self)
# proc get_inconsistent*(self: ToggleButton): bool {.inline.} =

# gtk_toggle_button_get_mode
# flags: {isMethod} container: ToggleButton
# need sugar: is method
# 'bool' 'bool'
proc gtk_toggle_button_get_mode(self: ptr TToggleButton): bool {.cdecl, dynlib: lib, importc: "gtk_toggle_button_get_mode".}
proc get_mode*(self: ToggleButton): bool {.inline.} =
  gtk_toggle_button_get_mode(self)
# proc get_mode*(self: ToggleButton): bool {.inline.} =

# gtk_toggle_button_set_active
# flags: {isMethod} container: ToggleButton
# need sugar: is method
# is_active 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_toggle_button_set_active(self: ptr TToggleButton, is_active: bool) {.cdecl, dynlib: lib, importc: "gtk_toggle_button_set_active".}
proc set_active*(self: ToggleButton, is_active: bool) {.inline.} =
  gtk_toggle_button_set_active(self, is_active)
# proc set_active*(self: ToggleButton, is_active: bool) {.inline.} =

# gtk_toggle_button_set_inconsistent
# flags: {isMethod} container: ToggleButton
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_toggle_button_set_inconsistent(self: ptr TToggleButton, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_toggle_button_set_inconsistent".}
proc set_inconsistent*(self: ToggleButton, setting: bool) {.inline.} =
  gtk_toggle_button_set_inconsistent(self, setting)
# proc set_inconsistent*(self: ToggleButton, setting: bool) {.inline.} =

# gtk_toggle_button_set_mode
# flags: {isMethod} container: ToggleButton
# need sugar: is method
# draw_indicator 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_toggle_button_set_mode(self: ptr TToggleButton, draw_indicator: bool) {.cdecl, dynlib: lib, importc: "gtk_toggle_button_set_mode".}
proc set_mode*(self: ToggleButton, draw_indicator: bool) {.inline.} =
  gtk_toggle_button_set_mode(self, draw_indicator)
# proc set_mode*(self: ToggleButton, draw_indicator: bool) {.inline.} =

# gtk_toggle_button_toggled
# flags: {isMethod} container: ToggleButton
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_toggle_button_toggled(self: ptr TToggleButton) {.cdecl, dynlib: lib, importc: "gtk_toggle_button_toggled".}
proc toggled*(self: ToggleButton) {.inline.} =
  gtk_toggle_button_toggled(self)
# proc toggled*(self: ToggleButton) {.inline.} =

# gtk_toggle_tool_button_new
# flags: {isConstructor} container: ToggleToolButton
# need sugar: is static method
# 'ToggleToolButton' 'TransferNone[TToggleToolButton]' (diff., need sugar)
proc gtk_toggle_tool_button_new(): TransferNone[TToggleToolButton] {.cdecl, dynlib: lib, importc: "gtk_toggle_tool_button_new".}
proc new_toggletoolbutton*(): ToggleToolButton {.inline.} =
  wrap(gtk_toggle_tool_button_new())
# proc new_toggletoolbutton*(): ToggleToolButton {.inline.} =

# gtk_toggle_tool_button_new_from_stock
# flags: {isConstructor} container: ToggleToolButton (deprecated)
# gtk_toggle_tool_button_get_active
# flags: {isMethod} container: ToggleToolButton
# need sugar: is method
# 'bool' 'bool'
proc gtk_toggle_tool_button_get_active(self: ptr TToggleToolButton): bool {.cdecl, dynlib: lib, importc: "gtk_toggle_tool_button_get_active".}
proc get_active*(self: ToggleToolButton): bool {.inline.} =
  gtk_toggle_tool_button_get_active(self)
# proc get_active*(self: ToggleToolButton): bool {.inline.} =

# gtk_toggle_tool_button_set_active
# flags: {isMethod} container: ToggleToolButton
# need sugar: is method
# is_active 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_toggle_tool_button_set_active(self: ptr TToggleToolButton, is_active: bool) {.cdecl, dynlib: lib, importc: "gtk_toggle_tool_button_set_active".}
proc set_active*(self: ToggleToolButton, is_active: bool) {.inline.} =
  gtk_toggle_tool_button_set_active(self, is_active)
# proc set_active*(self: ToggleToolButton, is_active: bool) {.inline.} =

# gtk_tool_button_new
# flags: {isConstructor} container: ToolButton
# need sugar: is static method
# icon_widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'ToolButton' 'TransferNone[TToolButton]' (diff., need sugar)
proc gtk_tool_button_new(icon_widget: ptr TWidget, label: ucstring): TransferNone[TToolButton] {.cdecl, dynlib: lib, importc: "gtk_tool_button_new".}
proc new_toolbutton*(icon_widget: Widget, label: ustring): ToolButton {.inline.} =
  wrap(gtk_tool_button_new(icon_widget.getPointer, ucstring(label)))
# proc new_toolbutton*(icon_widget: Widget, label: ustring): ToolButton {.inline.} =

# gtk_tool_button_new_from_stock
# flags: {isConstructor} container: ToolButton (deprecated)
# gtk_tool_button_get_icon_name
# flags: {isMethod} container: ToolButton
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_tool_button_get_icon_name(self: ptr TToolButton): ucstring {.cdecl, dynlib: lib, importc: "gtk_tool_button_get_icon_name".}
proc get_icon_name*(self: ToolButton): ustring {.inline.} =
  ustring($(gtk_tool_button_get_icon_name(self)))
# proc get_icon_name*(self: ToolButton): ustring {.inline.} =

# gtk_tool_button_get_icon_widget
# flags: {isMethod} container: ToolButton
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_tool_button_get_icon_widget(self: ptr TToolButton): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_tool_button_get_icon_widget".}
proc get_icon_widget*(self: ToolButton): Widget {.inline.} =
  wrap(gtk_tool_button_get_icon_widget(self))
# proc get_icon_widget*(self: ToolButton): Widget {.inline.} =

# gtk_tool_button_get_label
# flags: {isMethod} container: ToolButton
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_tool_button_get_label(self: ptr TToolButton): ucstring {.cdecl, dynlib: lib, importc: "gtk_tool_button_get_label".}
proc get_label*(self: ToolButton): ustring {.inline.} =
  ustring($(gtk_tool_button_get_label(self)))
# proc get_label*(self: ToolButton): ustring {.inline.} =

# gtk_tool_button_get_label_widget
# flags: {isMethod} container: ToolButton
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_tool_button_get_label_widget(self: ptr TToolButton): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_tool_button_get_label_widget".}
proc get_label_widget*(self: ToolButton): Widget {.inline.} =
  wrap(gtk_tool_button_get_label_widget(self))
# proc get_label_widget*(self: ToolButton): Widget {.inline.} =

# gtk_tool_button_get_stock_id
# flags: {isMethod} container: ToolButton (deprecated)
# gtk_tool_button_get_use_underline
# flags: {isMethod} container: ToolButton
# need sugar: is method
# 'bool' 'bool'
proc gtk_tool_button_get_use_underline(self: ptr TToolButton): bool {.cdecl, dynlib: lib, importc: "gtk_tool_button_get_use_underline".}
proc get_use_underline*(self: ToolButton): bool {.inline.} =
  gtk_tool_button_get_use_underline(self)
# proc get_use_underline*(self: ToolButton): bool {.inline.} =

# gtk_tool_button_set_icon_name
# flags: {isMethod} container: ToolButton
# need sugar: is method
# icon_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_button_set_icon_name(self: ptr TToolButton, icon_name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_tool_button_set_icon_name".}
proc set_icon_name*(self: ToolButton, icon_name: ustring) {.inline.} =
  gtk_tool_button_set_icon_name(self, ucstring(icon_name))
# proc set_icon_name*(self: ToolButton, icon_name: ustring) {.inline.} =

# gtk_tool_button_set_icon_widget
# flags: {isMethod} container: ToolButton
# need sugar: is method
# icon_widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_button_set_icon_widget(self: ptr TToolButton, icon_widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_tool_button_set_icon_widget".}
proc set_icon_widget*(self: ToolButton, icon_widget: Widget) {.inline.} =
  gtk_tool_button_set_icon_widget(self, icon_widget.getPointer)
# proc set_icon_widget*(self: ToolButton, icon_widget: Widget) {.inline.} =

# gtk_tool_button_set_label
# flags: {isMethod} container: ToolButton
# need sugar: is method
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_button_set_label(self: ptr TToolButton, label: ucstring) {.cdecl, dynlib: lib, importc: "gtk_tool_button_set_label".}
proc set_label*(self: ToolButton, label: ustring) {.inline.} =
  gtk_tool_button_set_label(self, ucstring(label))
# proc set_label*(self: ToolButton, label: ustring) {.inline.} =

# gtk_tool_button_set_label_widget
# flags: {isMethod} container: ToolButton
# need sugar: is method
# label_widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_button_set_label_widget(self: ptr TToolButton, label_widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_tool_button_set_label_widget".}
proc set_label_widget*(self: ToolButton, label_widget: Widget) {.inline.} =
  gtk_tool_button_set_label_widget(self, label_widget.getPointer)
# proc set_label_widget*(self: ToolButton, label_widget: Widget) {.inline.} =

# gtk_tool_button_set_stock_id
# flags: {isMethod} container: ToolButton (deprecated)
# gtk_tool_button_set_use_underline
# flags: {isMethod} container: ToolButton
# need sugar: is method
# use_underline 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_button_set_use_underline(self: ptr TToolButton, use_underline: bool) {.cdecl, dynlib: lib, importc: "gtk_tool_button_set_use_underline".}
proc set_use_underline*(self: ToolButton, use_underline: bool) {.inline.} =
  gtk_tool_button_set_use_underline(self, use_underline)
# proc set_use_underline*(self: ToolButton, use_underline: bool) {.inline.} =

# gtk_tool_item_new
# flags: {isConstructor} container: ToolItem
# need sugar: is static method
# 'ToolItem' 'TransferNone[TToolItem]' (diff., need sugar)
proc gtk_tool_item_new(): TransferNone[TToolItem] {.cdecl, dynlib: lib, importc: "gtk_tool_item_new".}
proc new_toolitem*(): ToolItem {.inline.} =
  wrap(gtk_tool_item_new())
# proc new_toolitem*(): ToolItem {.inline.} =

# gtk_tool_item_get_ellipsize_mode
# flags: {isMethod} container: ToolItem
# need sugar: is method
# 'Pango1.EllipsizeMode' 'Pango1.EllipsizeMode'
proc gtk_tool_item_get_ellipsize_mode(self: ptr TToolItem): Pango1.EllipsizeMode {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_ellipsize_mode".}
proc get_ellipsize_mode*(self: ToolItem): Pango1.EllipsizeMode {.inline.} =
  gtk_tool_item_get_ellipsize_mode(self)
# proc get_ellipsize_mode*(self: ToolItem): Pango1.EllipsizeMode {.inline.} =

# gtk_tool_item_get_expand
# flags: {isMethod} container: ToolItem
# need sugar: is method
# 'bool' 'bool'
proc gtk_tool_item_get_expand(self: ptr TToolItem): bool {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_expand".}
proc get_expand*(self: ToolItem): bool {.inline.} =
  gtk_tool_item_get_expand(self)
# proc get_expand*(self: ToolItem): bool {.inline.} =

# gtk_tool_item_get_homogeneous
# flags: {isMethod} container: ToolItem
# need sugar: is method
# 'bool' 'bool'
proc gtk_tool_item_get_homogeneous(self: ptr TToolItem): bool {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_homogeneous".}
proc get_homogeneous*(self: ToolItem): bool {.inline.} =
  gtk_tool_item_get_homogeneous(self)
# proc get_homogeneous*(self: ToolItem): bool {.inline.} =

# gtk_tool_item_get_icon_size
# flags: {isMethod} container: ToolItem
# need sugar: is method
# 'int32' 'int32'
proc gtk_tool_item_get_icon_size(self: ptr TToolItem): int32 {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_icon_size".}
proc get_icon_size*(self: ToolItem): int32 {.inline.} =
  gtk_tool_item_get_icon_size(self)
# proc get_icon_size*(self: ToolItem): int32 {.inline.} =

# gtk_tool_item_get_is_important
# flags: {isMethod} container: ToolItem
# need sugar: is method
# 'bool' 'bool'
proc gtk_tool_item_get_is_important(self: ptr TToolItem): bool {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_is_important".}
proc get_is_important*(self: ToolItem): bool {.inline.} =
  gtk_tool_item_get_is_important(self)
# proc get_is_important*(self: ToolItem): bool {.inline.} =

# gtk_tool_item_get_orientation
# flags: {isMethod} container: ToolItem
# need sugar: is method
# 'Orientation' 'Orientation'
proc gtk_tool_item_get_orientation(self: ptr TToolItem): Orientation {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_orientation".}
proc get_orientation*(self: ToolItem): Orientation {.inline.} =
  gtk_tool_item_get_orientation(self)
# proc get_orientation*(self: ToolItem): Orientation {.inline.} =

# gtk_tool_item_get_proxy_menu_item
# flags: {isMethod} container: ToolItem
# need sugar: is method
# menu_item_id 'ustring' 'ucstring' IN (diff., need sugar)
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_tool_item_get_proxy_menu_item(self: ptr TToolItem, menu_item_id: ucstring): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_proxy_menu_item".}
proc get_proxy_menu_item*(self: ToolItem, menu_item_id: ustring): Widget {.inline.} =
  wrap(gtk_tool_item_get_proxy_menu_item(self, ucstring(menu_item_id)))
# proc get_proxy_menu_item*(self: ToolItem, menu_item_id: ustring): Widget {.inline.} =

# gtk_tool_item_get_relief_style
# flags: {isMethod} container: ToolItem
# need sugar: is method
# 'ReliefStyle' 'ReliefStyle'
proc gtk_tool_item_get_relief_style(self: ptr TToolItem): ReliefStyle {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_relief_style".}
proc get_relief_style*(self: ToolItem): ReliefStyle {.inline.} =
  gtk_tool_item_get_relief_style(self)
# proc get_relief_style*(self: ToolItem): ReliefStyle {.inline.} =

# gtk_tool_item_get_text_alignment
# flags: {isMethod} container: ToolItem
# need sugar: is method
# 'float32' 'float32'
proc gtk_tool_item_get_text_alignment(self: ptr TToolItem): float32 {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_text_alignment".}
proc get_text_alignment*(self: ToolItem): float32 {.inline.} =
  gtk_tool_item_get_text_alignment(self)
# proc get_text_alignment*(self: ToolItem): float32 {.inline.} =

# gtk_tool_item_get_text_orientation
# flags: {isMethod} container: ToolItem
# need sugar: is method
# 'Orientation' 'Orientation'
proc gtk_tool_item_get_text_orientation(self: ptr TToolItem): Orientation {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_text_orientation".}
proc get_text_orientation*(self: ToolItem): Orientation {.inline.} =
  gtk_tool_item_get_text_orientation(self)
# proc get_text_orientation*(self: ToolItem): Orientation {.inline.} =

# gtk_tool_item_get_text_size_group
# flags: {isMethod} container: ToolItem
# need sugar: is method
# 'SizeGroup' 'TransferNone[TSizeGroup]' (diff., need sugar)
proc gtk_tool_item_get_text_size_group(self: ptr TToolItem): TransferNone[TSizeGroup] {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_text_size_group".}
proc get_text_size_group*(self: ToolItem): SizeGroup {.inline.} =
  wrap(gtk_tool_item_get_text_size_group(self))
# proc get_text_size_group*(self: ToolItem): SizeGroup {.inline.} =

# gtk_tool_item_get_toolbar_style
# flags: {isMethod} container: ToolItem
# need sugar: is method
# 'ToolbarStyle' 'ToolbarStyle'
proc gtk_tool_item_get_toolbar_style(self: ptr TToolItem): ToolbarStyle {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_toolbar_style".}
proc get_toolbar_style*(self: ToolItem): ToolbarStyle {.inline.} =
  gtk_tool_item_get_toolbar_style(self)
# proc get_toolbar_style*(self: ToolItem): ToolbarStyle {.inline.} =

# gtk_tool_item_get_use_drag_window
# flags: {isMethod} container: ToolItem
# need sugar: is method
# 'bool' 'bool'
proc gtk_tool_item_get_use_drag_window(self: ptr TToolItem): bool {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_use_drag_window".}
proc get_use_drag_window*(self: ToolItem): bool {.inline.} =
  gtk_tool_item_get_use_drag_window(self)
# proc get_use_drag_window*(self: ToolItem): bool {.inline.} =

# gtk_tool_item_get_visible_horizontal
# flags: {isMethod} container: ToolItem
# need sugar: is method
# 'bool' 'bool'
proc gtk_tool_item_get_visible_horizontal(self: ptr TToolItem): bool {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_visible_horizontal".}
proc get_visible_horizontal*(self: ToolItem): bool {.inline.} =
  gtk_tool_item_get_visible_horizontal(self)
# proc get_visible_horizontal*(self: ToolItem): bool {.inline.} =

# gtk_tool_item_get_visible_vertical
# flags: {isMethod} container: ToolItem
# need sugar: is method
# 'bool' 'bool'
proc gtk_tool_item_get_visible_vertical(self: ptr TToolItem): bool {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_visible_vertical".}
proc get_visible_vertical*(self: ToolItem): bool {.inline.} =
  gtk_tool_item_get_visible_vertical(self)
# proc get_visible_vertical*(self: ToolItem): bool {.inline.} =

# gtk_tool_item_rebuild_menu
# flags: {isMethod} container: ToolItem
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_rebuild_menu(self: ptr TToolItem) {.cdecl, dynlib: lib, importc: "gtk_tool_item_rebuild_menu".}
proc rebuild_menu*(self: ToolItem) {.inline.} =
  gtk_tool_item_rebuild_menu(self)
# proc rebuild_menu*(self: ToolItem) {.inline.} =

# gtk_tool_item_retrieve_proxy_menu_item
# flags: {isMethod} container: ToolItem
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_tool_item_retrieve_proxy_menu_item(self: ptr TToolItem): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_tool_item_retrieve_proxy_menu_item".}
proc retrieve_proxy_menu_item*(self: ToolItem): Widget {.inline.} =
  wrap(gtk_tool_item_retrieve_proxy_menu_item(self))
# proc retrieve_proxy_menu_item*(self: ToolItem): Widget {.inline.} =

# gtk_tool_item_set_expand
# flags: {isMethod} container: ToolItem
# need sugar: is method
# expand 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_set_expand(self: ptr TToolItem, expand: bool) {.cdecl, dynlib: lib, importc: "gtk_tool_item_set_expand".}
proc set_expand*(self: ToolItem, expand: bool) {.inline.} =
  gtk_tool_item_set_expand(self, expand)
# proc set_expand*(self: ToolItem, expand: bool) {.inline.} =

# gtk_tool_item_set_homogeneous
# flags: {isMethod} container: ToolItem
# need sugar: is method
# homogeneous 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_set_homogeneous(self: ptr TToolItem, homogeneous: bool) {.cdecl, dynlib: lib, importc: "gtk_tool_item_set_homogeneous".}
proc set_homogeneous*(self: ToolItem, homogeneous: bool) {.inline.} =
  gtk_tool_item_set_homogeneous(self, homogeneous)
# proc set_homogeneous*(self: ToolItem, homogeneous: bool) {.inline.} =

# gtk_tool_item_set_is_important
# flags: {isMethod} container: ToolItem
# need sugar: is method
# is_important 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_set_is_important(self: ptr TToolItem, is_important: bool) {.cdecl, dynlib: lib, importc: "gtk_tool_item_set_is_important".}
proc set_is_important*(self: ToolItem, is_important: bool) {.inline.} =
  gtk_tool_item_set_is_important(self, is_important)
# proc set_is_important*(self: ToolItem, is_important: bool) {.inline.} =

# gtk_tool_item_set_proxy_menu_item
# flags: {isMethod} container: ToolItem
# need sugar: is method
# menu_item_id 'ustring' 'ucstring' IN (diff., need sugar)
# menu_item 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_set_proxy_menu_item(self: ptr TToolItem, menu_item_id: ucstring, menu_item: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_tool_item_set_proxy_menu_item".}
proc set_proxy_menu_item*(self: ToolItem, menu_item_id: ustring, menu_item: Widget) {.inline.} =
  gtk_tool_item_set_proxy_menu_item(self, ucstring(menu_item_id), menu_item.getPointer)
# proc set_proxy_menu_item*(self: ToolItem, menu_item_id: ustring, menu_item: Widget) {.inline.} =

# gtk_tool_item_set_tooltip_markup
# flags: {isMethod} container: ToolItem
# need sugar: is method
# markup 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_set_tooltip_markup(self: ptr TToolItem, markup: ucstring) {.cdecl, dynlib: lib, importc: "gtk_tool_item_set_tooltip_markup".}
proc set_tooltip_markup*(self: ToolItem, markup: ustring) {.inline.} =
  gtk_tool_item_set_tooltip_markup(self, ucstring(markup))
# proc set_tooltip_markup*(self: ToolItem, markup: ustring) {.inline.} =

# gtk_tool_item_set_tooltip_text
# flags: {isMethod} container: ToolItem
# need sugar: is method
# text 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_set_tooltip_text(self: ptr TToolItem, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_tool_item_set_tooltip_text".}
proc set_tooltip_text*(self: ToolItem, text: ustring) {.inline.} =
  gtk_tool_item_set_tooltip_text(self, ucstring(text))
# proc set_tooltip_text*(self: ToolItem, text: ustring) {.inline.} =

# gtk_tool_item_set_use_drag_window
# flags: {isMethod} container: ToolItem
# need sugar: is method
# use_drag_window 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_set_use_drag_window(self: ptr TToolItem, use_drag_window: bool) {.cdecl, dynlib: lib, importc: "gtk_tool_item_set_use_drag_window".}
proc set_use_drag_window*(self: ToolItem, use_drag_window: bool) {.inline.} =
  gtk_tool_item_set_use_drag_window(self, use_drag_window)
# proc set_use_drag_window*(self: ToolItem, use_drag_window: bool) {.inline.} =

# gtk_tool_item_set_visible_horizontal
# flags: {isMethod} container: ToolItem
# need sugar: is method
# visible_horizontal 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_set_visible_horizontal(self: ptr TToolItem, visible_horizontal: bool) {.cdecl, dynlib: lib, importc: "gtk_tool_item_set_visible_horizontal".}
proc set_visible_horizontal*(self: ToolItem, visible_horizontal: bool) {.inline.} =
  gtk_tool_item_set_visible_horizontal(self, visible_horizontal)
# proc set_visible_horizontal*(self: ToolItem, visible_horizontal: bool) {.inline.} =

# gtk_tool_item_set_visible_vertical
# flags: {isMethod} container: ToolItem
# need sugar: is method
# visible_vertical 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_set_visible_vertical(self: ptr TToolItem, visible_vertical: bool) {.cdecl, dynlib: lib, importc: "gtk_tool_item_set_visible_vertical".}
proc set_visible_vertical*(self: ToolItem, visible_vertical: bool) {.inline.} =
  gtk_tool_item_set_visible_vertical(self, visible_vertical)
# proc set_visible_vertical*(self: ToolItem, visible_vertical: bool) {.inline.} =

# gtk_tool_item_toolbar_reconfigured
# flags: {isMethod} container: ToolItem
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_toolbar_reconfigured(self: ptr TToolItem) {.cdecl, dynlib: lib, importc: "gtk_tool_item_toolbar_reconfigured".}
proc toolbar_reconfigured*(self: ToolItem) {.inline.} =
  gtk_tool_item_toolbar_reconfigured(self)
# proc toolbar_reconfigured*(self: ToolItem) {.inline.} =

# gtk_tool_item_group_new
# flags: {isConstructor} container: ToolItemGroup
# need sugar: is static method
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'ToolItemGroup' 'TransferNone[TToolItemGroup]' (diff., need sugar)
proc gtk_tool_item_group_new(label: ucstring): TransferNone[TToolItemGroup] {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_new".}
proc new_toolitemgroup*(label: ustring): ToolItemGroup {.inline.} =
  wrap(gtk_tool_item_group_new(ucstring(label)))
# proc new_toolitemgroup*(label: ustring): ToolItemGroup {.inline.} =

# gtk_tool_item_group_get_collapsed
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# 'bool' 'bool'
proc gtk_tool_item_group_get_collapsed(self: ptr TToolItemGroup): bool {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_get_collapsed".}
proc get_collapsed*(self: ToolItemGroup): bool {.inline.} =
  gtk_tool_item_group_get_collapsed(self)
# proc get_collapsed*(self: ToolItemGroup): bool {.inline.} =

# gtk_tool_item_group_get_drop_item
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# x 'int32' 'int32' IN
# y 'int32' 'int32' IN
# 'ToolItem' 'TransferNone[TToolItem]' (diff., need sugar)
proc gtk_tool_item_group_get_drop_item(self: ptr TToolItemGroup, x: int32, y: int32): TransferNone[TToolItem] {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_get_drop_item".}
proc get_drop_item*(self: ToolItemGroup, x: int32, y: int32): ToolItem {.inline.} =
  wrap(gtk_tool_item_group_get_drop_item(self, x, y))
# proc get_drop_item*(self: ToolItemGroup, x: int32, y: int32): ToolItem {.inline.} =

# gtk_tool_item_group_get_ellipsize
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# 'Pango1.EllipsizeMode' 'Pango1.EllipsizeMode'
proc gtk_tool_item_group_get_ellipsize(self: ptr TToolItemGroup): Pango1.EllipsizeMode {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_get_ellipsize".}
proc get_ellipsize*(self: ToolItemGroup): Pango1.EllipsizeMode {.inline.} =
  gtk_tool_item_group_get_ellipsize(self)
# proc get_ellipsize*(self: ToolItemGroup): Pango1.EllipsizeMode {.inline.} =

# gtk_tool_item_group_get_header_relief
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# 'ReliefStyle' 'ReliefStyle'
proc gtk_tool_item_group_get_header_relief(self: ptr TToolItemGroup): ReliefStyle {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_get_header_relief".}
proc get_header_relief*(self: ToolItemGroup): ReliefStyle {.inline.} =
  gtk_tool_item_group_get_header_relief(self)
# proc get_header_relief*(self: ToolItemGroup): ReliefStyle {.inline.} =

# gtk_tool_item_group_get_item_position
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# item 'ToolItem' 'ptr TToolItem' IN (diff., need sugar)
# 'int32' 'int32'
proc gtk_tool_item_group_get_item_position(self: ptr TToolItemGroup, item: ptr TToolItem): int32 {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_get_item_position".}
proc get_item_position*(self: ToolItemGroup, item: ToolItem): int32 {.inline.} =
  gtk_tool_item_group_get_item_position(self, item.getPointer)
# proc get_item_position*(self: ToolItemGroup, item: ToolItem): int32 {.inline.} =

# gtk_tool_item_group_get_label
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_tool_item_group_get_label(self: ptr TToolItemGroup): ucstring {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_get_label".}
proc get_label*(self: ToolItemGroup): ustring {.inline.} =
  ustring($(gtk_tool_item_group_get_label(self)))
# proc get_label*(self: ToolItemGroup): ustring {.inline.} =

# gtk_tool_item_group_get_label_widget
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_tool_item_group_get_label_widget(self: ptr TToolItemGroup): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_get_label_widget".}
proc get_label_widget*(self: ToolItemGroup): Widget {.inline.} =
  wrap(gtk_tool_item_group_get_label_widget(self))
# proc get_label_widget*(self: ToolItemGroup): Widget {.inline.} =

# gtk_tool_item_group_get_n_items
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# 'uint32' 'uint32'
proc gtk_tool_item_group_get_n_items(self: ptr TToolItemGroup): uint32 {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_get_n_items".}
proc get_n_items*(self: ToolItemGroup): uint32 {.inline.} =
  gtk_tool_item_group_get_n_items(self)
# proc get_n_items*(self: ToolItemGroup): uint32 {.inline.} =

# gtk_tool_item_group_get_nth_item
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# index 'uint32' 'uint32' IN
# 'ToolItem' 'TransferNone[TToolItem]' (diff., need sugar)
proc gtk_tool_item_group_get_nth_item(self: ptr TToolItemGroup, index: uint32): TransferNone[TToolItem] {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_get_nth_item".}
proc get_nth_item*(self: ToolItemGroup, index: uint32): ToolItem {.inline.} =
  wrap(gtk_tool_item_group_get_nth_item(self, index))
# proc get_nth_item*(self: ToolItemGroup, index: uint32): ToolItem {.inline.} =

# gtk_tool_item_group_insert
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# item 'ToolItem' 'ptr TToolItem' IN (diff., need sugar)
# position 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_group_insert(self: ptr TToolItemGroup, item: ptr TToolItem, position: int32) {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_insert".}
proc insert*(self: ToolItemGroup, item: ToolItem, position: int32) {.inline.} =
  gtk_tool_item_group_insert(self, item.getPointer, position)
# proc insert*(self: ToolItemGroup, item: ToolItem, position: int32) {.inline.} =

# gtk_tool_item_group_set_collapsed
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# collapsed 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_group_set_collapsed(self: ptr TToolItemGroup, collapsed: bool) {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_set_collapsed".}
proc set_collapsed*(self: ToolItemGroup, collapsed: bool) {.inline.} =
  gtk_tool_item_group_set_collapsed(self, collapsed)
# proc set_collapsed*(self: ToolItemGroup, collapsed: bool) {.inline.} =

# gtk_tool_item_group_set_ellipsize
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# ellipsize 'Pango1.EllipsizeMode' 'Pango1.EllipsizeMode' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_group_set_ellipsize(self: ptr TToolItemGroup, ellipsize: Pango1.EllipsizeMode) {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_set_ellipsize".}
proc set_ellipsize*(self: ToolItemGroup, ellipsize: Pango1.EllipsizeMode) {.inline.} =
  gtk_tool_item_group_set_ellipsize(self, ellipsize)
# proc set_ellipsize*(self: ToolItemGroup, ellipsize: Pango1.EllipsizeMode) {.inline.} =

# gtk_tool_item_group_set_header_relief
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# style 'ReliefStyle' 'ReliefStyle' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_group_set_header_relief(self: ptr TToolItemGroup, style: ReliefStyle) {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_set_header_relief".}
proc set_header_relief*(self: ToolItemGroup, style: ReliefStyle) {.inline.} =
  gtk_tool_item_group_set_header_relief(self, style)
# proc set_header_relief*(self: ToolItemGroup, style: ReliefStyle) {.inline.} =

# gtk_tool_item_group_set_item_position
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# item 'ToolItem' 'ptr TToolItem' IN (diff., need sugar)
# position 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_group_set_item_position(self: ptr TToolItemGroup, item: ptr TToolItem, position: int32) {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_set_item_position".}
proc set_item_position*(self: ToolItemGroup, item: ToolItem, position: int32) {.inline.} =
  gtk_tool_item_group_set_item_position(self, item.getPointer, position)
# proc set_item_position*(self: ToolItemGroup, item: ToolItem, position: int32) {.inline.} =

# gtk_tool_item_group_set_label
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# label 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_group_set_label(self: ptr TToolItemGroup, label: ucstring) {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_set_label".}
proc set_label*(self: ToolItemGroup, label: ustring) {.inline.} =
  gtk_tool_item_group_set_label(self, ucstring(label))
# proc set_label*(self: ToolItemGroup, label: ustring) {.inline.} =

# gtk_tool_item_group_set_label_widget
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# label_widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_group_set_label_widget(self: ptr TToolItemGroup, label_widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_set_label_widget".}
proc set_label_widget*(self: ToolItemGroup, label_widget: Widget) {.inline.} =
  gtk_tool_item_group_set_label_widget(self, label_widget.getPointer)
# proc set_label_widget*(self: ToolItemGroup, label_widget: Widget) {.inline.} =

# gtk_tool_palette_new
# flags: {isConstructor} container: ToolPalette
# need sugar: is static method
# 'ToolPalette' 'TransferNone[TToolPalette]' (diff., need sugar)
proc gtk_tool_palette_new(): TransferNone[TToolPalette] {.cdecl, dynlib: lib, importc: "gtk_tool_palette_new".}
proc new_toolpalette*(): ToolPalette {.inline.} =
  wrap(gtk_tool_palette_new())
# proc new_toolpalette*(): ToolPalette {.inline.} =

# gtk_tool_palette_get_drag_target_group
# flags: {} container: ToolPalette
# need sugar: is static method
# 'TTargetEntry' 'ptr TTargetEntry' (diff., need sugar)
proc gtk_tool_palette_get_drag_target_group(): ptr TTargetEntry {.cdecl, dynlib: lib, importc: "gtk_tool_palette_get_drag_target_group".}
template get_drag_target_group*(klass_parameter: typedesc[ToolPalette]): TTargetEntry =
  (gtk_tool_palette_get_drag_target_group())[]
# template get_drag_target_group*(klass_parameter: typedesc[ToolPalette]): TTargetEntry =

# gtk_tool_palette_get_drag_target_item
# flags: {} container: ToolPalette
# need sugar: is static method
# 'TTargetEntry' 'ptr TTargetEntry' (diff., need sugar)
proc gtk_tool_palette_get_drag_target_item(): ptr TTargetEntry {.cdecl, dynlib: lib, importc: "gtk_tool_palette_get_drag_target_item".}
template get_drag_target_item*(klass_parameter: typedesc[ToolPalette]): TTargetEntry =
  (gtk_tool_palette_get_drag_target_item())[]
# template get_drag_target_item*(klass_parameter: typedesc[ToolPalette]): TTargetEntry =

# gtk_tool_palette_add_drag_dest
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# flags 'SDestDefaults' 'SDestDefaults' IN
# targets 'SToolPaletteDragTargets' 'SToolPaletteDragTargets' IN
# actions 'Gdk3.SDragAction' 'Gdk3.SDragAction' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_palette_add_drag_dest(self: ptr TToolPalette, widget: ptr TWidget, flags: SDestDefaults, targets: SToolPaletteDragTargets, actions: Gdk3.SDragAction) {.cdecl, dynlib: lib, importc: "gtk_tool_palette_add_drag_dest".}
proc add_drag_dest*(self: ToolPalette, widget: Widget, flags: SDestDefaults, targets: SToolPaletteDragTargets, actions: Gdk3.SDragAction) {.inline.} =
  gtk_tool_palette_add_drag_dest(self, widget.getPointer, flags, targets, actions)
# proc add_drag_dest*(self: ToolPalette, widget: Widget, flags: SDestDefaults, targets: SToolPaletteDragTargets, actions: Gdk3.SDragAction) {.inline.} =

# gtk_tool_palette_get_drag_item
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# selection 'TSelectionData' 'ptr TSelectionData' IN (diff., need sugar)
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_tool_palette_get_drag_item(self: ptr TToolPalette, selection: ptr TSelectionData): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_tool_palette_get_drag_item".}
proc get_drag_item*(self: ToolPalette, selection: TSelectionData): Widget {.inline.} =
  wrap(gtk_tool_palette_get_drag_item(self, myUnsafeAddr(selection)))
# proc get_drag_item*(self: ToolPalette, selection: TSelectionData): Widget {.inline.} =

# gtk_tool_palette_get_drop_group
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# x 'int32' 'int32' IN
# y 'int32' 'int32' IN
# 'ToolItemGroup' 'TransferNone[TToolItemGroup]' (diff., need sugar)
proc gtk_tool_palette_get_drop_group(self: ptr TToolPalette, x: int32, y: int32): TransferNone[TToolItemGroup] {.cdecl, dynlib: lib, importc: "gtk_tool_palette_get_drop_group".}
proc get_drop_group*(self: ToolPalette, x: int32, y: int32): ToolItemGroup {.inline.} =
  wrap(gtk_tool_palette_get_drop_group(self, x, y))
# proc get_drop_group*(self: ToolPalette, x: int32, y: int32): ToolItemGroup {.inline.} =

# gtk_tool_palette_get_drop_item
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# x 'int32' 'int32' IN
# y 'int32' 'int32' IN
# 'ToolItem' 'TransferNone[TToolItem]' (diff., need sugar)
proc gtk_tool_palette_get_drop_item(self: ptr TToolPalette, x: int32, y: int32): TransferNone[TToolItem] {.cdecl, dynlib: lib, importc: "gtk_tool_palette_get_drop_item".}
proc get_drop_item*(self: ToolPalette, x: int32, y: int32): ToolItem {.inline.} =
  wrap(gtk_tool_palette_get_drop_item(self, x, y))
# proc get_drop_item*(self: ToolPalette, x: int32, y: int32): ToolItem {.inline.} =

# gtk_tool_palette_get_exclusive
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# group 'ToolItemGroup' 'ptr TToolItemGroup' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_tool_palette_get_exclusive(self: ptr TToolPalette, group: ptr TToolItemGroup): bool {.cdecl, dynlib: lib, importc: "gtk_tool_palette_get_exclusive".}
proc get_exclusive*(self: ToolPalette, group: ToolItemGroup): bool {.inline.} =
  gtk_tool_palette_get_exclusive(self, group.getPointer)
# proc get_exclusive*(self: ToolPalette, group: ToolItemGroup): bool {.inline.} =

# gtk_tool_palette_get_expand
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# group 'ToolItemGroup' 'ptr TToolItemGroup' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_tool_palette_get_expand(self: ptr TToolPalette, group: ptr TToolItemGroup): bool {.cdecl, dynlib: lib, importc: "gtk_tool_palette_get_expand".}
proc get_expand*(self: ToolPalette, group: ToolItemGroup): bool {.inline.} =
  gtk_tool_palette_get_expand(self, group.getPointer)
# proc get_expand*(self: ToolPalette, group: ToolItemGroup): bool {.inline.} =

# gtk_tool_palette_get_group_position
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# group 'ToolItemGroup' 'ptr TToolItemGroup' IN (diff., need sugar)
# 'int32' 'int32'
proc gtk_tool_palette_get_group_position(self: ptr TToolPalette, group: ptr TToolItemGroup): int32 {.cdecl, dynlib: lib, importc: "gtk_tool_palette_get_group_position".}
proc get_group_position*(self: ToolPalette, group: ToolItemGroup): int32 {.inline.} =
  gtk_tool_palette_get_group_position(self, group.getPointer)
# proc get_group_position*(self: ToolPalette, group: ToolItemGroup): int32 {.inline.} =

# gtk_tool_palette_get_hadjustment
# flags: {isMethod} container: ToolPalette (deprecated)
# gtk_tool_palette_get_icon_size
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# 'int32' 'int32'
proc gtk_tool_palette_get_icon_size(self: ptr TToolPalette): int32 {.cdecl, dynlib: lib, importc: "gtk_tool_palette_get_icon_size".}
proc get_icon_size*(self: ToolPalette): int32 {.inline.} =
  gtk_tool_palette_get_icon_size(self)
# proc get_icon_size*(self: ToolPalette): int32 {.inline.} =

# gtk_tool_palette_get_style
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# 'ToolbarStyle' 'ToolbarStyle'
proc gtk_tool_palette_get_style(self: ptr TToolPalette): ToolbarStyle {.cdecl, dynlib: lib, importc: "gtk_tool_palette_get_style".}
proc get_style*(self: ToolPalette): ToolbarStyle {.inline.} =
  gtk_tool_palette_get_style(self)
# proc get_style*(self: ToolPalette): ToolbarStyle {.inline.} =

# gtk_tool_palette_get_vadjustment
# flags: {isMethod} container: ToolPalette (deprecated)
# gtk_tool_palette_set_drag_source
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# targets 'SToolPaletteDragTargets' 'SToolPaletteDragTargets' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_palette_set_drag_source(self: ptr TToolPalette, targets: SToolPaletteDragTargets) {.cdecl, dynlib: lib, importc: "gtk_tool_palette_set_drag_source".}
proc set_drag_source*(self: ToolPalette, targets: SToolPaletteDragTargets) {.inline.} =
  gtk_tool_palette_set_drag_source(self, targets)
# proc set_drag_source*(self: ToolPalette, targets: SToolPaletteDragTargets) {.inline.} =

# gtk_tool_palette_set_exclusive
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# group 'ToolItemGroup' 'ptr TToolItemGroup' IN (diff., need sugar)
# exclusive 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_palette_set_exclusive(self: ptr TToolPalette, group: ptr TToolItemGroup, exclusive: bool) {.cdecl, dynlib: lib, importc: "gtk_tool_palette_set_exclusive".}
proc set_exclusive*(self: ToolPalette, group: ToolItemGroup, exclusive: bool) {.inline.} =
  gtk_tool_palette_set_exclusive(self, group.getPointer, exclusive)
# proc set_exclusive*(self: ToolPalette, group: ToolItemGroup, exclusive: bool) {.inline.} =

# gtk_tool_palette_set_expand
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# group 'ToolItemGroup' 'ptr TToolItemGroup' IN (diff., need sugar)
# expand 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_palette_set_expand(self: ptr TToolPalette, group: ptr TToolItemGroup, expand: bool) {.cdecl, dynlib: lib, importc: "gtk_tool_palette_set_expand".}
proc set_expand*(self: ToolPalette, group: ToolItemGroup, expand: bool) {.inline.} =
  gtk_tool_palette_set_expand(self, group.getPointer, expand)
# proc set_expand*(self: ToolPalette, group: ToolItemGroup, expand: bool) {.inline.} =

# gtk_tool_palette_set_group_position
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# group 'ToolItemGroup' 'ptr TToolItemGroup' IN (diff., need sugar)
# position 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_palette_set_group_position(self: ptr TToolPalette, group: ptr TToolItemGroup, position: int32) {.cdecl, dynlib: lib, importc: "gtk_tool_palette_set_group_position".}
proc set_group_position*(self: ToolPalette, group: ToolItemGroup, position: int32) {.inline.} =
  gtk_tool_palette_set_group_position(self, group.getPointer, position)
# proc set_group_position*(self: ToolPalette, group: ToolItemGroup, position: int32) {.inline.} =

# gtk_tool_palette_set_icon_size
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# icon_size 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_palette_set_icon_size(self: ptr TToolPalette, icon_size: int32) {.cdecl, dynlib: lib, importc: "gtk_tool_palette_set_icon_size".}
proc set_icon_size*(self: ToolPalette, icon_size: int32) {.inline.} =
  gtk_tool_palette_set_icon_size(self, icon_size)
# proc set_icon_size*(self: ToolPalette, icon_size: int32) {.inline.} =

# gtk_tool_palette_set_style
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# style 'ToolbarStyle' 'ToolbarStyle' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_palette_set_style(self: ptr TToolPalette, style: ToolbarStyle) {.cdecl, dynlib: lib, importc: "gtk_tool_palette_set_style".}
proc set_style*(self: ToolPalette, style: ToolbarStyle) {.inline.} =
  gtk_tool_palette_set_style(self, style)
# proc set_style*(self: ToolPalette, style: ToolbarStyle) {.inline.} =

# gtk_tool_palette_unset_icon_size
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_palette_unset_icon_size(self: ptr TToolPalette) {.cdecl, dynlib: lib, importc: "gtk_tool_palette_unset_icon_size".}
proc unset_icon_size*(self: ToolPalette) {.inline.} =
  gtk_tool_palette_unset_icon_size(self)
# proc unset_icon_size*(self: ToolPalette) {.inline.} =

# gtk_tool_palette_unset_style
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_palette_unset_style(self: ptr TToolPalette) {.cdecl, dynlib: lib, importc: "gtk_tool_palette_unset_style".}
proc unset_style*(self: ToolPalette) {.inline.} =
  gtk_tool_palette_unset_style(self)
# proc unset_style*(self: ToolPalette) {.inline.} =

# gtk_toolbar_new
# flags: {isConstructor} container: Toolbar
# need sugar: is static method
# 'Toolbar' 'TransferNone[TToolbar]' (diff., need sugar)
proc gtk_toolbar_new(): TransferNone[TToolbar] {.cdecl, dynlib: lib, importc: "gtk_toolbar_new".}
proc new_toolbar*(): Toolbar {.inline.} =
  wrap(gtk_toolbar_new())
# proc new_toolbar*(): Toolbar {.inline.} =

# gtk_toolbar_get_drop_index
# flags: {isMethod} container: Toolbar
# need sugar: is method
# x 'int32' 'int32' IN
# y 'int32' 'int32' IN
# 'int32' 'int32'
proc gtk_toolbar_get_drop_index(self: ptr TToolbar, x: int32, y: int32): int32 {.cdecl, dynlib: lib, importc: "gtk_toolbar_get_drop_index".}
proc get_drop_index*(self: Toolbar, x: int32, y: int32): int32 {.inline.} =
  gtk_toolbar_get_drop_index(self, x, y)
# proc get_drop_index*(self: Toolbar, x: int32, y: int32): int32 {.inline.} =

# gtk_toolbar_get_icon_size
# flags: {isMethod} container: Toolbar
# need sugar: is method
# 'IconSize' 'IconSize'
proc gtk_toolbar_get_icon_size(self: ptr TToolbar): IconSize {.cdecl, dynlib: lib, importc: "gtk_toolbar_get_icon_size".}
proc get_icon_size*(self: Toolbar): IconSize {.inline.} =
  gtk_toolbar_get_icon_size(self)
# proc get_icon_size*(self: Toolbar): IconSize {.inline.} =

# gtk_toolbar_get_item_index
# flags: {isMethod} container: Toolbar
# need sugar: is method
# item 'ToolItem' 'ptr TToolItem' IN (diff., need sugar)
# 'int32' 'int32'
proc gtk_toolbar_get_item_index(self: ptr TToolbar, item: ptr TToolItem): int32 {.cdecl, dynlib: lib, importc: "gtk_toolbar_get_item_index".}
proc get_item_index*(self: Toolbar, item: ToolItem): int32 {.inline.} =
  gtk_toolbar_get_item_index(self, item.getPointer)
# proc get_item_index*(self: Toolbar, item: ToolItem): int32 {.inline.} =

# gtk_toolbar_get_n_items
# flags: {isMethod} container: Toolbar
# need sugar: is method
# 'int32' 'int32'
proc gtk_toolbar_get_n_items(self: ptr TToolbar): int32 {.cdecl, dynlib: lib, importc: "gtk_toolbar_get_n_items".}
proc get_n_items*(self: Toolbar): int32 {.inline.} =
  gtk_toolbar_get_n_items(self)
# proc get_n_items*(self: Toolbar): int32 {.inline.} =

# gtk_toolbar_get_nth_item
# flags: {isMethod} container: Toolbar
# need sugar: is method
# n 'int32' 'int32' IN
# 'ToolItem' 'TransferNone[TToolItem]' (diff., need sugar)
proc gtk_toolbar_get_nth_item(self: ptr TToolbar, n: int32): TransferNone[TToolItem] {.cdecl, dynlib: lib, importc: "gtk_toolbar_get_nth_item".}
proc get_nth_item*(self: Toolbar, n: int32): ToolItem {.inline.} =
  wrap(gtk_toolbar_get_nth_item(self, n))
# proc get_nth_item*(self: Toolbar, n: int32): ToolItem {.inline.} =

# gtk_toolbar_get_relief_style
# flags: {isMethod} container: Toolbar
# need sugar: is method
# 'ReliefStyle' 'ReliefStyle'
proc gtk_toolbar_get_relief_style(self: ptr TToolbar): ReliefStyle {.cdecl, dynlib: lib, importc: "gtk_toolbar_get_relief_style".}
proc get_relief_style*(self: Toolbar): ReliefStyle {.inline.} =
  gtk_toolbar_get_relief_style(self)
# proc get_relief_style*(self: Toolbar): ReliefStyle {.inline.} =

# gtk_toolbar_get_show_arrow
# flags: {isMethod} container: Toolbar
# need sugar: is method
# 'bool' 'bool'
proc gtk_toolbar_get_show_arrow(self: ptr TToolbar): bool {.cdecl, dynlib: lib, importc: "gtk_toolbar_get_show_arrow".}
proc get_show_arrow*(self: Toolbar): bool {.inline.} =
  gtk_toolbar_get_show_arrow(self)
# proc get_show_arrow*(self: Toolbar): bool {.inline.} =

# gtk_toolbar_get_style
# flags: {isMethod} container: Toolbar
# need sugar: is method
# 'ToolbarStyle' 'ToolbarStyle'
proc gtk_toolbar_get_style(self: ptr TToolbar): ToolbarStyle {.cdecl, dynlib: lib, importc: "gtk_toolbar_get_style".}
proc get_style*(self: Toolbar): ToolbarStyle {.inline.} =
  gtk_toolbar_get_style(self)
# proc get_style*(self: Toolbar): ToolbarStyle {.inline.} =

# gtk_toolbar_insert
# flags: {isMethod} container: Toolbar
# need sugar: is method
# item 'ToolItem' 'ptr TToolItem' IN (diff., need sugar)
# pos 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_toolbar_insert(self: ptr TToolbar, item: ptr TToolItem, pos: int32) {.cdecl, dynlib: lib, importc: "gtk_toolbar_insert".}
proc insert*(self: Toolbar, item: ToolItem, pos: int32) {.inline.} =
  gtk_toolbar_insert(self, item.getPointer, pos)
# proc insert*(self: Toolbar, item: ToolItem, pos: int32) {.inline.} =

# gtk_toolbar_set_drop_highlight_item
# flags: {isMethod} container: Toolbar
# need sugar: is method
# tool_item 'ToolItem' 'ptr TToolItem' IN (diff., need sugar)
# index_ 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_toolbar_set_drop_highlight_item(self: ptr TToolbar, tool_item: ptr TToolItem, index_x: int32) {.cdecl, dynlib: lib, importc: "gtk_toolbar_set_drop_highlight_item".}
proc set_drop_highlight_item*(self: Toolbar, tool_item: ToolItem, index_x: int32) {.inline.} =
  gtk_toolbar_set_drop_highlight_item(self, tool_item.getPointer, index_x)
# proc set_drop_highlight_item*(self: Toolbar, tool_item: ToolItem, index_x: int32) {.inline.} =

# gtk_toolbar_set_icon_size
# flags: {isMethod} container: Toolbar
# need sugar: is method
# icon_size 'IconSize' 'IconSize' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_toolbar_set_icon_size(self: ptr TToolbar, icon_size: IconSize) {.cdecl, dynlib: lib, importc: "gtk_toolbar_set_icon_size".}
proc set_icon_size*(self: Toolbar, icon_size: IconSize) {.inline.} =
  gtk_toolbar_set_icon_size(self, icon_size)
# proc set_icon_size*(self: Toolbar, icon_size: IconSize) {.inline.} =

# gtk_toolbar_set_show_arrow
# flags: {isMethod} container: Toolbar
# need sugar: is method
# show_arrow 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_toolbar_set_show_arrow(self: ptr TToolbar, show_arrow: bool) {.cdecl, dynlib: lib, importc: "gtk_toolbar_set_show_arrow".}
proc set_show_arrow*(self: Toolbar, show_arrow: bool) {.inline.} =
  gtk_toolbar_set_show_arrow(self, show_arrow)
# proc set_show_arrow*(self: Toolbar, show_arrow: bool) {.inline.} =

# gtk_toolbar_set_style
# flags: {isMethod} container: Toolbar
# need sugar: is method
# style 'ToolbarStyle' 'ToolbarStyle' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_toolbar_set_style(self: ptr TToolbar, style: ToolbarStyle) {.cdecl, dynlib: lib, importc: "gtk_toolbar_set_style".}
proc set_style*(self: Toolbar, style: ToolbarStyle) {.inline.} =
  gtk_toolbar_set_style(self, style)
# proc set_style*(self: Toolbar, style: ToolbarStyle) {.inline.} =

# gtk_toolbar_unset_icon_size
# flags: {isMethod} container: Toolbar
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_toolbar_unset_icon_size(self: ptr TToolbar) {.cdecl, dynlib: lib, importc: "gtk_toolbar_unset_icon_size".}
proc unset_icon_size*(self: Toolbar) {.inline.} =
  gtk_toolbar_unset_icon_size(self)
# proc unset_icon_size*(self: Toolbar) {.inline.} =

# gtk_toolbar_unset_style
# flags: {isMethod} container: Toolbar
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_toolbar_unset_style(self: ptr TToolbar) {.cdecl, dynlib: lib, importc: "gtk_toolbar_unset_style".}
proc unset_style*(self: Toolbar) {.inline.} =
  gtk_toolbar_unset_style(self)
# proc unset_style*(self: Toolbar) {.inline.} =

# gtk_tooltip_trigger_tooltip_query
# flags: {} container: Tooltip
# need sugar: is static method
# display 'Gdk3.Display' 'ptr Gdk3.TDisplay' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tooltip_trigger_tooltip_query(display: ptr Gdk3.TDisplay) {.cdecl, dynlib: lib, importc: "gtk_tooltip_trigger_tooltip_query".}
template trigger_tooltip_query*(klass_parameter: typedesc[Tooltip], display: Gdk3.Display) =
  gtk_tooltip_trigger_tooltip_query(display.getPointer)
# template trigger_tooltip_query*(klass_parameter: typedesc[Tooltip], display: Gdk3.Display) =

# gtk_tooltip_set_custom
# flags: {isMethod} container: Tooltip
# need sugar: is method
# custom_widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tooltip_set_custom(self: ptr TTooltip, custom_widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_tooltip_set_custom".}
proc set_custom*(self: Tooltip, custom_widget: Widget) {.inline.} =
  gtk_tooltip_set_custom(self, custom_widget.getPointer)
# proc set_custom*(self: Tooltip, custom_widget: Widget) {.inline.} =

# gtk_tooltip_set_icon
# flags: {isMethod} container: Tooltip
# need sugar: is method
# pixbuf 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tooltip_set_icon(self: ptr TTooltip, pixbuf: ptr GdkPixbuf2.TPixbuf) {.cdecl, dynlib: lib, importc: "gtk_tooltip_set_icon".}
proc set_icon*(self: Tooltip, pixbuf: GdkPixbuf2.Pixbuf) {.inline.} =
  gtk_tooltip_set_icon(self, pixbuf.getPointer)
# proc set_icon*(self: Tooltip, pixbuf: GdkPixbuf2.Pixbuf) {.inline.} =

# gtk_tooltip_set_icon_from_gicon
# flags: {isMethod} container: Tooltip
# need sugar: is method
# gicon 'Gio2.Icon' 'ptr Gio2.TIcon' IN (diff., need sugar)
# size 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tooltip_set_icon_from_gicon(self: ptr TTooltip, gicon: ptr Gio2.TIcon, size: int32) {.cdecl, dynlib: lib, importc: "gtk_tooltip_set_icon_from_gicon".}
proc set_icon_from_gicon*(self: Tooltip, gicon: Gio2.Icon, size: int32) {.inline.} =
  gtk_tooltip_set_icon_from_gicon(self, unwrap(gicon), size)
# proc set_icon_from_gicon*(self: Tooltip, gicon: Gio2.Icon, size: int32) {.inline.} =

# gtk_tooltip_set_icon_from_icon_name
# flags: {isMethod} container: Tooltip
# need sugar: is method
# icon_name 'ustring' 'ucstring' IN (diff., need sugar)
# size 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tooltip_set_icon_from_icon_name(self: ptr TTooltip, icon_name: ucstring, size: int32) {.cdecl, dynlib: lib, importc: "gtk_tooltip_set_icon_from_icon_name".}
proc set_icon_from_icon_name*(self: Tooltip, icon_name: ustring, size: int32) {.inline.} =
  gtk_tooltip_set_icon_from_icon_name(self, ucstring(icon_name), size)
# proc set_icon_from_icon_name*(self: Tooltip, icon_name: ustring, size: int32) {.inline.} =

# gtk_tooltip_set_icon_from_stock
# flags: {isMethod} container: Tooltip (deprecated)
# gtk_tooltip_set_markup
# flags: {isMethod} container: Tooltip
# need sugar: is method
# markup 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tooltip_set_markup(self: ptr TTooltip, markup: ucstring) {.cdecl, dynlib: lib, importc: "gtk_tooltip_set_markup".}
proc set_markup*(self: Tooltip, markup: ustring) {.inline.} =
  gtk_tooltip_set_markup(self, ucstring(markup))
# proc set_markup*(self: Tooltip, markup: ustring) {.inline.} =

# gtk_tooltip_set_text
# flags: {isMethod} container: Tooltip
# need sugar: is method
# text 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tooltip_set_text(self: ptr TTooltip, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_tooltip_set_text".}
proc set_text*(self: Tooltip, text: ustring) {.inline.} =
  gtk_tooltip_set_text(self, ucstring(text))
# proc set_text*(self: Tooltip, text: ustring) {.inline.} =

# gtk_tooltip_set_tip_area
# flags: {isMethod} container: Tooltip
# need sugar: is method
# rect 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tooltip_set_tip_area(self: ptr TTooltip, rect: ptr cairo1.TRectangleInt) {.cdecl, dynlib: lib, importc: "gtk_tooltip_set_tip_area".}
proc set_tip_area*(self: Tooltip, rect: cairo1.TRectangleInt) {.inline.} =
  gtk_tooltip_set_tip_area(self, myUnsafeAddr(rect))
# proc set_tip_area*(self: Tooltip, rect: cairo1.TRectangleInt) {.inline.} =

# gtk_toplevel_accessible_get_children
# flags: {isMethod} container: ToplevelAccessible
# need sugar: is method
# 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_toplevel_accessible_get_children(self: ptr TToplevelAccessible): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_toplevel_accessible_get_children".}
proc get_children*(self: ToplevelAccessible): ptr GLIST_TODO {.inline.} =
  gtk_toplevel_accessible_get_children(self)
# proc get_children*(self: ToplevelAccessible): ptr GLIST_TODO {.inline.} =

# gtk_tree_model_filter_clear_cache
# flags: {isMethod} container: TreeModelFilter
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_model_filter_clear_cache(self: ptr TTreeModelFilter) {.cdecl, dynlib: lib, importc: "gtk_tree_model_filter_clear_cache".}
proc clear_cache*(self: TreeModelFilter) {.inline.} =
  gtk_tree_model_filter_clear_cache(self)
# proc clear_cache*(self: TreeModelFilter) {.inline.} =

# gtk_tree_model_filter_convert_child_iter_to_iter
# flags: {isMethod} container: TreeModelFilter
# need sugar: is method
# filter_iter 'var TTreeIter' 'ptr TTreeIter' OUT (diff., need sugar) caller-allocates
# child_iter 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_tree_model_filter_convert_child_iter_to_iter(self: ptr TTreeModelFilter, filter_iter: ptr TTreeIter, child_iter: ptr TTreeIter): bool {.cdecl, dynlib: lib, importc: "gtk_tree_model_filter_convert_child_iter_to_iter".}
proc convert_child_iter_to_iter*(self: TreeModelFilter, filter_iter: var TTreeIter, child_iter: TTreeIter): bool {.inline.} =
  gtk_tree_model_filter_convert_child_iter_to_iter(self, addr(filter_iter), myUnsafeAddr(child_iter))
# tuple-return
# filter_iter: var TTreeIter
# proc convert_child_iter_to_iter*(self: TreeModelFilter, child_iter: TTreeIter): bool {.inline.} =

# gtk_tree_model_filter_convert_child_path_to_path
# flags: {isMethod} container: TreeModelFilter
# need sugar: is method
# child_path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'TTreePath' 'ptr TTreePath' (diff., need sugar)
proc gtk_tree_model_filter_convert_child_path_to_path(self: ptr TTreeModelFilter, child_path: ptr TTreePath): ptr TTreePath {.cdecl, dynlib: lib, importc: "gtk_tree_model_filter_convert_child_path_to_path".}
proc convert_child_path_to_path*(self: TreeModelFilter, child_path: TTreePath): TTreePath {.inline.} =
  (gtk_tree_model_filter_convert_child_path_to_path(self, myUnsafeAddr(child_path)))[]
# proc convert_child_path_to_path*(self: TreeModelFilter, child_path: TTreePath): TTreePath {.inline.} =

# gtk_tree_model_filter_convert_iter_to_child_iter
# flags: {isMethod} container: TreeModelFilter
# need sugar: is method
# child_iter 'var TTreeIter' 'ptr TTreeIter' OUT (diff., need sugar) caller-allocates
# filter_iter 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_model_filter_convert_iter_to_child_iter(self: ptr TTreeModelFilter, child_iter: ptr TTreeIter, filter_iter: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_tree_model_filter_convert_iter_to_child_iter".}
proc convert_iter_to_child_iter*(self: TreeModelFilter, child_iter: var TTreeIter, filter_iter: TTreeIter) {.inline.} =
  gtk_tree_model_filter_convert_iter_to_child_iter(self, addr(child_iter), myUnsafeAddr(filter_iter))
# tuple-return
# child_iter: var TTreeIter
# proc convert_iter_to_child_iter*(self: TreeModelFilter, filter_iter: TTreeIter) {.inline.} =

# gtk_tree_model_filter_convert_path_to_child_path
# flags: {isMethod} container: TreeModelFilter
# need sugar: is method
# filter_path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'TTreePath' 'ptr TTreePath' (diff., need sugar)
proc gtk_tree_model_filter_convert_path_to_child_path(self: ptr TTreeModelFilter, filter_path: ptr TTreePath): ptr TTreePath {.cdecl, dynlib: lib, importc: "gtk_tree_model_filter_convert_path_to_child_path".}
proc convert_path_to_child_path*(self: TreeModelFilter, filter_path: TTreePath): TTreePath {.inline.} =
  (gtk_tree_model_filter_convert_path_to_child_path(self, myUnsafeAddr(filter_path)))[]
# proc convert_path_to_child_path*(self: TreeModelFilter, filter_path: TTreePath): TTreePath {.inline.} =

# gtk_tree_model_filter_get_model
# flags: {isMethod} container: TreeModelFilter
# need sugar: is method
# 'TreeModel' 'TransferNone[TTreeModel]' (diff., need sugar)
proc gtk_tree_model_filter_get_model(self: ptr TTreeModelFilter): TransferNone[TTreeModel] {.cdecl, dynlib: lib, importc: "gtk_tree_model_filter_get_model".}
proc get_model*(self: TreeModelFilter): TreeModel {.inline.} =
  wrap(gtk_tree_model_filter_get_model(self))
# proc get_model*(self: TreeModelFilter): TreeModel {.inline.} =

# gtk_tree_model_filter_refilter
# flags: {isMethod} container: TreeModelFilter
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_model_filter_refilter(self: ptr TTreeModelFilter) {.cdecl, dynlib: lib, importc: "gtk_tree_model_filter_refilter".}
proc refilter*(self: TreeModelFilter) {.inline.} =
  gtk_tree_model_filter_refilter(self)
# proc refilter*(self: TreeModelFilter) {.inline.} =

# gtk_tree_model_filter_set_modify_func
# flags: {isMethod} container: TreeModelFilter
# need sugar: is method
# n_columns 'int32' 'int32' IN
# types 'var openarray[GType]' 'openarray[GType]' IN (diff., need sugar) array lengthArg: 0
# func 'pointer' 'pointer' IN
# data 'pointer' 'pointer' IN
# destroy 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_model_filter_set_modify_func(self: ptr TTreeModelFilter, n_columns: int32, types: openarray[GType], func_x: pointer, data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_tree_model_filter_set_modify_func".}
proc set_modify_func*(self: TreeModelFilter, types: var openarray[GType], func_x: pointer, data: pointer, destroy: pointer) {.inline.} =
  gtk_tree_model_filter_set_modify_func(self, types.len.int32, types, func_x, data, destroy)
# proc set_modify_func*(self: TreeModelFilter, types: var openarray[GType], func_x: pointer, data: pointer, destroy: pointer) {.inline.} =

# gtk_tree_model_filter_set_visible_column
# flags: {isMethod} container: TreeModelFilter
# need sugar: is method
# column 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_model_filter_set_visible_column(self: ptr TTreeModelFilter, column: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_model_filter_set_visible_column".}
proc set_visible_column*(self: TreeModelFilter, column: int32) {.inline.} =
  gtk_tree_model_filter_set_visible_column(self, column)
# proc set_visible_column*(self: TreeModelFilter, column: int32) {.inline.} =

# gtk_tree_model_filter_set_visible_func
# flags: {isMethod} container: TreeModelFilter
# need sugar: is method
# func 'pointer' 'pointer' IN
# data 'pointer' 'pointer' IN
# destroy 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_model_filter_set_visible_func(self: ptr TTreeModelFilter, func_x: pointer, data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_tree_model_filter_set_visible_func".}
proc set_visible_func*(self: TreeModelFilter, func_x: pointer, data: pointer, destroy: pointer) {.inline.} =
  gtk_tree_model_filter_set_visible_func(self, func_x, data, destroy)
# proc set_visible_func*(self: TreeModelFilter, func_x: pointer, data: pointer, destroy: pointer) {.inline.} =

# gtk_tree_model_sort_clear_cache
# flags: {isMethod} container: TreeModelSort
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_model_sort_clear_cache(self: ptr TTreeModelSort) {.cdecl, dynlib: lib, importc: "gtk_tree_model_sort_clear_cache".}
proc clear_cache*(self: TreeModelSort) {.inline.} =
  gtk_tree_model_sort_clear_cache(self)
# proc clear_cache*(self: TreeModelSort) {.inline.} =

# gtk_tree_model_sort_convert_child_iter_to_iter
# flags: {isMethod} container: TreeModelSort
# need sugar: is method
# sort_iter 'var TTreeIter' 'ptr TTreeIter' OUT (diff., need sugar) caller-allocates
# child_iter 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_tree_model_sort_convert_child_iter_to_iter(self: ptr TTreeModelSort, sort_iter: ptr TTreeIter, child_iter: ptr TTreeIter): bool {.cdecl, dynlib: lib, importc: "gtk_tree_model_sort_convert_child_iter_to_iter".}
proc convert_child_iter_to_iter*(self: TreeModelSort, sort_iter: var TTreeIter, child_iter: TTreeIter): bool {.inline.} =
  gtk_tree_model_sort_convert_child_iter_to_iter(self, addr(sort_iter), myUnsafeAddr(child_iter))
# tuple-return
# sort_iter: var TTreeIter
# proc convert_child_iter_to_iter*(self: TreeModelSort, child_iter: TTreeIter): bool {.inline.} =

# gtk_tree_model_sort_convert_child_path_to_path
# flags: {isMethod} container: TreeModelSort
# need sugar: is method
# child_path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'TTreePath' 'ptr TTreePath' (diff., need sugar)
proc gtk_tree_model_sort_convert_child_path_to_path(self: ptr TTreeModelSort, child_path: ptr TTreePath): ptr TTreePath {.cdecl, dynlib: lib, importc: "gtk_tree_model_sort_convert_child_path_to_path".}
proc convert_child_path_to_path*(self: TreeModelSort, child_path: TTreePath): TTreePath {.inline.} =
  (gtk_tree_model_sort_convert_child_path_to_path(self, myUnsafeAddr(child_path)))[]
# proc convert_child_path_to_path*(self: TreeModelSort, child_path: TTreePath): TTreePath {.inline.} =

# gtk_tree_model_sort_convert_iter_to_child_iter
# flags: {isMethod} container: TreeModelSort
# need sugar: is method
# child_iter 'var TTreeIter' 'ptr TTreeIter' OUT (diff., need sugar) caller-allocates
# sorted_iter 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_model_sort_convert_iter_to_child_iter(self: ptr TTreeModelSort, child_iter: ptr TTreeIter, sorted_iter: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_tree_model_sort_convert_iter_to_child_iter".}
proc convert_iter_to_child_iter*(self: TreeModelSort, child_iter: var TTreeIter, sorted_iter: TTreeIter) {.inline.} =
  gtk_tree_model_sort_convert_iter_to_child_iter(self, addr(child_iter), myUnsafeAddr(sorted_iter))
# tuple-return
# child_iter: var TTreeIter
# proc convert_iter_to_child_iter*(self: TreeModelSort, sorted_iter: TTreeIter) {.inline.} =

# gtk_tree_model_sort_convert_path_to_child_path
# flags: {isMethod} container: TreeModelSort
# need sugar: is method
# sorted_path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'TTreePath' 'ptr TTreePath' (diff., need sugar)
proc gtk_tree_model_sort_convert_path_to_child_path(self: ptr TTreeModelSort, sorted_path: ptr TTreePath): ptr TTreePath {.cdecl, dynlib: lib, importc: "gtk_tree_model_sort_convert_path_to_child_path".}
proc convert_path_to_child_path*(self: TreeModelSort, sorted_path: TTreePath): TTreePath {.inline.} =
  (gtk_tree_model_sort_convert_path_to_child_path(self, myUnsafeAddr(sorted_path)))[]
# proc convert_path_to_child_path*(self: TreeModelSort, sorted_path: TTreePath): TTreePath {.inline.} =

# gtk_tree_model_sort_get_model
# flags: {isMethod} container: TreeModelSort
# need sugar: is method
# 'TreeModel' 'TransferNone[TTreeModel]' (diff., need sugar)
proc gtk_tree_model_sort_get_model(self: ptr TTreeModelSort): TransferNone[TTreeModel] {.cdecl, dynlib: lib, importc: "gtk_tree_model_sort_get_model".}
proc get_model*(self: TreeModelSort): TreeModel {.inline.} =
  wrap(gtk_tree_model_sort_get_model(self))
# proc get_model*(self: TreeModelSort): TreeModel {.inline.} =

# gtk_tree_model_sort_iter_is_valid
# flags: {isMethod} container: TreeModelSort
# need sugar: is method
# iter 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_tree_model_sort_iter_is_valid(self: ptr TTreeModelSort, iter: ptr TTreeIter): bool {.cdecl, dynlib: lib, importc: "gtk_tree_model_sort_iter_is_valid".}
proc iter_is_valid*(self: TreeModelSort, iter: TTreeIter): bool {.inline.} =
  gtk_tree_model_sort_iter_is_valid(self, myUnsafeAddr(iter))
# proc iter_is_valid*(self: TreeModelSort, iter: TTreeIter): bool {.inline.} =

# gtk_tree_model_sort_reset_default_sort_func
# flags: {isMethod} container: TreeModelSort
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_model_sort_reset_default_sort_func(self: ptr TTreeModelSort) {.cdecl, dynlib: lib, importc: "gtk_tree_model_sort_reset_default_sort_func".}
proc reset_default_sort_func*(self: TreeModelSort) {.inline.} =
  gtk_tree_model_sort_reset_default_sort_func(self)
# proc reset_default_sort_func*(self: TreeModelSort) {.inline.} =

# gtk_tree_selection_count_selected_rows
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# 'int32' 'int32'
proc gtk_tree_selection_count_selected_rows(self: ptr TTreeSelection): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_selection_count_selected_rows".}
proc count_selected_rows*(self: TreeSelection): int32 {.inline.} =
  gtk_tree_selection_count_selected_rows(self)
# proc count_selected_rows*(self: TreeSelection): int32 {.inline.} =

# gtk_tree_selection_get_mode
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# 'SelectionMode' 'SelectionMode'
proc gtk_tree_selection_get_mode(self: ptr TTreeSelection): SelectionMode {.cdecl, dynlib: lib, importc: "gtk_tree_selection_get_mode".}
proc get_mode*(self: TreeSelection): SelectionMode {.inline.} =
  gtk_tree_selection_get_mode(self)
# proc get_mode*(self: TreeSelection): SelectionMode {.inline.} =

# gtk_tree_selection_get_selected
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# model 'var TreeModel' 'ptr TTreeModel' OUT (diff., need sugar) optional
# iter 'var TTreeIter' 'ptr TTreeIter' OUT (diff., need sugar) caller-allocates optional
# 'bool' 'bool'
proc gtk_tree_selection_get_selected(self: ptr TTreeSelection, model: ptr TTreeModel, iter: ptr TTreeIter): bool {.cdecl, dynlib: lib, importc: "gtk_tree_selection_get_selected".}
proc get_selected*(self: TreeSelection, model: var TreeModel, iter: var TTreeIter): bool {.inline.} =
  gtk_tree_selection_get_selected(self, unwrap(model), addr(iter))
# tuple-return
# model: var TreeModel
# iter: var TTreeIter
# proc get_selected*(self: TreeSelection): bool {.inline.} =

# gtk_tree_selection_get_selected_rows
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# model 'var TreeModel' 'ptr TTreeModel' OUT (diff., need sugar) optional
# 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_tree_selection_get_selected_rows(self: ptr TTreeSelection, model: ptr TTreeModel): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_tree_selection_get_selected_rows".}
proc get_selected_rows*(self: TreeSelection, model: var TreeModel): ptr GLIST_TODO {.inline.} =
  gtk_tree_selection_get_selected_rows(self, unwrap(model))
# tuple-return
# model: var TreeModel
# proc get_selected_rows*(self: TreeSelection): ptr GLIST_TODO {.inline.} =

# gtk_tree_selection_get_tree_view
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# 'TreeView' 'TransferNone[TTreeView]' (diff., need sugar)
proc gtk_tree_selection_get_tree_view(self: ptr TTreeSelection): TransferNone[TTreeView] {.cdecl, dynlib: lib, importc: "gtk_tree_selection_get_tree_view".}
proc get_tree_view*(self: TreeSelection): TreeView {.inline.} =
  wrap(gtk_tree_selection_get_tree_view(self))
# proc get_tree_view*(self: TreeSelection): TreeView {.inline.} =

# gtk_tree_selection_iter_is_selected
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# iter 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_tree_selection_iter_is_selected(self: ptr TTreeSelection, iter: ptr TTreeIter): bool {.cdecl, dynlib: lib, importc: "gtk_tree_selection_iter_is_selected".}
proc iter_is_selected*(self: TreeSelection, iter: TTreeIter): bool {.inline.} =
  gtk_tree_selection_iter_is_selected(self, myUnsafeAddr(iter))
# proc iter_is_selected*(self: TreeSelection, iter: TTreeIter): bool {.inline.} =

# gtk_tree_selection_path_is_selected
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_tree_selection_path_is_selected(self: ptr TTreeSelection, path: ptr TTreePath): bool {.cdecl, dynlib: lib, importc: "gtk_tree_selection_path_is_selected".}
proc path_is_selected*(self: TreeSelection, path: TTreePath): bool {.inline.} =
  gtk_tree_selection_path_is_selected(self, myUnsafeAddr(path))
# proc path_is_selected*(self: TreeSelection, path: TTreePath): bool {.inline.} =

# gtk_tree_selection_select_all
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_selection_select_all(self: ptr TTreeSelection) {.cdecl, dynlib: lib, importc: "gtk_tree_selection_select_all".}
proc select_all*(self: TreeSelection) {.inline.} =
  gtk_tree_selection_select_all(self)
# proc select_all*(self: TreeSelection) {.inline.} =

# gtk_tree_selection_select_iter
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# iter 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_selection_select_iter(self: ptr TTreeSelection, iter: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_tree_selection_select_iter".}
proc select_iter*(self: TreeSelection, iter: TTreeIter) {.inline.} =
  gtk_tree_selection_select_iter(self, myUnsafeAddr(iter))
# proc select_iter*(self: TreeSelection, iter: TTreeIter) {.inline.} =

# gtk_tree_selection_select_path
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_selection_select_path(self: ptr TTreeSelection, path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_tree_selection_select_path".}
proc select_path*(self: TreeSelection, path: TTreePath) {.inline.} =
  gtk_tree_selection_select_path(self, myUnsafeAddr(path))
# proc select_path*(self: TreeSelection, path: TTreePath) {.inline.} =

# gtk_tree_selection_select_range
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# start_path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# end_path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_selection_select_range(self: ptr TTreeSelection, start_path: ptr TTreePath, end_path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_tree_selection_select_range".}
proc select_range*(self: TreeSelection, start_path: TTreePath, end_path: TTreePath) {.inline.} =
  gtk_tree_selection_select_range(self, myUnsafeAddr(start_path), myUnsafeAddr(end_path))
# proc select_range*(self: TreeSelection, start_path: TTreePath, end_path: TTreePath) {.inline.} =

# gtk_tree_selection_selected_foreach
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# func 'pointer' 'pointer' IN
# data 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_selection_selected_foreach(self: ptr TTreeSelection, func_x: pointer, data: pointer) {.cdecl, dynlib: lib, importc: "gtk_tree_selection_selected_foreach".}
proc selected_foreach*(self: TreeSelection, func_x: pointer, data: pointer) {.inline.} =
  gtk_tree_selection_selected_foreach(self, func_x, data)
# proc selected_foreach*(self: TreeSelection, func_x: pointer, data: pointer) {.inline.} =

# gtk_tree_selection_set_mode
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# type 'SelectionMode' 'SelectionMode' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_selection_set_mode(self: ptr TTreeSelection, type_x: SelectionMode) {.cdecl, dynlib: lib, importc: "gtk_tree_selection_set_mode".}
proc set_mode*(self: TreeSelection, type_x: SelectionMode) {.inline.} =
  gtk_tree_selection_set_mode(self, type_x)
# proc set_mode*(self: TreeSelection, type_x: SelectionMode) {.inline.} =

# gtk_tree_selection_set_select_function
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# func 'pointer' 'pointer' IN
# data 'pointer' 'pointer' IN
# destroy 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_selection_set_select_function(self: ptr TTreeSelection, func_x: pointer, data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_tree_selection_set_select_function".}
proc set_select_function*(self: TreeSelection, func_x: pointer, data: pointer, destroy: pointer) {.inline.} =
  gtk_tree_selection_set_select_function(self, func_x, data, destroy)
# proc set_select_function*(self: TreeSelection, func_x: pointer, data: pointer, destroy: pointer) {.inline.} =

# gtk_tree_selection_unselect_all
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_selection_unselect_all(self: ptr TTreeSelection) {.cdecl, dynlib: lib, importc: "gtk_tree_selection_unselect_all".}
proc unselect_all*(self: TreeSelection) {.inline.} =
  gtk_tree_selection_unselect_all(self)
# proc unselect_all*(self: TreeSelection) {.inline.} =

# gtk_tree_selection_unselect_iter
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# iter 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_selection_unselect_iter(self: ptr TTreeSelection, iter: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_tree_selection_unselect_iter".}
proc unselect_iter*(self: TreeSelection, iter: TTreeIter) {.inline.} =
  gtk_tree_selection_unselect_iter(self, myUnsafeAddr(iter))
# proc unselect_iter*(self: TreeSelection, iter: TTreeIter) {.inline.} =

# gtk_tree_selection_unselect_path
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_selection_unselect_path(self: ptr TTreeSelection, path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_tree_selection_unselect_path".}
proc unselect_path*(self: TreeSelection, path: TTreePath) {.inline.} =
  gtk_tree_selection_unselect_path(self, myUnsafeAddr(path))
# proc unselect_path*(self: TreeSelection, path: TTreePath) {.inline.} =

# gtk_tree_selection_unselect_range
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# start_path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# end_path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_selection_unselect_range(self: ptr TTreeSelection, start_path: ptr TTreePath, end_path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_tree_selection_unselect_range".}
proc unselect_range*(self: TreeSelection, start_path: TTreePath, end_path: TTreePath) {.inline.} =
  gtk_tree_selection_unselect_range(self, myUnsafeAddr(start_path), myUnsafeAddr(end_path))
# proc unselect_range*(self: TreeSelection, start_path: TTreePath, end_path: TTreePath) {.inline.} =

# gtk_tree_store_newv
# flags: {isConstructor} container: TreeStore
# need sugar: is static method
# n_columns 'int32' 'int32' IN
# types 'var openarray[GType]' 'openarray[GType]' IN (diff., need sugar) array lengthArg: 0
# 'TreeStore' 'TransferFull[TTreeStore]' (diff., need sugar)
proc gtk_tree_store_newv(n_columns: int32, types: openarray[GType]): TransferFull[TTreeStore] {.cdecl, dynlib: lib, importc: "gtk_tree_store_newv".}
proc new_treestore*(types: var openarray[GType]): TreeStore {.inline.} =
  wrap(gtk_tree_store_newv(types.len.int32, types))
# proc new_treestore*(types: var openarray[GType]): TreeStore {.inline.} =

# gtk_tree_store_append
# flags: {isMethod} container: TreeStore
# need sugar: is method
# iter 'var TTreeIter' 'ptr TTreeIter' OUT (diff., need sugar) caller-allocates
# parent 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_store_append(self: ptr TTreeStore, iter: ptr TTreeIter, parent: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_tree_store_append".}
proc append*(self: TreeStore, iter: var TTreeIter, parent: TTreeIter) {.inline.} =
  gtk_tree_store_append(self, addr(iter), myUnsafeAddr(parent))
# tuple-return
# iter: var TTreeIter
# proc append*(self: TreeStore, parent: TTreeIter) {.inline.} =

# gtk_tree_store_clear
# flags: {isMethod} container: TreeStore
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_store_clear(self: ptr TTreeStore) {.cdecl, dynlib: lib, importc: "gtk_tree_store_clear".}
proc clear*(self: TreeStore) {.inline.} =
  gtk_tree_store_clear(self)
# proc clear*(self: TreeStore) {.inline.} =

# gtk_tree_store_insert
# flags: {isMethod} container: TreeStore
# need sugar: is method
# iter 'var TTreeIter' 'ptr TTreeIter' OUT (diff., need sugar) caller-allocates
# parent 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# position 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_store_insert(self: ptr TTreeStore, iter: ptr TTreeIter, parent: ptr TTreeIter, position: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_store_insert".}
proc insert*(self: TreeStore, iter: var TTreeIter, parent: TTreeIter, position: int32) {.inline.} =
  gtk_tree_store_insert(self, addr(iter), myUnsafeAddr(parent), position)
# tuple-return
# iter: var TTreeIter
# proc insert*(self: TreeStore, parent: TTreeIter, position: int32) {.inline.} =

# gtk_tree_store_insert_after
# flags: {isMethod} container: TreeStore
# need sugar: is method
# iter 'var TTreeIter' 'ptr TTreeIter' OUT (diff., need sugar) caller-allocates
# parent 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# sibling 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_store_insert_after(self: ptr TTreeStore, iter: ptr TTreeIter, parent: ptr TTreeIter, sibling: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_tree_store_insert_after".}
proc insert_after*(self: TreeStore, iter: var TTreeIter, parent: TTreeIter, sibling: TTreeIter) {.inline.} =
  gtk_tree_store_insert_after(self, addr(iter), myUnsafeAddr(parent), myUnsafeAddr(sibling))
# tuple-return
# iter: var TTreeIter
# proc insert_after*(self: TreeStore, parent: TTreeIter, sibling: TTreeIter) {.inline.} =

# gtk_tree_store_insert_before
# flags: {isMethod} container: TreeStore
# need sugar: is method
# iter 'var TTreeIter' 'ptr TTreeIter' OUT (diff., need sugar) caller-allocates
# parent 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# sibling 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_store_insert_before(self: ptr TTreeStore, iter: ptr TTreeIter, parent: ptr TTreeIter, sibling: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_tree_store_insert_before".}
proc insert_before*(self: TreeStore, iter: var TTreeIter, parent: TTreeIter, sibling: TTreeIter) {.inline.} =
  gtk_tree_store_insert_before(self, addr(iter), myUnsafeAddr(parent), myUnsafeAddr(sibling))
# tuple-return
# iter: var TTreeIter
# proc insert_before*(self: TreeStore, parent: TTreeIter, sibling: TTreeIter) {.inline.} =

# gtk_tree_store_insert_with_valuesv
# flags: {isMethod} container: TreeStore
# need sugar: is method
# iter 'var TTreeIter' 'ptr TTreeIter' OUT (diff., need sugar) caller-allocates optional
# parent 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# position 'int32' 'int32' IN
# columns 'var openarray[int32]' 'openarray[int32]' IN (diff., need sugar) array lengthArg: 5
# values 'var openarray[GObject2.TValue]' 'openarray[GObject2.TValue]' IN (diff., need sugar) array lengthArg: 5
# n_values 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_store_insert_with_valuesv(self: ptr TTreeStore, iter: ptr TTreeIter, parent: ptr TTreeIter, position: int32, columns: openarray[int32], values: openarray[GObject2.TValue], n_values: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_store_insert_with_valuesv".}
proc insert_with_values*(self: TreeStore, iter: var TTreeIter, parent: TTreeIter, position: int32, columns: var openarray[int32], values: var openarray[GObject2.TValue]) {.inline.} =
  gtk_tree_store_insert_with_valuesv(self, addr(iter), myUnsafeAddr(parent), position, columns, values, values.len.int32)
# tuple-return
# iter: var TTreeIter
# proc insert_with_values*(self: TreeStore, parent: TTreeIter, position: int32, columns: var openarray[int32], values: var openarray[GObject2.TValue]) {.inline.} =

# gtk_tree_store_is_ancestor
# flags: {isMethod} container: TreeStore
# need sugar: is method
# iter 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# descendant 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_tree_store_is_ancestor(self: ptr TTreeStore, iter: ptr TTreeIter, descendant: ptr TTreeIter): bool {.cdecl, dynlib: lib, importc: "gtk_tree_store_is_ancestor".}
proc is_ancestor*(self: TreeStore, iter: TTreeIter, descendant: TTreeIter): bool {.inline.} =
  gtk_tree_store_is_ancestor(self, myUnsafeAddr(iter), myUnsafeAddr(descendant))
# proc is_ancestor*(self: TreeStore, iter: TTreeIter, descendant: TTreeIter): bool {.inline.} =

# gtk_tree_store_iter_depth
# flags: {isMethod} container: TreeStore
# need sugar: is method
# iter 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'int32' 'int32'
proc gtk_tree_store_iter_depth(self: ptr TTreeStore, iter: ptr TTreeIter): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_store_iter_depth".}
proc iter_depth*(self: TreeStore, iter: TTreeIter): int32 {.inline.} =
  gtk_tree_store_iter_depth(self, myUnsafeAddr(iter))
# proc iter_depth*(self: TreeStore, iter: TTreeIter): int32 {.inline.} =

# gtk_tree_store_iter_is_valid
# flags: {isMethod} container: TreeStore
# need sugar: is method
# iter 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_tree_store_iter_is_valid(self: ptr TTreeStore, iter: ptr TTreeIter): bool {.cdecl, dynlib: lib, importc: "gtk_tree_store_iter_is_valid".}
proc iter_is_valid*(self: TreeStore, iter: TTreeIter): bool {.inline.} =
  gtk_tree_store_iter_is_valid(self, myUnsafeAddr(iter))
# proc iter_is_valid*(self: TreeStore, iter: TTreeIter): bool {.inline.} =

# gtk_tree_store_move_after
# flags: {isMethod} container: TreeStore
# need sugar: is method
# iter 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# position 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_store_move_after(self: ptr TTreeStore, iter: ptr TTreeIter, position: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_tree_store_move_after".}
proc move_after*(self: TreeStore, iter: TTreeIter, position: TTreeIter) {.inline.} =
  gtk_tree_store_move_after(self, myUnsafeAddr(iter), myUnsafeAddr(position))
# proc move_after*(self: TreeStore, iter: TTreeIter, position: TTreeIter) {.inline.} =

# gtk_tree_store_move_before
# flags: {isMethod} container: TreeStore
# need sugar: is method
# iter 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# position 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_store_move_before(self: ptr TTreeStore, iter: ptr TTreeIter, position: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_tree_store_move_before".}
proc move_before*(self: TreeStore, iter: TTreeIter, position: TTreeIter) {.inline.} =
  gtk_tree_store_move_before(self, myUnsafeAddr(iter), myUnsafeAddr(position))
# proc move_before*(self: TreeStore, iter: TTreeIter, position: TTreeIter) {.inline.} =

# gtk_tree_store_prepend
# flags: {isMethod} container: TreeStore
# need sugar: is method
# iter 'var TTreeIter' 'ptr TTreeIter' OUT (diff., need sugar) caller-allocates
# parent 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_store_prepend(self: ptr TTreeStore, iter: ptr TTreeIter, parent: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_tree_store_prepend".}
proc prepend*(self: TreeStore, iter: var TTreeIter, parent: TTreeIter) {.inline.} =
  gtk_tree_store_prepend(self, addr(iter), myUnsafeAddr(parent))
# tuple-return
# iter: var TTreeIter
# proc prepend*(self: TreeStore, parent: TTreeIter) {.inline.} =

# gtk_tree_store_remove
# flags: {isMethod} container: TreeStore
# need sugar: is method
# iter 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_tree_store_remove(self: ptr TTreeStore, iter: ptr TTreeIter): bool {.cdecl, dynlib: lib, importc: "gtk_tree_store_remove".}
proc remove*(self: TreeStore, iter: TTreeIter): bool {.inline.} =
  gtk_tree_store_remove(self, myUnsafeAddr(iter))
# proc remove*(self: TreeStore, iter: TTreeIter): bool {.inline.} =

# gtk_tree_store_set_column_types
# flags: {isMethod} container: TreeStore
# need sugar: is method
# n_columns 'int32' 'int32' IN
# types 'var openarray[GType]' 'openarray[GType]' IN (diff., need sugar) array lengthArg: 0
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_store_set_column_types(self: ptr TTreeStore, n_columns: int32, types: openarray[GType]) {.cdecl, dynlib: lib, importc: "gtk_tree_store_set_column_types".}
proc set_column_types*(self: TreeStore, types: var openarray[GType]) {.inline.} =
  gtk_tree_store_set_column_types(self, types.len.int32, types)
# proc set_column_types*(self: TreeStore, types: var openarray[GType]) {.inline.} =

# gtk_tree_store_set_value
# flags: {isMethod} container: TreeStore
# need sugar: is method
# iter 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# column 'int32' 'int32' IN
# value 'GObject2.TValue' 'ptr GObject2.TValue' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_store_set_value(self: ptr TTreeStore, iter: ptr TTreeIter, column: int32, value: ptr GObject2.TValue) {.cdecl, dynlib: lib, importc: "gtk_tree_store_set_value".}
proc set_value*(self: TreeStore, iter: TTreeIter, column: int32, value: GObject2.TValue) {.inline.} =
  gtk_tree_store_set_value(self, myUnsafeAddr(iter), column, myUnsafeAddr(value))
# proc set_value*(self: TreeStore, iter: TTreeIter, column: int32, value: GObject2.TValue) {.inline.} =

# gtk_tree_store_set_valuesv
# flags: {isMethod} container: TreeStore
# need sugar: is method
# iter 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# columns 'var openarray[int32]' 'openarray[int32]' IN (diff., need sugar) array lengthArg: 3
# values 'var openarray[GObject2.TValue]' 'openarray[GObject2.TValue]' IN (diff., need sugar) array lengthArg: 3
# n_values 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_store_set_valuesv(self: ptr TTreeStore, iter: ptr TTreeIter, columns: openarray[int32], values: openarray[GObject2.TValue], n_values: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_store_set_valuesv".}
proc set*(self: TreeStore, iter: TTreeIter, columns: var openarray[int32], values: var openarray[GObject2.TValue]) {.inline.} =
  gtk_tree_store_set_valuesv(self, myUnsafeAddr(iter), columns, values, values.len.int32)
# proc set*(self: TreeStore, iter: TTreeIter, columns: var openarray[int32], values: var openarray[GObject2.TValue]) {.inline.} =

# gtk_tree_store_swap
# flags: {isMethod} container: TreeStore
# need sugar: is method
# a 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# b 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_store_swap(self: ptr TTreeStore, a: ptr TTreeIter, b: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_tree_store_swap".}
proc swap*(self: TreeStore, a: TTreeIter, b: TTreeIter) {.inline.} =
  gtk_tree_store_swap(self, myUnsafeAddr(a), myUnsafeAddr(b))
# proc swap*(self: TreeStore, a: TTreeIter, b: TTreeIter) {.inline.} =

# gtk_tree_view_new
# flags: {isConstructor} container: TreeView
# need sugar: is static method
# 'TreeView' 'TransferNone[TTreeView]' (diff., need sugar)
proc gtk_tree_view_new(): TransferNone[TTreeView] {.cdecl, dynlib: lib, importc: "gtk_tree_view_new".}
proc new_treeview*(): TreeView {.inline.} =
  wrap(gtk_tree_view_new())
# proc new_treeview*(): TreeView {.inline.} =

# gtk_tree_view_new_with_model
# flags: {isConstructor} container: TreeView
# need sugar: is static method
# model 'TreeModel' 'ptr TTreeModel' IN (diff., need sugar)
# 'TreeView' 'TransferNone[TTreeView]' (diff., need sugar)
proc gtk_tree_view_new_with_model(model: ptr TTreeModel): TransferNone[TTreeView] {.cdecl, dynlib: lib, importc: "gtk_tree_view_new_with_model".}
proc new_treeview_with_model*(model: TreeModel): TreeView {.inline.} =
  wrap(gtk_tree_view_new_with_model(unwrap(model)))
# proc new_treeview_with_model*(model: TreeModel): TreeView {.inline.} =

# gtk_tree_view_append_column
# flags: {isMethod} container: TreeView
# need sugar: is method
# column 'TreeViewColumn' 'ptr TTreeViewColumn' IN (diff., need sugar)
# 'int32' 'int32'
proc gtk_tree_view_append_column(self: ptr TTreeView, column: ptr TTreeViewColumn): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_append_column".}
proc append_column*(self: TreeView, column: TreeViewColumn): int32 {.inline.} =
  gtk_tree_view_append_column(self, column.getPointer)
# proc append_column*(self: TreeView, column: TreeViewColumn): int32 {.inline.} =

# gtk_tree_view_collapse_all
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_collapse_all(self: ptr TTreeView) {.cdecl, dynlib: lib, importc: "gtk_tree_view_collapse_all".}
proc collapse_all*(self: TreeView) {.inline.} =
  gtk_tree_view_collapse_all(self)
# proc collapse_all*(self: TreeView) {.inline.} =

# gtk_tree_view_collapse_row
# flags: {isMethod} container: TreeView
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_tree_view_collapse_row(self: ptr TTreeView, path: ptr TTreePath): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_collapse_row".}
proc collapse_row*(self: TreeView, path: TTreePath): bool {.inline.} =
  gtk_tree_view_collapse_row(self, myUnsafeAddr(path))
# proc collapse_row*(self: TreeView, path: TTreePath): bool {.inline.} =

# gtk_tree_view_columns_autosize
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_columns_autosize(self: ptr TTreeView) {.cdecl, dynlib: lib, importc: "gtk_tree_view_columns_autosize".}
proc columns_autosize*(self: TreeView) {.inline.} =
  gtk_tree_view_columns_autosize(self)
# proc columns_autosize*(self: TreeView) {.inline.} =

# gtk_tree_view_convert_bin_window_to_tree_coords
# flags: {isMethod} container: TreeView
# need sugar: is method
# bx 'int32' 'int32' IN
# by 'int32' 'int32' IN
# tx 'var int32' 'ptr int32' OUT (diff., need sugar)
# ty 'var int32' 'ptr int32' OUT (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_convert_bin_window_to_tree_coords(self: ptr TTreeView, bx: int32, by: int32, tx: ptr int32, ty: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_convert_bin_window_to_tree_coords".}
proc convert_bin_window_to_tree_coords*(self: TreeView, bx: int32, by: int32, tx: var int32, ty: var int32) {.inline.} =
  gtk_tree_view_convert_bin_window_to_tree_coords(self, bx, by, addr(tx), addr(ty))
# tuple-return
# tx: var int32
# ty: var int32
# proc convert_bin_window_to_tree_coords*(self: TreeView, bx: int32, by: int32) {.inline.} =

# gtk_tree_view_convert_bin_window_to_widget_coords
# flags: {isMethod} container: TreeView
# need sugar: is method
# bx 'int32' 'int32' IN
# by 'int32' 'int32' IN
# wx 'var int32' 'ptr int32' OUT (diff., need sugar)
# wy 'var int32' 'ptr int32' OUT (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_convert_bin_window_to_widget_coords(self: ptr TTreeView, bx: int32, by: int32, wx: ptr int32, wy: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_convert_bin_window_to_widget_coords".}
proc convert_bin_window_to_widget_coords*(self: TreeView, bx: int32, by: int32, wx: var int32, wy: var int32) {.inline.} =
  gtk_tree_view_convert_bin_window_to_widget_coords(self, bx, by, addr(wx), addr(wy))
# tuple-return
# wx: var int32
# wy: var int32
# proc convert_bin_window_to_widget_coords*(self: TreeView, bx: int32, by: int32) {.inline.} =

# gtk_tree_view_convert_tree_to_bin_window_coords
# flags: {isMethod} container: TreeView
# need sugar: is method
# tx 'int32' 'int32' IN
# ty 'int32' 'int32' IN
# bx 'var int32' 'ptr int32' OUT (diff., need sugar)
# by 'var int32' 'ptr int32' OUT (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_convert_tree_to_bin_window_coords(self: ptr TTreeView, tx: int32, ty: int32, bx: ptr int32, by: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_convert_tree_to_bin_window_coords".}
proc convert_tree_to_bin_window_coords*(self: TreeView, tx: int32, ty: int32, bx: var int32, by: var int32) {.inline.} =
  gtk_tree_view_convert_tree_to_bin_window_coords(self, tx, ty, addr(bx), addr(by))
# tuple-return
# bx: var int32
# by: var int32
# proc convert_tree_to_bin_window_coords*(self: TreeView, tx: int32, ty: int32) {.inline.} =

# gtk_tree_view_convert_tree_to_widget_coords
# flags: {isMethod} container: TreeView
# need sugar: is method
# tx 'int32' 'int32' IN
# ty 'int32' 'int32' IN
# wx 'var int32' 'ptr int32' OUT (diff., need sugar)
# wy 'var int32' 'ptr int32' OUT (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_convert_tree_to_widget_coords(self: ptr TTreeView, tx: int32, ty: int32, wx: ptr int32, wy: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_convert_tree_to_widget_coords".}
proc convert_tree_to_widget_coords*(self: TreeView, tx: int32, ty: int32, wx: var int32, wy: var int32) {.inline.} =
  gtk_tree_view_convert_tree_to_widget_coords(self, tx, ty, addr(wx), addr(wy))
# tuple-return
# wx: var int32
# wy: var int32
# proc convert_tree_to_widget_coords*(self: TreeView, tx: int32, ty: int32) {.inline.} =

# gtk_tree_view_convert_widget_to_bin_window_coords
# flags: {isMethod} container: TreeView
# need sugar: is method
# wx 'int32' 'int32' IN
# wy 'int32' 'int32' IN
# bx 'var int32' 'ptr int32' OUT (diff., need sugar)
# by 'var int32' 'ptr int32' OUT (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_convert_widget_to_bin_window_coords(self: ptr TTreeView, wx: int32, wy: int32, bx: ptr int32, by: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_convert_widget_to_bin_window_coords".}
proc convert_widget_to_bin_window_coords*(self: TreeView, wx: int32, wy: int32, bx: var int32, by: var int32) {.inline.} =
  gtk_tree_view_convert_widget_to_bin_window_coords(self, wx, wy, addr(bx), addr(by))
# tuple-return
# bx: var int32
# by: var int32
# proc convert_widget_to_bin_window_coords*(self: TreeView, wx: int32, wy: int32) {.inline.} =

# gtk_tree_view_convert_widget_to_tree_coords
# flags: {isMethod} container: TreeView
# need sugar: is method
# wx 'int32' 'int32' IN
# wy 'int32' 'int32' IN
# tx 'var int32' 'ptr int32' OUT (diff., need sugar)
# ty 'var int32' 'ptr int32' OUT (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_convert_widget_to_tree_coords(self: ptr TTreeView, wx: int32, wy: int32, tx: ptr int32, ty: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_convert_widget_to_tree_coords".}
proc convert_widget_to_tree_coords*(self: TreeView, wx: int32, wy: int32, tx: var int32, ty: var int32) {.inline.} =
  gtk_tree_view_convert_widget_to_tree_coords(self, wx, wy, addr(tx), addr(ty))
# tuple-return
# tx: var int32
# ty: var int32
# proc convert_widget_to_tree_coords*(self: TreeView, wx: int32, wy: int32) {.inline.} =

# gtk_tree_view_create_row_drag_icon
# flags: {isMethod} container: TreeView
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'cairo1.TSurface' 'ptr cairo1.TSurface' (diff., need sugar)
proc gtk_tree_view_create_row_drag_icon(self: ptr TTreeView, path: ptr TTreePath): ptr cairo1.TSurface {.cdecl, dynlib: lib, importc: "gtk_tree_view_create_row_drag_icon".}
proc create_row_drag_icon*(self: TreeView, path: TTreePath): cairo1.TSurface {.inline.} =
  (gtk_tree_view_create_row_drag_icon(self, myUnsafeAddr(path)))[]
# proc create_row_drag_icon*(self: TreeView, path: TTreePath): cairo1.TSurface {.inline.} =

# gtk_tree_view_enable_model_drag_dest
# flags: {isMethod} container: TreeView
# need sugar: is method
# targets 'var openarray[TTargetEntry]' 'openarray[TTargetEntry]' IN (diff., need sugar) array lengthArg: 1
# n_targets 'int32' 'int32' IN
# actions 'Gdk3.SDragAction' 'Gdk3.SDragAction' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_enable_model_drag_dest(self: ptr TTreeView, targets: openarray[TTargetEntry], n_targets: int32, actions: Gdk3.SDragAction) {.cdecl, dynlib: lib, importc: "gtk_tree_view_enable_model_drag_dest".}
proc enable_model_drag_dest*(self: TreeView, targets: var openarray[TTargetEntry], actions: Gdk3.SDragAction) {.inline.} =
  gtk_tree_view_enable_model_drag_dest(self, targets, targets.len.int32, actions)
# proc enable_model_drag_dest*(self: TreeView, targets: var openarray[TTargetEntry], actions: Gdk3.SDragAction) {.inline.} =

# gtk_tree_view_enable_model_drag_source
# flags: {isMethod} container: TreeView
# need sugar: is method
# start_button_mask 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# targets 'var openarray[TTargetEntry]' 'openarray[TTargetEntry]' IN (diff., need sugar) array lengthArg: 2
# n_targets 'int32' 'int32' IN
# actions 'Gdk3.SDragAction' 'Gdk3.SDragAction' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_enable_model_drag_source(self: ptr TTreeView, start_button_mask: Gdk3.SModifierType, targets: openarray[TTargetEntry], n_targets: int32, actions: Gdk3.SDragAction) {.cdecl, dynlib: lib, importc: "gtk_tree_view_enable_model_drag_source".}
proc enable_model_drag_source*(self: TreeView, start_button_mask: Gdk3.SModifierType, targets: var openarray[TTargetEntry], actions: Gdk3.SDragAction) {.inline.} =
  gtk_tree_view_enable_model_drag_source(self, start_button_mask, targets, targets.len.int32, actions)
# proc enable_model_drag_source*(self: TreeView, start_button_mask: Gdk3.SModifierType, targets: var openarray[TTargetEntry], actions: Gdk3.SDragAction) {.inline.} =

# gtk_tree_view_expand_all
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_expand_all(self: ptr TTreeView) {.cdecl, dynlib: lib, importc: "gtk_tree_view_expand_all".}
proc expand_all*(self: TreeView) {.inline.} =
  gtk_tree_view_expand_all(self)
# proc expand_all*(self: TreeView) {.inline.} =

# gtk_tree_view_expand_row
# flags: {isMethod} container: TreeView
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# open_all 'bool' 'bool' IN
# 'bool' 'bool'
proc gtk_tree_view_expand_row(self: ptr TTreeView, path: ptr TTreePath, open_all: bool): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_expand_row".}
proc expand_row*(self: TreeView, path: TTreePath, open_all: bool): bool {.inline.} =
  gtk_tree_view_expand_row(self, myUnsafeAddr(path), open_all)
# proc expand_row*(self: TreeView, path: TTreePath, open_all: bool): bool {.inline.} =

# gtk_tree_view_expand_to_path
# flags: {isMethod} container: TreeView
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_expand_to_path(self: ptr TTreeView, path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_tree_view_expand_to_path".}
proc expand_to_path*(self: TreeView, path: TTreePath) {.inline.} =
  gtk_tree_view_expand_to_path(self, myUnsafeAddr(path))
# proc expand_to_path*(self: TreeView, path: TTreePath) {.inline.} =

# gtk_tree_view_get_activate_on_single_click
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'bool' 'bool'
proc gtk_tree_view_get_activate_on_single_click(self: ptr TTreeView): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_activate_on_single_click".}
proc get_activate_on_single_click*(self: TreeView): bool {.inline.} =
  gtk_tree_view_get_activate_on_single_click(self)
# proc get_activate_on_single_click*(self: TreeView): bool {.inline.} =

# gtk_tree_view_get_background_area
# flags: {isMethod} container: TreeView
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# column 'TreeViewColumn' 'ptr TTreeViewColumn' IN (diff., need sugar)
# rect 'var cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_get_background_area(self: ptr TTreeView, path: ptr TTreePath, column: ptr TTreeViewColumn, rect: ptr cairo1.TRectangleInt) {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_background_area".}
proc get_background_area*(self: TreeView, path: TTreePath, column: TreeViewColumn, rect: var cairo1.TRectangleInt) {.inline.} =
  gtk_tree_view_get_background_area(self, myUnsafeAddr(path), column.getPointer, addr(rect))
# tuple-return
# rect: var cairo1.TRectangleInt
# proc get_background_area*(self: TreeView, path: TTreePath, column: TreeViewColumn) {.inline.} =

# gtk_tree_view_get_bin_window
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'Gdk3.Window' 'TransferNone[Gdk3.TWindow]' (diff., need sugar)
proc gtk_tree_view_get_bin_window(self: ptr TTreeView): TransferNone[Gdk3.TWindow] {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_bin_window".}
proc get_bin_window*(self: TreeView): Gdk3.Window {.inline.} =
  wrap(gtk_tree_view_get_bin_window(self))
# proc get_bin_window*(self: TreeView): Gdk3.Window {.inline.} =

# gtk_tree_view_get_cell_area
# flags: {isMethod} container: TreeView
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# column 'TreeViewColumn' 'ptr TTreeViewColumn' IN (diff., need sugar)
# rect 'var cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_get_cell_area(self: ptr TTreeView, path: ptr TTreePath, column: ptr TTreeViewColumn, rect: ptr cairo1.TRectangleInt) {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_cell_area".}
proc get_cell_area*(self: TreeView, path: TTreePath, column: TreeViewColumn, rect: var cairo1.TRectangleInt) {.inline.} =
  gtk_tree_view_get_cell_area(self, myUnsafeAddr(path), column.getPointer, addr(rect))
# tuple-return
# rect: var cairo1.TRectangleInt
# proc get_cell_area*(self: TreeView, path: TTreePath, column: TreeViewColumn) {.inline.} =

# gtk_tree_view_get_column
# flags: {isMethod} container: TreeView
# need sugar: is method
# n 'int32' 'int32' IN
# 'TreeViewColumn' 'TransferNone[TTreeViewColumn]' (diff., need sugar)
proc gtk_tree_view_get_column(self: ptr TTreeView, n: int32): TransferNone[TTreeViewColumn] {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_column".}
proc get_column*(self: TreeView, n: int32): TreeViewColumn {.inline.} =
  wrap(gtk_tree_view_get_column(self, n))
# proc get_column*(self: TreeView, n: int32): TreeViewColumn {.inline.} =

# gtk_tree_view_get_columns
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_tree_view_get_columns(self: ptr TTreeView): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_columns".}
proc get_columns*(self: TreeView): ptr GLIST_TODO {.inline.} =
  gtk_tree_view_get_columns(self)
# proc get_columns*(self: TreeView): ptr GLIST_TODO {.inline.} =

# gtk_tree_view_get_cursor
# flags: {isMethod} container: TreeView
# need sugar: is method
# path 'var TTreePath' 'ptr TTreePath' OUT (diff., need sugar) optional
# focus_column 'var TreeViewColumn' 'ptr TTreeViewColumn' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_get_cursor(self: ptr TTreeView, path: ptr TTreePath, focus_column: ptr TTreeViewColumn) {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_cursor".}
proc get_cursor*(self: TreeView, path: var TTreePath, focus_column: var TreeViewColumn) {.inline.} =
  gtk_tree_view_get_cursor(self, addr(path), focus_column.getPointer)
# tuple-return
# path: var TTreePath
# focus_column: var TreeViewColumn
# proc get_cursor*(self: TreeView) {.inline.} =

# gtk_tree_view_get_dest_row_at_pos
# flags: {isMethod} container: TreeView
# need sugar: is method
# drag_x 'int32' 'int32' IN
# drag_y 'int32' 'int32' IN
# path 'var TTreePath' 'ptr TTreePath' OUT (diff., need sugar) optional
# pos 'TreeViewDropPosition' 'TreeViewDropPosition' OUT optional
# 'bool' 'bool'
proc gtk_tree_view_get_dest_row_at_pos(self: ptr TTreeView, drag_x: int32, drag_y: int32, path: ptr TTreePath, pos: TreeViewDropPosition): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_dest_row_at_pos".}
proc get_dest_row_at_pos*(self: TreeView, drag_x: int32, drag_y: int32, path: var TTreePath, pos: TreeViewDropPosition): bool {.inline.} =
  gtk_tree_view_get_dest_row_at_pos(self, drag_x, drag_y, addr(path), pos)
# tuple-return
# path: var TTreePath
# pos: TreeViewDropPosition
# proc get_dest_row_at_pos*(self: TreeView, drag_x: int32, drag_y: int32): bool {.inline.} =

# gtk_tree_view_get_drag_dest_row
# flags: {isMethod} container: TreeView
# need sugar: is method
# path 'var TTreePath' 'ptr TTreePath' OUT (diff., need sugar) optional
# pos 'TreeViewDropPosition' 'TreeViewDropPosition' OUT optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_get_drag_dest_row(self: ptr TTreeView, path: ptr TTreePath, pos: TreeViewDropPosition) {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_drag_dest_row".}
proc get_drag_dest_row*(self: TreeView, path: var TTreePath, pos: TreeViewDropPosition) {.inline.} =
  gtk_tree_view_get_drag_dest_row(self, addr(path), pos)
# tuple-return
# path: var TTreePath
# pos: TreeViewDropPosition
# proc get_drag_dest_row*(self: TreeView) {.inline.} =

# gtk_tree_view_get_enable_search
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'bool' 'bool'
proc gtk_tree_view_get_enable_search(self: ptr TTreeView): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_enable_search".}
proc get_enable_search*(self: TreeView): bool {.inline.} =
  gtk_tree_view_get_enable_search(self)
# proc get_enable_search*(self: TreeView): bool {.inline.} =

# gtk_tree_view_get_enable_tree_lines
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'bool' 'bool'
proc gtk_tree_view_get_enable_tree_lines(self: ptr TTreeView): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_enable_tree_lines".}
proc get_enable_tree_lines*(self: TreeView): bool {.inline.} =
  gtk_tree_view_get_enable_tree_lines(self)
# proc get_enable_tree_lines*(self: TreeView): bool {.inline.} =

# gtk_tree_view_get_expander_column
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'TreeViewColumn' 'TransferNone[TTreeViewColumn]' (diff., need sugar)
proc gtk_tree_view_get_expander_column(self: ptr TTreeView): TransferNone[TTreeViewColumn] {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_expander_column".}
proc get_expander_column*(self: TreeView): TreeViewColumn {.inline.} =
  wrap(gtk_tree_view_get_expander_column(self))
# proc get_expander_column*(self: TreeView): TreeViewColumn {.inline.} =

# gtk_tree_view_get_fixed_height_mode
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'bool' 'bool'
proc gtk_tree_view_get_fixed_height_mode(self: ptr TTreeView): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_fixed_height_mode".}
proc get_fixed_height_mode*(self: TreeView): bool {.inline.} =
  gtk_tree_view_get_fixed_height_mode(self)
# proc get_fixed_height_mode*(self: TreeView): bool {.inline.} =

# gtk_tree_view_get_grid_lines
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'TreeViewGridLines' 'TreeViewGridLines'
proc gtk_tree_view_get_grid_lines(self: ptr TTreeView): TreeViewGridLines {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_grid_lines".}
proc get_grid_lines*(self: TreeView): TreeViewGridLines {.inline.} =
  gtk_tree_view_get_grid_lines(self)
# proc get_grid_lines*(self: TreeView): TreeViewGridLines {.inline.} =

# gtk_tree_view_get_hadjustment
# flags: {isMethod} container: TreeView (deprecated)
# gtk_tree_view_get_headers_clickable
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'bool' 'bool'
proc gtk_tree_view_get_headers_clickable(self: ptr TTreeView): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_headers_clickable".}
proc get_headers_clickable*(self: TreeView): bool {.inline.} =
  gtk_tree_view_get_headers_clickable(self)
# proc get_headers_clickable*(self: TreeView): bool {.inline.} =

# gtk_tree_view_get_headers_visible
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'bool' 'bool'
proc gtk_tree_view_get_headers_visible(self: ptr TTreeView): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_headers_visible".}
proc get_headers_visible*(self: TreeView): bool {.inline.} =
  gtk_tree_view_get_headers_visible(self)
# proc get_headers_visible*(self: TreeView): bool {.inline.} =

# gtk_tree_view_get_hover_expand
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'bool' 'bool'
proc gtk_tree_view_get_hover_expand(self: ptr TTreeView): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_hover_expand".}
proc get_hover_expand*(self: TreeView): bool {.inline.} =
  gtk_tree_view_get_hover_expand(self)
# proc get_hover_expand*(self: TreeView): bool {.inline.} =

# gtk_tree_view_get_hover_selection
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'bool' 'bool'
proc gtk_tree_view_get_hover_selection(self: ptr TTreeView): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_hover_selection".}
proc get_hover_selection*(self: TreeView): bool {.inline.} =
  gtk_tree_view_get_hover_selection(self)
# proc get_hover_selection*(self: TreeView): bool {.inline.} =

# gtk_tree_view_get_level_indentation
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'int32' 'int32'
proc gtk_tree_view_get_level_indentation(self: ptr TTreeView): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_level_indentation".}
proc get_level_indentation*(self: TreeView): int32 {.inline.} =
  gtk_tree_view_get_level_indentation(self)
# proc get_level_indentation*(self: TreeView): int32 {.inline.} =

# gtk_tree_view_get_model
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'TreeModel' 'TransferNone[TTreeModel]' (diff., need sugar)
proc gtk_tree_view_get_model(self: ptr TTreeView): TransferNone[TTreeModel] {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_model".}
proc get_model*(self: TreeView): TreeModel {.inline.} =
  wrap(gtk_tree_view_get_model(self))
# proc get_model*(self: TreeView): TreeModel {.inline.} =

# gtk_tree_view_get_n_columns
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'uint32' 'uint32'
proc gtk_tree_view_get_n_columns(self: ptr TTreeView): uint32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_n_columns".}
proc get_n_columns*(self: TreeView): uint32 {.inline.} =
  gtk_tree_view_get_n_columns(self)
# proc get_n_columns*(self: TreeView): uint32 {.inline.} =

# gtk_tree_view_get_path_at_pos
# flags: {isMethod} container: TreeView
# need sugar: is method
# x 'int32' 'int32' IN
# y 'int32' 'int32' IN
# path 'var TTreePath' 'ptr TTreePath' OUT (diff., need sugar) optional
# column 'var TreeViewColumn' 'ptr TTreeViewColumn' OUT (diff., need sugar) optional
# cell_x 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# cell_y 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'bool' 'bool'
proc gtk_tree_view_get_path_at_pos(self: ptr TTreeView, x: int32, y: int32, path: ptr TTreePath, column: ptr TTreeViewColumn, cell_x: ptr int32, cell_y: ptr int32): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_path_at_pos".}
proc get_path_at_pos*(self: TreeView, x: int32, y: int32, path: var TTreePath, column: var TreeViewColumn, cell_x: var int32, cell_y: var int32): bool {.inline.} =
  gtk_tree_view_get_path_at_pos(self, x, y, addr(path), column.getPointer, addr(cell_x), addr(cell_y))
# tuple-return
# path: var TTreePath
# column: var TreeViewColumn
# cell_x: var int32
# cell_y: var int32
# proc get_path_at_pos*(self: TreeView, x: int32, y: int32): bool {.inline.} =

# gtk_tree_view_get_reorderable
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'bool' 'bool'
proc gtk_tree_view_get_reorderable(self: ptr TTreeView): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_reorderable".}
proc get_reorderable*(self: TreeView): bool {.inline.} =
  gtk_tree_view_get_reorderable(self)
# proc get_reorderable*(self: TreeView): bool {.inline.} =

# gtk_tree_view_get_rubber_banding
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'bool' 'bool'
proc gtk_tree_view_get_rubber_banding(self: ptr TTreeView): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_rubber_banding".}
proc get_rubber_banding*(self: TreeView): bool {.inline.} =
  gtk_tree_view_get_rubber_banding(self)
# proc get_rubber_banding*(self: TreeView): bool {.inline.} =

# gtk_tree_view_get_rules_hint
# flags: {isMethod} container: TreeView (deprecated)
# gtk_tree_view_get_search_column
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'int32' 'int32'
proc gtk_tree_view_get_search_column(self: ptr TTreeView): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_search_column".}
proc get_search_column*(self: TreeView): int32 {.inline.} =
  gtk_tree_view_get_search_column(self)
# proc get_search_column*(self: TreeView): int32 {.inline.} =

# gtk_tree_view_get_search_entry
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'Entry' 'TransferNone[TEntry]' (diff., need sugar)
proc gtk_tree_view_get_search_entry(self: ptr TTreeView): TransferNone[TEntry] {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_search_entry".}
proc get_search_entry*(self: TreeView): Entry {.inline.} =
  wrap(gtk_tree_view_get_search_entry(self))
# proc get_search_entry*(self: TreeView): Entry {.inline.} =

# gtk_tree_view_get_selection
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'TreeSelection' 'TransferNone[TTreeSelection]' (diff., need sugar)
proc gtk_tree_view_get_selection(self: ptr TTreeView): TransferNone[TTreeSelection] {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_selection".}
proc get_selection*(self: TreeView): TreeSelection {.inline.} =
  wrap(gtk_tree_view_get_selection(self))
# proc get_selection*(self: TreeView): TreeSelection {.inline.} =

# gtk_tree_view_get_show_expanders
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'bool' 'bool'
proc gtk_tree_view_get_show_expanders(self: ptr TTreeView): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_show_expanders".}
proc get_show_expanders*(self: TreeView): bool {.inline.} =
  gtk_tree_view_get_show_expanders(self)
# proc get_show_expanders*(self: TreeView): bool {.inline.} =

# gtk_tree_view_get_tooltip_column
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'int32' 'int32'
proc gtk_tree_view_get_tooltip_column(self: ptr TTreeView): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_tooltip_column".}
proc get_tooltip_column*(self: TreeView): int32 {.inline.} =
  gtk_tree_view_get_tooltip_column(self)
# proc get_tooltip_column*(self: TreeView): int32 {.inline.} =

# gtk_tree_view_get_tooltip_context
# flags: {isMethod} container: TreeView
# need sugar: is method
# x 'var int32' 'ptr int32' INOUT (diff., need sugar)
# y 'var int32' 'ptr int32' INOUT (diff., need sugar)
# keyboard_tip 'bool' 'bool' IN
# model 'var TreeModel' 'ptr TTreeModel' OUT (diff., need sugar) optional
# path 'var TTreePath' 'ptr TTreePath' OUT (diff., need sugar) optional
# iter 'var TTreeIter' 'ptr TTreeIter' OUT (diff., need sugar) caller-allocates optional
# 'bool' 'bool'
proc gtk_tree_view_get_tooltip_context(self: ptr TTreeView, x: ptr int32, y: ptr int32, keyboard_tip: bool, model: ptr TTreeModel, path: ptr TTreePath, iter: ptr TTreeIter): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_tooltip_context".}
proc get_tooltip_context*(self: TreeView, x: var int32, y: var int32, keyboard_tip: bool, model: var TreeModel, path: var TTreePath, iter: var TTreeIter): bool {.inline.} =
  gtk_tree_view_get_tooltip_context(self, addr(x), addr(y), keyboard_tip, unwrap(model), addr(path), addr(iter))
# tuple-return
# model: var TreeModel
# path: var TTreePath
# iter: var TTreeIter
# proc get_tooltip_context*(self: TreeView, x: var int32, y: var int32, keyboard_tip: bool): bool {.inline.} =

# gtk_tree_view_get_vadjustment
# flags: {isMethod} container: TreeView (deprecated)
# gtk_tree_view_get_visible_range
# flags: {isMethod} container: TreeView
# need sugar: is method
# start_path 'var TTreePath' 'ptr TTreePath' OUT (diff., need sugar) optional
# end_path 'var TTreePath' 'ptr TTreePath' OUT (diff., need sugar) optional
# 'bool' 'bool'
proc gtk_tree_view_get_visible_range(self: ptr TTreeView, start_path: ptr TTreePath, end_path: ptr TTreePath): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_visible_range".}
proc get_visible_range*(self: TreeView, start_path: var TTreePath, end_path: var TTreePath): bool {.inline.} =
  gtk_tree_view_get_visible_range(self, addr(start_path), addr(end_path))
# tuple-return
# start_path: var TTreePath
# end_path: var TTreePath
# proc get_visible_range*(self: TreeView): bool {.inline.} =

# gtk_tree_view_get_visible_rect
# flags: {isMethod} container: TreeView
# need sugar: is method
# visible_rect 'var cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_get_visible_rect(self: ptr TTreeView, visible_rect: ptr cairo1.TRectangleInt) {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_visible_rect".}
proc get_visible_rect*(self: TreeView, visible_rect: var cairo1.TRectangleInt) {.inline.} =
  gtk_tree_view_get_visible_rect(self, addr(visible_rect))
# tuple-return
# visible_rect: var cairo1.TRectangleInt
# proc get_visible_rect*(self: TreeView) {.inline.} =

# gtk_tree_view_insert_column
# flags: {isMethod} container: TreeView
# need sugar: is method
# column 'TreeViewColumn' 'ptr TTreeViewColumn' IN (diff., need sugar)
# position 'int32' 'int32' IN
# 'int32' 'int32'
proc gtk_tree_view_insert_column(self: ptr TTreeView, column: ptr TTreeViewColumn, position: int32): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_insert_column".}
proc insert_column*(self: TreeView, column: TreeViewColumn, position: int32): int32 {.inline.} =
  gtk_tree_view_insert_column(self, column.getPointer, position)
# proc insert_column*(self: TreeView, column: TreeViewColumn, position: int32): int32 {.inline.} =

# gtk_tree_view_insert_column_with_data_func
# flags: {isMethod} container: TreeView
# need sugar: is method
# position 'int32' 'int32' IN
# title 'ustring' 'ucstring' IN (diff., need sugar)
# cell 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# func 'pointer' 'pointer' IN
# data 'pointer' 'pointer' IN
# dnotify 'pointer' 'pointer' IN
# 'int32' 'int32'
proc gtk_tree_view_insert_column_with_data_func(self: ptr TTreeView, position: int32, title: ucstring, cell: ptr TCellRenderer, func_x: pointer, data: pointer, dnotify: pointer): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_insert_column_with_data_func".}
proc insert_column_with_data_func*(self: TreeView, position: int32, title: ustring, cell: CellRenderer, func_x: pointer, data: pointer, dnotify: pointer): int32 {.inline.} =
  gtk_tree_view_insert_column_with_data_func(self, position, ucstring(title), cell.getPointer, func_x, data, dnotify)
# proc insert_column_with_data_func*(self: TreeView, position: int32, title: ustring, cell: CellRenderer, func_x: pointer, data: pointer, dnotify: pointer): int32 {.inline.} =

# gtk_tree_view_is_blank_at_pos
# flags: {isMethod} container: TreeView
# need sugar: is method
# x 'int32' 'int32' IN
# y 'int32' 'int32' IN
# path 'var TTreePath' 'ptr TTreePath' OUT (diff., need sugar) optional
# column 'var TreeViewColumn' 'ptr TTreeViewColumn' OUT (diff., need sugar) optional
# cell_x 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# cell_y 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'bool' 'bool'
proc gtk_tree_view_is_blank_at_pos(self: ptr TTreeView, x: int32, y: int32, path: ptr TTreePath, column: ptr TTreeViewColumn, cell_x: ptr int32, cell_y: ptr int32): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_is_blank_at_pos".}
proc is_blank_at_pos*(self: TreeView, x: int32, y: int32, path: var TTreePath, column: var TreeViewColumn, cell_x: var int32, cell_y: var int32): bool {.inline.} =
  gtk_tree_view_is_blank_at_pos(self, x, y, addr(path), column.getPointer, addr(cell_x), addr(cell_y))
# tuple-return
# path: var TTreePath
# column: var TreeViewColumn
# cell_x: var int32
# cell_y: var int32
# proc is_blank_at_pos*(self: TreeView, x: int32, y: int32): bool {.inline.} =

# gtk_tree_view_is_rubber_banding_active
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'bool' 'bool'
proc gtk_tree_view_is_rubber_banding_active(self: ptr TTreeView): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_is_rubber_banding_active".}
proc is_rubber_banding_active*(self: TreeView): bool {.inline.} =
  gtk_tree_view_is_rubber_banding_active(self)
# proc is_rubber_banding_active*(self: TreeView): bool {.inline.} =

# gtk_tree_view_map_expanded_rows
# flags: {isMethod} container: TreeView
# need sugar: is method
# func 'pointer' 'pointer' IN
# data 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_map_expanded_rows(self: ptr TTreeView, func_x: pointer, data: pointer) {.cdecl, dynlib: lib, importc: "gtk_tree_view_map_expanded_rows".}
proc map_expanded_rows*(self: TreeView, func_x: pointer, data: pointer) {.inline.} =
  gtk_tree_view_map_expanded_rows(self, func_x, data)
# proc map_expanded_rows*(self: TreeView, func_x: pointer, data: pointer) {.inline.} =

# gtk_tree_view_move_column_after
# flags: {isMethod} container: TreeView
# need sugar: is method
# column 'TreeViewColumn' 'ptr TTreeViewColumn' IN (diff., need sugar)
# base_column 'TreeViewColumn' 'ptr TTreeViewColumn' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_move_column_after(self: ptr TTreeView, column: ptr TTreeViewColumn, base_column: ptr TTreeViewColumn) {.cdecl, dynlib: lib, importc: "gtk_tree_view_move_column_after".}
proc move_column_after*(self: TreeView, column: TreeViewColumn, base_column: TreeViewColumn) {.inline.} =
  gtk_tree_view_move_column_after(self, column.getPointer, base_column.getPointer)
# proc move_column_after*(self: TreeView, column: TreeViewColumn, base_column: TreeViewColumn) {.inline.} =

# gtk_tree_view_remove_column
# flags: {isMethod} container: TreeView
# need sugar: is method
# column 'TreeViewColumn' 'ptr TTreeViewColumn' IN (diff., need sugar)
# 'int32' 'int32'
proc gtk_tree_view_remove_column(self: ptr TTreeView, column: ptr TTreeViewColumn): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_remove_column".}
proc remove_column*(self: TreeView, column: TreeViewColumn): int32 {.inline.} =
  gtk_tree_view_remove_column(self, column.getPointer)
# proc remove_column*(self: TreeView, column: TreeViewColumn): int32 {.inline.} =

# gtk_tree_view_row_activated
# flags: {isMethod} container: TreeView
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# column 'TreeViewColumn' 'ptr TTreeViewColumn' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_row_activated(self: ptr TTreeView, path: ptr TTreePath, column: ptr TTreeViewColumn) {.cdecl, dynlib: lib, importc: "gtk_tree_view_row_activated".}
proc row_activated*(self: TreeView, path: TTreePath, column: TreeViewColumn) {.inline.} =
  gtk_tree_view_row_activated(self, myUnsafeAddr(path), column.getPointer)
# proc row_activated*(self: TreeView, path: TTreePath, column: TreeViewColumn) {.inline.} =

# gtk_tree_view_row_expanded
# flags: {isMethod} container: TreeView
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_tree_view_row_expanded(self: ptr TTreeView, path: ptr TTreePath): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_row_expanded".}
proc row_expanded*(self: TreeView, path: TTreePath): bool {.inline.} =
  gtk_tree_view_row_expanded(self, myUnsafeAddr(path))
# proc row_expanded*(self: TreeView, path: TTreePath): bool {.inline.} =

# gtk_tree_view_scroll_to_cell
# flags: {isMethod} container: TreeView
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# column 'TreeViewColumn' 'ptr TTreeViewColumn' IN (diff., need sugar)
# use_align 'bool' 'bool' IN
# row_align 'float32' 'float32' IN
# col_align 'float32' 'float32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_scroll_to_cell(self: ptr TTreeView, path: ptr TTreePath, column: ptr TTreeViewColumn, use_align: bool, row_align: float32, col_align: float32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_scroll_to_cell".}
proc scroll_to_cell*(self: TreeView, path: TTreePath, column: TreeViewColumn, use_align: bool, row_align: float32, col_align: float32) {.inline.} =
  gtk_tree_view_scroll_to_cell(self, myUnsafeAddr(path), column.getPointer, use_align, row_align, col_align)
# proc scroll_to_cell*(self: TreeView, path: TTreePath, column: TreeViewColumn, use_align: bool, row_align: float32, col_align: float32) {.inline.} =

# gtk_tree_view_scroll_to_point
# flags: {isMethod} container: TreeView
# need sugar: is method
# tree_x 'int32' 'int32' IN
# tree_y 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_scroll_to_point(self: ptr TTreeView, tree_x: int32, tree_y: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_scroll_to_point".}
proc scroll_to_point*(self: TreeView, tree_x: int32, tree_y: int32) {.inline.} =
  gtk_tree_view_scroll_to_point(self, tree_x, tree_y)
# proc scroll_to_point*(self: TreeView, tree_x: int32, tree_y: int32) {.inline.} =

# gtk_tree_view_set_activate_on_single_click
# flags: {isMethod} container: TreeView
# need sugar: is method
# single 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_activate_on_single_click(self: ptr TTreeView, single: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_activate_on_single_click".}
proc set_activate_on_single_click*(self: TreeView, single: bool) {.inline.} =
  gtk_tree_view_set_activate_on_single_click(self, single)
# proc set_activate_on_single_click*(self: TreeView, single: bool) {.inline.} =

# gtk_tree_view_set_column_drag_function
# flags: {isMethod} container: TreeView
# need sugar: is method
# func 'pointer' 'pointer' IN
# user_data 'pointer' 'pointer' IN
# destroy 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_column_drag_function(self: ptr TTreeView, func_x: pointer, user_data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_column_drag_function".}
proc set_column_drag_function*(self: TreeView, func_x: pointer, user_data: pointer, destroy: pointer) {.inline.} =
  gtk_tree_view_set_column_drag_function(self, func_x, user_data, destroy)
# proc set_column_drag_function*(self: TreeView, func_x: pointer, user_data: pointer, destroy: pointer) {.inline.} =

# gtk_tree_view_set_cursor
# flags: {isMethod} container: TreeView
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# focus_column 'TreeViewColumn' 'ptr TTreeViewColumn' IN (diff., need sugar)
# start_editing 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_cursor(self: ptr TTreeView, path: ptr TTreePath, focus_column: ptr TTreeViewColumn, start_editing: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_cursor".}
proc set_cursor*(self: TreeView, path: TTreePath, focus_column: TreeViewColumn, start_editing: bool) {.inline.} =
  gtk_tree_view_set_cursor(self, myUnsafeAddr(path), focus_column.getPointer, start_editing)
# proc set_cursor*(self: TreeView, path: TTreePath, focus_column: TreeViewColumn, start_editing: bool) {.inline.} =

# gtk_tree_view_set_cursor_on_cell
# flags: {isMethod} container: TreeView
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# focus_column 'TreeViewColumn' 'ptr TTreeViewColumn' IN (diff., need sugar)
# focus_cell 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# start_editing 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_cursor_on_cell(self: ptr TTreeView, path: ptr TTreePath, focus_column: ptr TTreeViewColumn, focus_cell: ptr TCellRenderer, start_editing: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_cursor_on_cell".}
proc set_cursor_on_cell*(self: TreeView, path: TTreePath, focus_column: TreeViewColumn, focus_cell: CellRenderer, start_editing: bool) {.inline.} =
  gtk_tree_view_set_cursor_on_cell(self, myUnsafeAddr(path), focus_column.getPointer, focus_cell.getPointer, start_editing)
# proc set_cursor_on_cell*(self: TreeView, path: TTreePath, focus_column: TreeViewColumn, focus_cell: CellRenderer, start_editing: bool) {.inline.} =

# gtk_tree_view_set_destroy_count_func
# flags: {isMethod} container: TreeView (deprecated)
# gtk_tree_view_set_drag_dest_row
# flags: {isMethod} container: TreeView
# need sugar: is method
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# pos 'TreeViewDropPosition' 'TreeViewDropPosition' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_drag_dest_row(self: ptr TTreeView, path: ptr TTreePath, pos: TreeViewDropPosition) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_drag_dest_row".}
proc set_drag_dest_row*(self: TreeView, path: TTreePath, pos: TreeViewDropPosition) {.inline.} =
  gtk_tree_view_set_drag_dest_row(self, myUnsafeAddr(path), pos)
# proc set_drag_dest_row*(self: TreeView, path: TTreePath, pos: TreeViewDropPosition) {.inline.} =

# gtk_tree_view_set_enable_search
# flags: {isMethod} container: TreeView
# need sugar: is method
# enable_search 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_enable_search(self: ptr TTreeView, enable_search: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_enable_search".}
proc set_enable_search*(self: TreeView, enable_search: bool) {.inline.} =
  gtk_tree_view_set_enable_search(self, enable_search)
# proc set_enable_search*(self: TreeView, enable_search: bool) {.inline.} =

# gtk_tree_view_set_enable_tree_lines
# flags: {isMethod} container: TreeView
# need sugar: is method
# enabled 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_enable_tree_lines(self: ptr TTreeView, enabled: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_enable_tree_lines".}
proc set_enable_tree_lines*(self: TreeView, enabled: bool) {.inline.} =
  gtk_tree_view_set_enable_tree_lines(self, enabled)
# proc set_enable_tree_lines*(self: TreeView, enabled: bool) {.inline.} =

# gtk_tree_view_set_expander_column
# flags: {isMethod} container: TreeView
# need sugar: is method
# column 'TreeViewColumn' 'ptr TTreeViewColumn' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_expander_column(self: ptr TTreeView, column: ptr TTreeViewColumn) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_expander_column".}
proc set_expander_column*(self: TreeView, column: TreeViewColumn) {.inline.} =
  gtk_tree_view_set_expander_column(self, column.getPointer)
# proc set_expander_column*(self: TreeView, column: TreeViewColumn) {.inline.} =

# gtk_tree_view_set_fixed_height_mode
# flags: {isMethod} container: TreeView
# need sugar: is method
# enable 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_fixed_height_mode(self: ptr TTreeView, enable: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_fixed_height_mode".}
proc set_fixed_height_mode*(self: TreeView, enable: bool) {.inline.} =
  gtk_tree_view_set_fixed_height_mode(self, enable)
# proc set_fixed_height_mode*(self: TreeView, enable: bool) {.inline.} =

# gtk_tree_view_set_grid_lines
# flags: {isMethod} container: TreeView
# need sugar: is method
# grid_lines 'TreeViewGridLines' 'TreeViewGridLines' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_grid_lines(self: ptr TTreeView, grid_lines: TreeViewGridLines) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_grid_lines".}
proc set_grid_lines*(self: TreeView, grid_lines: TreeViewGridLines) {.inline.} =
  gtk_tree_view_set_grid_lines(self, grid_lines)
# proc set_grid_lines*(self: TreeView, grid_lines: TreeViewGridLines) {.inline.} =

# gtk_tree_view_set_hadjustment
# flags: {isMethod} container: TreeView (deprecated)
# gtk_tree_view_set_headers_clickable
# flags: {isMethod} container: TreeView
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_headers_clickable(self: ptr TTreeView, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_headers_clickable".}
proc set_headers_clickable*(self: TreeView, setting: bool) {.inline.} =
  gtk_tree_view_set_headers_clickable(self, setting)
# proc set_headers_clickable*(self: TreeView, setting: bool) {.inline.} =

# gtk_tree_view_set_headers_visible
# flags: {isMethod} container: TreeView
# need sugar: is method
# headers_visible 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_headers_visible(self: ptr TTreeView, headers_visible: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_headers_visible".}
proc set_headers_visible*(self: TreeView, headers_visible: bool) {.inline.} =
  gtk_tree_view_set_headers_visible(self, headers_visible)
# proc set_headers_visible*(self: TreeView, headers_visible: bool) {.inline.} =

# gtk_tree_view_set_hover_expand
# flags: {isMethod} container: TreeView
# need sugar: is method
# expand 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_hover_expand(self: ptr TTreeView, expand: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_hover_expand".}
proc set_hover_expand*(self: TreeView, expand: bool) {.inline.} =
  gtk_tree_view_set_hover_expand(self, expand)
# proc set_hover_expand*(self: TreeView, expand: bool) {.inline.} =

# gtk_tree_view_set_hover_selection
# flags: {isMethod} container: TreeView
# need sugar: is method
# hover 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_hover_selection(self: ptr TTreeView, hover: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_hover_selection".}
proc set_hover_selection*(self: TreeView, hover: bool) {.inline.} =
  gtk_tree_view_set_hover_selection(self, hover)
# proc set_hover_selection*(self: TreeView, hover: bool) {.inline.} =

# gtk_tree_view_set_level_indentation
# flags: {isMethod} container: TreeView
# need sugar: is method
# indentation 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_level_indentation(self: ptr TTreeView, indentation: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_level_indentation".}
proc set_level_indentation*(self: TreeView, indentation: int32) {.inline.} =
  gtk_tree_view_set_level_indentation(self, indentation)
# proc set_level_indentation*(self: TreeView, indentation: int32) {.inline.} =

# gtk_tree_view_set_model
# flags: {isMethod} container: TreeView
# need sugar: is method
# model 'TreeModel' 'ptr TTreeModel' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_model(self: ptr TTreeView, model: ptr TTreeModel) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_model".}
proc set_model*(self: TreeView, model: TreeModel) {.inline.} =
  gtk_tree_view_set_model(self, unwrap(model))
# proc set_model*(self: TreeView, model: TreeModel) {.inline.} =

# gtk_tree_view_set_reorderable
# flags: {isMethod} container: TreeView
# need sugar: is method
# reorderable 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_reorderable(self: ptr TTreeView, reorderable: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_reorderable".}
proc set_reorderable*(self: TreeView, reorderable: bool) {.inline.} =
  gtk_tree_view_set_reorderable(self, reorderable)
# proc set_reorderable*(self: TreeView, reorderable: bool) {.inline.} =

# gtk_tree_view_set_row_separator_func
# flags: {isMethod} container: TreeView
# need sugar: is method
# func 'pointer' 'pointer' IN
# data 'pointer' 'pointer' IN
# destroy 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_row_separator_func(self: ptr TTreeView, func_x: pointer, data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_row_separator_func".}
proc set_row_separator_func*(self: TreeView, func_x: pointer, data: pointer, destroy: pointer) {.inline.} =
  gtk_tree_view_set_row_separator_func(self, func_x, data, destroy)
# proc set_row_separator_func*(self: TreeView, func_x: pointer, data: pointer, destroy: pointer) {.inline.} =

# gtk_tree_view_set_rubber_banding
# flags: {isMethod} container: TreeView
# need sugar: is method
# enable 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_rubber_banding(self: ptr TTreeView, enable: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_rubber_banding".}
proc set_rubber_banding*(self: TreeView, enable: bool) {.inline.} =
  gtk_tree_view_set_rubber_banding(self, enable)
# proc set_rubber_banding*(self: TreeView, enable: bool) {.inline.} =

# gtk_tree_view_set_rules_hint
# flags: {isMethod} container: TreeView (deprecated)
# gtk_tree_view_set_search_column
# flags: {isMethod} container: TreeView
# need sugar: is method
# column 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_search_column(self: ptr TTreeView, column: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_search_column".}
proc set_search_column*(self: TreeView, column: int32) {.inline.} =
  gtk_tree_view_set_search_column(self, column)
# proc set_search_column*(self: TreeView, column: int32) {.inline.} =

# gtk_tree_view_set_search_entry
# flags: {isMethod} container: TreeView
# need sugar: is method
# entry 'Entry' 'ptr TEntry' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_search_entry(self: ptr TTreeView, entry: ptr TEntry) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_search_entry".}
proc set_search_entry*(self: TreeView, entry: Entry) {.inline.} =
  gtk_tree_view_set_search_entry(self, entry.getPointer)
# proc set_search_entry*(self: TreeView, entry: Entry) {.inline.} =

# gtk_tree_view_set_search_equal_func
# flags: {isMethod} container: TreeView
# need sugar: is method
# search_equal_func 'pointer' 'pointer' IN
# search_user_data 'pointer' 'pointer' IN
# search_destroy 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_search_equal_func(self: ptr TTreeView, search_equal_func: pointer, search_user_data: pointer, search_destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_search_equal_func".}
proc set_search_equal_func*(self: TreeView, search_equal_func: pointer, search_user_data: pointer, search_destroy: pointer) {.inline.} =
  gtk_tree_view_set_search_equal_func(self, search_equal_func, search_user_data, search_destroy)
# proc set_search_equal_func*(self: TreeView, search_equal_func: pointer, search_user_data: pointer, search_destroy: pointer) {.inline.} =

# gtk_tree_view_set_search_position_func
# flags: {isMethod} container: TreeView
# need sugar: is method
# func 'pointer' 'pointer' IN
# data 'pointer' 'pointer' IN
# destroy 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_search_position_func(self: ptr TTreeView, func_x: pointer, data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_search_position_func".}
proc set_search_position_func*(self: TreeView, func_x: pointer, data: pointer, destroy: pointer) {.inline.} =
  gtk_tree_view_set_search_position_func(self, func_x, data, destroy)
# proc set_search_position_func*(self: TreeView, func_x: pointer, data: pointer, destroy: pointer) {.inline.} =

# gtk_tree_view_set_show_expanders
# flags: {isMethod} container: TreeView
# need sugar: is method
# enabled 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_show_expanders(self: ptr TTreeView, enabled: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_show_expanders".}
proc set_show_expanders*(self: TreeView, enabled: bool) {.inline.} =
  gtk_tree_view_set_show_expanders(self, enabled)
# proc set_show_expanders*(self: TreeView, enabled: bool) {.inline.} =

# gtk_tree_view_set_tooltip_cell
# flags: {isMethod} container: TreeView
# need sugar: is method
# tooltip 'Tooltip' 'ptr TTooltip' IN (diff., need sugar)
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# column 'TreeViewColumn' 'ptr TTreeViewColumn' IN (diff., need sugar)
# cell 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_tooltip_cell(self: ptr TTreeView, tooltip: ptr TTooltip, path: ptr TTreePath, column: ptr TTreeViewColumn, cell: ptr TCellRenderer) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_tooltip_cell".}
proc set_tooltip_cell*(self: TreeView, tooltip: Tooltip, path: TTreePath, column: TreeViewColumn, cell: CellRenderer) {.inline.} =
  gtk_tree_view_set_tooltip_cell(self, tooltip.getPointer, myUnsafeAddr(path), column.getPointer, cell.getPointer)
# proc set_tooltip_cell*(self: TreeView, tooltip: Tooltip, path: TTreePath, column: TreeViewColumn, cell: CellRenderer) {.inline.} =

# gtk_tree_view_set_tooltip_column
# flags: {isMethod} container: TreeView
# need sugar: is method
# column 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_tooltip_column(self: ptr TTreeView, column: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_tooltip_column".}
proc set_tooltip_column*(self: TreeView, column: int32) {.inline.} =
  gtk_tree_view_set_tooltip_column(self, column)
# proc set_tooltip_column*(self: TreeView, column: int32) {.inline.} =

# gtk_tree_view_set_tooltip_row
# flags: {isMethod} container: TreeView
# need sugar: is method
# tooltip 'Tooltip' 'ptr TTooltip' IN (diff., need sugar)
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_tooltip_row(self: ptr TTreeView, tooltip: ptr TTooltip, path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_tooltip_row".}
proc set_tooltip_row*(self: TreeView, tooltip: Tooltip, path: TTreePath) {.inline.} =
  gtk_tree_view_set_tooltip_row(self, tooltip.getPointer, myUnsafeAddr(path))
# proc set_tooltip_row*(self: TreeView, tooltip: Tooltip, path: TTreePath) {.inline.} =

# gtk_tree_view_set_vadjustment
# flags: {isMethod} container: TreeView (deprecated)
# gtk_tree_view_unset_rows_drag_dest
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_unset_rows_drag_dest(self: ptr TTreeView) {.cdecl, dynlib: lib, importc: "gtk_tree_view_unset_rows_drag_dest".}
proc unset_rows_drag_dest*(self: TreeView) {.inline.} =
  gtk_tree_view_unset_rows_drag_dest(self)
# proc unset_rows_drag_dest*(self: TreeView) {.inline.} =

# gtk_tree_view_unset_rows_drag_source
# flags: {isMethod} container: TreeView
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_unset_rows_drag_source(self: ptr TTreeView) {.cdecl, dynlib: lib, importc: "gtk_tree_view_unset_rows_drag_source".}
proc unset_rows_drag_source*(self: TreeView) {.inline.} =
  gtk_tree_view_unset_rows_drag_source(self)
# proc unset_rows_drag_source*(self: TreeView) {.inline.} =

# gtk_tree_view_column_new
# flags: {isConstructor} container: TreeViewColumn
# need sugar: is static method
# 'TreeViewColumn' 'TransferNone[TTreeViewColumn]' (diff., need sugar)
proc gtk_tree_view_column_new(): TransferNone[TTreeViewColumn] {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_new".}
proc new_treeviewcolumn*(): TreeViewColumn {.inline.} =
  wrap(gtk_tree_view_column_new())
# proc new_treeviewcolumn*(): TreeViewColumn {.inline.} =

# gtk_tree_view_column_new_with_area
# flags: {isConstructor} container: TreeViewColumn
# need sugar: is static method
# area 'CellArea' 'ptr TCellArea' IN (diff., need sugar)
# 'TreeViewColumn' 'TransferNone[TTreeViewColumn]' (diff., need sugar)
proc gtk_tree_view_column_new_with_area(area: ptr TCellArea): TransferNone[TTreeViewColumn] {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_new_with_area".}
proc new_treeviewcolumn_with_area*(area: CellArea): TreeViewColumn {.inline.} =
  wrap(gtk_tree_view_column_new_with_area(area.getPointer))
# proc new_treeviewcolumn_with_area*(area: CellArea): TreeViewColumn {.inline.} =

# gtk_tree_view_column_add_attribute
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# cell_renderer 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# attribute 'ustring' 'ucstring' IN (diff., need sugar)
# column 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_add_attribute(self: ptr TTreeViewColumn, cell_renderer: ptr TCellRenderer, attribute: ucstring, column: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_add_attribute".}
proc add_attribute*(self: TreeViewColumn, cell_renderer: CellRenderer, attribute: ustring, column: int32) {.inline.} =
  gtk_tree_view_column_add_attribute(self, cell_renderer.getPointer, ucstring(attribute), column)
# proc add_attribute*(self: TreeViewColumn, cell_renderer: CellRenderer, attribute: ustring, column: int32) {.inline.} =

# gtk_tree_view_column_cell_get_position
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# cell_renderer 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# x_offset 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# width 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'bool' 'bool'
proc gtk_tree_view_column_cell_get_position(self: ptr TTreeViewColumn, cell_renderer: ptr TCellRenderer, x_offset: ptr int32, width: ptr int32): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_cell_get_position".}
proc cell_get_position*(self: TreeViewColumn, cell_renderer: CellRenderer, x_offset: var int32, width: var int32): bool {.inline.} =
  gtk_tree_view_column_cell_get_position(self, cell_renderer.getPointer, addr(x_offset), addr(width))
# tuple-return
# x_offset: var int32
# width: var int32
# proc cell_get_position*(self: TreeViewColumn, cell_renderer: CellRenderer): bool {.inline.} =

# gtk_tree_view_column_cell_get_size
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# cell_area 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# x_offset 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# y_offset 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# width 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# height 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_cell_get_size(self: ptr TTreeViewColumn, cell_area: ptr cairo1.TRectangleInt, x_offset: ptr int32, y_offset: ptr int32, width: ptr int32, height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_cell_get_size".}
proc cell_get_size*(self: TreeViewColumn, cell_area: cairo1.TRectangleInt, x_offset: var int32, y_offset: var int32, width: var int32, height: var int32) {.inline.} =
  gtk_tree_view_column_cell_get_size(self, myUnsafeAddr(cell_area), addr(x_offset), addr(y_offset), addr(width), addr(height))
# tuple-return
# x_offset: var int32
# y_offset: var int32
# width: var int32
# height: var int32
# proc cell_get_size*(self: TreeViewColumn, cell_area: cairo1.TRectangleInt) {.inline.} =

# gtk_tree_view_column_cell_is_visible
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# 'bool' 'bool'
proc gtk_tree_view_column_cell_is_visible(self: ptr TTreeViewColumn): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_cell_is_visible".}
proc cell_is_visible*(self: TreeViewColumn): bool {.inline.} =
  gtk_tree_view_column_cell_is_visible(self)
# proc cell_is_visible*(self: TreeViewColumn): bool {.inline.} =

# gtk_tree_view_column_cell_set_cell_data
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# tree_model 'TreeModel' 'ptr TTreeModel' IN (diff., need sugar)
# iter 'TTreeIter' 'ptr TTreeIter' IN (diff., need sugar)
# is_expander 'bool' 'bool' IN
# is_expanded 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_cell_set_cell_data(self: ptr TTreeViewColumn, tree_model: ptr TTreeModel, iter: ptr TTreeIter, is_expander: bool, is_expanded: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_cell_set_cell_data".}
proc cell_set_cell_data*(self: TreeViewColumn, tree_model: TreeModel, iter: TTreeIter, is_expander: bool, is_expanded: bool) {.inline.} =
  gtk_tree_view_column_cell_set_cell_data(self, unwrap(tree_model), myUnsafeAddr(iter), is_expander, is_expanded)
# proc cell_set_cell_data*(self: TreeViewColumn, tree_model: TreeModel, iter: TTreeIter, is_expander: bool, is_expanded: bool) {.inline.} =

# gtk_tree_view_column_clear
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_clear(self: ptr TTreeViewColumn) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_clear".}
proc clear*(self: TreeViewColumn) {.inline.} =
  gtk_tree_view_column_clear(self)
# proc clear*(self: TreeViewColumn) {.inline.} =

# gtk_tree_view_column_clear_attributes
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# cell_renderer 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_clear_attributes(self: ptr TTreeViewColumn, cell_renderer: ptr TCellRenderer) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_clear_attributes".}
proc clear_attributes*(self: TreeViewColumn, cell_renderer: CellRenderer) {.inline.} =
  gtk_tree_view_column_clear_attributes(self, cell_renderer.getPointer)
# proc clear_attributes*(self: TreeViewColumn, cell_renderer: CellRenderer) {.inline.} =

# gtk_tree_view_column_clicked
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_clicked(self: ptr TTreeViewColumn) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_clicked".}
proc clicked*(self: TreeViewColumn) {.inline.} =
  gtk_tree_view_column_clicked(self)
# proc clicked*(self: TreeViewColumn) {.inline.} =

# gtk_tree_view_column_focus_cell
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# cell 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_focus_cell(self: ptr TTreeViewColumn, cell: ptr TCellRenderer) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_focus_cell".}
proc focus_cell*(self: TreeViewColumn, cell: CellRenderer) {.inline.} =
  gtk_tree_view_column_focus_cell(self, cell.getPointer)
# proc focus_cell*(self: TreeViewColumn, cell: CellRenderer) {.inline.} =

# gtk_tree_view_column_get_alignment
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# 'float32' 'float32'
proc gtk_tree_view_column_get_alignment(self: ptr TTreeViewColumn): float32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_alignment".}
proc get_alignment*(self: TreeViewColumn): float32 {.inline.} =
  gtk_tree_view_column_get_alignment(self)
# proc get_alignment*(self: TreeViewColumn): float32 {.inline.} =

# gtk_tree_view_column_get_button
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_tree_view_column_get_button(self: ptr TTreeViewColumn): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_button".}
proc get_button*(self: TreeViewColumn): Widget {.inline.} =
  wrap(gtk_tree_view_column_get_button(self))
# proc get_button*(self: TreeViewColumn): Widget {.inline.} =

# gtk_tree_view_column_get_clickable
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# 'bool' 'bool'
proc gtk_tree_view_column_get_clickable(self: ptr TTreeViewColumn): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_clickable".}
proc get_clickable*(self: TreeViewColumn): bool {.inline.} =
  gtk_tree_view_column_get_clickable(self)
# proc get_clickable*(self: TreeViewColumn): bool {.inline.} =

# gtk_tree_view_column_get_expand
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# 'bool' 'bool'
proc gtk_tree_view_column_get_expand(self: ptr TTreeViewColumn): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_expand".}
proc get_expand*(self: TreeViewColumn): bool {.inline.} =
  gtk_tree_view_column_get_expand(self)
# proc get_expand*(self: TreeViewColumn): bool {.inline.} =

# gtk_tree_view_column_get_fixed_width
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# 'int32' 'int32'
proc gtk_tree_view_column_get_fixed_width(self: ptr TTreeViewColumn): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_fixed_width".}
proc get_fixed_width*(self: TreeViewColumn): int32 {.inline.} =
  gtk_tree_view_column_get_fixed_width(self)
# proc get_fixed_width*(self: TreeViewColumn): int32 {.inline.} =

# gtk_tree_view_column_get_max_width
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# 'int32' 'int32'
proc gtk_tree_view_column_get_max_width(self: ptr TTreeViewColumn): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_max_width".}
proc get_max_width*(self: TreeViewColumn): int32 {.inline.} =
  gtk_tree_view_column_get_max_width(self)
# proc get_max_width*(self: TreeViewColumn): int32 {.inline.} =

# gtk_tree_view_column_get_min_width
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# 'int32' 'int32'
proc gtk_tree_view_column_get_min_width(self: ptr TTreeViewColumn): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_min_width".}
proc get_min_width*(self: TreeViewColumn): int32 {.inline.} =
  gtk_tree_view_column_get_min_width(self)
# proc get_min_width*(self: TreeViewColumn): int32 {.inline.} =

# gtk_tree_view_column_get_reorderable
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# 'bool' 'bool'
proc gtk_tree_view_column_get_reorderable(self: ptr TTreeViewColumn): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_reorderable".}
proc get_reorderable*(self: TreeViewColumn): bool {.inline.} =
  gtk_tree_view_column_get_reorderable(self)
# proc get_reorderable*(self: TreeViewColumn): bool {.inline.} =

# gtk_tree_view_column_get_resizable
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# 'bool' 'bool'
proc gtk_tree_view_column_get_resizable(self: ptr TTreeViewColumn): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_resizable".}
proc get_resizable*(self: TreeViewColumn): bool {.inline.} =
  gtk_tree_view_column_get_resizable(self)
# proc get_resizable*(self: TreeViewColumn): bool {.inline.} =

# gtk_tree_view_column_get_sizing
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# 'TreeViewColumnSizing' 'TreeViewColumnSizing'
proc gtk_tree_view_column_get_sizing(self: ptr TTreeViewColumn): TreeViewColumnSizing {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_sizing".}
proc get_sizing*(self: TreeViewColumn): TreeViewColumnSizing {.inline.} =
  gtk_tree_view_column_get_sizing(self)
# proc get_sizing*(self: TreeViewColumn): TreeViewColumnSizing {.inline.} =

# gtk_tree_view_column_get_sort_column_id
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# 'int32' 'int32'
proc gtk_tree_view_column_get_sort_column_id(self: ptr TTreeViewColumn): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_sort_column_id".}
proc get_sort_column_id*(self: TreeViewColumn): int32 {.inline.} =
  gtk_tree_view_column_get_sort_column_id(self)
# proc get_sort_column_id*(self: TreeViewColumn): int32 {.inline.} =

# gtk_tree_view_column_get_sort_indicator
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# 'bool' 'bool'
proc gtk_tree_view_column_get_sort_indicator(self: ptr TTreeViewColumn): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_sort_indicator".}
proc get_sort_indicator*(self: TreeViewColumn): bool {.inline.} =
  gtk_tree_view_column_get_sort_indicator(self)
# proc get_sort_indicator*(self: TreeViewColumn): bool {.inline.} =

# gtk_tree_view_column_get_sort_order
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# 'SortType' 'SortType'
proc gtk_tree_view_column_get_sort_order(self: ptr TTreeViewColumn): SortType {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_sort_order".}
proc get_sort_order*(self: TreeViewColumn): SortType {.inline.} =
  gtk_tree_view_column_get_sort_order(self)
# proc get_sort_order*(self: TreeViewColumn): SortType {.inline.} =

# gtk_tree_view_column_get_spacing
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# 'int32' 'int32'
proc gtk_tree_view_column_get_spacing(self: ptr TTreeViewColumn): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_spacing".}
proc get_spacing*(self: TreeViewColumn): int32 {.inline.} =
  gtk_tree_view_column_get_spacing(self)
# proc get_spacing*(self: TreeViewColumn): int32 {.inline.} =

# gtk_tree_view_column_get_title
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_tree_view_column_get_title(self: ptr TTreeViewColumn): ucstring {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_title".}
proc get_title*(self: TreeViewColumn): ustring {.inline.} =
  ustring($(gtk_tree_view_column_get_title(self)))
# proc get_title*(self: TreeViewColumn): ustring {.inline.} =

# gtk_tree_view_column_get_tree_view
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_tree_view_column_get_tree_view(self: ptr TTreeViewColumn): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_tree_view".}
proc get_tree_view*(self: TreeViewColumn): Widget {.inline.} =
  wrap(gtk_tree_view_column_get_tree_view(self))
# proc get_tree_view*(self: TreeViewColumn): Widget {.inline.} =

# gtk_tree_view_column_get_visible
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# 'bool' 'bool'
proc gtk_tree_view_column_get_visible(self: ptr TTreeViewColumn): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_visible".}
proc get_visible*(self: TreeViewColumn): bool {.inline.} =
  gtk_tree_view_column_get_visible(self)
# proc get_visible*(self: TreeViewColumn): bool {.inline.} =

# gtk_tree_view_column_get_widget
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_tree_view_column_get_widget(self: ptr TTreeViewColumn): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_widget".}
proc get_widget*(self: TreeViewColumn): Widget {.inline.} =
  wrap(gtk_tree_view_column_get_widget(self))
# proc get_widget*(self: TreeViewColumn): Widget {.inline.} =

# gtk_tree_view_column_get_width
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# 'int32' 'int32'
proc gtk_tree_view_column_get_width(self: ptr TTreeViewColumn): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_width".}
proc get_width*(self: TreeViewColumn): int32 {.inline.} =
  gtk_tree_view_column_get_width(self)
# proc get_width*(self: TreeViewColumn): int32 {.inline.} =

# gtk_tree_view_column_get_x_offset
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# 'int32' 'int32'
proc gtk_tree_view_column_get_x_offset(self: ptr TTreeViewColumn): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_x_offset".}
proc get_x_offset*(self: TreeViewColumn): int32 {.inline.} =
  gtk_tree_view_column_get_x_offset(self)
# proc get_x_offset*(self: TreeViewColumn): int32 {.inline.} =

# gtk_tree_view_column_pack_end
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# cell 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# expand 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_pack_end(self: ptr TTreeViewColumn, cell: ptr TCellRenderer, expand: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_pack_end".}
proc pack_end*(self: TreeViewColumn, cell: CellRenderer, expand: bool) {.inline.} =
  gtk_tree_view_column_pack_end(self, cell.getPointer, expand)
# proc pack_end*(self: TreeViewColumn, cell: CellRenderer, expand: bool) {.inline.} =

# gtk_tree_view_column_pack_start
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# cell 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# expand 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_pack_start(self: ptr TTreeViewColumn, cell: ptr TCellRenderer, expand: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_pack_start".}
proc pack_start*(self: TreeViewColumn, cell: CellRenderer, expand: bool) {.inline.} =
  gtk_tree_view_column_pack_start(self, cell.getPointer, expand)
# proc pack_start*(self: TreeViewColumn, cell: CellRenderer, expand: bool) {.inline.} =

# gtk_tree_view_column_queue_resize
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_queue_resize(self: ptr TTreeViewColumn) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_queue_resize".}
proc queue_resize*(self: TreeViewColumn) {.inline.} =
  gtk_tree_view_column_queue_resize(self)
# proc queue_resize*(self: TreeViewColumn) {.inline.} =

# gtk_tree_view_column_set_alignment
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# xalign 'float32' 'float32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_alignment(self: ptr TTreeViewColumn, xalign: float32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_alignment".}
proc set_alignment*(self: TreeViewColumn, xalign: float32) {.inline.} =
  gtk_tree_view_column_set_alignment(self, xalign)
# proc set_alignment*(self: TreeViewColumn, xalign: float32) {.inline.} =

# gtk_tree_view_column_set_cell_data_func
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# cell_renderer 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# func 'pointer' 'pointer' IN
# func_data 'pointer' 'pointer' IN
# destroy 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_cell_data_func(self: ptr TTreeViewColumn, cell_renderer: ptr TCellRenderer, func_x: pointer, func_data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_cell_data_func".}
proc set_cell_data_func*(self: TreeViewColumn, cell_renderer: CellRenderer, func_x: pointer, func_data: pointer, destroy: pointer) {.inline.} =
  gtk_tree_view_column_set_cell_data_func(self, cell_renderer.getPointer, func_x, func_data, destroy)
# proc set_cell_data_func*(self: TreeViewColumn, cell_renderer: CellRenderer, func_x: pointer, func_data: pointer, destroy: pointer) {.inline.} =

# gtk_tree_view_column_set_clickable
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# clickable 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_clickable(self: ptr TTreeViewColumn, clickable: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_clickable".}
proc set_clickable*(self: TreeViewColumn, clickable: bool) {.inline.} =
  gtk_tree_view_column_set_clickable(self, clickable)
# proc set_clickable*(self: TreeViewColumn, clickable: bool) {.inline.} =

# gtk_tree_view_column_set_expand
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# expand 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_expand(self: ptr TTreeViewColumn, expand: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_expand".}
proc set_expand*(self: TreeViewColumn, expand: bool) {.inline.} =
  gtk_tree_view_column_set_expand(self, expand)
# proc set_expand*(self: TreeViewColumn, expand: bool) {.inline.} =

# gtk_tree_view_column_set_fixed_width
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# fixed_width 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_fixed_width(self: ptr TTreeViewColumn, fixed_width: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_fixed_width".}
proc set_fixed_width*(self: TreeViewColumn, fixed_width: int32) {.inline.} =
  gtk_tree_view_column_set_fixed_width(self, fixed_width)
# proc set_fixed_width*(self: TreeViewColumn, fixed_width: int32) {.inline.} =

# gtk_tree_view_column_set_max_width
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# max_width 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_max_width(self: ptr TTreeViewColumn, max_width: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_max_width".}
proc set_max_width*(self: TreeViewColumn, max_width: int32) {.inline.} =
  gtk_tree_view_column_set_max_width(self, max_width)
# proc set_max_width*(self: TreeViewColumn, max_width: int32) {.inline.} =

# gtk_tree_view_column_set_min_width
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# min_width 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_min_width(self: ptr TTreeViewColumn, min_width: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_min_width".}
proc set_min_width*(self: TreeViewColumn, min_width: int32) {.inline.} =
  gtk_tree_view_column_set_min_width(self, min_width)
# proc set_min_width*(self: TreeViewColumn, min_width: int32) {.inline.} =

# gtk_tree_view_column_set_reorderable
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# reorderable 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_reorderable(self: ptr TTreeViewColumn, reorderable: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_reorderable".}
proc set_reorderable*(self: TreeViewColumn, reorderable: bool) {.inline.} =
  gtk_tree_view_column_set_reorderable(self, reorderable)
# proc set_reorderable*(self: TreeViewColumn, reorderable: bool) {.inline.} =

# gtk_tree_view_column_set_resizable
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# resizable 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_resizable(self: ptr TTreeViewColumn, resizable: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_resizable".}
proc set_resizable*(self: TreeViewColumn, resizable: bool) {.inline.} =
  gtk_tree_view_column_set_resizable(self, resizable)
# proc set_resizable*(self: TreeViewColumn, resizable: bool) {.inline.} =

# gtk_tree_view_column_set_sizing
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# type 'TreeViewColumnSizing' 'TreeViewColumnSizing' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_sizing(self: ptr TTreeViewColumn, type_x: TreeViewColumnSizing) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_sizing".}
proc set_sizing*(self: TreeViewColumn, type_x: TreeViewColumnSizing) {.inline.} =
  gtk_tree_view_column_set_sizing(self, type_x)
# proc set_sizing*(self: TreeViewColumn, type_x: TreeViewColumnSizing) {.inline.} =

# gtk_tree_view_column_set_sort_column_id
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# sort_column_id 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_sort_column_id(self: ptr TTreeViewColumn, sort_column_id: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_sort_column_id".}
proc set_sort_column_id*(self: TreeViewColumn, sort_column_id: int32) {.inline.} =
  gtk_tree_view_column_set_sort_column_id(self, sort_column_id)
# proc set_sort_column_id*(self: TreeViewColumn, sort_column_id: int32) {.inline.} =

# gtk_tree_view_column_set_sort_indicator
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_sort_indicator(self: ptr TTreeViewColumn, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_sort_indicator".}
proc set_sort_indicator*(self: TreeViewColumn, setting: bool) {.inline.} =
  gtk_tree_view_column_set_sort_indicator(self, setting)
# proc set_sort_indicator*(self: TreeViewColumn, setting: bool) {.inline.} =

# gtk_tree_view_column_set_sort_order
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# order 'SortType' 'SortType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_sort_order(self: ptr TTreeViewColumn, order: SortType) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_sort_order".}
proc set_sort_order*(self: TreeViewColumn, order: SortType) {.inline.} =
  gtk_tree_view_column_set_sort_order(self, order)
# proc set_sort_order*(self: TreeViewColumn, order: SortType) {.inline.} =

# gtk_tree_view_column_set_spacing
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# spacing 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_spacing(self: ptr TTreeViewColumn, spacing: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_spacing".}
proc set_spacing*(self: TreeViewColumn, spacing: int32) {.inline.} =
  gtk_tree_view_column_set_spacing(self, spacing)
# proc set_spacing*(self: TreeViewColumn, spacing: int32) {.inline.} =

# gtk_tree_view_column_set_title
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# title 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_title(self: ptr TTreeViewColumn, title: ucstring) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_title".}
proc set_title*(self: TreeViewColumn, title: ustring) {.inline.} =
  gtk_tree_view_column_set_title(self, ucstring(title))
# proc set_title*(self: TreeViewColumn, title: ustring) {.inline.} =

# gtk_tree_view_column_set_visible
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# visible 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_visible(self: ptr TTreeViewColumn, visible: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_visible".}
proc set_visible*(self: TreeViewColumn, visible: bool) {.inline.} =
  gtk_tree_view_column_set_visible(self, visible)
# proc set_visible*(self: TreeViewColumn, visible: bool) {.inline.} =

# gtk_tree_view_column_set_widget
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_widget(self: ptr TTreeViewColumn, widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_widget".}
proc set_widget*(self: TreeViewColumn, widget: Widget) {.inline.} =
  gtk_tree_view_column_set_widget(self, widget.getPointer)
# proc set_widget*(self: TreeViewColumn, widget: Widget) {.inline.} =

# gtk_ui_manager_new
# flags: {isConstructor} container: UIManager (deprecated)
# gtk_ui_manager_add_ui
# flags: {isMethod} container: UIManager (deprecated)
# gtk_ui_manager_add_ui_from_file
# flags: {isMethod, throws} container: UIManager (deprecated)
# can throw
# gtk_ui_manager_add_ui_from_resource
# flags: {isMethod, throws} container: UIManager (deprecated)
# can throw
# gtk_ui_manager_add_ui_from_string
# flags: {isMethod, throws} container: UIManager (deprecated)
# can throw
# gtk_ui_manager_ensure_update
# flags: {isMethod} container: UIManager (deprecated)
# gtk_ui_manager_get_accel_group
# flags: {isMethod} container: UIManager (deprecated)
# gtk_ui_manager_get_action
# flags: {isMethod} container: UIManager (deprecated)
# gtk_ui_manager_get_action_groups
# flags: {isMethod} container: UIManager (deprecated)
# gtk_ui_manager_get_add_tearoffs
# flags: {isMethod} container: UIManager (deprecated)
# gtk_ui_manager_get_toplevels
# flags: {isMethod} container: UIManager (deprecated)
# gtk_ui_manager_get_ui
# flags: {isMethod} container: UIManager (deprecated)
# gtk_ui_manager_get_widget
# flags: {isMethod} container: UIManager (deprecated)
# gtk_ui_manager_insert_action_group
# flags: {isMethod} container: UIManager (deprecated)
# gtk_ui_manager_new_merge_id
# flags: {isMethod} container: UIManager (deprecated)
# gtk_ui_manager_remove_action_group
# flags: {isMethod} container: UIManager (deprecated)
# gtk_ui_manager_remove_ui
# flags: {isMethod} container: UIManager (deprecated)
# gtk_ui_manager_set_add_tearoffs
# flags: {isMethod} container: UIManager (deprecated)
# gtk_vbox_new
# flags: {isConstructor} container: VBox (deprecated)
# gtk_vbutton_box_new
# flags: {isConstructor} container: VButtonBox (deprecated)
# gtk_vpaned_new
# flags: {isConstructor} container: VPaned (deprecated)
# gtk_vscale_new
# flags: {isConstructor} container: VScale (deprecated)
# gtk_vscale_new_with_range
# flags: {isConstructor} container: VScale (deprecated)
# gtk_vscrollbar_new
# flags: {isConstructor} container: VScrollbar (deprecated)
# gtk_vseparator_new
# flags: {isConstructor} container: VSeparator (deprecated)
# gtk_viewport_new
# flags: {isConstructor} container: Viewport
# need sugar: is static method
# hadjustment 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# vadjustment 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# 'Viewport' 'TransferNone[TViewport]' (diff., need sugar)
proc gtk_viewport_new(hadjustment: ptr TAdjustment, vadjustment: ptr TAdjustment): TransferNone[TViewport] {.cdecl, dynlib: lib, importc: "gtk_viewport_new".}
proc new_viewport*(hadjustment: Adjustment, vadjustment: Adjustment): Viewport {.inline.} =
  wrap(gtk_viewport_new(hadjustment.getPointer, vadjustment.getPointer))
# proc new_viewport*(hadjustment: Adjustment, vadjustment: Adjustment): Viewport {.inline.} =

# gtk_viewport_get_bin_window
# flags: {isMethod} container: Viewport
# need sugar: is method
# 'Gdk3.Window' 'TransferNone[Gdk3.TWindow]' (diff., need sugar)
proc gtk_viewport_get_bin_window(self: ptr TViewport): TransferNone[Gdk3.TWindow] {.cdecl, dynlib: lib, importc: "gtk_viewport_get_bin_window".}
proc get_bin_window*(self: Viewport): Gdk3.Window {.inline.} =
  wrap(gtk_viewport_get_bin_window(self))
# proc get_bin_window*(self: Viewport): Gdk3.Window {.inline.} =

# gtk_viewport_get_hadjustment
# flags: {isMethod} container: Viewport (deprecated)
# gtk_viewport_get_shadow_type
# flags: {isMethod} container: Viewport
# need sugar: is method
# 'ShadowType' 'ShadowType'
proc gtk_viewport_get_shadow_type(self: ptr TViewport): ShadowType {.cdecl, dynlib: lib, importc: "gtk_viewport_get_shadow_type".}
proc get_shadow_type*(self: Viewport): ShadowType {.inline.} =
  gtk_viewport_get_shadow_type(self)
# proc get_shadow_type*(self: Viewport): ShadowType {.inline.} =

# gtk_viewport_get_vadjustment
# flags: {isMethod} container: Viewport (deprecated)
# gtk_viewport_get_view_window
# flags: {isMethod} container: Viewport
# need sugar: is method
# 'Gdk3.Window' 'TransferNone[Gdk3.TWindow]' (diff., need sugar)
proc gtk_viewport_get_view_window(self: ptr TViewport): TransferNone[Gdk3.TWindow] {.cdecl, dynlib: lib, importc: "gtk_viewport_get_view_window".}
proc get_view_window*(self: Viewport): Gdk3.Window {.inline.} =
  wrap(gtk_viewport_get_view_window(self))
# proc get_view_window*(self: Viewport): Gdk3.Window {.inline.} =

# gtk_viewport_set_hadjustment
# flags: {isMethod} container: Viewport (deprecated)
# gtk_viewport_set_shadow_type
# flags: {isMethod} container: Viewport
# need sugar: is method
# type 'ShadowType' 'ShadowType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_viewport_set_shadow_type(self: ptr TViewport, type_x: ShadowType) {.cdecl, dynlib: lib, importc: "gtk_viewport_set_shadow_type".}
proc set_shadow_type*(self: Viewport, type_x: ShadowType) {.inline.} =
  gtk_viewport_set_shadow_type(self, type_x)
# proc set_shadow_type*(self: Viewport, type_x: ShadowType) {.inline.} =

# gtk_viewport_set_vadjustment
# flags: {isMethod} container: Viewport (deprecated)
# gtk_volume_button_new
# flags: {isConstructor} container: VolumeButton
# need sugar: is static method
# 'VolumeButton' 'TransferNone[TVolumeButton]' (diff., need sugar)
proc gtk_volume_button_new(): TransferNone[TVolumeButton] {.cdecl, dynlib: lib, importc: "gtk_volume_button_new".}
proc new_volumebutton*(): VolumeButton {.inline.} =
  wrap(gtk_volume_button_new())
# proc new_volumebutton*(): VolumeButton {.inline.} =

# gtk_widget_get_default_direction
# flags: {} container: Widget
# need sugar: is static method
# 'TextDirection' 'TextDirection'
proc gtk_widget_get_default_direction(): TextDirection {.cdecl, dynlib: lib, importc: "gtk_widget_get_default_direction".}
template get_default_direction*(klass_parameter: typedesc[Widget]): TextDirection =
  gtk_widget_get_default_direction()
# template get_default_direction*(klass_parameter: typedesc[Widget]): TextDirection =

# gtk_widget_get_default_style
# flags: {} container: Widget (deprecated)
# gtk_widget_pop_composite_child
# flags: {} container: Widget (deprecated)
# gtk_widget_push_composite_child
# flags: {} container: Widget (deprecated)
# gtk_widget_set_default_direction
# flags: {} container: Widget
# need sugar: is static method
# dir 'TextDirection' 'TextDirection' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_default_direction(dir: TextDirection) {.cdecl, dynlib: lib, importc: "gtk_widget_set_default_direction".}
template set_default_direction*(klass_parameter: typedesc[Widget], dir: TextDirection) =
  gtk_widget_set_default_direction(dir)
# template set_default_direction*(klass_parameter: typedesc[Widget], dir: TextDirection) =

# gtk_widget_activate
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_activate(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_activate".}
proc activate*(self: Widget): bool {.inline.} =
  gtk_widget_activate(self)
# proc activate*(self: Widget): bool {.inline.} =

# gtk_widget_add_accelerator
# flags: {isMethod} container: Widget
# need sugar: is method
# accel_signal 'ustring' 'ucstring' IN (diff., need sugar)
# accel_group 'AccelGroup' 'ptr TAccelGroup' IN (diff., need sugar)
# accel_key 'uint32' 'uint32' IN
# accel_mods 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# accel_flags 'SAccelFlags' 'SAccelFlags' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_add_accelerator(self: ptr TWidget, accel_signal: ucstring, accel_group: ptr TAccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType, accel_flags: SAccelFlags) {.cdecl, dynlib: lib, importc: "gtk_widget_add_accelerator".}
proc add_accelerator*(self: Widget, accel_signal: ustring, accel_group: AccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType, accel_flags: SAccelFlags) {.inline.} =
  gtk_widget_add_accelerator(self, ucstring(accel_signal), accel_group.getPointer, accel_key, accel_mods, accel_flags)
# proc add_accelerator*(self: Widget, accel_signal: ustring, accel_group: AccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType, accel_flags: SAccelFlags) {.inline.} =

# gtk_widget_add_device_events
# flags: {isMethod} container: Widget
# need sugar: is method
# device 'Gdk3.Device' 'ptr Gdk3.TDevice' IN (diff., need sugar)
# events 'Gdk3.SEventMask' 'Gdk3.SEventMask' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_add_device_events(self: ptr TWidget, device: ptr Gdk3.TDevice, events: Gdk3.SEventMask) {.cdecl, dynlib: lib, importc: "gtk_widget_add_device_events".}
proc add_device_events*(self: Widget, device: Gdk3.Device, events: Gdk3.SEventMask) {.inline.} =
  gtk_widget_add_device_events(self, device.getPointer, events)
# proc add_device_events*(self: Widget, device: Gdk3.Device, events: Gdk3.SEventMask) {.inline.} =

# gtk_widget_add_events
# flags: {isMethod} container: Widget
# need sugar: is method
# events 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_add_events(self: ptr TWidget, events: int32) {.cdecl, dynlib: lib, importc: "gtk_widget_add_events".}
proc add_events*(self: Widget, events: int32) {.inline.} =
  gtk_widget_add_events(self, events)
# proc add_events*(self: Widget, events: int32) {.inline.} =

# gtk_widget_add_mnemonic_label
# flags: {isMethod} container: Widget
# need sugar: is method
# label 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_add_mnemonic_label(self: ptr TWidget, label: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_add_mnemonic_label".}
proc add_mnemonic_label*(self: Widget, label: Widget) {.inline.} =
  gtk_widget_add_mnemonic_label(self, label.getPointer)
# proc add_mnemonic_label*(self: Widget, label: Widget) {.inline.} =

# gtk_widget_add_tick_callback
# flags: {isMethod} container: Widget
# need sugar: is method
# callback 'pointer' 'pointer' IN
# user_data 'pointer' 'pointer' IN
# notify 'pointer' 'pointer' IN
# 'uint32' 'uint32'
proc gtk_widget_add_tick_callback(self: ptr TWidget, callback: pointer, user_data: pointer, notify: pointer): uint32 {.cdecl, dynlib: lib, importc: "gtk_widget_add_tick_callback".}
proc add_tick_callback*(self: Widget, callback: pointer, user_data: pointer, notify: pointer): uint32 {.inline.} =
  gtk_widget_add_tick_callback(self, callback, user_data, notify)
# proc add_tick_callback*(self: Widget, callback: pointer, user_data: pointer, notify: pointer): uint32 {.inline.} =

# gtk_widget_can_activate_accel
# flags: {isMethod} container: Widget
# need sugar: is method
# signal_id 'uint32' 'uint32' IN
# 'bool' 'bool'
proc gtk_widget_can_activate_accel(self: ptr TWidget, signal_id: uint32): bool {.cdecl, dynlib: lib, importc: "gtk_widget_can_activate_accel".}
proc can_activate_accel*(self: Widget, signal_id: uint32): bool {.inline.} =
  gtk_widget_can_activate_accel(self, signal_id)
# proc can_activate_accel*(self: Widget, signal_id: uint32): bool {.inline.} =

# gtk_widget_child_focus
# flags: {isMethod} container: Widget
# need sugar: is method
# direction 'DirectionType' 'DirectionType' IN
# 'bool' 'bool'
proc gtk_widget_child_focus(self: ptr TWidget, direction: DirectionType): bool {.cdecl, dynlib: lib, importc: "gtk_widget_child_focus".}
proc child_focus*(self: Widget, direction: DirectionType): bool {.inline.} =
  gtk_widget_child_focus(self, direction)
# proc child_focus*(self: Widget, direction: DirectionType): bool {.inline.} =

# gtk_widget_child_notify
# flags: {isMethod} container: Widget
# need sugar: is method
# child_property 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_child_notify(self: ptr TWidget, child_property: ucstring) {.cdecl, dynlib: lib, importc: "gtk_widget_child_notify".}
proc child_notify*(self: Widget, child_property: ustring) {.inline.} =
  gtk_widget_child_notify(self, ucstring(child_property))
# proc child_notify*(self: Widget, child_property: ustring) {.inline.} =

# gtk_widget_class_path
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_compute_expand
# flags: {isMethod} container: Widget
# need sugar: is method
# orientation 'Orientation' 'Orientation' IN
# 'bool' 'bool'
proc gtk_widget_compute_expand(self: ptr TWidget, orientation: Orientation): bool {.cdecl, dynlib: lib, importc: "gtk_widget_compute_expand".}
proc compute_expand*(self: Widget, orientation: Orientation): bool {.inline.} =
  gtk_widget_compute_expand(self, orientation)
# proc compute_expand*(self: Widget, orientation: Orientation): bool {.inline.} =

# gtk_widget_create_pango_context
# flags: {isMethod} container: Widget
# need sugar: is method
# 'Pango1.Context' 'TransferFull[Pango1.TContext]' (diff., need sugar)
proc gtk_widget_create_pango_context(self: ptr TWidget): TransferFull[Pango1.TContext] {.cdecl, dynlib: lib, importc: "gtk_widget_create_pango_context".}
proc create_pango_context*(self: Widget): Pango1.Context {.inline.} =
  wrap(gtk_widget_create_pango_context(self))
# proc create_pango_context*(self: Widget): Pango1.Context {.inline.} =

# gtk_widget_create_pango_layout
# flags: {isMethod} container: Widget
# need sugar: is method
# text 'ustring' 'ucstring' IN (diff., need sugar)
# 'Pango1.Layout' 'TransferFull[Pango1.TLayout]' (diff., need sugar)
proc gtk_widget_create_pango_layout(self: ptr TWidget, text: ucstring): TransferFull[Pango1.TLayout] {.cdecl, dynlib: lib, importc: "gtk_widget_create_pango_layout".}
proc create_pango_layout*(self: Widget, text: ustring): Pango1.Layout {.inline.} =
  wrap(gtk_widget_create_pango_layout(self, ucstring(text)))
# proc create_pango_layout*(self: Widget, text: ustring): Pango1.Layout {.inline.} =

# gtk_widget_destroy
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_destroy(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_destroy".}
proc destroy*(self: Widget) {.inline.} =
  gtk_widget_destroy(self)
# proc destroy*(self: Widget) {.inline.} =

# gtk_widget_destroyed
# flags: {isMethod} container: Widget
# need sugar: is method
# widget_pointer 'var Widget' 'ptr TWidget' INOUT (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_destroyed(self: ptr TWidget, widget_pointer: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_destroyed".}
proc destroyed*(self: Widget, widget_pointer: var Widget) {.inline.} =
  gtk_widget_destroyed(self, widget_pointer.getPointer)
# proc destroyed*(self: Widget, widget_pointer: var Widget) {.inline.} =

# gtk_widget_device_is_shadowed
# flags: {isMethod} container: Widget
# need sugar: is method
# device 'Gdk3.Device' 'ptr Gdk3.TDevice' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_widget_device_is_shadowed(self: ptr TWidget, device: ptr Gdk3.TDevice): bool {.cdecl, dynlib: lib, importc: "gtk_widget_device_is_shadowed".}
proc device_is_shadowed*(self: Widget, device: Gdk3.Device): bool {.inline.} =
  gtk_widget_device_is_shadowed(self, device.getPointer)
# proc device_is_shadowed*(self: Widget, device: Gdk3.Device): bool {.inline.} =

# gtk_drag_begin
# flags: {isMethod} container: Widget (deprecated)
# gtk_drag_begin_with_coordinates
# flags: {isMethod} container: Widget
# need sugar: is method
# targets 'TTargetList' 'ptr TTargetList' IN (diff., need sugar)
# actions 'Gdk3.SDragAction' 'Gdk3.SDragAction' IN
# button 'int32' 'int32' IN
# event 'Gdk3.TEvent' 'ptr Gdk3.TEvent' IN (diff., need sugar)
# x 'int32' 'int32' IN
# y 'int32' 'int32' IN
# 'Gdk3.DragContext' 'TransferNone[Gdk3.TDragContext]' (diff., need sugar)
proc gtk_drag_begin_with_coordinates(self: ptr TWidget, targets: ptr TTargetList, actions: Gdk3.SDragAction, button: int32, event: ptr Gdk3.TEvent, x: int32, y: int32): TransferNone[Gdk3.TDragContext] {.cdecl, dynlib: lib, importc: "gtk_drag_begin_with_coordinates".}
proc drag_begin_with_coordinates*(self: Widget, targets: TTargetList, actions: Gdk3.SDragAction, button: int32, event: Gdk3.TEvent, x: int32, y: int32): Gdk3.DragContext {.inline.} =
  wrap(gtk_drag_begin_with_coordinates(self, myUnsafeAddr(targets), actions, button, myUnsafeAddr(event), x, y))
# proc drag_begin_with_coordinates*(self: Widget, targets: TTargetList, actions: Gdk3.SDragAction, button: int32, event: Gdk3.TEvent, x: int32, y: int32): Gdk3.DragContext {.inline.} =

# gtk_drag_check_threshold
# flags: {isMethod} container: Widget
# need sugar: is method
# start_x 'int32' 'int32' IN
# start_y 'int32' 'int32' IN
# current_x 'int32' 'int32' IN
# current_y 'int32' 'int32' IN
# 'bool' 'bool'
proc gtk_drag_check_threshold(self: ptr TWidget, start_x: int32, start_y: int32, current_x: int32, current_y: int32): bool {.cdecl, dynlib: lib, importc: "gtk_drag_check_threshold".}
proc drag_check_threshold*(self: Widget, start_x: int32, start_y: int32, current_x: int32, current_y: int32): bool {.inline.} =
  gtk_drag_check_threshold(self, start_x, start_y, current_x, current_y)
# proc drag_check_threshold*(self: Widget, start_x: int32, start_y: int32, current_x: int32, current_y: int32): bool {.inline.} =

# gtk_drag_dest_add_image_targets
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_dest_add_image_targets(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_drag_dest_add_image_targets".}
proc drag_dest_add_image_targets*(self: Widget) {.inline.} =
  gtk_drag_dest_add_image_targets(self)
# proc drag_dest_add_image_targets*(self: Widget) {.inline.} =

# gtk_drag_dest_add_text_targets
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_dest_add_text_targets(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_drag_dest_add_text_targets".}
proc drag_dest_add_text_targets*(self: Widget) {.inline.} =
  gtk_drag_dest_add_text_targets(self)
# proc drag_dest_add_text_targets*(self: Widget) {.inline.} =

# gtk_drag_dest_add_uri_targets
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_dest_add_uri_targets(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_drag_dest_add_uri_targets".}
proc drag_dest_add_uri_targets*(self: Widget) {.inline.} =
  gtk_drag_dest_add_uri_targets(self)
# proc drag_dest_add_uri_targets*(self: Widget) {.inline.} =

# gtk_drag_dest_find_target
# flags: {isMethod} container: Widget
# need sugar: is method
# context 'Gdk3.DragContext' 'ptr Gdk3.TDragContext' IN (diff., need sugar)
# target_list 'TTargetList' 'ptr TTargetList' IN (diff., need sugar)
# 'Gdk3.TAtom' 'ptr Gdk3.TAtom' (diff., need sugar)
proc gtk_drag_dest_find_target(self: ptr TWidget, context: ptr Gdk3.TDragContext, target_list: ptr TTargetList): ptr Gdk3.TAtom {.cdecl, dynlib: lib, importc: "gtk_drag_dest_find_target".}
proc drag_dest_find_target*(self: Widget, context: Gdk3.DragContext, target_list: TTargetList): Gdk3.TAtom {.inline.} =
  (gtk_drag_dest_find_target(self, context.getPointer, myUnsafeAddr(target_list)))[]
# proc drag_dest_find_target*(self: Widget, context: Gdk3.DragContext, target_list: TTargetList): Gdk3.TAtom {.inline.} =

# gtk_drag_dest_get_target_list
# flags: {isMethod} container: Widget
# need sugar: is method
# 'TTargetList' 'ptr TTargetList' (diff., need sugar)
proc gtk_drag_dest_get_target_list(self: ptr TWidget): ptr TTargetList {.cdecl, dynlib: lib, importc: "gtk_drag_dest_get_target_list".}
proc drag_dest_get_target_list*(self: Widget): TTargetList {.inline.} =
  (gtk_drag_dest_get_target_list(self))[]
# proc drag_dest_get_target_list*(self: Widget): TTargetList {.inline.} =

# gtk_drag_dest_get_track_motion
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_drag_dest_get_track_motion(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_drag_dest_get_track_motion".}
proc drag_dest_get_track_motion*(self: Widget): bool {.inline.} =
  gtk_drag_dest_get_track_motion(self)
# proc drag_dest_get_track_motion*(self: Widget): bool {.inline.} =

# gtk_drag_dest_set
# flags: {isMethod} container: Widget
# need sugar: is method
# flags 'SDestDefaults' 'SDestDefaults' IN
# targets 'var openarray[TTargetEntry]' 'openarray[TTargetEntry]' IN (diff., need sugar) array lengthArg: 2
# n_targets 'int32' 'int32' IN
# actions 'Gdk3.SDragAction' 'Gdk3.SDragAction' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_dest_set(self: ptr TWidget, flags: SDestDefaults, targets: openarray[TTargetEntry], n_targets: int32, actions: Gdk3.SDragAction) {.cdecl, dynlib: lib, importc: "gtk_drag_dest_set".}
proc drag_dest_set*(self: Widget, flags: SDestDefaults, targets: var openarray[TTargetEntry], actions: Gdk3.SDragAction) {.inline.} =
  gtk_drag_dest_set(self, flags, targets, targets.len.int32, actions)
# proc drag_dest_set*(self: Widget, flags: SDestDefaults, targets: var openarray[TTargetEntry], actions: Gdk3.SDragAction) {.inline.} =

# gtk_drag_dest_set_proxy
# flags: {isMethod} container: Widget
# need sugar: is method
# proxy_window 'Gdk3.Window' 'ptr Gdk3.TWindow' IN (diff., need sugar)
# protocol 'Gdk3.DragProtocol' 'Gdk3.DragProtocol' IN
# use_coordinates 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_dest_set_proxy(self: ptr TWidget, proxy_window: ptr Gdk3.TWindow, protocol: Gdk3.DragProtocol, use_coordinates: bool) {.cdecl, dynlib: lib, importc: "gtk_drag_dest_set_proxy".}
proc drag_dest_set_proxy*(self: Widget, proxy_window: Gdk3.Window, protocol: Gdk3.DragProtocol, use_coordinates: bool) {.inline.} =
  gtk_drag_dest_set_proxy(self, proxy_window.getPointer, protocol, use_coordinates)
# proc drag_dest_set_proxy*(self: Widget, proxy_window: Gdk3.Window, protocol: Gdk3.DragProtocol, use_coordinates: bool) {.inline.} =

# gtk_drag_dest_set_target_list
# flags: {isMethod} container: Widget
# need sugar: is method
# target_list 'TTargetList' 'ptr TTargetList' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_dest_set_target_list(self: ptr TWidget, target_list: ptr TTargetList) {.cdecl, dynlib: lib, importc: "gtk_drag_dest_set_target_list".}
proc drag_dest_set_target_list*(self: Widget, target_list: TTargetList) {.inline.} =
  gtk_drag_dest_set_target_list(self, myUnsafeAddr(target_list))
# proc drag_dest_set_target_list*(self: Widget, target_list: TTargetList) {.inline.} =

# gtk_drag_dest_set_track_motion
# flags: {isMethod} container: Widget
# need sugar: is method
# track_motion 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_dest_set_track_motion(self: ptr TWidget, track_motion: bool) {.cdecl, dynlib: lib, importc: "gtk_drag_dest_set_track_motion".}
proc drag_dest_set_track_motion*(self: Widget, track_motion: bool) {.inline.} =
  gtk_drag_dest_set_track_motion(self, track_motion)
# proc drag_dest_set_track_motion*(self: Widget, track_motion: bool) {.inline.} =

# gtk_drag_dest_unset
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_dest_unset(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_drag_dest_unset".}
proc drag_dest_unset*(self: Widget) {.inline.} =
  gtk_drag_dest_unset(self)
# proc drag_dest_unset*(self: Widget) {.inline.} =

# gtk_drag_get_data
# flags: {isMethod} container: Widget
# need sugar: is method
# context 'Gdk3.DragContext' 'ptr Gdk3.TDragContext' IN (diff., need sugar)
# target 'Gdk3.TAtom' 'ptr Gdk3.TAtom' IN (diff., need sugar)
# time_ 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_get_data(self: ptr TWidget, context: ptr Gdk3.TDragContext, target: ptr Gdk3.TAtom, time_x: uint32) {.cdecl, dynlib: lib, importc: "gtk_drag_get_data".}
proc drag_get_data*(self: Widget, context: Gdk3.DragContext, target: Gdk3.TAtom, time_x: uint32) {.inline.} =
  gtk_drag_get_data(self, context.getPointer, myUnsafeAddr(target), time_x)
# proc drag_get_data*(self: Widget, context: Gdk3.DragContext, target: Gdk3.TAtom, time_x: uint32) {.inline.} =

# gtk_drag_highlight
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_highlight(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_drag_highlight".}
proc drag_highlight*(self: Widget) {.inline.} =
  gtk_drag_highlight(self)
# proc drag_highlight*(self: Widget) {.inline.} =

# gtk_drag_source_add_image_targets
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_source_add_image_targets(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_drag_source_add_image_targets".}
proc drag_source_add_image_targets*(self: Widget) {.inline.} =
  gtk_drag_source_add_image_targets(self)
# proc drag_source_add_image_targets*(self: Widget) {.inline.} =

# gtk_drag_source_add_text_targets
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_source_add_text_targets(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_drag_source_add_text_targets".}
proc drag_source_add_text_targets*(self: Widget) {.inline.} =
  gtk_drag_source_add_text_targets(self)
# proc drag_source_add_text_targets*(self: Widget) {.inline.} =

# gtk_drag_source_add_uri_targets
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_source_add_uri_targets(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_drag_source_add_uri_targets".}
proc drag_source_add_uri_targets*(self: Widget) {.inline.} =
  gtk_drag_source_add_uri_targets(self)
# proc drag_source_add_uri_targets*(self: Widget) {.inline.} =

# gtk_drag_source_get_target_list
# flags: {isMethod} container: Widget
# need sugar: is method
# 'TTargetList' 'ptr TTargetList' (diff., need sugar)
proc gtk_drag_source_get_target_list(self: ptr TWidget): ptr TTargetList {.cdecl, dynlib: lib, importc: "gtk_drag_source_get_target_list".}
proc drag_source_get_target_list*(self: Widget): TTargetList {.inline.} =
  (gtk_drag_source_get_target_list(self))[]
# proc drag_source_get_target_list*(self: Widget): TTargetList {.inline.} =

# gtk_drag_source_set
# flags: {isMethod} container: Widget
# need sugar: is method
# start_button_mask 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# targets 'var openarray[TTargetEntry]' 'openarray[TTargetEntry]' IN (diff., need sugar) array lengthArg: 2
# n_targets 'int32' 'int32' IN
# actions 'Gdk3.SDragAction' 'Gdk3.SDragAction' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_source_set(self: ptr TWidget, start_button_mask: Gdk3.SModifierType, targets: openarray[TTargetEntry], n_targets: int32, actions: Gdk3.SDragAction) {.cdecl, dynlib: lib, importc: "gtk_drag_source_set".}
proc drag_source_set*(self: Widget, start_button_mask: Gdk3.SModifierType, targets: var openarray[TTargetEntry], actions: Gdk3.SDragAction) {.inline.} =
  gtk_drag_source_set(self, start_button_mask, targets, targets.len.int32, actions)
# proc drag_source_set*(self: Widget, start_button_mask: Gdk3.SModifierType, targets: var openarray[TTargetEntry], actions: Gdk3.SDragAction) {.inline.} =

# gtk_drag_source_set_icon_gicon
# flags: {isMethod} container: Widget
# need sugar: is method
# icon 'Gio2.Icon' 'ptr Gio2.TIcon' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_source_set_icon_gicon(self: ptr TWidget, icon: ptr Gio2.TIcon) {.cdecl, dynlib: lib, importc: "gtk_drag_source_set_icon_gicon".}
proc drag_source_set_icon_gicon*(self: Widget, icon: Gio2.Icon) {.inline.} =
  gtk_drag_source_set_icon_gicon(self, unwrap(icon))
# proc drag_source_set_icon_gicon*(self: Widget, icon: Gio2.Icon) {.inline.} =

# gtk_drag_source_set_icon_name
# flags: {isMethod} container: Widget
# need sugar: is method
# icon_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_source_set_icon_name(self: ptr TWidget, icon_name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_drag_source_set_icon_name".}
proc drag_source_set_icon_name*(self: Widget, icon_name: ustring) {.inline.} =
  gtk_drag_source_set_icon_name(self, ucstring(icon_name))
# proc drag_source_set_icon_name*(self: Widget, icon_name: ustring) {.inline.} =

# gtk_drag_source_set_icon_pixbuf
# flags: {isMethod} container: Widget
# need sugar: is method
# pixbuf 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_source_set_icon_pixbuf(self: ptr TWidget, pixbuf: ptr GdkPixbuf2.TPixbuf) {.cdecl, dynlib: lib, importc: "gtk_drag_source_set_icon_pixbuf".}
proc drag_source_set_icon_pixbuf*(self: Widget, pixbuf: GdkPixbuf2.Pixbuf) {.inline.} =
  gtk_drag_source_set_icon_pixbuf(self, pixbuf.getPointer)
# proc drag_source_set_icon_pixbuf*(self: Widget, pixbuf: GdkPixbuf2.Pixbuf) {.inline.} =

# gtk_drag_source_set_icon_stock
# flags: {isMethod} container: Widget (deprecated)
# gtk_drag_source_set_target_list
# flags: {isMethod} container: Widget
# need sugar: is method
# target_list 'TTargetList' 'ptr TTargetList' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_source_set_target_list(self: ptr TWidget, target_list: ptr TTargetList) {.cdecl, dynlib: lib, importc: "gtk_drag_source_set_target_list".}
proc drag_source_set_target_list*(self: Widget, target_list: TTargetList) {.inline.} =
  gtk_drag_source_set_target_list(self, myUnsafeAddr(target_list))
# proc drag_source_set_target_list*(self: Widget, target_list: TTargetList) {.inline.} =

# gtk_drag_source_unset
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_source_unset(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_drag_source_unset".}
proc drag_source_unset*(self: Widget) {.inline.} =
  gtk_drag_source_unset(self)
# proc drag_source_unset*(self: Widget) {.inline.} =

# gtk_drag_unhighlight
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_unhighlight(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_drag_unhighlight".}
proc drag_unhighlight*(self: Widget) {.inline.} =
  gtk_drag_unhighlight(self)
# proc drag_unhighlight*(self: Widget) {.inline.} =

# gtk_widget_draw
# flags: {isMethod} container: Widget
# need sugar: is method
# cr 'cairo1.TContext' 'ptr cairo1.TContext' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_draw(self: ptr TWidget, cr: ptr cairo1.TContext) {.cdecl, dynlib: lib, importc: "gtk_widget_draw".}
proc draw*(self: Widget, cr: cairo1.TContext) {.inline.} =
  gtk_widget_draw(self, myUnsafeAddr(cr))
# proc draw*(self: Widget, cr: cairo1.TContext) {.inline.} =

# gtk_widget_ensure_style
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_error_bell
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_error_bell(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_error_bell".}
proc error_bell*(self: Widget) {.inline.} =
  gtk_widget_error_bell(self)
# proc error_bell*(self: Widget) {.inline.} =

# gtk_widget_event
# flags: {isMethod} container: Widget
# need sugar: is method
# event 'Gdk3.TEvent' 'ptr Gdk3.TEvent' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_widget_event(self: ptr TWidget, event: ptr Gdk3.TEvent): bool {.cdecl, dynlib: lib, importc: "gtk_widget_event".}
proc event*(self: Widget, event: Gdk3.TEvent): bool {.inline.} =
  gtk_widget_event(self, myUnsafeAddr(event))
# proc event*(self: Widget, event: Gdk3.TEvent): bool {.inline.} =

# gtk_widget_freeze_child_notify
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_freeze_child_notify(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_freeze_child_notify".}
proc freeze_child_notify*(self: Widget) {.inline.} =
  gtk_widget_freeze_child_notify(self)
# proc freeze_child_notify*(self: Widget) {.inline.} =

# gtk_widget_get_accessible
# flags: {isMethod} container: Widget
# need sugar: is method
# 'Atk1.Object' 'TransferNone[Atk1.TObject]' (diff., need sugar)
proc gtk_widget_get_accessible(self: ptr TWidget): TransferNone[Atk1.TObject] {.cdecl, dynlib: lib, importc: "gtk_widget_get_accessible".}
proc get_accessible*(self: Widget): Atk1.Object {.inline.} =
  wrap(gtk_widget_get_accessible(self))
# proc get_accessible*(self: Widget): Atk1.Object {.inline.} =

# gtk_widget_get_allocated_baseline
# flags: {isMethod} container: Widget
# need sugar: is method
# 'int32' 'int32'
proc gtk_widget_get_allocated_baseline(self: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_get_allocated_baseline".}
proc get_allocated_baseline*(self: Widget): int32 {.inline.} =
  gtk_widget_get_allocated_baseline(self)
# proc get_allocated_baseline*(self: Widget): int32 {.inline.} =

# gtk_widget_get_allocated_height
# flags: {isMethod} container: Widget
# need sugar: is method
# 'int32' 'int32'
proc gtk_widget_get_allocated_height(self: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_get_allocated_height".}
proc get_allocated_height*(self: Widget): int32 {.inline.} =
  gtk_widget_get_allocated_height(self)
# proc get_allocated_height*(self: Widget): int32 {.inline.} =

# gtk_widget_get_allocated_width
# flags: {isMethod} container: Widget
# need sugar: is method
# 'int32' 'int32'
proc gtk_widget_get_allocated_width(self: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_get_allocated_width".}
proc get_allocated_width*(self: Widget): int32 {.inline.} =
  gtk_widget_get_allocated_width(self)
# proc get_allocated_width*(self: Widget): int32 {.inline.} =

# gtk_widget_get_allocation
# flags: {isMethod} container: Widget
# need sugar: is method
# allocation 'var cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_get_allocation(self: ptr TWidget, allocation: ptr cairo1.TRectangleInt) {.cdecl, dynlib: lib, importc: "gtk_widget_get_allocation".}
proc get_allocation*(self: Widget, allocation: var cairo1.TRectangleInt) {.inline.} =
  gtk_widget_get_allocation(self, addr(allocation))
# tuple-return
# allocation: var cairo1.TRectangleInt
# proc get_allocation*(self: Widget) {.inline.} =

# gtk_widget_get_ancestor
# flags: {isMethod} container: Widget
# need sugar: is method
# widget_type 'GType' 'GType' IN
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_widget_get_ancestor(self: ptr TWidget, widget_type: GType): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_widget_get_ancestor".}
proc get_ancestor*(self: Widget, widget_type: GType): Widget {.inline.} =
  wrap(gtk_widget_get_ancestor(self, widget_type))
# proc get_ancestor*(self: Widget, widget_type: GType): Widget {.inline.} =

# gtk_widget_get_app_paintable
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_get_app_paintable(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_app_paintable".}
proc get_app_paintable*(self: Widget): bool {.inline.} =
  gtk_widget_get_app_paintable(self)
# proc get_app_paintable*(self: Widget): bool {.inline.} =

# gtk_widget_get_can_default
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_get_can_default(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_can_default".}
proc get_can_default*(self: Widget): bool {.inline.} =
  gtk_widget_get_can_default(self)
# proc get_can_default*(self: Widget): bool {.inline.} =

# gtk_widget_get_can_focus
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_get_can_focus(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_can_focus".}
proc get_can_focus*(self: Widget): bool {.inline.} =
  gtk_widget_get_can_focus(self)
# proc get_can_focus*(self: Widget): bool {.inline.} =

# gtk_widget_get_child_requisition
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_get_child_visible
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_get_child_visible(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_child_visible".}
proc get_child_visible*(self: Widget): bool {.inline.} =
  gtk_widget_get_child_visible(self)
# proc get_child_visible*(self: Widget): bool {.inline.} =

# gtk_widget_get_clip
# flags: {isMethod} container: Widget
# need sugar: is method
# clip 'var cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' OUT (diff., need sugar) caller-allocates
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_get_clip(self: ptr TWidget, clip: ptr cairo1.TRectangleInt) {.cdecl, dynlib: lib, importc: "gtk_widget_get_clip".}
proc get_clip*(self: Widget, clip: var cairo1.TRectangleInt) {.inline.} =
  gtk_widget_get_clip(self, addr(clip))
# tuple-return
# clip: var cairo1.TRectangleInt
# proc get_clip*(self: Widget) {.inline.} =

# gtk_widget_get_clipboard
# flags: {isMethod} container: Widget
# need sugar: is method
# selection 'Gdk3.TAtom' 'ptr Gdk3.TAtom' IN (diff., need sugar)
# 'Clipboard' 'TransferNone[TClipboard]' (diff., need sugar)
proc gtk_widget_get_clipboard(self: ptr TWidget, selection: ptr Gdk3.TAtom): TransferNone[TClipboard] {.cdecl, dynlib: lib, importc: "gtk_widget_get_clipboard".}
proc get_clipboard*(self: Widget, selection: Gdk3.TAtom): Clipboard {.inline.} =
  wrap(gtk_widget_get_clipboard(self, myUnsafeAddr(selection)))
# proc get_clipboard*(self: Widget, selection: Gdk3.TAtom): Clipboard {.inline.} =

# gtk_widget_get_composite_name
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_get_device_enabled
# flags: {isMethod} container: Widget
# need sugar: is method
# device 'Gdk3.Device' 'ptr Gdk3.TDevice' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_widget_get_device_enabled(self: ptr TWidget, device: ptr Gdk3.TDevice): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_device_enabled".}
proc get_device_enabled*(self: Widget, device: Gdk3.Device): bool {.inline.} =
  gtk_widget_get_device_enabled(self, device.getPointer)
# proc get_device_enabled*(self: Widget, device: Gdk3.Device): bool {.inline.} =

# gtk_widget_get_device_events
# flags: {isMethod} container: Widget
# need sugar: is method
# device 'Gdk3.Device' 'ptr Gdk3.TDevice' IN (diff., need sugar)
# 'Gdk3.SEventMask' 'Gdk3.SEventMask'
proc gtk_widget_get_device_events(self: ptr TWidget, device: ptr Gdk3.TDevice): Gdk3.SEventMask {.cdecl, dynlib: lib, importc: "gtk_widget_get_device_events".}
proc get_device_events*(self: Widget, device: Gdk3.Device): Gdk3.SEventMask {.inline.} =
  gtk_widget_get_device_events(self, device.getPointer)
# proc get_device_events*(self: Widget, device: Gdk3.Device): Gdk3.SEventMask {.inline.} =

# gtk_widget_get_direction
# flags: {isMethod} container: Widget
# need sugar: is method
# 'TextDirection' 'TextDirection'
proc gtk_widget_get_direction(self: ptr TWidget): TextDirection {.cdecl, dynlib: lib, importc: "gtk_widget_get_direction".}
proc get_direction*(self: Widget): TextDirection {.inline.} =
  gtk_widget_get_direction(self)
# proc get_direction*(self: Widget): TextDirection {.inline.} =

# gtk_widget_get_display
# flags: {isMethod} container: Widget
# need sugar: is method
# 'Gdk3.Display' 'TransferNone[Gdk3.TDisplay]' (diff., need sugar)
proc gtk_widget_get_display(self: ptr TWidget): TransferNone[Gdk3.TDisplay] {.cdecl, dynlib: lib, importc: "gtk_widget_get_display".}
proc get_display*(self: Widget): Gdk3.Display {.inline.} =
  wrap(gtk_widget_get_display(self))
# proc get_display*(self: Widget): Gdk3.Display {.inline.} =

# gtk_widget_get_double_buffered
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_get_double_buffered(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_double_buffered".}
proc get_double_buffered*(self: Widget): bool {.inline.} =
  gtk_widget_get_double_buffered(self)
# proc get_double_buffered*(self: Widget): bool {.inline.} =

# gtk_widget_get_events
# flags: {isMethod} container: Widget
# need sugar: is method
# 'int32' 'int32'
proc gtk_widget_get_events(self: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_get_events".}
proc get_events*(self: Widget): int32 {.inline.} =
  gtk_widget_get_events(self)
# proc get_events*(self: Widget): int32 {.inline.} =

# gtk_widget_get_frame_clock
# flags: {isMethod} container: Widget
# need sugar: is method
# 'Gdk3.FrameClock' 'TransferNone[Gdk3.TFrameClock]' (diff., need sugar)
proc gtk_widget_get_frame_clock(self: ptr TWidget): TransferNone[Gdk3.TFrameClock] {.cdecl, dynlib: lib, importc: "gtk_widget_get_frame_clock".}
proc get_frame_clock*(self: Widget): Gdk3.FrameClock {.inline.} =
  wrap(gtk_widget_get_frame_clock(self))
# proc get_frame_clock*(self: Widget): Gdk3.FrameClock {.inline.} =

# gtk_widget_get_halign
# flags: {isMethod} container: Widget
# need sugar: is method
# 'Align' 'Align'
proc gtk_widget_get_halign(self: ptr TWidget): Align {.cdecl, dynlib: lib, importc: "gtk_widget_get_halign".}
proc get_halign*(self: Widget): Align {.inline.} =
  gtk_widget_get_halign(self)
# proc get_halign*(self: Widget): Align {.inline.} =

# gtk_widget_get_has_tooltip
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_get_has_tooltip(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_has_tooltip".}
proc get_has_tooltip*(self: Widget): bool {.inline.} =
  gtk_widget_get_has_tooltip(self)
# proc get_has_tooltip*(self: Widget): bool {.inline.} =

# gtk_widget_get_has_window
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_get_has_window(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_has_window".}
proc get_has_window*(self: Widget): bool {.inline.} =
  gtk_widget_get_has_window(self)
# proc get_has_window*(self: Widget): bool {.inline.} =

# gtk_widget_get_hexpand
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_get_hexpand(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_hexpand".}
proc get_hexpand*(self: Widget): bool {.inline.} =
  gtk_widget_get_hexpand(self)
# proc get_hexpand*(self: Widget): bool {.inline.} =

# gtk_widget_get_hexpand_set
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_get_hexpand_set(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_hexpand_set".}
proc get_hexpand_set*(self: Widget): bool {.inline.} =
  gtk_widget_get_hexpand_set(self)
# proc get_hexpand_set*(self: Widget): bool {.inline.} =

# gtk_widget_get_mapped
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_get_mapped(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_mapped".}
proc get_mapped*(self: Widget): bool {.inline.} =
  gtk_widget_get_mapped(self)
# proc get_mapped*(self: Widget): bool {.inline.} =

# gtk_widget_get_margin_bottom
# flags: {isMethod} container: Widget
# need sugar: is method
# 'int32' 'int32'
proc gtk_widget_get_margin_bottom(self: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_get_margin_bottom".}
proc get_margin_bottom*(self: Widget): int32 {.inline.} =
  gtk_widget_get_margin_bottom(self)
# proc get_margin_bottom*(self: Widget): int32 {.inline.} =

# gtk_widget_get_margin_end
# flags: {isMethod} container: Widget
# need sugar: is method
# 'int32' 'int32'
proc gtk_widget_get_margin_end(self: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_get_margin_end".}
proc get_margin_end*(self: Widget): int32 {.inline.} =
  gtk_widget_get_margin_end(self)
# proc get_margin_end*(self: Widget): int32 {.inline.} =

# gtk_widget_get_margin_left
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_get_margin_right
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_get_margin_start
# flags: {isMethod} container: Widget
# need sugar: is method
# 'int32' 'int32'
proc gtk_widget_get_margin_start(self: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_get_margin_start".}
proc get_margin_start*(self: Widget): int32 {.inline.} =
  gtk_widget_get_margin_start(self)
# proc get_margin_start*(self: Widget): int32 {.inline.} =

# gtk_widget_get_margin_top
# flags: {isMethod} container: Widget
# need sugar: is method
# 'int32' 'int32'
proc gtk_widget_get_margin_top(self: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_get_margin_top".}
proc get_margin_top*(self: Widget): int32 {.inline.} =
  gtk_widget_get_margin_top(self)
# proc get_margin_top*(self: Widget): int32 {.inline.} =

# gtk_widget_get_modifier_mask
# flags: {isMethod} container: Widget
# need sugar: is method
# intent 'Gdk3.ModifierIntent' 'Gdk3.ModifierIntent' IN
# 'Gdk3.SModifierType' 'Gdk3.SModifierType'
proc gtk_widget_get_modifier_mask(self: ptr TWidget, intent: Gdk3.ModifierIntent): Gdk3.SModifierType {.cdecl, dynlib: lib, importc: "gtk_widget_get_modifier_mask".}
proc get_modifier_mask*(self: Widget, intent: Gdk3.ModifierIntent): Gdk3.SModifierType {.inline.} =
  gtk_widget_get_modifier_mask(self, intent)
# proc get_modifier_mask*(self: Widget, intent: Gdk3.ModifierIntent): Gdk3.SModifierType {.inline.} =

# gtk_widget_get_modifier_style
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_get_name
# flags: {isMethod} container: Widget
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_widget_get_name(self: ptr TWidget): ucstring {.cdecl, dynlib: lib, importc: "gtk_widget_get_name".}
proc get_name*(self: Widget): ustring {.inline.} =
  ustring($(gtk_widget_get_name(self)))
# proc get_name*(self: Widget): ustring {.inline.} =

# gtk_widget_get_no_show_all
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_get_no_show_all(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_no_show_all".}
proc get_no_show_all*(self: Widget): bool {.inline.} =
  gtk_widget_get_no_show_all(self)
# proc get_no_show_all*(self: Widget): bool {.inline.} =

# gtk_widget_get_opacity
# flags: {isMethod} container: Widget
# need sugar: is method
# 'float64' 'float64'
proc gtk_widget_get_opacity(self: ptr TWidget): float64 {.cdecl, dynlib: lib, importc: "gtk_widget_get_opacity".}
proc get_opacity*(self: Widget): float64 {.inline.} =
  gtk_widget_get_opacity(self)
# proc get_opacity*(self: Widget): float64 {.inline.} =

# gtk_widget_get_pango_context
# flags: {isMethod} container: Widget
# need sugar: is method
# 'Pango1.Context' 'TransferNone[Pango1.TContext]' (diff., need sugar)
proc gtk_widget_get_pango_context(self: ptr TWidget): TransferNone[Pango1.TContext] {.cdecl, dynlib: lib, importc: "gtk_widget_get_pango_context".}
proc get_pango_context*(self: Widget): Pango1.Context {.inline.} =
  wrap(gtk_widget_get_pango_context(self))
# proc get_pango_context*(self: Widget): Pango1.Context {.inline.} =

# gtk_widget_get_parent
# flags: {isMethod} container: Widget
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_widget_get_parent(self: ptr TWidget): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_widget_get_parent".}
proc get_parent*(self: Widget): Widget {.inline.} =
  wrap(gtk_widget_get_parent(self))
# proc get_parent*(self: Widget): Widget {.inline.} =

# gtk_widget_get_parent_window
# flags: {isMethod} container: Widget
# need sugar: is method
# 'Gdk3.Window' 'TransferNone[Gdk3.TWindow]' (diff., need sugar)
proc gtk_widget_get_parent_window(self: ptr TWidget): TransferNone[Gdk3.TWindow] {.cdecl, dynlib: lib, importc: "gtk_widget_get_parent_window".}
proc get_parent_window*(self: Widget): Gdk3.Window {.inline.} =
  wrap(gtk_widget_get_parent_window(self))
# proc get_parent_window*(self: Widget): Gdk3.Window {.inline.} =

# gtk_widget_get_path
# flags: {isMethod} container: Widget
# need sugar: is method
# 'TWidgetPath' 'ptr TWidgetPath' (diff., need sugar)
proc gtk_widget_get_path(self: ptr TWidget): ptr TWidgetPath {.cdecl, dynlib: lib, importc: "gtk_widget_get_path".}
proc get_path*(self: Widget): TWidgetPath {.inline.} =
  (gtk_widget_get_path(self))[]
# proc get_path*(self: Widget): TWidgetPath {.inline.} =

# gtk_widget_get_pointer
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_get_preferred_height
# flags: {isMethod} container: Widget
# need sugar: is method
# minimum_height 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# natural_height 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_get_preferred_height(self: ptr TWidget, minimum_height: ptr int32, natural_height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_widget_get_preferred_height".}
proc get_preferred_height*(self: Widget, minimum_height: var int32, natural_height: var int32) {.inline.} =
  gtk_widget_get_preferred_height(self, addr(minimum_height), addr(natural_height))
# tuple-return
# minimum_height: var int32
# natural_height: var int32
# proc get_preferred_height*(self: Widget) {.inline.} =

# gtk_widget_get_preferred_height_and_baseline_for_width
# flags: {isMethod} container: Widget
# need sugar: is method
# width 'int32' 'int32' IN
# minimum_height 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# natural_height 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# minimum_baseline 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# natural_baseline 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_get_preferred_height_and_baseline_for_width(self: ptr TWidget, width: int32, minimum_height: ptr int32, natural_height: ptr int32, minimum_baseline: ptr int32, natural_baseline: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_widget_get_preferred_height_and_baseline_for_width".}
proc get_preferred_height_and_baseline_for_width*(self: Widget, width: int32, minimum_height: var int32, natural_height: var int32, minimum_baseline: var int32, natural_baseline: var int32) {.inline.} =
  gtk_widget_get_preferred_height_and_baseline_for_width(self, width, addr(minimum_height), addr(natural_height), addr(minimum_baseline), addr(natural_baseline))
# tuple-return
# minimum_height: var int32
# natural_height: var int32
# minimum_baseline: var int32
# natural_baseline: var int32
# proc get_preferred_height_and_baseline_for_width*(self: Widget, width: int32) {.inline.} =

# gtk_widget_get_preferred_height_for_width
# flags: {isMethod} container: Widget
# need sugar: is method
# width 'int32' 'int32' IN
# minimum_height 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# natural_height 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_get_preferred_height_for_width(self: ptr TWidget, width: int32, minimum_height: ptr int32, natural_height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_widget_get_preferred_height_for_width".}
proc get_preferred_height_for_width*(self: Widget, width: int32, minimum_height: var int32, natural_height: var int32) {.inline.} =
  gtk_widget_get_preferred_height_for_width(self, width, addr(minimum_height), addr(natural_height))
# tuple-return
# minimum_height: var int32
# natural_height: var int32
# proc get_preferred_height_for_width*(self: Widget, width: int32) {.inline.} =

# gtk_widget_get_preferred_size
# flags: {isMethod} container: Widget
# need sugar: is method
# minimum_size 'var TRequisition' 'ptr TRequisition' OUT (diff., need sugar) caller-allocates optional
# natural_size 'var TRequisition' 'ptr TRequisition' OUT (diff., need sugar) caller-allocates optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_get_preferred_size(self: ptr TWidget, minimum_size: ptr TRequisition, natural_size: ptr TRequisition) {.cdecl, dynlib: lib, importc: "gtk_widget_get_preferred_size".}
proc get_preferred_size*(self: Widget, minimum_size: var TRequisition, natural_size: var TRequisition) {.inline.} =
  gtk_widget_get_preferred_size(self, addr(minimum_size), addr(natural_size))
# tuple-return
# minimum_size: var TRequisition
# natural_size: var TRequisition
# proc get_preferred_size*(self: Widget) {.inline.} =

# gtk_widget_get_preferred_width
# flags: {isMethod} container: Widget
# need sugar: is method
# minimum_width 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# natural_width 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_get_preferred_width(self: ptr TWidget, minimum_width: ptr int32, natural_width: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_widget_get_preferred_width".}
proc get_preferred_width*(self: Widget, minimum_width: var int32, natural_width: var int32) {.inline.} =
  gtk_widget_get_preferred_width(self, addr(minimum_width), addr(natural_width))
# tuple-return
# minimum_width: var int32
# natural_width: var int32
# proc get_preferred_width*(self: Widget) {.inline.} =

# gtk_widget_get_preferred_width_for_height
# flags: {isMethod} container: Widget
# need sugar: is method
# height 'int32' 'int32' IN
# minimum_width 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# natural_width 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_get_preferred_width_for_height(self: ptr TWidget, height: int32, minimum_width: ptr int32, natural_width: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_widget_get_preferred_width_for_height".}
proc get_preferred_width_for_height*(self: Widget, height: int32, minimum_width: var int32, natural_width: var int32) {.inline.} =
  gtk_widget_get_preferred_width_for_height(self, height, addr(minimum_width), addr(natural_width))
# tuple-return
# minimum_width: var int32
# natural_width: var int32
# proc get_preferred_width_for_height*(self: Widget, height: int32) {.inline.} =

# gtk_widget_get_realized
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_get_realized(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_realized".}
proc get_realized*(self: Widget): bool {.inline.} =
  gtk_widget_get_realized(self)
# proc get_realized*(self: Widget): bool {.inline.} =

# gtk_widget_get_receives_default
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_get_receives_default(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_receives_default".}
proc get_receives_default*(self: Widget): bool {.inline.} =
  gtk_widget_get_receives_default(self)
# proc get_receives_default*(self: Widget): bool {.inline.} =

# gtk_widget_get_request_mode
# flags: {isMethod} container: Widget
# need sugar: is method
# 'SizeRequestMode' 'SizeRequestMode'
proc gtk_widget_get_request_mode(self: ptr TWidget): SizeRequestMode {.cdecl, dynlib: lib, importc: "gtk_widget_get_request_mode".}
proc get_request_mode*(self: Widget): SizeRequestMode {.inline.} =
  gtk_widget_get_request_mode(self)
# proc get_request_mode*(self: Widget): SizeRequestMode {.inline.} =

# gtk_widget_get_requisition
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_get_root_window
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_get_scale_factor
# flags: {isMethod} container: Widget
# need sugar: is method
# 'int32' 'int32'
proc gtk_widget_get_scale_factor(self: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_get_scale_factor".}
proc get_scale_factor*(self: Widget): int32 {.inline.} =
  gtk_widget_get_scale_factor(self)
# proc get_scale_factor*(self: Widget): int32 {.inline.} =

# gtk_widget_get_screen
# flags: {isMethod} container: Widget
# need sugar: is method
# 'Gdk3.Screen' 'TransferNone[Gdk3.TScreen]' (diff., need sugar)
proc gtk_widget_get_screen(self: ptr TWidget): TransferNone[Gdk3.TScreen] {.cdecl, dynlib: lib, importc: "gtk_widget_get_screen".}
proc get_screen*(self: Widget): Gdk3.Screen {.inline.} =
  wrap(gtk_widget_get_screen(self))
# proc get_screen*(self: Widget): Gdk3.Screen {.inline.} =

# gtk_widget_get_sensitive
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_get_sensitive(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_sensitive".}
proc get_sensitive*(self: Widget): bool {.inline.} =
  gtk_widget_get_sensitive(self)
# proc get_sensitive*(self: Widget): bool {.inline.} =

# gtk_widget_get_settings
# flags: {isMethod} container: Widget
# need sugar: is method
# 'Settings' 'TransferNone[TSettings]' (diff., need sugar)
proc gtk_widget_get_settings(self: ptr TWidget): TransferNone[TSettings] {.cdecl, dynlib: lib, importc: "gtk_widget_get_settings".}
proc get_settings*(self: Widget): Settings {.inline.} =
  wrap(gtk_widget_get_settings(self))
# proc get_settings*(self: Widget): Settings {.inline.} =

# gtk_widget_get_size_request
# flags: {isMethod} container: Widget
# need sugar: is method
# width 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# height 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_get_size_request(self: ptr TWidget, width: ptr int32, height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_widget_get_size_request".}
proc get_size_request*(self: Widget, width: var int32, height: var int32) {.inline.} =
  gtk_widget_get_size_request(self, addr(width), addr(height))
# tuple-return
# width: var int32
# height: var int32
# proc get_size_request*(self: Widget) {.inline.} =

# gtk_widget_get_state
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_get_state_flags
# flags: {isMethod} container: Widget
# need sugar: is method
# 'SStateFlags' 'SStateFlags'
proc gtk_widget_get_state_flags(self: ptr TWidget): SStateFlags {.cdecl, dynlib: lib, importc: "gtk_widget_get_state_flags".}
proc get_state_flags*(self: Widget): SStateFlags {.inline.} =
  gtk_widget_get_state_flags(self)
# proc get_state_flags*(self: Widget): SStateFlags {.inline.} =

# gtk_widget_get_style
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_get_style_context
# flags: {isMethod} container: Widget
# need sugar: is method
# 'StyleContext' 'TransferNone[TStyleContext]' (diff., need sugar)
proc gtk_widget_get_style_context(self: ptr TWidget): TransferNone[TStyleContext] {.cdecl, dynlib: lib, importc: "gtk_widget_get_style_context".}
proc get_style_context*(self: Widget): StyleContext {.inline.} =
  wrap(gtk_widget_get_style_context(self))
# proc get_style_context*(self: Widget): StyleContext {.inline.} =

# gtk_widget_get_support_multidevice
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_get_support_multidevice(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_support_multidevice".}
proc get_support_multidevice*(self: Widget): bool {.inline.} =
  gtk_widget_get_support_multidevice(self)
# proc get_support_multidevice*(self: Widget): bool {.inline.} =

# gtk_widget_get_template_child
# flags: {isMethod} container: Widget
# need sugar: is method
# widget_type 'GType' 'GType' IN
# name 'ustring' 'ucstring' IN (diff., need sugar)
# 'GObject2.Object' 'TransferNone[GObject2.TObject]' (diff., need sugar)
proc gtk_widget_get_template_child(self: ptr TWidget, widget_type: GType, name: ucstring): TransferNone[GObject2.TObject] {.cdecl, dynlib: lib, importc: "gtk_widget_get_template_child".}
proc get_template_child*(self: Widget, widget_type: GType, name: ustring): GObject2.Object {.inline.} =
  wrap(gtk_widget_get_template_child(self, widget_type, ucstring(name)))
# proc get_template_child*(self: Widget, widget_type: GType, name: ustring): GObject2.Object {.inline.} =

# gtk_widget_get_tooltip_markup
# flags: {isMethod} container: Widget
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_widget_get_tooltip_markup(self: ptr TWidget): ucstring {.cdecl, dynlib: lib, importc: "gtk_widget_get_tooltip_markup".}
proc get_tooltip_markup*(self: Widget): ustring {.inline.} =
  ustring($(gtk_widget_get_tooltip_markup(self)))
# proc get_tooltip_markup*(self: Widget): ustring {.inline.} =

# gtk_widget_get_tooltip_text
# flags: {isMethod} container: Widget
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_widget_get_tooltip_text(self: ptr TWidget): ucstring {.cdecl, dynlib: lib, importc: "gtk_widget_get_tooltip_text".}
proc get_tooltip_text*(self: Widget): ustring {.inline.} =
  ustring($(gtk_widget_get_tooltip_text(self)))
# proc get_tooltip_text*(self: Widget): ustring {.inline.} =

# gtk_widget_get_tooltip_window
# flags: {isMethod} container: Widget
# need sugar: is method
# 'Window' 'TransferNone[TWindow]' (diff., need sugar)
proc gtk_widget_get_tooltip_window(self: ptr TWidget): TransferNone[TWindow] {.cdecl, dynlib: lib, importc: "gtk_widget_get_tooltip_window".}
proc get_tooltip_window*(self: Widget): Window {.inline.} =
  wrap(gtk_widget_get_tooltip_window(self))
# proc get_tooltip_window*(self: Widget): Window {.inline.} =

# gtk_widget_get_toplevel
# flags: {isMethod} container: Widget
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_widget_get_toplevel(self: ptr TWidget): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_widget_get_toplevel".}
proc get_toplevel*(self: Widget): Widget {.inline.} =
  wrap(gtk_widget_get_toplevel(self))
# proc get_toplevel*(self: Widget): Widget {.inline.} =

# gtk_widget_get_valign
# flags: {isMethod} container: Widget
# need sugar: is method
# 'Align' 'Align'
proc gtk_widget_get_valign(self: ptr TWidget): Align {.cdecl, dynlib: lib, importc: "gtk_widget_get_valign".}
proc get_valign*(self: Widget): Align {.inline.} =
  gtk_widget_get_valign(self)
# proc get_valign*(self: Widget): Align {.inline.} =

# gtk_widget_get_valign_with_baseline
# flags: {isMethod} container: Widget
# need sugar: is method
# 'Align' 'Align'
proc gtk_widget_get_valign_with_baseline(self: ptr TWidget): Align {.cdecl, dynlib: lib, importc: "gtk_widget_get_valign_with_baseline".}
proc get_valign_with_baseline*(self: Widget): Align {.inline.} =
  gtk_widget_get_valign_with_baseline(self)
# proc get_valign_with_baseline*(self: Widget): Align {.inline.} =

# gtk_widget_get_vexpand
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_get_vexpand(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_vexpand".}
proc get_vexpand*(self: Widget): bool {.inline.} =
  gtk_widget_get_vexpand(self)
# proc get_vexpand*(self: Widget): bool {.inline.} =

# gtk_widget_get_vexpand_set
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_get_vexpand_set(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_vexpand_set".}
proc get_vexpand_set*(self: Widget): bool {.inline.} =
  gtk_widget_get_vexpand_set(self)
# proc get_vexpand_set*(self: Widget): bool {.inline.} =

# gtk_widget_get_visible
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_get_visible(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_visible".}
proc get_visible*(self: Widget): bool {.inline.} =
  gtk_widget_get_visible(self)
# proc get_visible*(self: Widget): bool {.inline.} =

# gtk_widget_get_visual
# flags: {isMethod} container: Widget
# need sugar: is method
# 'Gdk3.Visual' 'TransferNone[Gdk3.TVisual]' (diff., need sugar)
proc gtk_widget_get_visual(self: ptr TWidget): TransferNone[Gdk3.TVisual] {.cdecl, dynlib: lib, importc: "gtk_widget_get_visual".}
proc get_visual*(self: Widget): Gdk3.Visual {.inline.} =
  wrap(gtk_widget_get_visual(self))
# proc get_visual*(self: Widget): Gdk3.Visual {.inline.} =

# gtk_widget_get_window
# flags: {isMethod} container: Widget
# need sugar: is method
# 'Gdk3.Window' 'TransferNone[Gdk3.TWindow]' (diff., need sugar)
proc gtk_widget_get_window(self: ptr TWidget): TransferNone[Gdk3.TWindow] {.cdecl, dynlib: lib, importc: "gtk_widget_get_window".}
proc get_window*(self: Widget): Gdk3.Window {.inline.} =
  wrap(gtk_widget_get_window(self))
# proc get_window*(self: Widget): Gdk3.Window {.inline.} =

# gtk_grab_add
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_grab_add(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_grab_add".}
proc grab_add*(self: Widget) {.inline.} =
  gtk_grab_add(self)
# proc grab_add*(self: Widget) {.inline.} =

# gtk_widget_grab_default
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_grab_default(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_grab_default".}
proc grab_default*(self: Widget) {.inline.} =
  gtk_widget_grab_default(self)
# proc grab_default*(self: Widget) {.inline.} =

# gtk_widget_grab_focus
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_grab_focus(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_grab_focus".}
proc grab_focus*(self: Widget) {.inline.} =
  gtk_widget_grab_focus(self)
# proc grab_focus*(self: Widget) {.inline.} =

# gtk_grab_remove
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_grab_remove(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_grab_remove".}
proc grab_remove*(self: Widget) {.inline.} =
  gtk_grab_remove(self)
# proc grab_remove*(self: Widget) {.inline.} =

# gtk_widget_has_default
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_has_default(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_has_default".}
proc has_default*(self: Widget): bool {.inline.} =
  gtk_widget_has_default(self)
# proc has_default*(self: Widget): bool {.inline.} =

# gtk_widget_has_focus
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_has_focus(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_has_focus".}
proc has_focus*(self: Widget): bool {.inline.} =
  gtk_widget_has_focus(self)
# proc has_focus*(self: Widget): bool {.inline.} =

# gtk_widget_has_grab
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_has_grab(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_has_grab".}
proc has_grab*(self: Widget): bool {.inline.} =
  gtk_widget_has_grab(self)
# proc has_grab*(self: Widget): bool {.inline.} =

# gtk_widget_has_rc_style
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_has_screen
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_has_screen(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_has_screen".}
proc has_screen*(self: Widget): bool {.inline.} =
  gtk_widget_has_screen(self)
# proc has_screen*(self: Widget): bool {.inline.} =

# gtk_widget_has_visible_focus
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_has_visible_focus(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_has_visible_focus".}
proc has_visible_focus*(self: Widget): bool {.inline.} =
  gtk_widget_has_visible_focus(self)
# proc has_visible_focus*(self: Widget): bool {.inline.} =

# gtk_widget_hide
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_hide(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_hide".}
proc hide*(self: Widget) {.inline.} =
  gtk_widget_hide(self)
# proc hide*(self: Widget) {.inline.} =

# gtk_widget_hide_on_delete
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_hide_on_delete(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_hide_on_delete".}
proc hide_on_delete*(self: Widget): bool {.inline.} =
  gtk_widget_hide_on_delete(self)
# proc hide_on_delete*(self: Widget): bool {.inline.} =

# gtk_widget_in_destruction
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_in_destruction(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_in_destruction".}
proc in_destruction*(self: Widget): bool {.inline.} =
  gtk_widget_in_destruction(self)
# proc in_destruction*(self: Widget): bool {.inline.} =

# gtk_widget_init_template
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_init_template(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_init_template".}
proc init_template*(self: Widget) {.inline.} =
  gtk_widget_init_template(self)
# proc init_template*(self: Widget) {.inline.} =

# gtk_widget_input_shape_combine_region
# flags: {isMethod} container: Widget
# need sugar: is method
# region 'cairo1.TRegion' 'ptr cairo1.TRegion' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_input_shape_combine_region(self: ptr TWidget, region: ptr cairo1.TRegion) {.cdecl, dynlib: lib, importc: "gtk_widget_input_shape_combine_region".}
proc input_shape_combine_region*(self: Widget, region: cairo1.TRegion) {.inline.} =
  gtk_widget_input_shape_combine_region(self, myUnsafeAddr(region))
# proc input_shape_combine_region*(self: Widget, region: cairo1.TRegion) {.inline.} =

# gtk_widget_insert_action_group
# flags: {isMethod} container: Widget
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# group 'Gio2.ActionGroup' 'ptr Gio2.TActionGroup' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_insert_action_group(self: ptr TWidget, name: ucstring, group: ptr Gio2.TActionGroup) {.cdecl, dynlib: lib, importc: "gtk_widget_insert_action_group".}
proc insert_action_group*(self: Widget, name: ustring, group: Gio2.ActionGroup) {.inline.} =
  gtk_widget_insert_action_group(self, ucstring(name), unwrap(group))
# proc insert_action_group*(self: Widget, name: ustring, group: Gio2.ActionGroup) {.inline.} =

# gtk_widget_intersect
# flags: {isMethod} container: Widget
# need sugar: is method
# area 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# intersection 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_widget_intersect(self: ptr TWidget, area: ptr cairo1.TRectangleInt, intersection: ptr cairo1.TRectangleInt): bool {.cdecl, dynlib: lib, importc: "gtk_widget_intersect".}
proc intersect*(self: Widget, area: cairo1.TRectangleInt, intersection: cairo1.TRectangleInt): bool {.inline.} =
  gtk_widget_intersect(self, myUnsafeAddr(area), myUnsafeAddr(intersection))
# proc intersect*(self: Widget, area: cairo1.TRectangleInt, intersection: cairo1.TRectangleInt): bool {.inline.} =

# gtk_widget_is_ancestor
# flags: {isMethod} container: Widget
# need sugar: is method
# ancestor 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_widget_is_ancestor(self: ptr TWidget, ancestor: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_is_ancestor".}
proc is_ancestor*(self: Widget, ancestor: Widget): bool {.inline.} =
  gtk_widget_is_ancestor(self, ancestor.getPointer)
# proc is_ancestor*(self: Widget, ancestor: Widget): bool {.inline.} =

# gtk_widget_is_composited
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_is_composited(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_is_composited".}
proc is_composited*(self: Widget): bool {.inline.} =
  gtk_widget_is_composited(self)
# proc is_composited*(self: Widget): bool {.inline.} =

# gtk_widget_is_drawable
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_is_drawable(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_is_drawable".}
proc is_drawable*(self: Widget): bool {.inline.} =
  gtk_widget_is_drawable(self)
# proc is_drawable*(self: Widget): bool {.inline.} =

# gtk_widget_is_focus
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_is_focus(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_is_focus".}
proc is_focus*(self: Widget): bool {.inline.} =
  gtk_widget_is_focus(self)
# proc is_focus*(self: Widget): bool {.inline.} =

# gtk_widget_is_sensitive
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_is_sensitive(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_is_sensitive".}
proc is_sensitive*(self: Widget): bool {.inline.} =
  gtk_widget_is_sensitive(self)
# proc is_sensitive*(self: Widget): bool {.inline.} =

# gtk_widget_is_toplevel
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_is_toplevel(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_is_toplevel".}
proc is_toplevel*(self: Widget): bool {.inline.} =
  gtk_widget_is_toplevel(self)
# proc is_toplevel*(self: Widget): bool {.inline.} =

# gtk_widget_is_visible
# flags: {isMethod} container: Widget
# need sugar: is method
# 'bool' 'bool'
proc gtk_widget_is_visible(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_is_visible".}
proc is_visible*(self: Widget): bool {.inline.} =
  gtk_widget_is_visible(self)
# proc is_visible*(self: Widget): bool {.inline.} =

# gtk_widget_keynav_failed
# flags: {isMethod} container: Widget
# need sugar: is method
# direction 'DirectionType' 'DirectionType' IN
# 'bool' 'bool'
proc gtk_widget_keynav_failed(self: ptr TWidget, direction: DirectionType): bool {.cdecl, dynlib: lib, importc: "gtk_widget_keynav_failed".}
proc keynav_failed*(self: Widget, direction: DirectionType): bool {.inline.} =
  gtk_widget_keynav_failed(self, direction)
# proc keynav_failed*(self: Widget, direction: DirectionType): bool {.inline.} =

# gtk_widget_list_accel_closures
# flags: {isMethod} container: Widget
# need sugar: is method
# 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_widget_list_accel_closures(self: ptr TWidget): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_widget_list_accel_closures".}
proc list_accel_closures*(self: Widget): ptr GLIST_TODO {.inline.} =
  gtk_widget_list_accel_closures(self)
# proc list_accel_closures*(self: Widget): ptr GLIST_TODO {.inline.} =

# gtk_widget_list_mnemonic_labels
# flags: {isMethod} container: Widget
# need sugar: is method
# 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_widget_list_mnemonic_labels(self: ptr TWidget): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_widget_list_mnemonic_labels".}
proc list_mnemonic_labels*(self: Widget): ptr GLIST_TODO {.inline.} =
  gtk_widget_list_mnemonic_labels(self)
# proc list_mnemonic_labels*(self: Widget): ptr GLIST_TODO {.inline.} =

# gtk_widget_map
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_map(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_map".}
proc map*(self: Widget) {.inline.} =
  gtk_widget_map(self)
# proc map*(self: Widget) {.inline.} =

# gtk_widget_mnemonic_activate
# flags: {isMethod} container: Widget
# need sugar: is method
# group_cycling 'bool' 'bool' IN
# 'bool' 'bool'
proc gtk_widget_mnemonic_activate(self: ptr TWidget, group_cycling: bool): bool {.cdecl, dynlib: lib, importc: "gtk_widget_mnemonic_activate".}
proc mnemonic_activate*(self: Widget, group_cycling: bool): bool {.inline.} =
  gtk_widget_mnemonic_activate(self, group_cycling)
# proc mnemonic_activate*(self: Widget, group_cycling: bool): bool {.inline.} =

# gtk_widget_modify_base
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_modify_bg
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_modify_cursor
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_modify_fg
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_modify_font
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_modify_style
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_modify_text
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_override_background_color
# flags: {isMethod} container: Widget
# need sugar: is method
# state 'SStateFlags' 'SStateFlags' IN
# color 'Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_override_background_color(self: ptr TWidget, state: SStateFlags, color: ptr Gdk3.TRGBA) {.cdecl, dynlib: lib, importc: "gtk_widget_override_background_color".}
proc override_background_color*(self: Widget, state: SStateFlags, color: Gdk3.TRGBA) {.inline.} =
  gtk_widget_override_background_color(self, state, myUnsafeAddr(color))
# proc override_background_color*(self: Widget, state: SStateFlags, color: Gdk3.TRGBA) {.inline.} =

# gtk_widget_override_color
# flags: {isMethod} container: Widget
# need sugar: is method
# state 'SStateFlags' 'SStateFlags' IN
# color 'Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_override_color(self: ptr TWidget, state: SStateFlags, color: ptr Gdk3.TRGBA) {.cdecl, dynlib: lib, importc: "gtk_widget_override_color".}
proc override_color*(self: Widget, state: SStateFlags, color: Gdk3.TRGBA) {.inline.} =
  gtk_widget_override_color(self, state, myUnsafeAddr(color))
# proc override_color*(self: Widget, state: SStateFlags, color: Gdk3.TRGBA) {.inline.} =

# gtk_widget_override_cursor
# flags: {isMethod} container: Widget
# need sugar: is method
# cursor 'Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN (diff., need sugar)
# secondary_cursor 'Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_override_cursor(self: ptr TWidget, cursor: ptr Gdk3.TRGBA, secondary_cursor: ptr Gdk3.TRGBA) {.cdecl, dynlib: lib, importc: "gtk_widget_override_cursor".}
proc override_cursor*(self: Widget, cursor: Gdk3.TRGBA, secondary_cursor: Gdk3.TRGBA) {.inline.} =
  gtk_widget_override_cursor(self, myUnsafeAddr(cursor), myUnsafeAddr(secondary_cursor))
# proc override_cursor*(self: Widget, cursor: Gdk3.TRGBA, secondary_cursor: Gdk3.TRGBA) {.inline.} =

# gtk_widget_override_font
# flags: {isMethod} container: Widget
# need sugar: is method
# font_desc 'Pango1.TFontDescription' 'ptr Pango1.TFontDescription' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_override_font(self: ptr TWidget, font_desc: ptr Pango1.TFontDescription) {.cdecl, dynlib: lib, importc: "gtk_widget_override_font".}
proc override_font*(self: Widget, font_desc: Pango1.TFontDescription) {.inline.} =
  gtk_widget_override_font(self, myUnsafeAddr(font_desc))
# proc override_font*(self: Widget, font_desc: Pango1.TFontDescription) {.inline.} =

# gtk_widget_override_symbolic_color
# flags: {isMethod} container: Widget
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# color 'Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_override_symbolic_color(self: ptr TWidget, name: ucstring, color: ptr Gdk3.TRGBA) {.cdecl, dynlib: lib, importc: "gtk_widget_override_symbolic_color".}
proc override_symbolic_color*(self: Widget, name: ustring, color: Gdk3.TRGBA) {.inline.} =
  gtk_widget_override_symbolic_color(self, ucstring(name), myUnsafeAddr(color))
# proc override_symbolic_color*(self: Widget, name: ustring, color: Gdk3.TRGBA) {.inline.} =

# gtk_widget_path
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_queue_compute_expand
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_queue_compute_expand(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_queue_compute_expand".}
proc queue_compute_expand*(self: Widget) {.inline.} =
  gtk_widget_queue_compute_expand(self)
# proc queue_compute_expand*(self: Widget) {.inline.} =

# gtk_widget_queue_draw
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_queue_draw(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_queue_draw".}
proc queue_draw*(self: Widget) {.inline.} =
  gtk_widget_queue_draw(self)
# proc queue_draw*(self: Widget) {.inline.} =

# gtk_widget_queue_draw_area
# flags: {isMethod} container: Widget
# need sugar: is method
# x 'int32' 'int32' IN
# y 'int32' 'int32' IN
# width 'int32' 'int32' IN
# height 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_queue_draw_area(self: ptr TWidget, x: int32, y: int32, width: int32, height: int32) {.cdecl, dynlib: lib, importc: "gtk_widget_queue_draw_area".}
proc queue_draw_area*(self: Widget, x: int32, y: int32, width: int32, height: int32) {.inline.} =
  gtk_widget_queue_draw_area(self, x, y, width, height)
# proc queue_draw_area*(self: Widget, x: int32, y: int32, width: int32, height: int32) {.inline.} =

# gtk_widget_queue_draw_region
# flags: {isMethod} container: Widget
# need sugar: is method
# region 'cairo1.TRegion' 'ptr cairo1.TRegion' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_queue_draw_region(self: ptr TWidget, region: ptr cairo1.TRegion) {.cdecl, dynlib: lib, importc: "gtk_widget_queue_draw_region".}
proc queue_draw_region*(self: Widget, region: cairo1.TRegion) {.inline.} =
  gtk_widget_queue_draw_region(self, myUnsafeAddr(region))
# proc queue_draw_region*(self: Widget, region: cairo1.TRegion) {.inline.} =

# gtk_widget_queue_resize
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_queue_resize(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_queue_resize".}
proc queue_resize*(self: Widget) {.inline.} =
  gtk_widget_queue_resize(self)
# proc queue_resize*(self: Widget) {.inline.} =

# gtk_widget_queue_resize_no_redraw
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_queue_resize_no_redraw(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_queue_resize_no_redraw".}
proc queue_resize_no_redraw*(self: Widget) {.inline.} =
  gtk_widget_queue_resize_no_redraw(self)
# proc queue_resize_no_redraw*(self: Widget) {.inline.} =

# gtk_widget_realize
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_realize(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_realize".}
proc realize*(self: Widget) {.inline.} =
  gtk_widget_realize(self)
# proc realize*(self: Widget) {.inline.} =

# gtk_widget_region_intersect
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_register_window
# flags: {isMethod} container: Widget
# need sugar: is method
# window 'Gdk3.Window' 'ptr Gdk3.TWindow' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_register_window(self: ptr TWidget, window: ptr Gdk3.TWindow) {.cdecl, dynlib: lib, importc: "gtk_widget_register_window".}
proc register_window*(self: Widget, window: Gdk3.Window) {.inline.} =
  gtk_widget_register_window(self, window.getPointer)
# proc register_window*(self: Widget, window: Gdk3.Window) {.inline.} =

# gtk_widget_remove_accelerator
# flags: {isMethod} container: Widget
# need sugar: is method
# accel_group 'AccelGroup' 'ptr TAccelGroup' IN (diff., need sugar)
# accel_key 'uint32' 'uint32' IN
# accel_mods 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# 'bool' 'bool'
proc gtk_widget_remove_accelerator(self: ptr TWidget, accel_group: ptr TAccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType): bool {.cdecl, dynlib: lib, importc: "gtk_widget_remove_accelerator".}
proc remove_accelerator*(self: Widget, accel_group: AccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType): bool {.inline.} =
  gtk_widget_remove_accelerator(self, accel_group.getPointer, accel_key, accel_mods)
# proc remove_accelerator*(self: Widget, accel_group: AccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType): bool {.inline.} =

# gtk_widget_remove_mnemonic_label
# flags: {isMethod} container: Widget
# need sugar: is method
# label 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_remove_mnemonic_label(self: ptr TWidget, label: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_remove_mnemonic_label".}
proc remove_mnemonic_label*(self: Widget, label: Widget) {.inline.} =
  gtk_widget_remove_mnemonic_label(self, label.getPointer)
# proc remove_mnemonic_label*(self: Widget, label: Widget) {.inline.} =

# gtk_widget_remove_tick_callback
# flags: {isMethod} container: Widget
# need sugar: is method
# id 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_remove_tick_callback(self: ptr TWidget, id: uint32) {.cdecl, dynlib: lib, importc: "gtk_widget_remove_tick_callback".}
proc remove_tick_callback*(self: Widget, id: uint32) {.inline.} =
  gtk_widget_remove_tick_callback(self, id)
# proc remove_tick_callback*(self: Widget, id: uint32) {.inline.} =

# gtk_widget_render_icon
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_render_icon_pixbuf
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_reparent
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_reset_rc_styles
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_reset_style
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_reset_style(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_reset_style".}
proc reset_style*(self: Widget) {.inline.} =
  gtk_widget_reset_style(self)
# proc reset_style*(self: Widget) {.inline.} =

# gtk_widget_send_expose
# flags: {isMethod} container: Widget
# need sugar: is method
# event 'Gdk3.TEvent' 'ptr Gdk3.TEvent' IN (diff., need sugar)
# 'int32' 'int32'
proc gtk_widget_send_expose(self: ptr TWidget, event: ptr Gdk3.TEvent): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_send_expose".}
proc send_expose*(self: Widget, event: Gdk3.TEvent): int32 {.inline.} =
  gtk_widget_send_expose(self, myUnsafeAddr(event))
# proc send_expose*(self: Widget, event: Gdk3.TEvent): int32 {.inline.} =

# gtk_widget_send_focus_change
# flags: {isMethod} container: Widget
# need sugar: is method
# event 'Gdk3.TEvent' 'ptr Gdk3.TEvent' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_widget_send_focus_change(self: ptr TWidget, event: ptr Gdk3.TEvent): bool {.cdecl, dynlib: lib, importc: "gtk_widget_send_focus_change".}
proc send_focus_change*(self: Widget, event: Gdk3.TEvent): bool {.inline.} =
  gtk_widget_send_focus_change(self, myUnsafeAddr(event))
# proc send_focus_change*(self: Widget, event: Gdk3.TEvent): bool {.inline.} =

# gtk_widget_set_accel_path
# flags: {isMethod} container: Widget
# need sugar: is method
# accel_path 'ustring' 'ucstring' IN (diff., need sugar)
# accel_group 'AccelGroup' 'ptr TAccelGroup' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_accel_path(self: ptr TWidget, accel_path: ucstring, accel_group: ptr TAccelGroup) {.cdecl, dynlib: lib, importc: "gtk_widget_set_accel_path".}
proc set_accel_path*(self: Widget, accel_path: ustring, accel_group: AccelGroup) {.inline.} =
  gtk_widget_set_accel_path(self, ucstring(accel_path), accel_group.getPointer)
# proc set_accel_path*(self: Widget, accel_path: ustring, accel_group: AccelGroup) {.inline.} =

# gtk_widget_set_allocation
# flags: {isMethod} container: Widget
# need sugar: is method
# allocation 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_allocation(self: ptr TWidget, allocation: ptr cairo1.TRectangleInt) {.cdecl, dynlib: lib, importc: "gtk_widget_set_allocation".}
proc set_allocation*(self: Widget, allocation: cairo1.TRectangleInt) {.inline.} =
  gtk_widget_set_allocation(self, myUnsafeAddr(allocation))
# proc set_allocation*(self: Widget, allocation: cairo1.TRectangleInt) {.inline.} =

# gtk_widget_set_app_paintable
# flags: {isMethod} container: Widget
# need sugar: is method
# app_paintable 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_app_paintable(self: ptr TWidget, app_paintable: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_app_paintable".}
proc set_app_paintable*(self: Widget, app_paintable: bool) {.inline.} =
  gtk_widget_set_app_paintable(self, app_paintable)
# proc set_app_paintable*(self: Widget, app_paintable: bool) {.inline.} =

# gtk_widget_set_can_default
# flags: {isMethod} container: Widget
# need sugar: is method
# can_default 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_can_default(self: ptr TWidget, can_default: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_can_default".}
proc set_can_default*(self: Widget, can_default: bool) {.inline.} =
  gtk_widget_set_can_default(self, can_default)
# proc set_can_default*(self: Widget, can_default: bool) {.inline.} =

# gtk_widget_set_can_focus
# flags: {isMethod} container: Widget
# need sugar: is method
# can_focus 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_can_focus(self: ptr TWidget, can_focus: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_can_focus".}
proc set_can_focus*(self: Widget, can_focus: bool) {.inline.} =
  gtk_widget_set_can_focus(self, can_focus)
# proc set_can_focus*(self: Widget, can_focus: bool) {.inline.} =

# gtk_widget_set_child_visible
# flags: {isMethod} container: Widget
# need sugar: is method
# is_visible 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_child_visible(self: ptr TWidget, is_visible: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_child_visible".}
proc set_child_visible*(self: Widget, is_visible: bool) {.inline.} =
  gtk_widget_set_child_visible(self, is_visible)
# proc set_child_visible*(self: Widget, is_visible: bool) {.inline.} =

# gtk_widget_set_clip
# flags: {isMethod} container: Widget
# need sugar: is method
# clip 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_clip(self: ptr TWidget, clip: ptr cairo1.TRectangleInt) {.cdecl, dynlib: lib, importc: "gtk_widget_set_clip".}
proc set_clip*(self: Widget, clip: cairo1.TRectangleInt) {.inline.} =
  gtk_widget_set_clip(self, myUnsafeAddr(clip))
# proc set_clip*(self: Widget, clip: cairo1.TRectangleInt) {.inline.} =

# gtk_widget_set_composite_name
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_set_device_enabled
# flags: {isMethod} container: Widget
# need sugar: is method
# device 'Gdk3.Device' 'ptr Gdk3.TDevice' IN (diff., need sugar)
# enabled 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_device_enabled(self: ptr TWidget, device: ptr Gdk3.TDevice, enabled: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_device_enabled".}
proc set_device_enabled*(self: Widget, device: Gdk3.Device, enabled: bool) {.inline.} =
  gtk_widget_set_device_enabled(self, device.getPointer, enabled)
# proc set_device_enabled*(self: Widget, device: Gdk3.Device, enabled: bool) {.inline.} =

# gtk_widget_set_device_events
# flags: {isMethod} container: Widget
# need sugar: is method
# device 'Gdk3.Device' 'ptr Gdk3.TDevice' IN (diff., need sugar)
# events 'Gdk3.SEventMask' 'Gdk3.SEventMask' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_device_events(self: ptr TWidget, device: ptr Gdk3.TDevice, events: Gdk3.SEventMask) {.cdecl, dynlib: lib, importc: "gtk_widget_set_device_events".}
proc set_device_events*(self: Widget, device: Gdk3.Device, events: Gdk3.SEventMask) {.inline.} =
  gtk_widget_set_device_events(self, device.getPointer, events)
# proc set_device_events*(self: Widget, device: Gdk3.Device, events: Gdk3.SEventMask) {.inline.} =

# gtk_widget_set_direction
# flags: {isMethod} container: Widget
# need sugar: is method
# dir 'TextDirection' 'TextDirection' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_direction(self: ptr TWidget, dir: TextDirection) {.cdecl, dynlib: lib, importc: "gtk_widget_set_direction".}
proc set_direction*(self: Widget, dir: TextDirection) {.inline.} =
  gtk_widget_set_direction(self, dir)
# proc set_direction*(self: Widget, dir: TextDirection) {.inline.} =

# gtk_widget_set_double_buffered
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_set_events
# flags: {isMethod} container: Widget
# need sugar: is method
# events 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_events(self: ptr TWidget, events: int32) {.cdecl, dynlib: lib, importc: "gtk_widget_set_events".}
proc set_events*(self: Widget, events: int32) {.inline.} =
  gtk_widget_set_events(self, events)
# proc set_events*(self: Widget, events: int32) {.inline.} =

# gtk_widget_set_halign
# flags: {isMethod} container: Widget
# need sugar: is method
# align 'Align' 'Align' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_halign(self: ptr TWidget, align: Align) {.cdecl, dynlib: lib, importc: "gtk_widget_set_halign".}
proc set_halign*(self: Widget, align: Align) {.inline.} =
  gtk_widget_set_halign(self, align)
# proc set_halign*(self: Widget, align: Align) {.inline.} =

# gtk_widget_set_has_tooltip
# flags: {isMethod} container: Widget
# need sugar: is method
# has_tooltip 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_has_tooltip(self: ptr TWidget, has_tooltip: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_has_tooltip".}
proc set_has_tooltip*(self: Widget, has_tooltip: bool) {.inline.} =
  gtk_widget_set_has_tooltip(self, has_tooltip)
# proc set_has_tooltip*(self: Widget, has_tooltip: bool) {.inline.} =

# gtk_widget_set_has_window
# flags: {isMethod} container: Widget
# need sugar: is method
# has_window 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_has_window(self: ptr TWidget, has_window: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_has_window".}
proc set_has_window*(self: Widget, has_window: bool) {.inline.} =
  gtk_widget_set_has_window(self, has_window)
# proc set_has_window*(self: Widget, has_window: bool) {.inline.} =

# gtk_widget_set_hexpand
# flags: {isMethod} container: Widget
# need sugar: is method
# expand 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_hexpand(self: ptr TWidget, expand: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_hexpand".}
proc set_hexpand*(self: Widget, expand: bool) {.inline.} =
  gtk_widget_set_hexpand(self, expand)
# proc set_hexpand*(self: Widget, expand: bool) {.inline.} =

# gtk_widget_set_hexpand_set
# flags: {isMethod} container: Widget
# need sugar: is method
# set 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_hexpand_set(self: ptr TWidget, set: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_hexpand_set".}
proc set_hexpand_set*(self: Widget, set: bool) {.inline.} =
  gtk_widget_set_hexpand_set(self, set)
# proc set_hexpand_set*(self: Widget, set: bool) {.inline.} =

# gtk_widget_set_mapped
# flags: {isMethod} container: Widget
# need sugar: is method
# mapped 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_mapped(self: ptr TWidget, mapped: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_mapped".}
proc set_mapped*(self: Widget, mapped: bool) {.inline.} =
  gtk_widget_set_mapped(self, mapped)
# proc set_mapped*(self: Widget, mapped: bool) {.inline.} =

# gtk_widget_set_margin_bottom
# flags: {isMethod} container: Widget
# need sugar: is method
# margin 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_margin_bottom(self: ptr TWidget, margin: int32) {.cdecl, dynlib: lib, importc: "gtk_widget_set_margin_bottom".}
proc set_margin_bottom*(self: Widget, margin: int32) {.inline.} =
  gtk_widget_set_margin_bottom(self, margin)
# proc set_margin_bottom*(self: Widget, margin: int32) {.inline.} =

# gtk_widget_set_margin_end
# flags: {isMethod} container: Widget
# need sugar: is method
# margin 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_margin_end(self: ptr TWidget, margin: int32) {.cdecl, dynlib: lib, importc: "gtk_widget_set_margin_end".}
proc set_margin_end*(self: Widget, margin: int32) {.inline.} =
  gtk_widget_set_margin_end(self, margin)
# proc set_margin_end*(self: Widget, margin: int32) {.inline.} =

# gtk_widget_set_margin_left
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_set_margin_right
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_set_margin_start
# flags: {isMethod} container: Widget
# need sugar: is method
# margin 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_margin_start(self: ptr TWidget, margin: int32) {.cdecl, dynlib: lib, importc: "gtk_widget_set_margin_start".}
proc set_margin_start*(self: Widget, margin: int32) {.inline.} =
  gtk_widget_set_margin_start(self, margin)
# proc set_margin_start*(self: Widget, margin: int32) {.inline.} =

# gtk_widget_set_margin_top
# flags: {isMethod} container: Widget
# need sugar: is method
# margin 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_margin_top(self: ptr TWidget, margin: int32) {.cdecl, dynlib: lib, importc: "gtk_widget_set_margin_top".}
proc set_margin_top*(self: Widget, margin: int32) {.inline.} =
  gtk_widget_set_margin_top(self, margin)
# proc set_margin_top*(self: Widget, margin: int32) {.inline.} =

# gtk_widget_set_name
# flags: {isMethod} container: Widget
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_name(self: ptr TWidget, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_widget_set_name".}
proc set_name*(self: Widget, name: ustring) {.inline.} =
  gtk_widget_set_name(self, ucstring(name))
# proc set_name*(self: Widget, name: ustring) {.inline.} =

# gtk_widget_set_no_show_all
# flags: {isMethod} container: Widget
# need sugar: is method
# no_show_all 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_no_show_all(self: ptr TWidget, no_show_all: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_no_show_all".}
proc set_no_show_all*(self: Widget, no_show_all: bool) {.inline.} =
  gtk_widget_set_no_show_all(self, no_show_all)
# proc set_no_show_all*(self: Widget, no_show_all: bool) {.inline.} =

# gtk_widget_set_opacity
# flags: {isMethod} container: Widget
# need sugar: is method
# opacity 'float64' 'float64' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_opacity(self: ptr TWidget, opacity: float64) {.cdecl, dynlib: lib, importc: "gtk_widget_set_opacity".}
proc set_opacity*(self: Widget, opacity: float64) {.inline.} =
  gtk_widget_set_opacity(self, opacity)
# proc set_opacity*(self: Widget, opacity: float64) {.inline.} =

# gtk_widget_set_parent
# flags: {isMethod} container: Widget
# need sugar: is method
# parent 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_parent(self: ptr TWidget, parent: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_set_parent".}
proc set_parent*(self: Widget, parent: Widget) {.inline.} =
  gtk_widget_set_parent(self, parent.getPointer)
# proc set_parent*(self: Widget, parent: Widget) {.inline.} =

# gtk_widget_set_parent_window
# flags: {isMethod} container: Widget
# need sugar: is method
# parent_window 'Gdk3.Window' 'ptr Gdk3.TWindow' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_parent_window(self: ptr TWidget, parent_window: ptr Gdk3.TWindow) {.cdecl, dynlib: lib, importc: "gtk_widget_set_parent_window".}
proc set_parent_window*(self: Widget, parent_window: Gdk3.Window) {.inline.} =
  gtk_widget_set_parent_window(self, parent_window.getPointer)
# proc set_parent_window*(self: Widget, parent_window: Gdk3.Window) {.inline.} =

# gtk_widget_set_realized
# flags: {isMethod} container: Widget
# need sugar: is method
# realized 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_realized(self: ptr TWidget, realized: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_realized".}
proc set_realized*(self: Widget, realized: bool) {.inline.} =
  gtk_widget_set_realized(self, realized)
# proc set_realized*(self: Widget, realized: bool) {.inline.} =

# gtk_widget_set_receives_default
# flags: {isMethod} container: Widget
# need sugar: is method
# receives_default 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_receives_default(self: ptr TWidget, receives_default: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_receives_default".}
proc set_receives_default*(self: Widget, receives_default: bool) {.inline.} =
  gtk_widget_set_receives_default(self, receives_default)
# proc set_receives_default*(self: Widget, receives_default: bool) {.inline.} =

# gtk_widget_set_redraw_on_allocate
# flags: {isMethod} container: Widget
# need sugar: is method
# redraw_on_allocate 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_redraw_on_allocate(self: ptr TWidget, redraw_on_allocate: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_redraw_on_allocate".}
proc set_redraw_on_allocate*(self: Widget, redraw_on_allocate: bool) {.inline.} =
  gtk_widget_set_redraw_on_allocate(self, redraw_on_allocate)
# proc set_redraw_on_allocate*(self: Widget, redraw_on_allocate: bool) {.inline.} =

# gtk_widget_set_sensitive
# flags: {isMethod} container: Widget
# need sugar: is method
# sensitive 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_sensitive(self: ptr TWidget, sensitive: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_sensitive".}
proc set_sensitive*(self: Widget, sensitive: bool) {.inline.} =
  gtk_widget_set_sensitive(self, sensitive)
# proc set_sensitive*(self: Widget, sensitive: bool) {.inline.} =

# gtk_widget_set_size_request
# flags: {isMethod} container: Widget
# need sugar: is method
# width 'int32' 'int32' IN
# height 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_size_request(self: ptr TWidget, width: int32, height: int32) {.cdecl, dynlib: lib, importc: "gtk_widget_set_size_request".}
proc set_size_request*(self: Widget, width: int32, height: int32) {.inline.} =
  gtk_widget_set_size_request(self, width, height)
# proc set_size_request*(self: Widget, width: int32, height: int32) {.inline.} =

# gtk_widget_set_state
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_set_state_flags
# flags: {isMethod} container: Widget
# need sugar: is method
# flags 'SStateFlags' 'SStateFlags' IN
# clear 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_state_flags(self: ptr TWidget, flags: SStateFlags, clear: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_state_flags".}
proc set_state_flags*(self: Widget, flags: SStateFlags, clear: bool) {.inline.} =
  gtk_widget_set_state_flags(self, flags, clear)
# proc set_state_flags*(self: Widget, flags: SStateFlags, clear: bool) {.inline.} =

# gtk_widget_set_style
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_set_support_multidevice
# flags: {isMethod} container: Widget
# need sugar: is method
# support_multidevice 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_support_multidevice(self: ptr TWidget, support_multidevice: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_support_multidevice".}
proc set_support_multidevice*(self: Widget, support_multidevice: bool) {.inline.} =
  gtk_widget_set_support_multidevice(self, support_multidevice)
# proc set_support_multidevice*(self: Widget, support_multidevice: bool) {.inline.} =

# gtk_widget_set_tooltip_markup
# flags: {isMethod} container: Widget
# need sugar: is method
# markup 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_tooltip_markup(self: ptr TWidget, markup: ucstring) {.cdecl, dynlib: lib, importc: "gtk_widget_set_tooltip_markup".}
proc set_tooltip_markup*(self: Widget, markup: ustring) {.inline.} =
  gtk_widget_set_tooltip_markup(self, ucstring(markup))
# proc set_tooltip_markup*(self: Widget, markup: ustring) {.inline.} =

# gtk_widget_set_tooltip_text
# flags: {isMethod} container: Widget
# need sugar: is method
# text 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_tooltip_text(self: ptr TWidget, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_widget_set_tooltip_text".}
proc set_tooltip_text*(self: Widget, text: ustring) {.inline.} =
  gtk_widget_set_tooltip_text(self, ucstring(text))
# proc set_tooltip_text*(self: Widget, text: ustring) {.inline.} =

# gtk_widget_set_tooltip_window
# flags: {isMethod} container: Widget
# need sugar: is method
# custom_window 'Window' 'ptr TWindow' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_tooltip_window(self: ptr TWidget, custom_window: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_widget_set_tooltip_window".}
proc set_tooltip_window*(self: Widget, custom_window: Window) {.inline.} =
  gtk_widget_set_tooltip_window(self, custom_window.getPointer)
# proc set_tooltip_window*(self: Widget, custom_window: Window) {.inline.} =

# gtk_widget_set_valign
# flags: {isMethod} container: Widget
# need sugar: is method
# align 'Align' 'Align' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_valign(self: ptr TWidget, align: Align) {.cdecl, dynlib: lib, importc: "gtk_widget_set_valign".}
proc set_valign*(self: Widget, align: Align) {.inline.} =
  gtk_widget_set_valign(self, align)
# proc set_valign*(self: Widget, align: Align) {.inline.} =

# gtk_widget_set_vexpand
# flags: {isMethod} container: Widget
# need sugar: is method
# expand 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_vexpand(self: ptr TWidget, expand: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_vexpand".}
proc set_vexpand*(self: Widget, expand: bool) {.inline.} =
  gtk_widget_set_vexpand(self, expand)
# proc set_vexpand*(self: Widget, expand: bool) {.inline.} =

# gtk_widget_set_vexpand_set
# flags: {isMethod} container: Widget
# need sugar: is method
# set 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_vexpand_set(self: ptr TWidget, set: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_vexpand_set".}
proc set_vexpand_set*(self: Widget, set: bool) {.inline.} =
  gtk_widget_set_vexpand_set(self, set)
# proc set_vexpand_set*(self: Widget, set: bool) {.inline.} =

# gtk_widget_set_visible
# flags: {isMethod} container: Widget
# need sugar: is method
# visible 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_visible(self: ptr TWidget, visible: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_visible".}
proc set_visible*(self: Widget, visible: bool) {.inline.} =
  gtk_widget_set_visible(self, visible)
# proc set_visible*(self: Widget, visible: bool) {.inline.} =

# gtk_widget_set_visual
# flags: {isMethod} container: Widget
# need sugar: is method
# visual 'Gdk3.Visual' 'ptr Gdk3.TVisual' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_visual(self: ptr TWidget, visual: ptr Gdk3.TVisual) {.cdecl, dynlib: lib, importc: "gtk_widget_set_visual".}
proc set_visual*(self: Widget, visual: Gdk3.Visual) {.inline.} =
  gtk_widget_set_visual(self, visual.getPointer)
# proc set_visual*(self: Widget, visual: Gdk3.Visual) {.inline.} =

# gtk_widget_set_window
# flags: {isMethod} container: Widget
# need sugar: is method
# window 'Gdk3.Window' 'ptr Gdk3.TWindow' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_window(self: ptr TWidget, window: ptr Gdk3.TWindow) {.cdecl, dynlib: lib, importc: "gtk_widget_set_window".}
proc set_window*(self: Widget, window: Gdk3.Window) {.inline.} =
  gtk_widget_set_window(self, window.getPointer)
# proc set_window*(self: Widget, window: Gdk3.Window) {.inline.} =

# gtk_widget_shape_combine_region
# flags: {isMethod} container: Widget
# need sugar: is method
# region 'cairo1.TRegion' 'ptr cairo1.TRegion' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_shape_combine_region(self: ptr TWidget, region: ptr cairo1.TRegion) {.cdecl, dynlib: lib, importc: "gtk_widget_shape_combine_region".}
proc shape_combine_region*(self: Widget, region: cairo1.TRegion) {.inline.} =
  gtk_widget_shape_combine_region(self, myUnsafeAddr(region))
# proc shape_combine_region*(self: Widget, region: cairo1.TRegion) {.inline.} =

# gtk_widget_show
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_show(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_show".}
proc show*(self: Widget) {.inline.} =
  gtk_widget_show(self)
# proc show*(self: Widget) {.inline.} =

# gtk_widget_show_all
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_show_all(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_show_all".}
proc show_all*(self: Widget) {.inline.} =
  gtk_widget_show_all(self)
# proc show_all*(self: Widget) {.inline.} =

# gtk_widget_show_now
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_show_now(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_show_now".}
proc show_now*(self: Widget) {.inline.} =
  gtk_widget_show_now(self)
# proc show_now*(self: Widget) {.inline.} =

# gtk_widget_size_allocate
# flags: {isMethod} container: Widget
# need sugar: is method
# allocation 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_size_allocate(self: ptr TWidget, allocation: ptr cairo1.TRectangleInt) {.cdecl, dynlib: lib, importc: "gtk_widget_size_allocate".}
proc size_allocate*(self: Widget, allocation: cairo1.TRectangleInt) {.inline.} =
  gtk_widget_size_allocate(self, myUnsafeAddr(allocation))
# proc size_allocate*(self: Widget, allocation: cairo1.TRectangleInt) {.inline.} =

# gtk_widget_size_allocate_with_baseline
# flags: {isMethod} container: Widget
# need sugar: is method
# allocation 'cairo1.TRectangleInt' 'ptr cairo1.TRectangleInt' IN (diff., need sugar)
# baseline 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_size_allocate_with_baseline(self: ptr TWidget, allocation: ptr cairo1.TRectangleInt, baseline: int32) {.cdecl, dynlib: lib, importc: "gtk_widget_size_allocate_with_baseline".}
proc size_allocate_with_baseline*(self: Widget, allocation: cairo1.TRectangleInt, baseline: int32) {.inline.} =
  gtk_widget_size_allocate_with_baseline(self, myUnsafeAddr(allocation), baseline)
# proc size_allocate_with_baseline*(self: Widget, allocation: cairo1.TRectangleInt, baseline: int32) {.inline.} =

# gtk_widget_size_request
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_style_attach
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_style_get_property
# flags: {isMethod} container: Widget
# need sugar: is method
# property_name 'ustring' 'ucstring' IN (diff., need sugar)
# value 'GObject2.TValue' 'ptr GObject2.TValue' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_style_get_property(self: ptr TWidget, property_name: ucstring, value: ptr GObject2.TValue) {.cdecl, dynlib: lib, importc: "gtk_widget_style_get_property".}
proc style_get_property*(self: Widget, property_name: ustring, value: GObject2.TValue) {.inline.} =
  gtk_widget_style_get_property(self, ucstring(property_name), myUnsafeAddr(value))
# proc style_get_property*(self: Widget, property_name: ustring, value: GObject2.TValue) {.inline.} =

# gtk_widget_thaw_child_notify
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_thaw_child_notify(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_thaw_child_notify".}
proc thaw_child_notify*(self: Widget) {.inline.} =
  gtk_widget_thaw_child_notify(self)
# proc thaw_child_notify*(self: Widget) {.inline.} =

# gtk_widget_translate_coordinates
# flags: {isMethod} container: Widget
# need sugar: is method
# dest_widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# src_x 'int32' 'int32' IN
# src_y 'int32' 'int32' IN
# dest_x 'var int32' 'ptr int32' OUT (diff., need sugar)
# dest_y 'var int32' 'ptr int32' OUT (diff., need sugar)
# 'bool' 'bool'
proc gtk_widget_translate_coordinates(self: ptr TWidget, dest_widget: ptr TWidget, src_x: int32, src_y: int32, dest_x: ptr int32, dest_y: ptr int32): bool {.cdecl, dynlib: lib, importc: "gtk_widget_translate_coordinates".}
proc translate_coordinates*(self: Widget, dest_widget: Widget, src_x: int32, src_y: int32, dest_x: var int32, dest_y: var int32): bool {.inline.} =
  gtk_widget_translate_coordinates(self, dest_widget.getPointer, src_x, src_y, addr(dest_x), addr(dest_y))
# tuple-return
# dest_x: var int32
# dest_y: var int32
# proc translate_coordinates*(self: Widget, dest_widget: Widget, src_x: int32, src_y: int32): bool {.inline.} =

# gtk_widget_trigger_tooltip_query
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_trigger_tooltip_query(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_trigger_tooltip_query".}
proc trigger_tooltip_query*(self: Widget) {.inline.} =
  gtk_widget_trigger_tooltip_query(self)
# proc trigger_tooltip_query*(self: Widget) {.inline.} =

# gtk_widget_unmap
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_unmap(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_unmap".}
proc unmap*(self: Widget) {.inline.} =
  gtk_widget_unmap(self)
# proc unmap*(self: Widget) {.inline.} =

# gtk_widget_unparent
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_unparent(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_unparent".}
proc unparent*(self: Widget) {.inline.} =
  gtk_widget_unparent(self)
# proc unparent*(self: Widget) {.inline.} =

# gtk_widget_unrealize
# flags: {isMethod} container: Widget
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_unrealize(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_unrealize".}
proc unrealize*(self: Widget) {.inline.} =
  gtk_widget_unrealize(self)
# proc unrealize*(self: Widget) {.inline.} =

# gtk_widget_unregister_window
# flags: {isMethod} container: Widget
# need sugar: is method
# window 'Gdk3.Window' 'ptr Gdk3.TWindow' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_unregister_window(self: ptr TWidget, window: ptr Gdk3.TWindow) {.cdecl, dynlib: lib, importc: "gtk_widget_unregister_window".}
proc unregister_window*(self: Widget, window: Gdk3.Window) {.inline.} =
  gtk_widget_unregister_window(self, window.getPointer)
# proc unregister_window*(self: Widget, window: Gdk3.Window) {.inline.} =

# gtk_widget_unset_state_flags
# flags: {isMethod} container: Widget
# need sugar: is method
# flags 'SStateFlags' 'SStateFlags' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_unset_state_flags(self: ptr TWidget, flags: SStateFlags) {.cdecl, dynlib: lib, importc: "gtk_widget_unset_state_flags".}
proc unset_state_flags*(self: Widget, flags: SStateFlags) {.inline.} =
  gtk_widget_unset_state_flags(self, flags)
# proc unset_state_flags*(self: Widget, flags: SStateFlags) {.inline.} =

# gtk_window_new
# flags: {isConstructor} container: Window
# need sugar: is static method
# type 'WindowType' 'WindowType' IN
# 'Window' 'TransferNone[TWindow]' (diff., need sugar)
proc gtk_window_new(type_x: WindowType): TransferNone[TWindow] {.cdecl, dynlib: lib, importc: "gtk_window_new".}
proc new_window*(type_x: WindowType): Window {.inline.} =
  wrap(gtk_window_new(type_x))
# proc new_window*(type_x: WindowType): Window {.inline.} =

# gtk_window_get_default_icon_list
# flags: {} container: Window
# need sugar: is static method
# 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_window_get_default_icon_list(): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_window_get_default_icon_list".}
template get_default_icon_list*(klass_parameter: typedesc[Window]): ptr GLIST_TODO =
  gtk_window_get_default_icon_list()
# template get_default_icon_list*(klass_parameter: typedesc[Window]): ptr GLIST_TODO =

# gtk_window_get_default_icon_name
# flags: {} container: Window
# need sugar: is static method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_window_get_default_icon_name(): ucstring {.cdecl, dynlib: lib, importc: "gtk_window_get_default_icon_name".}
template get_default_icon_name*(klass_parameter: typedesc[Window]): ustring =
  ustring($(gtk_window_get_default_icon_name()))
# template get_default_icon_name*(klass_parameter: typedesc[Window]): ustring =

# gtk_window_list_toplevels
# flags: {} container: Window
# need sugar: is static method
# 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_window_list_toplevels(): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_window_list_toplevels".}
template list_toplevels*(klass_parameter: typedesc[Window]): ptr GLIST_TODO =
  gtk_window_list_toplevels()
# template list_toplevels*(klass_parameter: typedesc[Window]): ptr GLIST_TODO =

# gtk_window_set_auto_startup_notification
# flags: {} container: Window
# need sugar: is static method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_auto_startup_notification(setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_auto_startup_notification".}
template set_auto_startup_notification*(klass_parameter: typedesc[Window], setting: bool) =
  gtk_window_set_auto_startup_notification(setting)
# template set_auto_startup_notification*(klass_parameter: typedesc[Window], setting: bool) =

# gtk_window_set_default_icon
# flags: {} container: Window
# need sugar: is static method
# icon 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_default_icon(icon: ptr GdkPixbuf2.TPixbuf) {.cdecl, dynlib: lib, importc: "gtk_window_set_default_icon".}
template set_default_icon*(klass_parameter: typedesc[Window], icon: GdkPixbuf2.Pixbuf) =
  gtk_window_set_default_icon(icon.getPointer)
# template set_default_icon*(klass_parameter: typedesc[Window], icon: GdkPixbuf2.Pixbuf) =

# gtk_window_set_default_icon_from_file
# flags: {throws} container: Window
# can throw
# need sugar: is static method
# filename 'string' 'cstring' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_window_set_default_icon_from_file(filename: cstring, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_window_set_default_icon_from_file".}
template set_default_icon_from_file*(klass_parameter: typedesc[Window], filename: string): bool =
  gtk_window_set_default_icon_from_file(cstring(filename))
# template set_default_icon_from_file*(klass_parameter: typedesc[Window], filename: string): bool =

# gtk_window_set_default_icon_list
# flags: {} container: Window
# need sugar: is static method
# list 'ptr GLIST_TODO' 'ptr GLIST_TODO' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_default_icon_list(list: ptr GLIST_TODO) {.cdecl, dynlib: lib, importc: "gtk_window_set_default_icon_list".}
template set_default_icon_list*(klass_parameter: typedesc[Window], list: ptr GLIST_TODO) =
  gtk_window_set_default_icon_list(list)
# template set_default_icon_list*(klass_parameter: typedesc[Window], list: ptr GLIST_TODO) =

# gtk_window_set_default_icon_name
# flags: {} container: Window
# need sugar: is static method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_default_icon_name(name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_window_set_default_icon_name".}
template set_default_icon_name*(klass_parameter: typedesc[Window], name: ustring) =
  gtk_window_set_default_icon_name(ucstring(name))
# template set_default_icon_name*(klass_parameter: typedesc[Window], name: ustring) =

# gtk_window_set_interactive_debugging
# flags: {} container: Window
# need sugar: is static method
# enable 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_interactive_debugging(enable: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_interactive_debugging".}
template set_interactive_debugging*(klass_parameter: typedesc[Window], enable: bool) =
  gtk_window_set_interactive_debugging(enable)
# template set_interactive_debugging*(klass_parameter: typedesc[Window], enable: bool) =

# gtk_window_activate_default
# flags: {isMethod} container: Window
# need sugar: is method
# 'bool' 'bool'
proc gtk_window_activate_default(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_activate_default".}
proc activate_default*(self: Window): bool {.inline.} =
  gtk_window_activate_default(self)
# proc activate_default*(self: Window): bool {.inline.} =

# gtk_window_activate_focus
# flags: {isMethod} container: Window
# need sugar: is method
# 'bool' 'bool'
proc gtk_window_activate_focus(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_activate_focus".}
proc activate_focus*(self: Window): bool {.inline.} =
  gtk_window_activate_focus(self)
# proc activate_focus*(self: Window): bool {.inline.} =

# gtk_window_activate_key
# flags: {isMethod} container: Window
# need sugar: is method
# event 'Gdk3.TEventKey' 'ptr Gdk3.TEventKey' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_window_activate_key(self: ptr TWindow, event: ptr Gdk3.TEventKey): bool {.cdecl, dynlib: lib, importc: "gtk_window_activate_key".}
proc activate_key*(self: Window, event: Gdk3.TEventKey): bool {.inline.} =
  gtk_window_activate_key(self, myUnsafeAddr(event))
# proc activate_key*(self: Window, event: Gdk3.TEventKey): bool {.inline.} =

# gtk_window_add_accel_group
# flags: {isMethod} container: Window
# need sugar: is method
# accel_group 'AccelGroup' 'ptr TAccelGroup' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_add_accel_group(self: ptr TWindow, accel_group: ptr TAccelGroup) {.cdecl, dynlib: lib, importc: "gtk_window_add_accel_group".}
proc add_accel_group*(self: Window, accel_group: AccelGroup) {.inline.} =
  gtk_window_add_accel_group(self, accel_group.getPointer)
# proc add_accel_group*(self: Window, accel_group: AccelGroup) {.inline.} =

# gtk_window_add_mnemonic
# flags: {isMethod} container: Window
# need sugar: is method
# keyval 'uint32' 'uint32' IN
# target 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_add_mnemonic(self: ptr TWindow, keyval: uint32, target: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_window_add_mnemonic".}
proc add_mnemonic*(self: Window, keyval: uint32, target: Widget) {.inline.} =
  gtk_window_add_mnemonic(self, keyval, target.getPointer)
# proc add_mnemonic*(self: Window, keyval: uint32, target: Widget) {.inline.} =

# gtk_window_begin_move_drag
# flags: {isMethod} container: Window
# need sugar: is method
# button 'int32' 'int32' IN
# root_x 'int32' 'int32' IN
# root_y 'int32' 'int32' IN
# timestamp 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_begin_move_drag(self: ptr TWindow, button: int32, root_x: int32, root_y: int32, timestamp: uint32) {.cdecl, dynlib: lib, importc: "gtk_window_begin_move_drag".}
proc begin_move_drag*(self: Window, button: int32, root_x: int32, root_y: int32, timestamp: uint32) {.inline.} =
  gtk_window_begin_move_drag(self, button, root_x, root_y, timestamp)
# proc begin_move_drag*(self: Window, button: int32, root_x: int32, root_y: int32, timestamp: uint32) {.inline.} =

# gtk_window_begin_resize_drag
# flags: {isMethod} container: Window
# need sugar: is method
# edge 'Gdk3.WindowEdge' 'Gdk3.WindowEdge' IN
# button 'int32' 'int32' IN
# root_x 'int32' 'int32' IN
# root_y 'int32' 'int32' IN
# timestamp 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_begin_resize_drag(self: ptr TWindow, edge: Gdk3.WindowEdge, button: int32, root_x: int32, root_y: int32, timestamp: uint32) {.cdecl, dynlib: lib, importc: "gtk_window_begin_resize_drag".}
proc begin_resize_drag*(self: Window, edge: Gdk3.WindowEdge, button: int32, root_x: int32, root_y: int32, timestamp: uint32) {.inline.} =
  gtk_window_begin_resize_drag(self, edge, button, root_x, root_y, timestamp)
# proc begin_resize_drag*(self: Window, edge: Gdk3.WindowEdge, button: int32, root_x: int32, root_y: int32, timestamp: uint32) {.inline.} =

# gtk_window_close
# flags: {isMethod} container: Window
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_close(self: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_window_close".}
proc close*(self: Window) {.inline.} =
  gtk_window_close(self)
# proc close*(self: Window) {.inline.} =

# gtk_window_deiconify
# flags: {isMethod} container: Window
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_deiconify(self: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_window_deiconify".}
proc deiconify*(self: Window) {.inline.} =
  gtk_window_deiconify(self)
# proc deiconify*(self: Window) {.inline.} =

# gtk_window_fullscreen
# flags: {isMethod} container: Window
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_fullscreen(self: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_window_fullscreen".}
proc fullscreen*(self: Window) {.inline.} =
  gtk_window_fullscreen(self)
# proc fullscreen*(self: Window) {.inline.} =

# gtk_window_get_accept_focus
# flags: {isMethod} container: Window
# need sugar: is method
# 'bool' 'bool'
proc gtk_window_get_accept_focus(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_get_accept_focus".}
proc get_accept_focus*(self: Window): bool {.inline.} =
  gtk_window_get_accept_focus(self)
# proc get_accept_focus*(self: Window): bool {.inline.} =

# gtk_window_get_application
# flags: {isMethod} container: Window
# need sugar: is method
# 'Application' 'TransferNone[TApplication]' (diff., need sugar)
proc gtk_window_get_application(self: ptr TWindow): TransferNone[TApplication] {.cdecl, dynlib: lib, importc: "gtk_window_get_application".}
proc get_application*(self: Window): Application {.inline.} =
  wrap(gtk_window_get_application(self))
# proc get_application*(self: Window): Application {.inline.} =

# gtk_window_get_attached_to
# flags: {isMethod} container: Window
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_window_get_attached_to(self: ptr TWindow): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_window_get_attached_to".}
proc get_attached_to*(self: Window): Widget {.inline.} =
  wrap(gtk_window_get_attached_to(self))
# proc get_attached_to*(self: Window): Widget {.inline.} =

# gtk_window_get_decorated
# flags: {isMethod} container: Window
# need sugar: is method
# 'bool' 'bool'
proc gtk_window_get_decorated(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_get_decorated".}
proc get_decorated*(self: Window): bool {.inline.} =
  gtk_window_get_decorated(self)
# proc get_decorated*(self: Window): bool {.inline.} =

# gtk_window_get_default_size
# flags: {isMethod} container: Window
# need sugar: is method
# width 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# height 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_get_default_size(self: ptr TWindow, width: ptr int32, height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_window_get_default_size".}
proc get_default_size*(self: Window, width: var int32, height: var int32) {.inline.} =
  gtk_window_get_default_size(self, addr(width), addr(height))
# tuple-return
# width: var int32
# height: var int32
# proc get_default_size*(self: Window) {.inline.} =

# gtk_window_get_default_widget
# flags: {isMethod} container: Window
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_window_get_default_widget(self: ptr TWindow): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_window_get_default_widget".}
proc get_default_widget*(self: Window): Widget {.inline.} =
  wrap(gtk_window_get_default_widget(self))
# proc get_default_widget*(self: Window): Widget {.inline.} =

# gtk_window_get_deletable
# flags: {isMethod} container: Window
# need sugar: is method
# 'bool' 'bool'
proc gtk_window_get_deletable(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_get_deletable".}
proc get_deletable*(self: Window): bool {.inline.} =
  gtk_window_get_deletable(self)
# proc get_deletable*(self: Window): bool {.inline.} =

# gtk_window_get_destroy_with_parent
# flags: {isMethod} container: Window
# need sugar: is method
# 'bool' 'bool'
proc gtk_window_get_destroy_with_parent(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_get_destroy_with_parent".}
proc get_destroy_with_parent*(self: Window): bool {.inline.} =
  gtk_window_get_destroy_with_parent(self)
# proc get_destroy_with_parent*(self: Window): bool {.inline.} =

# gtk_window_get_focus
# flags: {isMethod} container: Window
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_window_get_focus(self: ptr TWindow): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_window_get_focus".}
proc get_focus*(self: Window): Widget {.inline.} =
  wrap(gtk_window_get_focus(self))
# proc get_focus*(self: Window): Widget {.inline.} =

# gtk_window_get_focus_on_map
# flags: {isMethod} container: Window
# need sugar: is method
# 'bool' 'bool'
proc gtk_window_get_focus_on_map(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_get_focus_on_map".}
proc get_focus_on_map*(self: Window): bool {.inline.} =
  gtk_window_get_focus_on_map(self)
# proc get_focus_on_map*(self: Window): bool {.inline.} =

# gtk_window_get_focus_visible
# flags: {isMethod} container: Window
# need sugar: is method
# 'bool' 'bool'
proc gtk_window_get_focus_visible(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_get_focus_visible".}
proc get_focus_visible*(self: Window): bool {.inline.} =
  gtk_window_get_focus_visible(self)
# proc get_focus_visible*(self: Window): bool {.inline.} =

# gtk_window_get_gravity
# flags: {isMethod} container: Window
# need sugar: is method
# 'Gdk3.Gravity' 'Gdk3.Gravity'
proc gtk_window_get_gravity(self: ptr TWindow): Gdk3.Gravity {.cdecl, dynlib: lib, importc: "gtk_window_get_gravity".}
proc get_gravity*(self: Window): Gdk3.Gravity {.inline.} =
  gtk_window_get_gravity(self)
# proc get_gravity*(self: Window): Gdk3.Gravity {.inline.} =

# gtk_window_get_group
# flags: {isMethod} container: Window
# need sugar: is method
# 'WindowGroup' 'TransferNone[TWindowGroup]' (diff., need sugar)
proc gtk_window_get_group(self: ptr TWindow): TransferNone[TWindowGroup] {.cdecl, dynlib: lib, importc: "gtk_window_get_group".}
proc get_group*(self: Window): WindowGroup {.inline.} =
  wrap(gtk_window_get_group(self))
# proc get_group*(self: Window): WindowGroup {.inline.} =

# gtk_window_get_has_resize_grip
# flags: {isMethod} container: Window (deprecated)
# gtk_window_get_hide_titlebar_when_maximized
# flags: {isMethod} container: Window
# need sugar: is method
# 'bool' 'bool'
proc gtk_window_get_hide_titlebar_when_maximized(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_get_hide_titlebar_when_maximized".}
proc get_hide_titlebar_when_maximized*(self: Window): bool {.inline.} =
  gtk_window_get_hide_titlebar_when_maximized(self)
# proc get_hide_titlebar_when_maximized*(self: Window): bool {.inline.} =

# gtk_window_get_icon
# flags: {isMethod} container: Window
# need sugar: is method
# 'GdkPixbuf2.Pixbuf' 'TransferNone[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_window_get_icon(self: ptr TWindow): TransferNone[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_window_get_icon".}
proc get_icon*(self: Window): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_window_get_icon(self))
# proc get_icon*(self: Window): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_window_get_icon_list
# flags: {isMethod} container: Window
# need sugar: is method
# 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_window_get_icon_list(self: ptr TWindow): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_window_get_icon_list".}
proc get_icon_list*(self: Window): ptr GLIST_TODO {.inline.} =
  gtk_window_get_icon_list(self)
# proc get_icon_list*(self: Window): ptr GLIST_TODO {.inline.} =

# gtk_window_get_icon_name
# flags: {isMethod} container: Window
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_window_get_icon_name(self: ptr TWindow): ucstring {.cdecl, dynlib: lib, importc: "gtk_window_get_icon_name".}
proc get_icon_name*(self: Window): ustring {.inline.} =
  ustring($(gtk_window_get_icon_name(self)))
# proc get_icon_name*(self: Window): ustring {.inline.} =

# gtk_window_get_mnemonic_modifier
# flags: {isMethod} container: Window
# need sugar: is method
# 'Gdk3.SModifierType' 'Gdk3.SModifierType'
proc gtk_window_get_mnemonic_modifier(self: ptr TWindow): Gdk3.SModifierType {.cdecl, dynlib: lib, importc: "gtk_window_get_mnemonic_modifier".}
proc get_mnemonic_modifier*(self: Window): Gdk3.SModifierType {.inline.} =
  gtk_window_get_mnemonic_modifier(self)
# proc get_mnemonic_modifier*(self: Window): Gdk3.SModifierType {.inline.} =

# gtk_window_get_mnemonics_visible
# flags: {isMethod} container: Window
# need sugar: is method
# 'bool' 'bool'
proc gtk_window_get_mnemonics_visible(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_get_mnemonics_visible".}
proc get_mnemonics_visible*(self: Window): bool {.inline.} =
  gtk_window_get_mnemonics_visible(self)
# proc get_mnemonics_visible*(self: Window): bool {.inline.} =

# gtk_window_get_modal
# flags: {isMethod} container: Window
# need sugar: is method
# 'bool' 'bool'
proc gtk_window_get_modal(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_get_modal".}
proc get_modal*(self: Window): bool {.inline.} =
  gtk_window_get_modal(self)
# proc get_modal*(self: Window): bool {.inline.} =

# gtk_window_get_opacity
# flags: {isMethod} container: Window (deprecated)
# gtk_window_get_position
# flags: {isMethod} container: Window
# need sugar: is method
# root_x 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# root_y 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_get_position(self: ptr TWindow, root_x: ptr int32, root_y: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_window_get_position".}
proc get_position*(self: Window, root_x: var int32, root_y: var int32) {.inline.} =
  gtk_window_get_position(self, addr(root_x), addr(root_y))
# tuple-return
# root_x: var int32
# root_y: var int32
# proc get_position*(self: Window) {.inline.} =

# gtk_window_get_resizable
# flags: {isMethod} container: Window
# need sugar: is method
# 'bool' 'bool'
proc gtk_window_get_resizable(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_get_resizable".}
proc get_resizable*(self: Window): bool {.inline.} =
  gtk_window_get_resizable(self)
# proc get_resizable*(self: Window): bool {.inline.} =

# gtk_window_get_resize_grip_area
# flags: {isMethod} container: Window (deprecated)
# gtk_window_get_role
# flags: {isMethod} container: Window
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_window_get_role(self: ptr TWindow): ucstring {.cdecl, dynlib: lib, importc: "gtk_window_get_role".}
proc get_role*(self: Window): ustring {.inline.} =
  ustring($(gtk_window_get_role(self)))
# proc get_role*(self: Window): ustring {.inline.} =

# gtk_window_get_screen
# flags: {isMethod} container: Window
# need sugar: is method
# 'Gdk3.Screen' 'TransferNone[Gdk3.TScreen]' (diff., need sugar)
proc gtk_window_get_screen(self: ptr TWindow): TransferNone[Gdk3.TScreen] {.cdecl, dynlib: lib, importc: "gtk_window_get_screen".}
proc get_screen*(self: Window): Gdk3.Screen {.inline.} =
  wrap(gtk_window_get_screen(self))
# proc get_screen*(self: Window): Gdk3.Screen {.inline.} =

# gtk_window_get_size
# flags: {isMethod} container: Window
# need sugar: is method
# width 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# height 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_get_size(self: ptr TWindow, width: ptr int32, height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_window_get_size".}
proc get_size*(self: Window, width: var int32, height: var int32) {.inline.} =
  gtk_window_get_size(self, addr(width), addr(height))
# tuple-return
# width: var int32
# height: var int32
# proc get_size*(self: Window) {.inline.} =

# gtk_window_get_skip_pager_hint
# flags: {isMethod} container: Window
# need sugar: is method
# 'bool' 'bool'
proc gtk_window_get_skip_pager_hint(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_get_skip_pager_hint".}
proc get_skip_pager_hint*(self: Window): bool {.inline.} =
  gtk_window_get_skip_pager_hint(self)
# proc get_skip_pager_hint*(self: Window): bool {.inline.} =

# gtk_window_get_skip_taskbar_hint
# flags: {isMethod} container: Window
# need sugar: is method
# 'bool' 'bool'
proc gtk_window_get_skip_taskbar_hint(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_get_skip_taskbar_hint".}
proc get_skip_taskbar_hint*(self: Window): bool {.inline.} =
  gtk_window_get_skip_taskbar_hint(self)
# proc get_skip_taskbar_hint*(self: Window): bool {.inline.} =

# gtk_window_get_title
# flags: {isMethod} container: Window
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_window_get_title(self: ptr TWindow): ucstring {.cdecl, dynlib: lib, importc: "gtk_window_get_title".}
proc get_title*(self: Window): ustring {.inline.} =
  ustring($(gtk_window_get_title(self)))
# proc get_title*(self: Window): ustring {.inline.} =

# gtk_window_get_transient_for
# flags: {isMethod} container: Window
# need sugar: is method
# 'Window' 'TransferNone[TWindow]' (diff., need sugar)
proc gtk_window_get_transient_for(self: ptr TWindow): TransferNone[TWindow] {.cdecl, dynlib: lib, importc: "gtk_window_get_transient_for".}
proc get_transient_for*(self: Window): Window {.inline.} =
  wrap(gtk_window_get_transient_for(self))
# proc get_transient_for*(self: Window): Window {.inline.} =

# gtk_window_get_type_hint
# flags: {isMethod} container: Window
# need sugar: is method
# 'Gdk3.WindowTypeHint' 'Gdk3.WindowTypeHint'
proc gtk_window_get_type_hint(self: ptr TWindow): Gdk3.WindowTypeHint {.cdecl, dynlib: lib, importc: "gtk_window_get_type_hint".}
proc get_type_hint*(self: Window): Gdk3.WindowTypeHint {.inline.} =
  gtk_window_get_type_hint(self)
# proc get_type_hint*(self: Window): Gdk3.WindowTypeHint {.inline.} =

# gtk_window_get_urgency_hint
# flags: {isMethod} container: Window
# need sugar: is method
# 'bool' 'bool'
proc gtk_window_get_urgency_hint(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_get_urgency_hint".}
proc get_urgency_hint*(self: Window): bool {.inline.} =
  gtk_window_get_urgency_hint(self)
# proc get_urgency_hint*(self: Window): bool {.inline.} =

# gtk_window_get_window_type
# flags: {isMethod} container: Window
# need sugar: is method
# 'WindowType' 'WindowType'
proc gtk_window_get_window_type(self: ptr TWindow): WindowType {.cdecl, dynlib: lib, importc: "gtk_window_get_window_type".}
proc get_window_type*(self: Window): WindowType {.inline.} =
  gtk_window_get_window_type(self)
# proc get_window_type*(self: Window): WindowType {.inline.} =

# gtk_window_has_group
# flags: {isMethod} container: Window
# need sugar: is method
# 'bool' 'bool'
proc gtk_window_has_group(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_has_group".}
proc has_group*(self: Window): bool {.inline.} =
  gtk_window_has_group(self)
# proc has_group*(self: Window): bool {.inline.} =

# gtk_window_has_toplevel_focus
# flags: {isMethod} container: Window
# need sugar: is method
# 'bool' 'bool'
proc gtk_window_has_toplevel_focus(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_has_toplevel_focus".}
proc has_toplevel_focus*(self: Window): bool {.inline.} =
  gtk_window_has_toplevel_focus(self)
# proc has_toplevel_focus*(self: Window): bool {.inline.} =

# gtk_window_iconify
# flags: {isMethod} container: Window
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_iconify(self: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_window_iconify".}
proc iconify*(self: Window) {.inline.} =
  gtk_window_iconify(self)
# proc iconify*(self: Window) {.inline.} =

# gtk_window_is_active
# flags: {isMethod} container: Window
# need sugar: is method
# 'bool' 'bool'
proc gtk_window_is_active(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_is_active".}
proc is_active*(self: Window): bool {.inline.} =
  gtk_window_is_active(self)
# proc is_active*(self: Window): bool {.inline.} =

# gtk_window_is_maximized
# flags: {isMethod} container: Window
# need sugar: is method
# 'bool' 'bool'
proc gtk_window_is_maximized(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_is_maximized".}
proc is_maximized*(self: Window): bool {.inline.} =
  gtk_window_is_maximized(self)
# proc is_maximized*(self: Window): bool {.inline.} =

# gtk_window_maximize
# flags: {isMethod} container: Window
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_maximize(self: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_window_maximize".}
proc maximize*(self: Window) {.inline.} =
  gtk_window_maximize(self)
# proc maximize*(self: Window) {.inline.} =

# gtk_window_mnemonic_activate
# flags: {isMethod} container: Window
# need sugar: is method
# keyval 'uint32' 'uint32' IN
# modifier 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# 'bool' 'bool'
proc gtk_window_mnemonic_activate(self: ptr TWindow, keyval: uint32, modifier: Gdk3.SModifierType): bool {.cdecl, dynlib: lib, importc: "gtk_window_mnemonic_activate".}
proc mnemonic_activate*(self: Window, keyval: uint32, modifier: Gdk3.SModifierType): bool {.inline.} =
  gtk_window_mnemonic_activate(self, keyval, modifier)
# proc mnemonic_activate*(self: Window, keyval: uint32, modifier: Gdk3.SModifierType): bool {.inline.} =

# gtk_window_move
# flags: {isMethod} container: Window
# need sugar: is method
# x 'int32' 'int32' IN
# y 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_move(self: ptr TWindow, x: int32, y: int32) {.cdecl, dynlib: lib, importc: "gtk_window_move".}
proc move*(self: Window, x: int32, y: int32) {.inline.} =
  gtk_window_move(self, x, y)
# proc move*(self: Window, x: int32, y: int32) {.inline.} =

# gtk_window_parse_geometry
# flags: {isMethod} container: Window
# need sugar: is method
# geometry 'ustring' 'ucstring' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_window_parse_geometry(self: ptr TWindow, geometry: ucstring): bool {.cdecl, dynlib: lib, importc: "gtk_window_parse_geometry".}
proc parse_geometry*(self: Window, geometry: ustring): bool {.inline.} =
  gtk_window_parse_geometry(self, ucstring(geometry))
# proc parse_geometry*(self: Window, geometry: ustring): bool {.inline.} =

# gtk_window_present
# flags: {isMethod} container: Window
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_present(self: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_window_present".}
proc present*(self: Window) {.inline.} =
  gtk_window_present(self)
# proc present*(self: Window) {.inline.} =

# gtk_window_present_with_time
# flags: {isMethod} container: Window
# need sugar: is method
# timestamp 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_present_with_time(self: ptr TWindow, timestamp: uint32) {.cdecl, dynlib: lib, importc: "gtk_window_present_with_time".}
proc present_with_time*(self: Window, timestamp: uint32) {.inline.} =
  gtk_window_present_with_time(self, timestamp)
# proc present_with_time*(self: Window, timestamp: uint32) {.inline.} =

# gtk_window_propagate_key_event
# flags: {isMethod} container: Window
# need sugar: is method
# event 'Gdk3.TEventKey' 'ptr Gdk3.TEventKey' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_window_propagate_key_event(self: ptr TWindow, event: ptr Gdk3.TEventKey): bool {.cdecl, dynlib: lib, importc: "gtk_window_propagate_key_event".}
proc propagate_key_event*(self: Window, event: Gdk3.TEventKey): bool {.inline.} =
  gtk_window_propagate_key_event(self, myUnsafeAddr(event))
# proc propagate_key_event*(self: Window, event: Gdk3.TEventKey): bool {.inline.} =

# gtk_window_remove_accel_group
# flags: {isMethod} container: Window
# need sugar: is method
# accel_group 'AccelGroup' 'ptr TAccelGroup' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_remove_accel_group(self: ptr TWindow, accel_group: ptr TAccelGroup) {.cdecl, dynlib: lib, importc: "gtk_window_remove_accel_group".}
proc remove_accel_group*(self: Window, accel_group: AccelGroup) {.inline.} =
  gtk_window_remove_accel_group(self, accel_group.getPointer)
# proc remove_accel_group*(self: Window, accel_group: AccelGroup) {.inline.} =

# gtk_window_remove_mnemonic
# flags: {isMethod} container: Window
# need sugar: is method
# keyval 'uint32' 'uint32' IN
# target 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_remove_mnemonic(self: ptr TWindow, keyval: uint32, target: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_window_remove_mnemonic".}
proc remove_mnemonic*(self: Window, keyval: uint32, target: Widget) {.inline.} =
  gtk_window_remove_mnemonic(self, keyval, target.getPointer)
# proc remove_mnemonic*(self: Window, keyval: uint32, target: Widget) {.inline.} =

# gtk_window_reshow_with_initial_size
# flags: {isMethod} container: Window (deprecated)
# gtk_window_resize
# flags: {isMethod} container: Window
# need sugar: is method
# width 'int32' 'int32' IN
# height 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_resize(self: ptr TWindow, width: int32, height: int32) {.cdecl, dynlib: lib, importc: "gtk_window_resize".}
proc resize*(self: Window, width: int32, height: int32) {.inline.} =
  gtk_window_resize(self, width, height)
# proc resize*(self: Window, width: int32, height: int32) {.inline.} =

# gtk_window_resize_grip_is_visible
# flags: {isMethod} container: Window (deprecated)
# gtk_window_resize_to_geometry
# flags: {isMethod} container: Window
# need sugar: is method
# width 'int32' 'int32' IN
# height 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_resize_to_geometry(self: ptr TWindow, width: int32, height: int32) {.cdecl, dynlib: lib, importc: "gtk_window_resize_to_geometry".}
proc resize_to_geometry*(self: Window, width: int32, height: int32) {.inline.} =
  gtk_window_resize_to_geometry(self, width, height)
# proc resize_to_geometry*(self: Window, width: int32, height: int32) {.inline.} =

# gtk_window_set_accept_focus
# flags: {isMethod} container: Window
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_accept_focus(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_accept_focus".}
proc set_accept_focus*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_accept_focus(self, setting)
# proc set_accept_focus*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_application
# flags: {isMethod} container: Window
# need sugar: is method
# application 'Application' 'ptr TApplication' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_application(self: ptr TWindow, application: ptr TApplication) {.cdecl, dynlib: lib, importc: "gtk_window_set_application".}
proc set_application*(self: Window, application: Application) {.inline.} =
  gtk_window_set_application(self, application.getPointer)
# proc set_application*(self: Window, application: Application) {.inline.} =

# gtk_window_set_attached_to
# flags: {isMethod} container: Window
# need sugar: is method
# attach_widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_attached_to(self: ptr TWindow, attach_widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_window_set_attached_to".}
proc set_attached_to*(self: Window, attach_widget: Widget) {.inline.} =
  gtk_window_set_attached_to(self, attach_widget.getPointer)
# proc set_attached_to*(self: Window, attach_widget: Widget) {.inline.} =

# gtk_window_set_decorated
# flags: {isMethod} container: Window
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_decorated(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_decorated".}
proc set_decorated*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_decorated(self, setting)
# proc set_decorated*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_default
# flags: {isMethod} container: Window
# need sugar: is method
# default_widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_default(self: ptr TWindow, default_widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_window_set_default".}
proc set_default*(self: Window, default_widget: Widget) {.inline.} =
  gtk_window_set_default(self, default_widget.getPointer)
# proc set_default*(self: Window, default_widget: Widget) {.inline.} =

# gtk_window_set_default_geometry
# flags: {isMethod} container: Window
# need sugar: is method
# width 'int32' 'int32' IN
# height 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_default_geometry(self: ptr TWindow, width: int32, height: int32) {.cdecl, dynlib: lib, importc: "gtk_window_set_default_geometry".}
proc set_default_geometry*(self: Window, width: int32, height: int32) {.inline.} =
  gtk_window_set_default_geometry(self, width, height)
# proc set_default_geometry*(self: Window, width: int32, height: int32) {.inline.} =

# gtk_window_set_default_size
# flags: {isMethod} container: Window
# need sugar: is method
# width 'int32' 'int32' IN
# height 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_default_size(self: ptr TWindow, width: int32, height: int32) {.cdecl, dynlib: lib, importc: "gtk_window_set_default_size".}
proc set_default_size*(self: Window, width: int32, height: int32) {.inline.} =
  gtk_window_set_default_size(self, width, height)
# proc set_default_size*(self: Window, width: int32, height: int32) {.inline.} =

# gtk_window_set_deletable
# flags: {isMethod} container: Window
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_deletable(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_deletable".}
proc set_deletable*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_deletable(self, setting)
# proc set_deletable*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_destroy_with_parent
# flags: {isMethod} container: Window
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_destroy_with_parent(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_destroy_with_parent".}
proc set_destroy_with_parent*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_destroy_with_parent(self, setting)
# proc set_destroy_with_parent*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_focus
# flags: {isMethod} container: Window
# need sugar: is method
# focus 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_focus(self: ptr TWindow, focus: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_window_set_focus".}
proc set_focus*(self: Window, focus: Widget) {.inline.} =
  gtk_window_set_focus(self, focus.getPointer)
# proc set_focus*(self: Window, focus: Widget) {.inline.} =

# gtk_window_set_focus_on_map
# flags: {isMethod} container: Window
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_focus_on_map(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_focus_on_map".}
proc set_focus_on_map*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_focus_on_map(self, setting)
# proc set_focus_on_map*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_focus_visible
# flags: {isMethod} container: Window
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_focus_visible(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_focus_visible".}
proc set_focus_visible*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_focus_visible(self, setting)
# proc set_focus_visible*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_geometry_hints
# flags: {isMethod} container: Window
# need sugar: is method
# geometry_widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# geometry 'Gdk3.TGeometry' 'ptr Gdk3.TGeometry' IN (diff., need sugar)
# geom_mask 'Gdk3.SWindowHints' 'Gdk3.SWindowHints' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_geometry_hints(self: ptr TWindow, geometry_widget: ptr TWidget, geometry: ptr Gdk3.TGeometry, geom_mask: Gdk3.SWindowHints) {.cdecl, dynlib: lib, importc: "gtk_window_set_geometry_hints".}
proc set_geometry_hints*(self: Window, geometry_widget: Widget, geometry: Gdk3.TGeometry, geom_mask: Gdk3.SWindowHints) {.inline.} =
  gtk_window_set_geometry_hints(self, geometry_widget.getPointer, myUnsafeAddr(geometry), geom_mask)
# proc set_geometry_hints*(self: Window, geometry_widget: Widget, geometry: Gdk3.TGeometry, geom_mask: Gdk3.SWindowHints) {.inline.} =

# gtk_window_set_gravity
# flags: {isMethod} container: Window
# need sugar: is method
# gravity 'Gdk3.Gravity' 'Gdk3.Gravity' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_gravity(self: ptr TWindow, gravity: Gdk3.Gravity) {.cdecl, dynlib: lib, importc: "gtk_window_set_gravity".}
proc set_gravity*(self: Window, gravity: Gdk3.Gravity) {.inline.} =
  gtk_window_set_gravity(self, gravity)
# proc set_gravity*(self: Window, gravity: Gdk3.Gravity) {.inline.} =

# gtk_window_set_has_resize_grip
# flags: {isMethod} container: Window (deprecated)
# gtk_window_set_has_user_ref_count
# flags: {isMethod} container: Window
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_has_user_ref_count(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_has_user_ref_count".}
proc set_has_user_ref_count*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_has_user_ref_count(self, setting)
# proc set_has_user_ref_count*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_hide_titlebar_when_maximized
# flags: {isMethod} container: Window
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_hide_titlebar_when_maximized(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_hide_titlebar_when_maximized".}
proc set_hide_titlebar_when_maximized*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_hide_titlebar_when_maximized(self, setting)
# proc set_hide_titlebar_when_maximized*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_icon
# flags: {isMethod} container: Window
# need sugar: is method
# icon 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_icon(self: ptr TWindow, icon: ptr GdkPixbuf2.TPixbuf) {.cdecl, dynlib: lib, importc: "gtk_window_set_icon".}
proc set_icon*(self: Window, icon: GdkPixbuf2.Pixbuf) {.inline.} =
  gtk_window_set_icon(self, icon.getPointer)
# proc set_icon*(self: Window, icon: GdkPixbuf2.Pixbuf) {.inline.} =

# gtk_window_set_icon_from_file
# flags: {isMethod, throws} container: Window
# can throw
# need sugar: is method
# filename 'string' 'cstring' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_window_set_icon_from_file(self: ptr TWindow, filename: cstring, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_window_set_icon_from_file".}
proc set_icon_from_file*(self: Window, filename: string): bool {.inline.} =
  gtk_window_set_icon_from_file(self, cstring(filename))
# proc set_icon_from_file*(self: Window, filename: string): bool {.inline.} =

# gtk_window_set_icon_list
# flags: {isMethod} container: Window
# need sugar: is method
# list 'ptr GLIST_TODO' 'ptr GLIST_TODO' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_icon_list(self: ptr TWindow, list: ptr GLIST_TODO) {.cdecl, dynlib: lib, importc: "gtk_window_set_icon_list".}
proc set_icon_list*(self: Window, list: ptr GLIST_TODO) {.inline.} =
  gtk_window_set_icon_list(self, list)
# proc set_icon_list*(self: Window, list: ptr GLIST_TODO) {.inline.} =

# gtk_window_set_icon_name
# flags: {isMethod} container: Window
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_icon_name(self: ptr TWindow, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_window_set_icon_name".}
proc set_icon_name*(self: Window, name: ustring) {.inline.} =
  gtk_window_set_icon_name(self, ucstring(name))
# proc set_icon_name*(self: Window, name: ustring) {.inline.} =

# gtk_window_set_keep_above
# flags: {isMethod} container: Window
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_keep_above(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_keep_above".}
proc set_keep_above*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_keep_above(self, setting)
# proc set_keep_above*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_keep_below
# flags: {isMethod} container: Window
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_keep_below(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_keep_below".}
proc set_keep_below*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_keep_below(self, setting)
# proc set_keep_below*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_mnemonic_modifier
# flags: {isMethod} container: Window
# need sugar: is method
# modifier 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_mnemonic_modifier(self: ptr TWindow, modifier: Gdk3.SModifierType) {.cdecl, dynlib: lib, importc: "gtk_window_set_mnemonic_modifier".}
proc set_mnemonic_modifier*(self: Window, modifier: Gdk3.SModifierType) {.inline.} =
  gtk_window_set_mnemonic_modifier(self, modifier)
# proc set_mnemonic_modifier*(self: Window, modifier: Gdk3.SModifierType) {.inline.} =

# gtk_window_set_mnemonics_visible
# flags: {isMethod} container: Window
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_mnemonics_visible(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_mnemonics_visible".}
proc set_mnemonics_visible*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_mnemonics_visible(self, setting)
# proc set_mnemonics_visible*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_modal
# flags: {isMethod} container: Window
# need sugar: is method
# modal 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_modal(self: ptr TWindow, modal: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_modal".}
proc set_modal*(self: Window, modal: bool) {.inline.} =
  gtk_window_set_modal(self, modal)
# proc set_modal*(self: Window, modal: bool) {.inline.} =

# gtk_window_set_opacity
# flags: {isMethod} container: Window (deprecated)
# gtk_window_set_position
# flags: {isMethod} container: Window
# need sugar: is method
# position 'WindowPosition' 'WindowPosition' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_position(self: ptr TWindow, position: WindowPosition) {.cdecl, dynlib: lib, importc: "gtk_window_set_position".}
proc set_position*(self: Window, position: WindowPosition) {.inline.} =
  gtk_window_set_position(self, position)
# proc set_position*(self: Window, position: WindowPosition) {.inline.} =

# gtk_window_set_resizable
# flags: {isMethod} container: Window
# need sugar: is method
# resizable 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_resizable(self: ptr TWindow, resizable: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_resizable".}
proc set_resizable*(self: Window, resizable: bool) {.inline.} =
  gtk_window_set_resizable(self, resizable)
# proc set_resizable*(self: Window, resizable: bool) {.inline.} =

# gtk_window_set_role
# flags: {isMethod} container: Window
# need sugar: is method
# role 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_role(self: ptr TWindow, role: ucstring) {.cdecl, dynlib: lib, importc: "gtk_window_set_role".}
proc set_role*(self: Window, role: ustring) {.inline.} =
  gtk_window_set_role(self, ucstring(role))
# proc set_role*(self: Window, role: ustring) {.inline.} =

# gtk_window_set_screen
# flags: {isMethod} container: Window
# need sugar: is method
# screen 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_screen(self: ptr TWindow, screen: ptr Gdk3.TScreen) {.cdecl, dynlib: lib, importc: "gtk_window_set_screen".}
proc set_screen*(self: Window, screen: Gdk3.Screen) {.inline.} =
  gtk_window_set_screen(self, screen.getPointer)
# proc set_screen*(self: Window, screen: Gdk3.Screen) {.inline.} =

# gtk_window_set_skip_pager_hint
# flags: {isMethod} container: Window
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_skip_pager_hint(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_skip_pager_hint".}
proc set_skip_pager_hint*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_skip_pager_hint(self, setting)
# proc set_skip_pager_hint*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_skip_taskbar_hint
# flags: {isMethod} container: Window
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_skip_taskbar_hint(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_skip_taskbar_hint".}
proc set_skip_taskbar_hint*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_skip_taskbar_hint(self, setting)
# proc set_skip_taskbar_hint*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_startup_id
# flags: {isMethod} container: Window
# need sugar: is method
# startup_id 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_startup_id(self: ptr TWindow, startup_id: ucstring) {.cdecl, dynlib: lib, importc: "gtk_window_set_startup_id".}
proc set_startup_id*(self: Window, startup_id: ustring) {.inline.} =
  gtk_window_set_startup_id(self, ucstring(startup_id))
# proc set_startup_id*(self: Window, startup_id: ustring) {.inline.} =

# gtk_window_set_title
# flags: {isMethod} container: Window
# need sugar: is method
# title 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_title(self: ptr TWindow, title: ucstring) {.cdecl, dynlib: lib, importc: "gtk_window_set_title".}
proc set_title*(self: Window, title: ustring) {.inline.} =
  gtk_window_set_title(self, ucstring(title))
# proc set_title*(self: Window, title: ustring) {.inline.} =

# gtk_window_set_titlebar
# flags: {isMethod} container: Window
# need sugar: is method
# titlebar 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_titlebar(self: ptr TWindow, titlebar: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_window_set_titlebar".}
proc set_titlebar*(self: Window, titlebar: Widget) {.inline.} =
  gtk_window_set_titlebar(self, titlebar.getPointer)
# proc set_titlebar*(self: Window, titlebar: Widget) {.inline.} =

# gtk_window_set_transient_for
# flags: {isMethod} container: Window
# need sugar: is method
# parent 'Window' 'ptr TWindow' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_transient_for(self: ptr TWindow, parent: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_window_set_transient_for".}
proc set_transient_for*(self: Window, parent: Window) {.inline.} =
  gtk_window_set_transient_for(self, parent.getPointer)
# proc set_transient_for*(self: Window, parent: Window) {.inline.} =

# gtk_window_set_type_hint
# flags: {isMethod} container: Window
# need sugar: is method
# hint 'Gdk3.WindowTypeHint' 'Gdk3.WindowTypeHint' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_type_hint(self: ptr TWindow, hint: Gdk3.WindowTypeHint) {.cdecl, dynlib: lib, importc: "gtk_window_set_type_hint".}
proc set_type_hint*(self: Window, hint: Gdk3.WindowTypeHint) {.inline.} =
  gtk_window_set_type_hint(self, hint)
# proc set_type_hint*(self: Window, hint: Gdk3.WindowTypeHint) {.inline.} =

# gtk_window_set_urgency_hint
# flags: {isMethod} container: Window
# need sugar: is method
# setting 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_urgency_hint(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_urgency_hint".}
proc set_urgency_hint*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_urgency_hint(self, setting)
# proc set_urgency_hint*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_wmclass
# flags: {isMethod} container: Window
# need sugar: is method
# wmclass_name 'ustring' 'ucstring' IN (diff., need sugar)
# wmclass_class 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_wmclass(self: ptr TWindow, wmclass_name: ucstring, wmclass_class: ucstring) {.cdecl, dynlib: lib, importc: "gtk_window_set_wmclass".}
proc set_wmclass*(self: Window, wmclass_name: ustring, wmclass_class: ustring) {.inline.} =
  gtk_window_set_wmclass(self, ucstring(wmclass_name), ucstring(wmclass_class))
# proc set_wmclass*(self: Window, wmclass_name: ustring, wmclass_class: ustring) {.inline.} =

# gtk_window_stick
# flags: {isMethod} container: Window
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_stick(self: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_window_stick".}
proc stick*(self: Window) {.inline.} =
  gtk_window_stick(self)
# proc stick*(self: Window) {.inline.} =

# gtk_window_unfullscreen
# flags: {isMethod} container: Window
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_unfullscreen(self: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_window_unfullscreen".}
proc unfullscreen*(self: Window) {.inline.} =
  gtk_window_unfullscreen(self)
# proc unfullscreen*(self: Window) {.inline.} =

# gtk_window_unmaximize
# flags: {isMethod} container: Window
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_unmaximize(self: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_window_unmaximize".}
proc unmaximize*(self: Window) {.inline.} =
  gtk_window_unmaximize(self)
# proc unmaximize*(self: Window) {.inline.} =

# gtk_window_unstick
# flags: {isMethod} container: Window
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_unstick(self: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_window_unstick".}
proc unstick*(self: Window) {.inline.} =
  gtk_window_unstick(self)
# proc unstick*(self: Window) {.inline.} =

# gtk_window_group_new
# flags: {isConstructor} container: WindowGroup
# need sugar: is static method
# 'WindowGroup' 'TransferFull[TWindowGroup]' (diff., need sugar)
proc gtk_window_group_new(): TransferFull[TWindowGroup] {.cdecl, dynlib: lib, importc: "gtk_window_group_new".}
proc new_windowgroup*(): WindowGroup {.inline.} =
  wrap(gtk_window_group_new())
# proc new_windowgroup*(): WindowGroup {.inline.} =

# gtk_window_group_add_window
# flags: {isMethod} container: WindowGroup
# need sugar: is method
# window 'Window' 'ptr TWindow' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_group_add_window(self: ptr TWindowGroup, window: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_window_group_add_window".}
proc add_window*(self: WindowGroup, window: Window) {.inline.} =
  gtk_window_group_add_window(self, window.getPointer)
# proc add_window*(self: WindowGroup, window: Window) {.inline.} =

# gtk_window_group_get_current_device_grab
# flags: {isMethod} container: WindowGroup
# need sugar: is method
# device 'Gdk3.Device' 'ptr Gdk3.TDevice' IN (diff., need sugar)
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_window_group_get_current_device_grab(self: ptr TWindowGroup, device: ptr Gdk3.TDevice): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_window_group_get_current_device_grab".}
proc get_current_device_grab*(self: WindowGroup, device: Gdk3.Device): Widget {.inline.} =
  wrap(gtk_window_group_get_current_device_grab(self, device.getPointer))
# proc get_current_device_grab*(self: WindowGroup, device: Gdk3.Device): Widget {.inline.} =

# gtk_window_group_get_current_grab
# flags: {isMethod} container: WindowGroup
# need sugar: is method
# 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_window_group_get_current_grab(self: ptr TWindowGroup): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_window_group_get_current_grab".}
proc get_current_grab*(self: WindowGroup): Widget {.inline.} =
  wrap(gtk_window_group_get_current_grab(self))
# proc get_current_grab*(self: WindowGroup): Widget {.inline.} =

# gtk_window_group_list_windows
# flags: {isMethod} container: WindowGroup
# need sugar: is method
# 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_window_group_list_windows(self: ptr TWindowGroup): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_window_group_list_windows".}
proc list_windows*(self: WindowGroup): ptr GLIST_TODO {.inline.} =
  gtk_window_group_list_windows(self)
# proc list_windows*(self: WindowGroup): ptr GLIST_TODO {.inline.} =

# gtk_window_group_remove_window
# flags: {isMethod} container: WindowGroup
# need sugar: is method
# window 'Window' 'ptr TWindow' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_window_group_remove_window(self: ptr TWindowGroup, window: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_window_group_remove_window".}
proc remove_window*(self: WindowGroup, window: Window) {.inline.} =
  gtk_window_group_remove_window(self, window.getPointer)
# proc remove_window*(self: WindowGroup, window: Window) {.inline.} =

# object signals
#------------------
# AboutDialog - activate-link - uri 
declareSignal(AboutDialog, TAboutDialog, activate_link, uri, ustring)
# AccelGroup - accel-activate - acceleratable keyval modifier 
# AccelGroup - accel-changed - keyval modifier accel_closure 
# AccelMap - changed - accel_path accel_key accel_mods 
# Action - activate - 
declareSignal(Action, TAction, activate)
# ActionGroup - connect-proxy - action proxy 
# ActionGroup - disconnect-proxy - action proxy 
# ActionGroup - post-activate - action 
declareSignal(ActionGroup, TActionGroup, post_activate, action, Action)
# ActionGroup - pre-activate - action 
declareSignal(ActionGroup, TActionGroup, pre_activate, action, Action)
# Adjustment - changed - 
declareSignal(Adjustment, TAdjustment, changed)
# Adjustment - value-changed - 
declareSignal(Adjustment, TAdjustment, value_changed)
# AppChooserButton - custom-item-activated - item_name 
declareSignal(AppChooserButton, TAppChooserButton, custom_item_activated, item_name, ustring)
# AppChooserWidget - application-activated - application 
declareSignal(AppChooserWidget, TAppChooserWidget, application_activated, application, Gio2.AppInfo)
# AppChooserWidget - application-selected - application 
declareSignal(AppChooserWidget, TAppChooserWidget, application_selected, application, Gio2.AppInfo)
# AppChooserWidget - populate-popup - menu application 
# Application - window-added - window 
declareSignal(Application, TApplication, window_added, window, Window)
# Application - window-removed - window 
declareSignal(Application, TApplication, window_removed, window, Window)
# Assistant - apply - 
declareSignal(Assistant, TAssistant, apply)
# Assistant - cancel - 
declareSignal(Assistant, TAssistant, cancel)
# Assistant - close - 
declareSignal(Assistant, TAssistant, close)
# Assistant - escape - 
declareSignal(Assistant, TAssistant, escape)
# Assistant - prepare - page 
declareSignal(Assistant, TAssistant, prepare, page, Widget)
# Button - activate - 
declareSignal(Button, TButton, activate)
# Button - clicked - 
declareSignal(Button, TButton, clicked)
# Button - enter - 
declareSignal(Button, TButton, enter)
# Button - leave - 
declareSignal(Button, TButton, leave)
# Button - pressed - 
declareSignal(Button, TButton, pressed)
# Button - released - 
declareSignal(Button, TButton, released)
# Calendar - day-selected - 
declareSignal(Calendar, TCalendar, day_selected)
# Calendar - day-selected-double-click - 
declareSignal(Calendar, TCalendar, day_selected_double_click)
# Calendar - month-changed - 
declareSignal(Calendar, TCalendar, month_changed)
# Calendar - next-month - 
declareSignal(Calendar, TCalendar, next_month)
# Calendar - next-year - 
declareSignal(Calendar, TCalendar, next_year)
# Calendar - prev-month - 
declareSignal(Calendar, TCalendar, prev_month)
# Calendar - prev-year - 
declareSignal(Calendar, TCalendar, prev_year)
# CellArea - add-editable - renderer editable cell_area path 
# CellArea - apply-attributes - model iter is_expander is_expanded 
# CellArea - focus-changed - renderer path 
# CellArea - remove-editable - renderer editable 
# CellRenderer - editing-canceled - 
declareSignal(CellRenderer, TCellRenderer, editing_canceled)
# CellRenderer - editing-started - editable path 
# CellRendererAccel - accel-cleared - path_string 
declareSignal(CellRendererAccel, TCellRendererAccel, accel_cleared, path_string, ustring)
# CellRendererAccel - accel-edited - path_string accel_key accel_mods hardware_keycode 
# CellRendererCombo - changed - path_string new_iter 
# CellRendererText - edited - path new_text 
# CellRendererToggle - toggled - path 
declareSignal(CellRendererToggle, TCellRendererToggle, toggled, path, ustring)
# CheckMenuItem - toggled - 
declareSignal(CheckMenuItem, TCheckMenuItem, toggled)
# Clipboard - owner-change - event 
declareSignal(Clipboard, TClipboard, owner_change, event, Gdk3.TEventOwnerChange)
# ColorButton - color-set - 
declareSignal(ColorButton, TColorButton, color_set)
# ColorSelection - color-changed - 
declareSignal(ColorSelection, TColorSelection, color_changed)
# ComboBox - changed - 
declareSignal(ComboBox, TComboBox, changed)
# ComboBox - format-entry-text - path 
declareSignal(ComboBox, TComboBox, format_entry_text, path, ustring)
# ComboBox - move-active - scroll_type 
declareSignal(ComboBox, TComboBox, move_active, scroll_type, ScrollType)
# ComboBox - popdown - 
declareSignal(ComboBox, TComboBox, popdown)
# ComboBox - popup - 
declareSignal(ComboBox, TComboBox, popup)
# Container - add - object 
declareSignal(Container, TContainer, add, object_x, Widget)
# Container - check-resize - 
declareSignal(Container, TContainer, check_resize)
# Container - remove - object 
declareSignal(Container, TContainer, remove, object_x, Widget)
# Container - set-focus-child - object 
declareSignal(Container, TContainer, set_focus_child, object_x, Widget)
# CssProvider - parsing-error - section error 
# Dialog - close - 
declareSignal(Dialog, TDialog, close)
# Dialog - response - response_id 
declareSignal(Dialog, TDialog, response, response_id, int32)
# Entry - activate - 
declareSignal(Entry, TEntry, activate)
# Entry - backspace - 
declareSignal(Entry, TEntry, backspace)
# Entry - copy-clipboard - 
declareSignal(Entry, TEntry, copy_clipboard)
# Entry - cut-clipboard - 
declareSignal(Entry, TEntry, cut_clipboard)
# Entry - delete-from-cursor - type count 
# Entry - icon-press - icon_pos event 
# Entry - icon-release - icon_pos event 
# Entry - insert-at-cursor - string 
declareSignal(Entry, TEntry, insert_at_cursor, string, ustring)
# Entry - move-cursor - step count extend_selection 
# Entry - paste-clipboard - 
declareSignal(Entry, TEntry, paste_clipboard)
# Entry - populate-popup - popup 
declareSignal(Entry, TEntry, populate_popup, popup, Widget)
# Entry - preedit-changed - preedit 
declareSignal(Entry, TEntry, preedit_changed, preedit, ustring)
# Entry - toggle-overwrite - 
declareSignal(Entry, TEntry, toggle_overwrite)
# EntryBuffer - deleted-text - position n_chars 
# EntryBuffer - inserted-text - position chars n_chars 
# EntryCompletion - action-activated - index 
declareSignal(EntryCompletion, TEntryCompletion, action_activated, index, int32)
# EntryCompletion - cursor-on-match - model iter 
# EntryCompletion - insert-prefix - prefix 
declareSignal(EntryCompletion, TEntryCompletion, insert_prefix, prefix, ustring)
# EntryCompletion - match-selected - model iter 
# EntryCompletion - no-matches - 
declareSignal(EntryCompletion, TEntryCompletion, no_matches)
# Expander - activate - 
declareSignal(Expander, TExpander, activate)
# FileChooserButton - file-set - 
declareSignal(FileChooserButton, TFileChooserButton, file_set)
# FileChooserWidget - desktop-folder - 
declareSignal(FileChooserWidget, TFileChooserWidget, desktop_folder)
# FileChooserWidget - down-folder - 
declareSignal(FileChooserWidget, TFileChooserWidget, down_folder)
# FileChooserWidget - home-folder - 
declareSignal(FileChooserWidget, TFileChooserWidget, home_folder)
# FileChooserWidget - location-popup - path 
declareSignal(FileChooserWidget, TFileChooserWidget, location_popup, path, ustring)
# FileChooserWidget - location-popup-on-paste - 
declareSignal(FileChooserWidget, TFileChooserWidget, location_popup_on_paste)
# FileChooserWidget - location-toggle-popup - 
declareSignal(FileChooserWidget, TFileChooserWidget, location_toggle_popup)
# FileChooserWidget - quick-bookmark - bookmark_index 
declareSignal(FileChooserWidget, TFileChooserWidget, quick_bookmark, bookmark_index, int32)
# FileChooserWidget - recent-shortcut - 
declareSignal(FileChooserWidget, TFileChooserWidget, recent_shortcut)
# FileChooserWidget - search-shortcut - 
declareSignal(FileChooserWidget, TFileChooserWidget, search_shortcut)
# FileChooserWidget - show-hidden - 
declareSignal(FileChooserWidget, TFileChooserWidget, show_hidden)
# FileChooserWidget - up-folder - 
declareSignal(FileChooserWidget, TFileChooserWidget, up_folder)
# FlowBox - activate-cursor-child - 
declareSignal(FlowBox, TFlowBox, activate_cursor_child)
# FlowBox - child-activated - child 
declareSignal(FlowBox, TFlowBox, child_activated, child, FlowBoxChild)
# FlowBox - move-cursor - step count 
# FlowBox - select-all - 
declareSignal(FlowBox, TFlowBox, select_all)
# FlowBox - selected-children-changed - 
declareSignal(FlowBox, TFlowBox, selected_children_changed)
# FlowBox - toggle-cursor-child - 
declareSignal(FlowBox, TFlowBox, toggle_cursor_child)
# FlowBox - unselect-all - 
declareSignal(FlowBox, TFlowBox, unselect_all)
# FlowBoxChild - activate - 
declareSignal(FlowBoxChild, TFlowBoxChild, activate)
# FontButton - font-set - 
declareSignal(FontButton, TFontButton, font_set)
# Gesture - begin - sequence 
declareSignal(Gesture, TGesture, begin, sequence, Gdk3.TEventSequence)
# Gesture - cancel - sequence 
declareSignal(Gesture, TGesture, cancel, sequence, Gdk3.TEventSequence)
# Gesture - end - sequence 
declareSignal(Gesture, TGesture, end_x, sequence, Gdk3.TEventSequence)
# Gesture - sequence-state-changed - sequence state 
# Gesture - update - sequence 
declareSignal(Gesture, TGesture, update, sequence, Gdk3.TEventSequence)
# GestureDrag - drag-begin - start_x start_y 
# GestureDrag - drag-end - offset_x offset_y 
# GestureDrag - drag-update - offset_x offset_y 
# GestureLongPress - cancelled - 
declareSignal(GestureLongPress, TGestureLongPress, cancelled)
# GestureLongPress - pressed - x y 
# GestureMultiPress - pressed - n_press x y 
# GestureMultiPress - released - n_press x y 
# GestureMultiPress - stopped - 
declareSignal(GestureMultiPress, TGestureMultiPress, stopped)
# GesturePan - pan - direction offset 
# GestureRotate - angle-changed - angle angle_delta 
# GestureSwipe - swipe - velocity_x velocity_y 
# GestureZoom - scale-changed - scale 
declareSignal(GestureZoom, TGestureZoom, scale_changed, scale, float64)
# HSV - changed - 
declareSignal(HSV, THSV, changed)
# HSV - move - object 
declareSignal(HSV, THSV, move, object_x, DirectionType)
# HandleBox - child-attached - widget 
declareSignal(HandleBox, THandleBox, child_attached, widget, Widget)
# HandleBox - child-detached - widget 
declareSignal(HandleBox, THandleBox, child_detached, widget, Widget)
# IMContext - commit - str 
declareSignal(IMContext, TIMContext, commit, str, ustring)
# IMContext - delete-surrounding - offset n_chars 
# IMContext - preedit-changed - 
declareSignal(IMContext, TIMContext, preedit_changed)
# IMContext - preedit-end - 
declareSignal(IMContext, TIMContext, preedit_end)
# IMContext - preedit-start - 
declareSignal(IMContext, TIMContext, preedit_start)
# IMContext - retrieve-surrounding - 
declareSignal(IMContext, TIMContext, retrieve_surrounding)
# IconTheme - changed - 
declareSignal(IconTheme, TIconTheme, changed)
# IconView - activate-cursor-item - 
declareSignal(IconView, TIconView, activate_cursor_item)
# IconView - item-activated - path 
declareSignal(IconView, TIconView, item_activated, path, TTreePath)
# IconView - move-cursor - step count 
# IconView - select-all - 
declareSignal(IconView, TIconView, select_all)
# IconView - select-cursor-item - 
declareSignal(IconView, TIconView, select_cursor_item)
# IconView - selection-changed - 
declareSignal(IconView, TIconView, selection_changed)
# IconView - toggle-cursor-item - 
declareSignal(IconView, TIconView, toggle_cursor_item)
# IconView - unselect-all - 
declareSignal(IconView, TIconView, unselect_all)
# InfoBar - close - 
declareSignal(InfoBar, TInfoBar, close)
# InfoBar - response - response_id 
declareSignal(InfoBar, TInfoBar, response, response_id, int32)
# Label - activate-current-link - 
declareSignal(Label, TLabel, activate_current_link)
# Label - activate-link - uri 
declareSignal(Label, TLabel, activate_link, uri, ustring)
# Label - copy-clipboard - 
declareSignal(Label, TLabel, copy_clipboard)
# Label - move-cursor - step count extend_selection 
# Label - populate-popup - menu 
declareSignal(Label, TLabel, populate_popup, menu, Menu)
# LevelBar - offset-changed - name 
declareSignal(LevelBar, TLevelBar, offset_changed, name, ustring)
# LinkButton - activate-link - 
declareSignal(LinkButton, TLinkButton, activate_link)
# ListBox - activate-cursor-row - 
declareSignal(ListBox, TListBox, activate_cursor_row)
# ListBox - move-cursor - object p0 
# ListBox - row-activated - row 
declareSignal(ListBox, TListBox, row_activated, row, ListBoxRow)
# ListBox - row-selected - row 
declareSignal(ListBox, TListBox, row_selected, row, ListBoxRow)
# ListBox - select-all - 
declareSignal(ListBox, TListBox, select_all)
# ListBox - selected-rows-changed - 
declareSignal(ListBox, TListBox, selected_rows_changed)
# ListBox - toggle-cursor-row - 
declareSignal(ListBox, TListBox, toggle_cursor_row)
# ListBox - unselect-all - 
declareSignal(ListBox, TListBox, unselect_all)
# ListBoxRow - activate - 
declareSignal(ListBoxRow, TListBoxRow, activate)
# Menu - move-scroll - scroll_type 
declareSignal(Menu, TMenu, move_scroll, scroll_type, ScrollType)
# MenuItem - activate - 
declareSignal(MenuItem, TMenuItem, activate)
# MenuItem - activate-item - 
declareSignal(MenuItem, TMenuItem, activate_item)
# MenuItem - deselect - 
declareSignal(MenuItem, TMenuItem, deselect)
# MenuItem - select - 
declareSignal(MenuItem, TMenuItem, select)
# MenuItem - toggle-size-allocate - object 
declareSignal(MenuItem, TMenuItem, toggle_size_allocate, object_x, int32)
# MenuItem - toggle-size-request - object 
declareSignal(MenuItem, TMenuItem, toggle_size_request, object_x, pointer)
# MenuShell - activate-current - force_hide 
declareSignal(MenuShell, TMenuShell, activate_current, force_hide, bool)
# MenuShell - cancel - 
declareSignal(MenuShell, TMenuShell, cancel)
# MenuShell - cycle-focus - direction 
declareSignal(MenuShell, TMenuShell, cycle_focus, direction, DirectionType)
# MenuShell - deactivate - 
declareSignal(MenuShell, TMenuShell, deactivate)
# MenuShell - insert - child position 
# MenuShell - move-current - direction 
declareSignal(MenuShell, TMenuShell, move_current, direction, MenuDirectionType)
# MenuShell - move-selected - distance 
declareSignal(MenuShell, TMenuShell, move_selected, distance, int32)
# MenuShell - selection-done - 
declareSignal(MenuShell, TMenuShell, selection_done)
# MenuToolButton - show-menu - 
declareSignal(MenuToolButton, TMenuToolButton, show_menu)
# Notebook - change-current-page - object 
declareSignal(Notebook, TNotebook, change_current_page, object_x, int32)
# Notebook - create-window - page x y 
# Notebook - focus-tab - object 
declareSignal(Notebook, TNotebook, focus_tab, object_x, NotebookTab)
# Notebook - move-focus-out - object 
declareSignal(Notebook, TNotebook, move_focus_out, object_x, DirectionType)
# Notebook - page-added - child page_num 
# Notebook - page-removed - child page_num 
# Notebook - page-reordered - child page_num 
# Notebook - reorder-tab - object p0 
# Notebook - select-page - object 
declareSignal(Notebook, TNotebook, select_page, object_x, bool)
# Notebook - switch-page - page page_num 
# Overlay - get-child-position - widget allocation 
# Paned - accept-position - 
declareSignal(Paned, TPaned, accept_position)
# Paned - cancel-position - 
declareSignal(Paned, TPaned, cancel_position)
# Paned - cycle-child-focus - reversed 
declareSignal(Paned, TPaned, cycle_child_focus, reversed, bool)
# Paned - cycle-handle-focus - reversed 
declareSignal(Paned, TPaned, cycle_handle_focus, reversed, bool)
# Paned - move-handle - scroll_type 
declareSignal(Paned, TPaned, move_handle, scroll_type, ScrollType)
# Paned - toggle-handle-focus - 
declareSignal(Paned, TPaned, toggle_handle_focus)
# PlacesSidebar - drag-action-ask - actions 
declareSignal(PlacesSidebar, TPlacesSidebar, drag_action_ask, actions, int32)
# PlacesSidebar - drag-action-requested - context dest_file source_file_list 
# PlacesSidebar - drag-perform-drop - dest_file source_file_list action 
# PlacesSidebar - open-location - location open_flags 
# PlacesSidebar - populate-popup - menu selected_item selected_volume 
# PlacesSidebar - show-connect-to-server - 
declareSignal(PlacesSidebar, TPlacesSidebar, show_connect_to_server)
# PlacesSidebar - show-enter-location - 
declareSignal(PlacesSidebar, TPlacesSidebar, show_enter_location)
# PlacesSidebar - show-error-message - primary secondary 
# Popover - closed - 
declareSignal(Popover, TPopover, closed)
# PrintOperation - begin-print - context 
declareSignal(PrintOperation, TPrintOperation, begin_print, context, PrintContext)
# PrintOperation - create-custom-widget - 
declareSignal(PrintOperation, TPrintOperation, create_custom_widget)
# PrintOperation - custom-widget-apply - widget 
declareSignal(PrintOperation, TPrintOperation, custom_widget_apply, widget, Widget)
# PrintOperation - done - result 
declareSignal(PrintOperation, TPrintOperation, done, result_x, PrintOperationResult)
# PrintOperation - draw-page - context page_nr 
# PrintOperation - end-print - context 
declareSignal(PrintOperation, TPrintOperation, end_print, context, PrintContext)
# PrintOperation - paginate - context 
declareSignal(PrintOperation, TPrintOperation, paginate, context, PrintContext)
# PrintOperation - preview - preview context parent 
# PrintOperation - request-page-setup - context page_nr setup 
# PrintOperation - status-changed - 
declareSignal(PrintOperation, TPrintOperation, status_changed)
# PrintOperation - update-custom-widget - widget setup settings 
# RadioAction - changed - current 
declareSignal(RadioAction, TRadioAction, changed, current, RadioAction)
# RadioButton - group-changed - 
declareSignal(RadioButton, TRadioButton, group_changed)
# RadioMenuItem - group-changed - 
declareSignal(RadioMenuItem, TRadioMenuItem, group_changed)
# Range - adjust-bounds - value 
declareSignal(Range, TRange, adjust_bounds, value, float64)
# Range - change-value - scroll value 
# Range - move-slider - step 
declareSignal(Range, TRange, move_slider, step, ScrollType)
# Range - value-changed - 
declareSignal(Range, TRange, value_changed)
# RecentManager - changed - 
declareSignal(RecentManager, TRecentManager, changed)
# Scale - format-value - value 
declareSignal(Scale, TScale, format_value, value, float64)
# ScaleButton - popdown - 
declareSignal(ScaleButton, TScaleButton, popdown)
# ScaleButton - popup - 
declareSignal(ScaleButton, TScaleButton, popup)
# ScaleButton - value-changed - value 
declareSignal(ScaleButton, TScaleButton, value_changed, value, float64)
# ScrolledWindow - move-focus-out - direction_type 
declareSignal(ScrolledWindow, TScrolledWindow, move_focus_out, direction_type, DirectionType)
# ScrolledWindow - scroll-child - scroll horizontal 
# SearchEntry - search-changed - 
declareSignal(SearchEntry, TSearchEntry, search_changed)
# SpinButton - change-value - scroll 
declareSignal(SpinButton, TSpinButton, change_value, scroll, ScrollType)
# SpinButton - input - new_value 
declareSignal(SpinButton, TSpinButton, input, new_value, var float64)
# SpinButton - output - 
declareSignal(SpinButton, TSpinButton, output)
# SpinButton - value-changed - 
declareSignal(SpinButton, TSpinButton, value_changed)
# SpinButton - wrapped - 
declareSignal(SpinButton, TSpinButton, wrapped)
# StatusIcon - activate - 
declareSignal(StatusIcon, TStatusIcon, activate)
# StatusIcon - button-press-event - event 
declareSignal(StatusIcon, TStatusIcon, button_press_event, event, Gdk3.TEventButton)
# StatusIcon - button-release-event - event 
declareSignal(StatusIcon, TStatusIcon, button_release_event, event, Gdk3.TEventButton)
# StatusIcon - popup-menu - button activate_time 
# StatusIcon - query-tooltip - x y keyboard_mode tooltip 
# StatusIcon - scroll-event - event 
declareSignal(StatusIcon, TStatusIcon, scroll_event, event, Gdk3.TEventScroll)
# StatusIcon - size-changed - size 
declareSignal(StatusIcon, TStatusIcon, size_changed, size, int32)
# Statusbar - text-popped - context_id text 
# Statusbar - text-pushed - context_id text 
# Style - realize - 
declareSignal(Style, TStyle, realize)
# Style - unrealize - 
declareSignal(Style, TStyle, unrealize)
# StyleContext - changed - 
declareSignal(StyleContext, TStyleContext, changed)
# Switch - activate - 
declareSignal(Switch, TSwitch, activate)
# Switch - state-set - state 
declareSignal(Switch, TSwitch, state_set, state, bool)
# TextBuffer - apply-tag - tag start end 
# TextBuffer - begin-user-action - 
declareSignal(TextBuffer, TTextBuffer, begin_user_action)
# TextBuffer - changed - 
declareSignal(TextBuffer, TTextBuffer, changed)
# TextBuffer - delete-range - start end 
# TextBuffer - end-user-action - 
declareSignal(TextBuffer, TTextBuffer, end_user_action)
# TextBuffer - insert-child-anchor - location anchor 
# TextBuffer - insert-pixbuf - location pixbuf 
# TextBuffer - insert-text - location text len 
# TextBuffer - mark-deleted - mark 
declareSignal(TextBuffer, TTextBuffer, mark_deleted, mark, TextMark)
# TextBuffer - mark-set - location mark 
# TextBuffer - modified-changed - 
declareSignal(TextBuffer, TTextBuffer, modified_changed)
# TextBuffer - paste-done - clipboard 
declareSignal(TextBuffer, TTextBuffer, paste_done, clipboard, Clipboard)
# TextBuffer - remove-tag - tag start end 
# TextTag - event - object event iter 
# TextTagTable - tag-added - tag 
declareSignal(TextTagTable, TTextTagTable, tag_added, tag, TextTag)
# TextTagTable - tag-changed - tag size_changed 
# TextTagTable - tag-removed - tag 
declareSignal(TextTagTable, TTextTagTable, tag_removed, tag, TextTag)
# TextView - backspace - 
declareSignal(TextView, TTextView, backspace)
# TextView - copy-clipboard - 
declareSignal(TextView, TTextView, copy_clipboard)
# TextView - cut-clipboard - 
declareSignal(TextView, TTextView, cut_clipboard)
# TextView - delete-from-cursor - type count 
# TextView - insert-at-cursor - string 
declareSignal(TextView, TTextView, insert_at_cursor, string, ustring)
# TextView - move-cursor - step count extend_selection 
# TextView - move-viewport - step count 
# TextView - paste-clipboard - 
declareSignal(TextView, TTextView, paste_clipboard)
# TextView - populate-popup - popup 
declareSignal(TextView, TTextView, populate_popup, popup, Widget)
# TextView - preedit-changed - preedit 
declareSignal(TextView, TTextView, preedit_changed, preedit, ustring)
# TextView - select-all - select 
declareSignal(TextView, TTextView, select_all, select, bool)
# TextView - set-anchor - 
declareSignal(TextView, TTextView, set_anchor)
# TextView - toggle-cursor-visible - 
declareSignal(TextView, TTextView, toggle_cursor_visible)
# TextView - toggle-overwrite - 
declareSignal(TextView, TTextView, toggle_overwrite)
# ToggleAction - toggled - 
declareSignal(ToggleAction, TToggleAction, toggled)
# ToggleButton - toggled - 
declareSignal(ToggleButton, TToggleButton, toggled)
# ToggleToolButton - toggled - 
declareSignal(ToggleToolButton, TToggleToolButton, toggled)
# ToolButton - clicked - 
declareSignal(ToolButton, TToolButton, clicked)
# ToolItem - create-menu-proxy - 
declareSignal(ToolItem, TToolItem, create_menu_proxy)
# ToolItem - toolbar-reconfigured - 
declareSignal(ToolItem, TToolItem, toolbar_reconfigured)
# Toolbar - focus-home-or-end - focus_home 
declareSignal(Toolbar, TToolbar, focus_home_or_end, focus_home, bool)
# Toolbar - orientation-changed - orientation 
declareSignal(Toolbar, TToolbar, orientation_changed, orientation, Orientation)
# Toolbar - popup-context-menu - x y button 
# Toolbar - style-changed - style 
declareSignal(Toolbar, TToolbar, style_changed, style, ToolbarStyle)
# TreeSelection - changed - 
declareSignal(TreeSelection, TTreeSelection, changed)
# TreeView - columns-changed - 
declareSignal(TreeView, TTreeView, columns_changed)
# TreeView - cursor-changed - 
declareSignal(TreeView, TTreeView, cursor_changed)
# TreeView - expand-collapse-cursor-row - object p0 p1 
# TreeView - move-cursor - step direction 
# TreeView - row-activated - path column 
# TreeView - row-collapsed - iter path 
# TreeView - row-expanded - iter path 
# TreeView - select-all - 
declareSignal(TreeView, TTreeView, select_all)
# TreeView - select-cursor-parent - 
declareSignal(TreeView, TTreeView, select_cursor_parent)
# TreeView - select-cursor-row - object 
declareSignal(TreeView, TTreeView, select_cursor_row, object_x, bool)
# TreeView - start-interactive-search - 
declareSignal(TreeView, TTreeView, start_interactive_search)
# TreeView - test-collapse-row - iter path 
# TreeView - test-expand-row - iter path 
# TreeView - toggle-cursor-row - 
declareSignal(TreeView, TTreeView, toggle_cursor_row)
# TreeView - unselect-all - 
declareSignal(TreeView, TTreeView, unselect_all)
# TreeViewColumn - clicked - 
declareSignal(TreeViewColumn, TTreeViewColumn, clicked)
# UIManager - actions-changed - 
declareSignal(UIManager, TUIManager, actions_changed)
# UIManager - add-widget - widget 
declareSignal(UIManager, TUIManager, add_widget, widget, Widget)
# UIManager - connect-proxy - action proxy 
# UIManager - disconnect-proxy - action proxy 
# UIManager - post-activate - action 
declareSignal(UIManager, TUIManager, post_activate, action, Action)
# UIManager - pre-activate - action 
declareSignal(UIManager, TUIManager, pre_activate, action, Action)
# Widget - accel-closures-changed - 
declareSignal(Widget, TWidget, accel_closures_changed)
# Widget - button-press-event - event 
declareSignal(Widget, TWidget, button_press_event, event, Gdk3.TEventButton)
# Widget - button-release-event - event 
declareSignal(Widget, TWidget, button_release_event, event, Gdk3.TEventButton)
# Widget - can-activate-accel - signal_id 
declareSignal(Widget, TWidget, can_activate_accel, signal_id, uint32)
# Widget - child-notify - child_property 
declareSignal(Widget, TWidget, child_notify, child_property, GObject2.ParamSpec)
# Widget - composited-changed - 
declareSignal(Widget, TWidget, composited_changed)
# Widget - configure-event - event 
declareSignal(Widget, TWidget, configure_event, event, Gdk3.TEventConfigure)
# Widget - damage-event - event 
declareSignal(Widget, TWidget, damage_event, event, Gdk3.TEventExpose)
# Widget - delete-event - event 
declareSignal(Widget, TWidget, delete_event, event, Gdk3.TEvent)
# Widget - destroy - 
declareSignal(Widget, TWidget, destroy)
# Widget - destroy-event - event 
declareSignal(Widget, TWidget, destroy_event, event, Gdk3.TEvent)
# Widget - direction-changed - previous_direction 
declareSignal(Widget, TWidget, direction_changed, previous_direction, TextDirection)
# Widget - drag-begin - context 
declareSignal(Widget, TWidget, drag_begin, context, Gdk3.DragContext)
# Widget - drag-data-delete - context 
declareSignal(Widget, TWidget, drag_data_delete, context, Gdk3.DragContext)
# Widget - drag-data-get - context data info time 
# Widget - drag-data-received - context x y data info time 
# Widget - drag-drop - context x y time 
# Widget - drag-end - context 
declareSignal(Widget, TWidget, drag_end, context, Gdk3.DragContext)
# Widget - drag-failed - context result 
# Widget - drag-leave - context time 
# Widget - drag-motion - context x y time 
# Widget - draw - cr 
declareSignal(Widget, TWidget, draw, cr, cairo1.TContext)
# Widget - enter-notify-event - event 
declareSignal(Widget, TWidget, enter_notify_event, event, Gdk3.TEventCrossing)
# Widget - event - event 
declareSignal(Widget, TWidget, event, event, Gdk3.TEvent)
# Widget - event-after - event 
declareSignal(Widget, TWidget, event_after, event, Gdk3.TEvent)
# Widget - focus - direction 
declareSignal(Widget, TWidget, focus, direction, DirectionType)
# Widget - focus-in-event - event 
declareSignal(Widget, TWidget, focus_in_event, event, Gdk3.TEventFocus)
# Widget - focus-out-event - event 
declareSignal(Widget, TWidget, focus_out_event, event, Gdk3.TEventFocus)
# Widget - grab-broken-event - event 
declareSignal(Widget, TWidget, grab_broken_event, event, Gdk3.TEventGrabBroken)
# Widget - grab-focus - 
declareSignal(Widget, TWidget, grab_focus)
# Widget - grab-notify - was_grabbed 
declareSignal(Widget, TWidget, grab_notify, was_grabbed, bool)
# Widget - hide - 
declareSignal(Widget, TWidget, hide)
# Widget - hierarchy-changed - previous_toplevel 
declareSignal(Widget, TWidget, hierarchy_changed, previous_toplevel, Widget)
# Widget - key-press-event - event 
declareSignal(Widget, TWidget, key_press_event, event, Gdk3.TEventKey)
# Widget - key-release-event - event 
declareSignal(Widget, TWidget, key_release_event, event, Gdk3.TEventKey)
# Widget - keynav-failed - direction 
declareSignal(Widget, TWidget, keynav_failed, direction, DirectionType)
# Widget - leave-notify-event - event 
declareSignal(Widget, TWidget, leave_notify_event, event, Gdk3.TEventCrossing)
# Widget - map - 
declareSignal(Widget, TWidget, map)
# Widget - map-event - event 
declareSignal(Widget, TWidget, map_event, event, Gdk3.TEventAny)
# Widget - mnemonic-activate - arg1 
declareSignal(Widget, TWidget, mnemonic_activate, arg1, bool)
# Widget - motion-notify-event - event 
declareSignal(Widget, TWidget, motion_notify_event, event, Gdk3.TEventMotion)
# Widget - move-focus - direction 
declareSignal(Widget, TWidget, move_focus, direction, DirectionType)
# Widget - parent-set - old_parent 
declareSignal(Widget, TWidget, parent_set, old_parent, Widget)
# Widget - popup-menu - 
declareSignal(Widget, TWidget, popup_menu)
# Widget - property-notify-event - event 
declareSignal(Widget, TWidget, property_notify_event, event, Gdk3.TEventProperty)
# Widget - proximity-in-event - event 
declareSignal(Widget, TWidget, proximity_in_event, event, Gdk3.TEventProximity)
# Widget - proximity-out-event - event 
declareSignal(Widget, TWidget, proximity_out_event, event, Gdk3.TEventProximity)
# Widget - query-tooltip - x y keyboard_mode tooltip 
# Widget - realize - 
declareSignal(Widget, TWidget, realize)
# Widget - screen-changed - previous_screen 
declareSignal(Widget, TWidget, screen_changed, previous_screen, Gdk3.Screen)
# Widget - scroll-event - event 
declareSignal(Widget, TWidget, scroll_event, event, Gdk3.TEventScroll)
# Widget - selection-clear-event - event 
declareSignal(Widget, TWidget, selection_clear_event, event, Gdk3.TEventSelection)
# Widget - selection-get - data info time 
# Widget - selection-notify-event - event 
declareSignal(Widget, TWidget, selection_notify_event, event, Gdk3.TEventSelection)
# Widget - selection-received - data time 
# Widget - selection-request-event - event 
declareSignal(Widget, TWidget, selection_request_event, event, Gdk3.TEventSelection)
# Widget - show - 
declareSignal(Widget, TWidget, show)
# Widget - show-help - help_type 
declareSignal(Widget, TWidget, show_help, help_type, WidgetHelpType)
# Widget - size-allocate - allocation 
declareSignal(Widget, TWidget, size_allocate, allocation, cairo1.TRectangleInt)
# Widget - state-changed - state 
declareSignal(Widget, TWidget, state_changed, state, StateType)
# Widget - state-flags-changed - flags 
declareSignal(Widget, TWidget, state_flags_changed, flags, SStateFlags)
# Widget - style-set - previous_style 
declareSignal(Widget, TWidget, style_set, previous_style, Style)
# Widget - style-updated - 
declareSignal(Widget, TWidget, style_updated)
# Widget - touch-event - object 
declareSignal(Widget, TWidget, touch_event, object_x, Gdk3.TEvent)
# Widget - unmap - 
declareSignal(Widget, TWidget, unmap)
# Widget - unmap-event - event 
declareSignal(Widget, TWidget, unmap_event, event, Gdk3.TEventAny)
# Widget - unrealize - 
declareSignal(Widget, TWidget, unrealize)
# Widget - visibility-notify-event - event 
declareSignal(Widget, TWidget, visibility_notify_event, event, Gdk3.TEventVisibility)
# Widget - window-state-event - event 
declareSignal(Widget, TWidget, window_state_event, event, Gdk3.TEventWindowState)
# Window - activate-default - 
declareSignal(Window, TWindow, activate_default)
# Window - activate-focus - 
declareSignal(Window, TWindow, activate_focus)
# Window - enable-debugging - toggle 
declareSignal(Window, TWindow, enable_debugging, toggle, bool)
# Window - keys-changed - 
declareSignal(Window, TWindow, keys_changed)
# Window - set-focus - object 
declareSignal(Window, TWindow, set_focus, object_x, Widget)
  # struct methods
  #------------------
# struct AboutDialogClass
# struct AboutDialogPrivate
# struct AccelGroupClass
# struct AccelGroupEntry
# struct AccelGroupPrivate
# struct AccelKey
# struct AccelLabelClass
# struct AccelLabelPrivate
# struct AccelMapClass
# struct AccessibleClass
# struct AccessiblePrivate
# struct ActionBarClass
# struct ActionBarPrivate
# struct ActionClass
# struct ActionEntry
# struct ActionGroupClass
# struct ActionGroupPrivate
# struct ActionPrivate
# struct ActionableInterface
# struct ActivatableIface
# struct AdjustmentClass
# struct AdjustmentPrivate
# struct AlignmentClass
# struct AlignmentPrivate
# struct AppChooserButtonClass
# struct AppChooserButtonPrivate
# struct AppChooserDialogClass
# struct AppChooserDialogPrivate
# struct AppChooserWidgetClass
# struct AppChooserWidgetPrivate
# struct ApplicationClass
# struct ApplicationPrivate
# struct ApplicationWindowClass
# struct ApplicationWindowPrivate
# struct ArrowAccessibleClass
# struct ArrowAccessiblePrivate
# struct ArrowClass
# struct ArrowPrivate
# struct AspectFrameClass
# struct AspectFramePrivate
# struct AssistantClass
# struct AssistantPrivate
# struct BinClass
# struct BinPrivate
# struct BindingArg
# struct BindingEntry
# gtk_binding_entry_add_signal_from_string
# flags: {} container: BindingEntry
# need sugar: is static method
# binding_set 'TBindingSet' 'ptr TBindingSet' IN (diff., need sugar)
# signal_desc 'ustring' 'ucstring' IN (diff., need sugar)
# 'GLib2.TokenType' 'GLib2.TokenType'
# warning, already written a prototype with the name of gtk_binding_entry_add_signal_from_string
# proc gtk_binding_entry_add_signal_from_string(binding_set: ptr TBindingSet, signal_desc: ucstring): GLib2.TokenType {.cdecl, dynlib: lib, importc: "gtk_binding_entry_add_signal_from_string".}
template add_signal_from_string*(klass_parameter: typedesc[BindingEntry], binding_set: TBindingSet, signal_desc: ustring): GLib2.TokenType =
  gtk_binding_entry_add_signal_from_string(myUnsafeAddr(binding_set), ucstring(signal_desc))
# template add_signal_from_string*(klass_parameter: typedesc[BindingEntry], binding_set: TBindingSet, signal_desc: ustring): GLib2.TokenType =

# gtk_binding_entry_add_signall
# flags: {} container: BindingEntry
# need sugar: is static method
# binding_set 'TBindingSet' 'ptr TBindingSet' IN (diff., need sugar)
# keyval 'uint32' 'uint32' IN
# modifiers 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# signal_name 'ustring' 'ucstring' IN (diff., need sugar)
# binding_args 'ptr GSLIST_TODO' 'ptr GSLIST_TODO' IN
# 'VOID_TODO' 'VOID_TODO'
# warning, already written a prototype with the name of gtk_binding_entry_add_signall
# proc gtk_binding_entry_add_signall(binding_set: ptr TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType, signal_name: ucstring, binding_args: ptr GSLIST_TODO) {.cdecl, dynlib: lib, importc: "gtk_binding_entry_add_signall".}
template add_signall*(klass_parameter: typedesc[BindingEntry], binding_set: TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType, signal_name: ustring, binding_args: ptr GSLIST_TODO) =
  gtk_binding_entry_add_signall(myUnsafeAddr(binding_set), keyval, modifiers, ucstring(signal_name), binding_args)
# template add_signall*(klass_parameter: typedesc[BindingEntry], binding_set: TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType, signal_name: ustring, binding_args: ptr GSLIST_TODO) =

# gtk_binding_entry_remove
# flags: {} container: BindingEntry
# need sugar: is static method
# binding_set 'TBindingSet' 'ptr TBindingSet' IN (diff., need sugar)
# keyval 'uint32' 'uint32' IN
# modifiers 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# 'VOID_TODO' 'VOID_TODO'
# warning, already written a prototype with the name of gtk_binding_entry_remove
# proc gtk_binding_entry_remove(binding_set: ptr TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType) {.cdecl, dynlib: lib, importc: "gtk_binding_entry_remove".}
template remove*(klass_parameter: typedesc[BindingEntry], binding_set: TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType) =
  gtk_binding_entry_remove(myUnsafeAddr(binding_set), keyval, modifiers)
# template remove*(klass_parameter: typedesc[BindingEntry], binding_set: TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType) =

# gtk_binding_entry_skip
# flags: {} container: BindingEntry
# need sugar: is static method
# binding_set 'TBindingSet' 'ptr TBindingSet' IN (diff., need sugar)
# keyval 'uint32' 'uint32' IN
# modifiers 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# 'VOID_TODO' 'VOID_TODO'
# warning, already written a prototype with the name of gtk_binding_entry_skip
# proc gtk_binding_entry_skip(binding_set: ptr TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType) {.cdecl, dynlib: lib, importc: "gtk_binding_entry_skip".}
template skip*(klass_parameter: typedesc[BindingEntry], binding_set: TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType) =
  gtk_binding_entry_skip(myUnsafeAddr(binding_set), keyval, modifiers)
# template skip*(klass_parameter: typedesc[BindingEntry], binding_set: TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType) =

# struct BindingSet
# gtk_binding_set_activate
# flags: {isMethod} container: BindingSet
# need sugar: is method
# keyval 'uint32' 'uint32' IN
# modifiers 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# object 'GObject2.Object' 'ptr GObject2.TObject' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_binding_set_activate(self: ptr TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType, object_x: ptr GObject2.TObject): bool {.cdecl, dynlib: lib, importc: "gtk_binding_set_activate".}
proc activate*(self: BindingSet, keyval: uint32, modifiers: Gdk3.SModifierType, object_x: GObject2.Object): bool {.inline.} =
  gtk_binding_set_activate(self, keyval, modifiers, object_x.getPointer)
# proc activate*(self: BindingSet, keyval: uint32, modifiers: Gdk3.SModifierType, object_x: GObject2.Object): bool {.inline.} =

# gtk_binding_set_add_path
# flags: {isMethod} container: BindingSet (deprecated)
# gtk_binding_set_find
# flags: {} container: BindingSet
# need sugar: is static method
# set_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'TBindingSet' 'ptr TBindingSet' (diff., need sugar)
# warning, already written a prototype with the name of gtk_binding_set_find
# proc gtk_binding_set_find(set_name: ucstring): ptr TBindingSet {.cdecl, dynlib: lib, importc: "gtk_binding_set_find".}
template find*(klass_parameter: typedesc[BindingSet], set_name: ustring): TBindingSet =
  (gtk_binding_set_find(ucstring(set_name)))[]
# template find*(klass_parameter: typedesc[BindingSet], set_name: ustring): TBindingSet =

# struct BindingSignal
# struct BooleanCellAccessibleClass
# struct BooleanCellAccessiblePrivate
# struct Border
# gtk_border_new
# flags: {isConstructor} container: Border
# need sugar: is static method
# 'TBorder' 'ptr TBorder' (diff., need sugar)
proc gtk_border_new(): ptr TBorder {.cdecl, dynlib: lib, importc: "gtk_border_new".}
proc new_border*(): TBorder {.inline.} =
  (gtk_border_new())[]
# proc new_border*(): TBorder {.inline.} =

# gtk_border_copy
# flags: {isMethod} container: Border
# need sugar: is method
# 'TBorder' 'ptr TBorder' (diff., need sugar)
proc gtk_border_copy(self: ptr TBorder): ptr TBorder {.cdecl, dynlib: lib, importc: "gtk_border_copy".}
proc copy*(self: Border): TBorder {.inline.} =
  (gtk_border_copy(self))[]
# proc copy*(self: Border): TBorder {.inline.} =

# gtk_border_free
# flags: {isMethod} container: Border
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_border_free(self: ptr TBorder) {.cdecl, dynlib: lib, importc: "gtk_border_free".}
proc free*(self: Border) {.inline.} =
  gtk_border_free(self)
# proc free*(self: Border) {.inline.} =

# struct BoxClass
# struct BoxPrivate
# struct BuildableIface
# struct BuilderClass
# struct BuilderPrivate
# struct ButtonAccessibleClass
# struct ButtonAccessiblePrivate
# struct ButtonBoxClass
# struct ButtonBoxPrivate
# struct ButtonClass
# struct ButtonPrivate
# struct CalendarClass
# struct CalendarPrivate
# struct CellAccessibleClass
# struct CellAccessibleParentIface
# struct CellAccessiblePrivate
# struct CellAreaBoxClass
# struct CellAreaBoxPrivate
# struct CellAreaClass
# gtk_cell_area_class_find_cell_property
# flags: {isMethod} container: CellAreaClass
# need sugar: is method
# property_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'GObject2.ParamSpec' 'TransferNone[GObject2.TParamSpec]' (diff., need sugar)
proc gtk_cell_area_class_find_cell_property(self: ptr TCellAreaClass, property_name: ucstring): TransferNone[GObject2.TParamSpec] {.cdecl, dynlib: lib, importc: "gtk_cell_area_class_find_cell_property".}
proc find_cell_property*(self: CellAreaClass, property_name: ustring): GObject2.ParamSpec {.inline.} =
  wrap(gtk_cell_area_class_find_cell_property(self, ucstring(property_name)))
# proc find_cell_property*(self: CellAreaClass, property_name: ustring): GObject2.ParamSpec {.inline.} =

# gtk_cell_area_class_install_cell_property
# flags: {isMethod} container: CellAreaClass
# need sugar: is method
# property_id 'uint32' 'uint32' IN
# pspec 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_class_install_cell_property(self: ptr TCellAreaClass, property_id: uint32, pspec: ptr GObject2.TParamSpec) {.cdecl, dynlib: lib, importc: "gtk_cell_area_class_install_cell_property".}
proc install_cell_property*(self: CellAreaClass, property_id: uint32, pspec: GObject2.ParamSpec) {.inline.} =
  gtk_cell_area_class_install_cell_property(self, property_id, pspec.getPointer)
# proc install_cell_property*(self: CellAreaClass, property_id: uint32, pspec: GObject2.ParamSpec) {.inline.} =

# gtk_cell_area_class_list_cell_properties
# flags: {isMethod} container: CellAreaClass
# need sugar: is method
# n_properties 'var uint32' 'ptr uint32' OUT (diff., need sugar)
# 'zeroTerminatedArray[ptr GObject2.TParamSpec]' 'zeroTerminatedArray[ptr GObject2.TParamSpec]'
proc gtk_cell_area_class_list_cell_properties(self: ptr TCellAreaClass, n_properties: ptr uint32): zeroTerminatedArray[ptr GObject2.TParamSpec] {.cdecl, dynlib: lib, importc: "gtk_cell_area_class_list_cell_properties".}
proc list_cell_properties*(self: CellAreaClass, n_properties: var uint32): zeroTerminatedArray[ptr GObject2.TParamSpec] {.inline.} =
  gtk_cell_area_class_list_cell_properties(self, addr(n_properties))
# tuple-return
# n_properties: var uint32
# proc list_cell_properties*(self: CellAreaClass): zeroTerminatedArray[ptr GObject2.TParamSpec] {.inline.} =

# struct CellAreaContextClass
# struct CellAreaContextPrivate
# struct CellAreaPrivate
# struct CellEditableIface
# struct CellLayoutIface
# struct CellRendererAccelClass
# struct CellRendererAccelPrivate
# struct CellRendererClass
# gtk_cell_renderer_class_set_accessible_type
# flags: {isMethod} container: CellRendererClass
# need sugar: is method
# type 'GType' 'GType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_class_set_accessible_type(self: ptr TCellRendererClass, type_x: GType) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_class_set_accessible_type".}
proc set_accessible_type*(self: CellRendererClass, type_x: GType) {.inline.} =
  gtk_cell_renderer_class_set_accessible_type(self, type_x)
# proc set_accessible_type*(self: CellRendererClass, type_x: GType) {.inline.} =

# struct CellRendererClassPrivate
# struct CellRendererComboClass
# struct CellRendererComboPrivate
# struct CellRendererPixbufClass
# struct CellRendererPixbufPrivate
# struct CellRendererPrivate
# struct CellRendererProgressClass
# struct CellRendererProgressPrivate
# struct CellRendererSpinClass
# struct CellRendererSpinPrivate
# struct CellRendererSpinnerClass
# struct CellRendererSpinnerPrivate
# struct CellRendererTextClass
# struct CellRendererTextPrivate
# struct CellRendererToggleClass
# struct CellRendererTogglePrivate
# struct CellViewClass
# struct CellViewPrivate
# struct CheckButtonClass
# struct CheckMenuItemAccessibleClass
# struct CheckMenuItemAccessiblePrivate
# struct CheckMenuItemClass
# struct CheckMenuItemPrivate
# struct ColorButtonClass
# struct ColorButtonPrivate
# struct ColorChooserDialogClass
# struct ColorChooserDialogPrivate
# struct ColorChooserInterface
# struct ColorChooserWidgetClass
# struct ColorChooserWidgetPrivate
# struct ColorSelectionClass
# struct ColorSelectionDialogClass
# struct ColorSelectionDialogPrivate
# struct ColorSelectionPrivate
# struct ComboBoxAccessibleClass
# struct ComboBoxAccessiblePrivate
# struct ComboBoxClass
# struct ComboBoxPrivate
# struct ComboBoxTextClass
# struct ComboBoxTextPrivate
# struct ContainerAccessibleClass
# struct ContainerAccessiblePrivate
# struct ContainerCellAccessibleClass
# struct ContainerCellAccessiblePrivate
# struct ContainerClass
# gtk_container_class_find_child_property
# flags: {isMethod} container: ContainerClass
# need sugar: is method
# property_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'GObject2.ParamSpec' 'TransferNone[GObject2.TParamSpec]' (diff., need sugar)
proc gtk_container_class_find_child_property(self: ptr TContainerClass, property_name: ucstring): TransferNone[GObject2.TParamSpec] {.cdecl, dynlib: lib, importc: "gtk_container_class_find_child_property".}
proc find_child_property*(self: ContainerClass, property_name: ustring): GObject2.ParamSpec {.inline.} =
  wrap(gtk_container_class_find_child_property(self, ucstring(property_name)))
# proc find_child_property*(self: ContainerClass, property_name: ustring): GObject2.ParamSpec {.inline.} =

# gtk_container_class_handle_border_width
# flags: {isMethod} container: ContainerClass
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_container_class_handle_border_width(self: ptr TContainerClass) {.cdecl, dynlib: lib, importc: "gtk_container_class_handle_border_width".}
proc handle_border_width*(self: ContainerClass) {.inline.} =
  gtk_container_class_handle_border_width(self)
# proc handle_border_width*(self: ContainerClass) {.inline.} =

# gtk_container_class_install_child_property
# flags: {isMethod} container: ContainerClass
# need sugar: is method
# property_id 'uint32' 'uint32' IN
# pspec 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_container_class_install_child_property(self: ptr TContainerClass, property_id: uint32, pspec: ptr GObject2.TParamSpec) {.cdecl, dynlib: lib, importc: "gtk_container_class_install_child_property".}
proc install_child_property*(self: ContainerClass, property_id: uint32, pspec: GObject2.ParamSpec) {.inline.} =
  gtk_container_class_install_child_property(self, property_id, pspec.getPointer)
# proc install_child_property*(self: ContainerClass, property_id: uint32, pspec: GObject2.ParamSpec) {.inline.} =

# gtk_container_class_list_child_properties
# flags: {isMethod} container: ContainerClass
# need sugar: is method
# n_properties 'var uint32' 'ptr uint32' OUT (diff., need sugar)
# 'zeroTerminatedArray[ptr GObject2.TParamSpec]' 'zeroTerminatedArray[ptr GObject2.TParamSpec]'
proc gtk_container_class_list_child_properties(self: ptr TContainerClass, n_properties: ptr uint32): zeroTerminatedArray[ptr GObject2.TParamSpec] {.cdecl, dynlib: lib, importc: "gtk_container_class_list_child_properties".}
proc list_child_properties*(self: ContainerClass, n_properties: var uint32): zeroTerminatedArray[ptr GObject2.TParamSpec] {.inline.} =
  gtk_container_class_list_child_properties(self, addr(n_properties))
# tuple-return
# n_properties: var uint32
# proc list_child_properties*(self: ContainerClass): zeroTerminatedArray[ptr GObject2.TParamSpec] {.inline.} =

# struct ContainerPrivate
# struct CssProviderClass
# struct CssProviderPrivate
# struct CssSection
# gtk_css_section_get_end_line
# flags: {isMethod} container: CssSection
# need sugar: is method
# 'uint32' 'uint32'
proc gtk_css_section_get_end_line(self: ptr TCssSection): uint32 {.cdecl, dynlib: lib, importc: "gtk_css_section_get_end_line".}
proc get_end_line*(self: CssSection): uint32 {.inline.} =
  gtk_css_section_get_end_line(self)
# proc get_end_line*(self: CssSection): uint32 {.inline.} =

# gtk_css_section_get_end_position
# flags: {isMethod} container: CssSection
# need sugar: is method
# 'uint32' 'uint32'
proc gtk_css_section_get_end_position(self: ptr TCssSection): uint32 {.cdecl, dynlib: lib, importc: "gtk_css_section_get_end_position".}
proc get_end_position*(self: CssSection): uint32 {.inline.} =
  gtk_css_section_get_end_position(self)
# proc get_end_position*(self: CssSection): uint32 {.inline.} =

# gtk_css_section_get_file
# flags: {isMethod} container: CssSection
# need sugar: is method
# 'Gio2.File' 'TransferNone[Gio2.TFile]' (diff., need sugar)
proc gtk_css_section_get_file(self: ptr TCssSection): TransferNone[Gio2.TFile] {.cdecl, dynlib: lib, importc: "gtk_css_section_get_file".}
proc get_file*(self: CssSection): Gio2.File {.inline.} =
  wrap(gtk_css_section_get_file(self))
# proc get_file*(self: CssSection): Gio2.File {.inline.} =

# gtk_css_section_get_parent
# flags: {isMethod} container: CssSection
# need sugar: is method
# 'TCssSection' 'ptr TCssSection' (diff., need sugar)
proc gtk_css_section_get_parent(self: ptr TCssSection): ptr TCssSection {.cdecl, dynlib: lib, importc: "gtk_css_section_get_parent".}
proc get_parent*(self: CssSection): TCssSection {.inline.} =
  (gtk_css_section_get_parent(self))[]
# proc get_parent*(self: CssSection): TCssSection {.inline.} =

# gtk_css_section_get_section_type
# flags: {isMethod} container: CssSection
# need sugar: is method
# 'CssSectionType' 'CssSectionType'
proc gtk_css_section_get_section_type(self: ptr TCssSection): CssSectionType {.cdecl, dynlib: lib, importc: "gtk_css_section_get_section_type".}
proc get_section_type*(self: CssSection): CssSectionType {.inline.} =
  gtk_css_section_get_section_type(self)
# proc get_section_type*(self: CssSection): CssSectionType {.inline.} =

# gtk_css_section_get_start_line
# flags: {isMethod} container: CssSection
# need sugar: is method
# 'uint32' 'uint32'
proc gtk_css_section_get_start_line(self: ptr TCssSection): uint32 {.cdecl, dynlib: lib, importc: "gtk_css_section_get_start_line".}
proc get_start_line*(self: CssSection): uint32 {.inline.} =
  gtk_css_section_get_start_line(self)
# proc get_start_line*(self: CssSection): uint32 {.inline.} =

# gtk_css_section_get_start_position
# flags: {isMethod} container: CssSection
# need sugar: is method
# 'uint32' 'uint32'
proc gtk_css_section_get_start_position(self: ptr TCssSection): uint32 {.cdecl, dynlib: lib, importc: "gtk_css_section_get_start_position".}
proc get_start_position*(self: CssSection): uint32 {.inline.} =
  gtk_css_section_get_start_position(self)
# proc get_start_position*(self: CssSection): uint32 {.inline.} =

# gtk_css_section_ref
# flags: {isMethod} container: CssSection
# need sugar: is method
# 'TCssSection' 'ptr TCssSection' (diff., need sugar)
proc gtk_css_section_ref(self: ptr TCssSection): ptr TCssSection {.cdecl, dynlib: lib, importc: "gtk_css_section_ref".}
proc ref_x*(self: CssSection): TCssSection {.inline.} =
  (gtk_css_section_ref(self))[]
# proc ref_x*(self: CssSection): TCssSection {.inline.} =

# gtk_css_section_unref
# flags: {isMethod} container: CssSection
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_css_section_unref(self: ptr TCssSection) {.cdecl, dynlib: lib, importc: "gtk_css_section_unref".}
proc unref*(self: CssSection) {.inline.} =
  gtk_css_section_unref(self)
# proc unref*(self: CssSection) {.inline.} =

# struct DialogClass
# struct DialogPrivate
# struct DrawingAreaClass
# struct EditableInterface
# struct EntryAccessibleClass
# struct EntryAccessiblePrivate
# struct EntryBufferClass
# struct EntryBufferPrivate
# struct EntryClass
# struct EntryCompletionClass
# struct EntryCompletionPrivate
# struct EntryPrivate
# struct EventBoxClass
# struct EventBoxPrivate
# struct EventControllerClass
# struct ExpanderAccessibleClass
# struct ExpanderAccessiblePrivate
# struct ExpanderClass
# struct ExpanderPrivate
# struct FileChooserButtonClass
# struct FileChooserButtonPrivate
# struct FileChooserDialogClass
# struct FileChooserDialogPrivate
# struct FileChooserWidgetClass
# struct FileChooserWidgetPrivate
# struct FileFilterInfo
# struct FixedChild
# struct FixedClass
# struct FixedPrivate
# struct FlowBoxAccessibleClass
# struct FlowBoxAccessiblePrivate
# struct FlowBoxChildAccessibleClass
# struct FlowBoxChildClass
# struct FlowBoxClass
# struct FontButtonClass
# struct FontButtonPrivate
# struct FontChooserDialogClass
# struct FontChooserDialogPrivate
# struct FontChooserIface
# struct FontChooserWidgetClass
# struct FontChooserWidgetPrivate
# struct FontSelectionClass
# struct FontSelectionDialogClass
# struct FontSelectionDialogPrivate
# struct FontSelectionPrivate
# struct FrameAccessibleClass
# struct FrameAccessiblePrivate
# struct FrameClass
# struct FramePrivate
# struct GestureClass
# struct GestureDragClass
# struct GestureLongPressClass
# struct GestureMultiPressClass
# struct GesturePanClass
# struct GestureRotateClass
# struct GestureSingleClass
# struct GestureSwipeClass
# struct GestureZoomClass
# struct Gradient
# gtk_gradient_new_linear
# flags: {isConstructor} container: Gradient (deprecated)
# gtk_gradient_new_radial
# flags: {isConstructor} container: Gradient (deprecated)
# gtk_gradient_add_color_stop
# flags: {isMethod} container: Gradient (deprecated)
# gtk_gradient_ref
# flags: {isMethod} container: Gradient (deprecated)
# gtk_gradient_resolve
# flags: {isMethod} container: Gradient (deprecated)
# gtk_gradient_resolve_for_context
# flags: {isMethod} container: Gradient
# need sugar: is method
# context 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# 'cairo1.TPattern' 'ptr cairo1.TPattern' (diff., need sugar)
proc gtk_gradient_resolve_for_context(self: ptr TGradient, context: ptr TStyleContext): ptr cairo1.TPattern {.cdecl, dynlib: lib, importc: "gtk_gradient_resolve_for_context".}
proc resolve_for_context*(self: Gradient, context: StyleContext): cairo1.TPattern {.inline.} =
  (gtk_gradient_resolve_for_context(self, context.getPointer))[]
# proc resolve_for_context*(self: Gradient, context: StyleContext): cairo1.TPattern {.inline.} =

# gtk_gradient_to_string
# flags: {isMethod} container: Gradient (deprecated)
# gtk_gradient_unref
# flags: {isMethod} container: Gradient (deprecated)
# struct GridClass
# struct GridPrivate
# struct HBoxClass
# struct HButtonBoxClass
# struct HPanedClass
# struct HSVClass
# struct HSVPrivate
# struct HScaleClass
# struct HScrollbarClass
# struct HSeparatorClass
# struct HandleBoxClass
# struct HandleBoxPrivate
# struct HeaderBarClass
# struct HeaderBarPrivate
# struct IMContextClass
# struct IMContextInfo
# struct IMContextSimpleClass
# struct IMContextSimplePrivate
# struct IMMulticontextClass
# struct IMMulticontextPrivate
# struct IconFactoryClass
# struct IconFactoryPrivate
# struct IconInfoClass
# struct IconSet
# gtk_icon_set_new
# flags: {isConstructor} container: IconSet (deprecated)
# gtk_icon_set_new_from_pixbuf
# flags: {isConstructor} container: IconSet (deprecated)
# gtk_icon_set_add_source
# flags: {isMethod} container: IconSet (deprecated)
# gtk_icon_set_copy
# flags: {isMethod} container: IconSet (deprecated)
# gtk_icon_set_get_sizes
# flags: {isMethod} container: IconSet (deprecated)
# gtk_icon_set_ref
# flags: {isMethod} container: IconSet (deprecated)
# gtk_icon_set_render_icon
# flags: {isMethod} container: IconSet (deprecated)
# gtk_icon_set_render_icon_pixbuf
# flags: {isMethod} container: IconSet (deprecated)
# gtk_icon_set_render_icon_surface
# flags: {isMethod} container: IconSet (deprecated)
# gtk_icon_set_unref
# flags: {isMethod} container: IconSet (deprecated)
# struct IconSource
# gtk_icon_source_new
# flags: {isConstructor} container: IconSource (deprecated)
# gtk_icon_source_copy
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_free
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_get_direction
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_get_direction_wildcarded
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_get_filename
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_get_icon_name
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_get_pixbuf
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_get_size
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_get_size_wildcarded
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_get_state
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_get_state_wildcarded
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_set_direction
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_set_direction_wildcarded
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_set_filename
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_set_icon_name
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_set_pixbuf
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_set_size
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_set_size_wildcarded
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_set_state
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_set_state_wildcarded
# flags: {isMethod} container: IconSource (deprecated)
# struct IconThemeClass
# struct IconThemePrivate
# struct IconViewAccessibleClass
# struct IconViewAccessiblePrivate
# struct IconViewClass
# struct IconViewPrivate
# struct ImageAccessibleClass
# struct ImageAccessiblePrivate
# struct ImageCellAccessibleClass
# struct ImageCellAccessiblePrivate
# struct ImageClass
# struct ImageMenuItemClass
# struct ImageMenuItemPrivate
# struct ImagePrivate
# struct InfoBarClass
# struct InfoBarPrivate
# struct InvisibleClass
# struct InvisiblePrivate
# struct LabelAccessibleClass
# struct LabelAccessiblePrivate
# struct LabelClass
# struct LabelPrivate
# struct LabelSelectionInfo
# struct LayoutClass
# struct LayoutPrivate
# struct LevelBarAccessibleClass
# struct LevelBarAccessiblePrivate
# struct LevelBarClass
# struct LevelBarPrivate
# struct LinkButtonAccessibleClass
# struct LinkButtonAccessiblePrivate
# struct LinkButtonClass
# struct LinkButtonPrivate
# struct ListBoxAccessibleClass
# struct ListBoxAccessiblePrivate
# struct ListBoxClass
# struct ListBoxRowAccessibleClass
# struct ListBoxRowClass
# struct ListStoreClass
# struct ListStorePrivate
# struct LockButtonAccessibleClass
# struct LockButtonAccessiblePrivate
# struct LockButtonClass
# struct LockButtonPrivate
# struct MenuAccessibleClass
# struct MenuAccessiblePrivate
# struct MenuBarClass
# struct MenuBarPrivate
# struct MenuButtonAccessibleClass
# struct MenuButtonAccessiblePrivate
# struct MenuButtonClass
# struct MenuButtonPrivate
# struct MenuClass
# struct MenuItemAccessibleClass
# struct MenuItemAccessiblePrivate
# struct MenuItemClass
# struct MenuItemPrivate
# struct MenuPrivate
# struct MenuShellAccessibleClass
# struct MenuShellAccessiblePrivate
# struct MenuShellClass
# struct MenuShellPrivate
# struct MenuToolButtonClass
# struct MenuToolButtonPrivate
# struct MessageDialogClass
# struct MessageDialogPrivate
# struct MiscClass
# struct MiscPrivate
# struct MountOperationClass
# struct MountOperationPrivate
# struct NotebookAccessibleClass
# struct NotebookAccessiblePrivate
# struct NotebookClass
# struct NotebookPageAccessibleClass
# struct NotebookPageAccessiblePrivate
# struct NotebookPrivate
# struct NumerableIconClass
# struct NumerableIconPrivate
# struct OffscreenWindowClass
# struct OrientableIface
# struct OverlayClass
# struct OverlayPrivate
# struct PageRange
# struct PanedAccessibleClass
# struct PanedAccessiblePrivate
# struct PanedClass
# struct PanedPrivate
# struct PaperSize
# gtk_paper_size_new
# flags: {isConstructor} container: PaperSize
# need sugar: is static method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# 'TPaperSize' 'ptr TPaperSize' (diff., need sugar)
proc gtk_paper_size_new(name: ucstring): ptr TPaperSize {.cdecl, dynlib: lib, importc: "gtk_paper_size_new".}
proc new_papersize*(name: ustring): TPaperSize {.inline.} =
  (gtk_paper_size_new(ucstring(name)))[]
# proc new_papersize*(name: ustring): TPaperSize {.inline.} =

# gtk_paper_size_new_custom
# flags: {isConstructor} container: PaperSize
# need sugar: is static method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# display_name 'ustring' 'ucstring' IN (diff., need sugar)
# width 'float64' 'float64' IN
# height 'float64' 'float64' IN
# unit 'Unit' 'Unit' IN
# 'TPaperSize' 'ptr TPaperSize' (diff., need sugar)
proc gtk_paper_size_new_custom(name: ucstring, display_name: ucstring, width: float64, height: float64, unit: Unit): ptr TPaperSize {.cdecl, dynlib: lib, importc: "gtk_paper_size_new_custom".}
proc new_papersize_custom*(name: ustring, display_name: ustring, width: float64, height: float64, unit: Unit): TPaperSize {.inline.} =
  (gtk_paper_size_new_custom(ucstring(name), ucstring(display_name), width, height, unit))[]
# proc new_papersize_custom*(name: ustring, display_name: ustring, width: float64, height: float64, unit: Unit): TPaperSize {.inline.} =

# gtk_paper_size_new_from_key_file
# flags: {isConstructor, throws} container: PaperSize
# can throw
# need sugar: is static method
# key_file 'GLib2.TKeyFile' 'ptr GLib2.TKeyFile' IN (diff., need sugar)
# group_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'TPaperSize' 'ptr TPaperSize' (diff., need sugar)
proc gtk_paper_size_new_from_key_file(key_file: ptr GLib2.TKeyFile, group_name: ucstring, error: ptr PGError=nil): ptr TPaperSize {.cdecl, dynlib: lib, importc: "gtk_paper_size_new_from_key_file".}
proc new_papersize_from_key_file*(key_file: GLib2.TKeyFile, group_name: ustring): TPaperSize {.inline.} =
  (gtk_paper_size_new_from_key_file(myUnsafeAddr(key_file), ucstring(group_name)))[]
# proc new_papersize_from_key_file*(key_file: GLib2.TKeyFile, group_name: ustring): TPaperSize {.inline.} =

# gtk_paper_size_new_from_ppd
# flags: {isConstructor} container: PaperSize
# need sugar: is static method
# ppd_name 'ustring' 'ucstring' IN (diff., need sugar)
# ppd_display_name 'ustring' 'ucstring' IN (diff., need sugar)
# width 'float64' 'float64' IN
# height 'float64' 'float64' IN
# 'TPaperSize' 'ptr TPaperSize' (diff., need sugar)
proc gtk_paper_size_new_from_ppd(ppd_name: ucstring, ppd_display_name: ucstring, width: float64, height: float64): ptr TPaperSize {.cdecl, dynlib: lib, importc: "gtk_paper_size_new_from_ppd".}
proc new_papersize_from_ppd*(ppd_name: ustring, ppd_display_name: ustring, width: float64, height: float64): TPaperSize {.inline.} =
  (gtk_paper_size_new_from_ppd(ucstring(ppd_name), ucstring(ppd_display_name), width, height))[]
# proc new_papersize_from_ppd*(ppd_name: ustring, ppd_display_name: ustring, width: float64, height: float64): TPaperSize {.inline.} =

# gtk_paper_size_copy
# flags: {isMethod} container: PaperSize
# need sugar: is method
# 'TPaperSize' 'ptr TPaperSize' (diff., need sugar)
proc gtk_paper_size_copy(self: ptr TPaperSize): ptr TPaperSize {.cdecl, dynlib: lib, importc: "gtk_paper_size_copy".}
proc copy*(self: PaperSize): TPaperSize {.inline.} =
  (gtk_paper_size_copy(self))[]
# proc copy*(self: PaperSize): TPaperSize {.inline.} =

# gtk_paper_size_free
# flags: {isMethod} container: PaperSize
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_paper_size_free(self: ptr TPaperSize) {.cdecl, dynlib: lib, importc: "gtk_paper_size_free".}
proc free*(self: PaperSize) {.inline.} =
  gtk_paper_size_free(self)
# proc free*(self: PaperSize) {.inline.} =

# gtk_paper_size_get_default_bottom_margin
# flags: {isMethod} container: PaperSize
# need sugar: is method
# unit 'Unit' 'Unit' IN
# 'float64' 'float64'
proc gtk_paper_size_get_default_bottom_margin(self: ptr TPaperSize, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_paper_size_get_default_bottom_margin".}
proc get_default_bottom_margin*(self: PaperSize, unit: Unit): float64 {.inline.} =
  gtk_paper_size_get_default_bottom_margin(self, unit)
# proc get_default_bottom_margin*(self: PaperSize, unit: Unit): float64 {.inline.} =

# gtk_paper_size_get_default_left_margin
# flags: {isMethod} container: PaperSize
# need sugar: is method
# unit 'Unit' 'Unit' IN
# 'float64' 'float64'
proc gtk_paper_size_get_default_left_margin(self: ptr TPaperSize, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_paper_size_get_default_left_margin".}
proc get_default_left_margin*(self: PaperSize, unit: Unit): float64 {.inline.} =
  gtk_paper_size_get_default_left_margin(self, unit)
# proc get_default_left_margin*(self: PaperSize, unit: Unit): float64 {.inline.} =

# gtk_paper_size_get_default_right_margin
# flags: {isMethod} container: PaperSize
# need sugar: is method
# unit 'Unit' 'Unit' IN
# 'float64' 'float64'
proc gtk_paper_size_get_default_right_margin(self: ptr TPaperSize, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_paper_size_get_default_right_margin".}
proc get_default_right_margin*(self: PaperSize, unit: Unit): float64 {.inline.} =
  gtk_paper_size_get_default_right_margin(self, unit)
# proc get_default_right_margin*(self: PaperSize, unit: Unit): float64 {.inline.} =

# gtk_paper_size_get_default_top_margin
# flags: {isMethod} container: PaperSize
# need sugar: is method
# unit 'Unit' 'Unit' IN
# 'float64' 'float64'
proc gtk_paper_size_get_default_top_margin(self: ptr TPaperSize, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_paper_size_get_default_top_margin".}
proc get_default_top_margin*(self: PaperSize, unit: Unit): float64 {.inline.} =
  gtk_paper_size_get_default_top_margin(self, unit)
# proc get_default_top_margin*(self: PaperSize, unit: Unit): float64 {.inline.} =

# gtk_paper_size_get_display_name
# flags: {isMethod} container: PaperSize
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_paper_size_get_display_name(self: ptr TPaperSize): ucstring {.cdecl, dynlib: lib, importc: "gtk_paper_size_get_display_name".}
proc get_display_name*(self: PaperSize): ustring {.inline.} =
  ustring($(gtk_paper_size_get_display_name(self)))
# proc get_display_name*(self: PaperSize): ustring {.inline.} =

# gtk_paper_size_get_height
# flags: {isMethod} container: PaperSize
# need sugar: is method
# unit 'Unit' 'Unit' IN
# 'float64' 'float64'
proc gtk_paper_size_get_height(self: ptr TPaperSize, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_paper_size_get_height".}
proc get_height*(self: PaperSize, unit: Unit): float64 {.inline.} =
  gtk_paper_size_get_height(self, unit)
# proc get_height*(self: PaperSize, unit: Unit): float64 {.inline.} =

# gtk_paper_size_get_name
# flags: {isMethod} container: PaperSize
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_paper_size_get_name(self: ptr TPaperSize): ucstring {.cdecl, dynlib: lib, importc: "gtk_paper_size_get_name".}
proc get_name*(self: PaperSize): ustring {.inline.} =
  ustring($(gtk_paper_size_get_name(self)))
# proc get_name*(self: PaperSize): ustring {.inline.} =

# gtk_paper_size_get_ppd_name
# flags: {isMethod} container: PaperSize
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_paper_size_get_ppd_name(self: ptr TPaperSize): ucstring {.cdecl, dynlib: lib, importc: "gtk_paper_size_get_ppd_name".}
proc get_ppd_name*(self: PaperSize): ustring {.inline.} =
  ustring($(gtk_paper_size_get_ppd_name(self)))
# proc get_ppd_name*(self: PaperSize): ustring {.inline.} =

# gtk_paper_size_get_width
# flags: {isMethod} container: PaperSize
# need sugar: is method
# unit 'Unit' 'Unit' IN
# 'float64' 'float64'
proc gtk_paper_size_get_width(self: ptr TPaperSize, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_paper_size_get_width".}
proc get_width*(self: PaperSize, unit: Unit): float64 {.inline.} =
  gtk_paper_size_get_width(self, unit)
# proc get_width*(self: PaperSize, unit: Unit): float64 {.inline.} =

# gtk_paper_size_is_custom
# flags: {isMethod} container: PaperSize
# need sugar: is method
# 'bool' 'bool'
proc gtk_paper_size_is_custom(self: ptr TPaperSize): bool {.cdecl, dynlib: lib, importc: "gtk_paper_size_is_custom".}
proc is_custom*(self: PaperSize): bool {.inline.} =
  gtk_paper_size_is_custom(self)
# proc is_custom*(self: PaperSize): bool {.inline.} =

# gtk_paper_size_is_equal
# flags: {isMethod} container: PaperSize
# need sugar: is method
# size2 'TPaperSize' 'ptr TPaperSize' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_paper_size_is_equal(self: ptr TPaperSize, size2: ptr TPaperSize): bool {.cdecl, dynlib: lib, importc: "gtk_paper_size_is_equal".}
proc is_equal*(self: PaperSize, size2: TPaperSize): bool {.inline.} =
  gtk_paper_size_is_equal(self, myUnsafeAddr(size2))
# proc is_equal*(self: PaperSize, size2: TPaperSize): bool {.inline.} =

# gtk_paper_size_set_size
# flags: {isMethod} container: PaperSize
# need sugar: is method
# width 'float64' 'float64' IN
# height 'float64' 'float64' IN
# unit 'Unit' 'Unit' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_paper_size_set_size(self: ptr TPaperSize, width: float64, height: float64, unit: Unit) {.cdecl, dynlib: lib, importc: "gtk_paper_size_set_size".}
proc set_size*(self: PaperSize, width: float64, height: float64, unit: Unit) {.inline.} =
  gtk_paper_size_set_size(self, width, height, unit)
# proc set_size*(self: PaperSize, width: float64, height: float64, unit: Unit) {.inline.} =

# gtk_paper_size_to_key_file
# flags: {isMethod} container: PaperSize
# need sugar: is method
# key_file 'GLib2.TKeyFile' 'ptr GLib2.TKeyFile' IN (diff., need sugar)
# group_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_paper_size_to_key_file(self: ptr TPaperSize, key_file: ptr GLib2.TKeyFile, group_name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_paper_size_to_key_file".}
proc to_key_file*(self: PaperSize, key_file: GLib2.TKeyFile, group_name: ustring) {.inline.} =
  gtk_paper_size_to_key_file(self, myUnsafeAddr(key_file), ucstring(group_name))
# proc to_key_file*(self: PaperSize, key_file: GLib2.TKeyFile, group_name: ustring) {.inline.} =

# gtk_paper_size_get_default
# flags: {} container: PaperSize
# need sugar: is static method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_paper_size_get_default(): ucstring {.cdecl, dynlib: lib, importc: "gtk_paper_size_get_default".}
template get_default*(klass_parameter: typedesc[PaperSize]): ustring =
  ustring($(gtk_paper_size_get_default()))
# template get_default*(klass_parameter: typedesc[PaperSize]): ustring =

# gtk_paper_size_get_paper_sizes
# flags: {} container: PaperSize
# need sugar: is static method
# include_custom 'bool' 'bool' IN
# 'ptr GLIST_TODO' 'ptr GLIST_TODO'
# warning, already written a prototype with the name of gtk_paper_size_get_paper_sizes
# proc gtk_paper_size_get_paper_sizes(include_custom: bool): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_paper_size_get_paper_sizes".}
template get_paper_sizes*(klass_parameter: typedesc[PaperSize], include_custom: bool): ptr GLIST_TODO =
  gtk_paper_size_get_paper_sizes(include_custom)
# template get_paper_sizes*(klass_parameter: typedesc[PaperSize], include_custom: bool): ptr GLIST_TODO =

# struct PlacesSidebarClass
# struct PopoverAccessibleClass
# struct PopoverClass
# struct PopoverPrivate
# struct PrintOperationClass
# struct PrintOperationPreviewIface
# struct PrintOperationPrivate
# struct ProgressBarAccessibleClass
# struct ProgressBarAccessiblePrivate
# struct ProgressBarClass
# struct ProgressBarPrivate
# struct RadioActionClass
# struct RadioActionEntry
# struct RadioActionPrivate
# struct RadioButtonAccessibleClass
# struct RadioButtonAccessiblePrivate
# struct RadioButtonClass
# struct RadioButtonPrivate
# struct RadioMenuItemAccessibleClass
# struct RadioMenuItemAccessiblePrivate
# struct RadioMenuItemClass
# struct RadioMenuItemPrivate
# struct RadioToolButtonClass
# struct RangeAccessibleClass
# struct RangeAccessiblePrivate
# struct RangeClass
# struct RangePrivate
# struct RcContext
# struct RcProperty
# gtk_rc_property_parse_border
# flags: {} container: RcProperty
# need sugar: is static method
# pspec 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# gstring 'GLib2.TString' 'ptr GLib2.TString' IN (diff., need sugar)
# property_value 'GObject2.TValue' 'ptr GObject2.TValue' IN (diff., need sugar)
# 'bool' 'bool'
# warning, already written a prototype with the name of gtk_rc_property_parse_border
# proc gtk_rc_property_parse_border(pspec: ptr GObject2.TParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.cdecl, dynlib: lib, importc: "gtk_rc_property_parse_border".}
template parse_border*(klass_parameter: typedesc[RcProperty], pspec: GObject2.ParamSpec, gstring: GLib2.TString, property_value: GObject2.TValue): bool =
  gtk_rc_property_parse_border(pspec.getPointer, myUnsafeAddr(gstring), myUnsafeAddr(property_value))
# template parse_border*(klass_parameter: typedesc[RcProperty], pspec: GObject2.ParamSpec, gstring: GLib2.TString, property_value: GObject2.TValue): bool =

# gtk_rc_property_parse_color
# flags: {} container: RcProperty
# need sugar: is static method
# pspec 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# gstring 'GLib2.TString' 'ptr GLib2.TString' IN (diff., need sugar)
# property_value 'GObject2.TValue' 'ptr GObject2.TValue' IN (diff., need sugar)
# 'bool' 'bool'
# warning, already written a prototype with the name of gtk_rc_property_parse_color
# proc gtk_rc_property_parse_color(pspec: ptr GObject2.TParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.cdecl, dynlib: lib, importc: "gtk_rc_property_parse_color".}
template parse_color*(klass_parameter: typedesc[RcProperty], pspec: GObject2.ParamSpec, gstring: GLib2.TString, property_value: GObject2.TValue): bool =
  gtk_rc_property_parse_color(pspec.getPointer, myUnsafeAddr(gstring), myUnsafeAddr(property_value))
# template parse_color*(klass_parameter: typedesc[RcProperty], pspec: GObject2.ParamSpec, gstring: GLib2.TString, property_value: GObject2.TValue): bool =

# gtk_rc_property_parse_enum
# flags: {} container: RcProperty
# need sugar: is static method
# pspec 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# gstring 'GLib2.TString' 'ptr GLib2.TString' IN (diff., need sugar)
# property_value 'GObject2.TValue' 'ptr GObject2.TValue' IN (diff., need sugar)
# 'bool' 'bool'
# warning, already written a prototype with the name of gtk_rc_property_parse_enum
# proc gtk_rc_property_parse_enum(pspec: ptr GObject2.TParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.cdecl, dynlib: lib, importc: "gtk_rc_property_parse_enum".}
template parse_enum*(klass_parameter: typedesc[RcProperty], pspec: GObject2.ParamSpec, gstring: GLib2.TString, property_value: GObject2.TValue): bool =
  gtk_rc_property_parse_enum(pspec.getPointer, myUnsafeAddr(gstring), myUnsafeAddr(property_value))
# template parse_enum*(klass_parameter: typedesc[RcProperty], pspec: GObject2.ParamSpec, gstring: GLib2.TString, property_value: GObject2.TValue): bool =

# gtk_rc_property_parse_flags
# flags: {} container: RcProperty
# need sugar: is static method
# pspec 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# gstring 'GLib2.TString' 'ptr GLib2.TString' IN (diff., need sugar)
# property_value 'GObject2.TValue' 'ptr GObject2.TValue' IN (diff., need sugar)
# 'bool' 'bool'
# warning, already written a prototype with the name of gtk_rc_property_parse_flags
# proc gtk_rc_property_parse_flags(pspec: ptr GObject2.TParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.cdecl, dynlib: lib, importc: "gtk_rc_property_parse_flags".}
template parse_flags*(klass_parameter: typedesc[RcProperty], pspec: GObject2.ParamSpec, gstring: GLib2.TString, property_value: GObject2.TValue): bool =
  gtk_rc_property_parse_flags(pspec.getPointer, myUnsafeAddr(gstring), myUnsafeAddr(property_value))
# template parse_flags*(klass_parameter: typedesc[RcProperty], pspec: GObject2.ParamSpec, gstring: GLib2.TString, property_value: GObject2.TValue): bool =

# gtk_rc_property_parse_requisition
# flags: {} container: RcProperty
# need sugar: is static method
# pspec 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# gstring 'GLib2.TString' 'ptr GLib2.TString' IN (diff., need sugar)
# property_value 'GObject2.TValue' 'ptr GObject2.TValue' IN (diff., need sugar)
# 'bool' 'bool'
# warning, already written a prototype with the name of gtk_rc_property_parse_requisition
# proc gtk_rc_property_parse_requisition(pspec: ptr GObject2.TParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.cdecl, dynlib: lib, importc: "gtk_rc_property_parse_requisition".}
template parse_requisition*(klass_parameter: typedesc[RcProperty], pspec: GObject2.ParamSpec, gstring: GLib2.TString, property_value: GObject2.TValue): bool =
  gtk_rc_property_parse_requisition(pspec.getPointer, myUnsafeAddr(gstring), myUnsafeAddr(property_value))
# template parse_requisition*(klass_parameter: typedesc[RcProperty], pspec: GObject2.ParamSpec, gstring: GLib2.TString, property_value: GObject2.TValue): bool =

# struct RcStyleClass
# struct RecentActionClass
# struct RecentActionPrivate
# struct RecentChooserDialogClass
# struct RecentChooserDialogPrivate
# struct RecentChooserIface
# struct RecentChooserMenuClass
# struct RecentChooserMenuPrivate
# struct RecentChooserWidgetClass
# struct RecentChooserWidgetPrivate
# struct RecentData
# struct RecentFilterInfo
# struct RecentInfo
# gtk_recent_info_create_app_info
# flags: {isMethod, throws} container: RecentInfo
# can throw
# need sugar: is method
# app_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'Gio2.AppInfo' 'TransferFull[Gio2.TAppInfo]' (diff., need sugar)
proc gtk_recent_info_create_app_info(self: ptr TRecentInfo, app_name: ucstring, error: ptr PGError=nil): TransferFull[Gio2.TAppInfo] {.cdecl, dynlib: lib, importc: "gtk_recent_info_create_app_info".}
proc create_app_info*(self: RecentInfo, app_name: ustring): Gio2.AppInfo {.inline.} =
  wrap(gtk_recent_info_create_app_info(self, ucstring(app_name)))
# proc create_app_info*(self: RecentInfo, app_name: ustring): Gio2.AppInfo {.inline.} =

# gtk_recent_info_exists
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# 'bool' 'bool'
proc gtk_recent_info_exists(self: ptr TRecentInfo): bool {.cdecl, dynlib: lib, importc: "gtk_recent_info_exists".}
proc exists*(self: RecentInfo): bool {.inline.} =
  gtk_recent_info_exists(self)
# proc exists*(self: RecentInfo): bool {.inline.} =

# gtk_recent_info_get_added
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# 'int32' 'int32'
proc gtk_recent_info_get_added(self: ptr TRecentInfo): int32 {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_added".}
proc get_added*(self: RecentInfo): int32 {.inline.} =
  gtk_recent_info_get_added(self)
# proc get_added*(self: RecentInfo): int32 {.inline.} =

# gtk_recent_info_get_age
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# 'int32' 'int32'
proc gtk_recent_info_get_age(self: ptr TRecentInfo): int32 {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_age".}
proc get_age*(self: RecentInfo): int32 {.inline.} =
  gtk_recent_info_get_age(self)
# proc get_age*(self: RecentInfo): int32 {.inline.} =

# gtk_recent_info_get_application_info
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# app_name 'ustring' 'ucstring' IN (diff., need sugar)
# app_exec 'var ucstring' 'ptr ucstring' OUT (diff., need sugar)
# count 'var uint32' 'ptr uint32' OUT (diff., need sugar)
# time_ 'var int32' 'ptr int32' OUT (diff., need sugar)
# 'bool' 'bool'
proc gtk_recent_info_get_application_info(self: ptr TRecentInfo, app_name: ucstring, app_exec: ptr ucstring, count: ptr uint32, time_x: ptr int32): bool {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_application_info".}
proc get_application_info*(self: RecentInfo, app_name: ustring, app_exec: var ucstring, count: var uint32, time_x: var int32): bool {.inline.} =
  gtk_recent_info_get_application_info(self, ucstring(app_name), addr(app_exec), addr(count), addr(time_x))
# tuple-return
# app_exec: var ucstring
# count: var uint32
# time_: var int32
# proc get_application_info*(self: RecentInfo, app_name: ustring): bool {.inline.} =

# gtk_recent_info_get_applications
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# length 'var uint32' 'ptr uint32' OUT (diff., need sugar) optional
# 'zeroTerminatedArray[ucstring]' 'zeroTerminatedArray[ucstring]'
proc gtk_recent_info_get_applications(self: ptr TRecentInfo, length: ptr uint32): zeroTerminatedArray[ucstring] {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_applications".}
proc get_applications*(self: RecentInfo, length: var uint32): zeroTerminatedArray[ucstring] {.inline.} =
  gtk_recent_info_get_applications(self, addr(length))
# tuple-return
# length: var uint32
# proc get_applications*(self: RecentInfo): zeroTerminatedArray[ucstring] {.inline.} =

# gtk_recent_info_get_description
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_recent_info_get_description(self: ptr TRecentInfo): ucstring {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_description".}
proc get_description*(self: RecentInfo): ustring {.inline.} =
  ustring($(gtk_recent_info_get_description(self)))
# proc get_description*(self: RecentInfo): ustring {.inline.} =

# gtk_recent_info_get_display_name
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_recent_info_get_display_name(self: ptr TRecentInfo): ucstring {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_display_name".}
proc get_display_name*(self: RecentInfo): ustring {.inline.} =
  ustring($(gtk_recent_info_get_display_name(self)))
# proc get_display_name*(self: RecentInfo): ustring {.inline.} =

# gtk_recent_info_get_gicon
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# 'Gio2.Icon' 'TransferFull[Gio2.TIcon]' (diff., need sugar)
proc gtk_recent_info_get_gicon(self: ptr TRecentInfo): TransferFull[Gio2.TIcon] {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_gicon".}
proc get_gicon*(self: RecentInfo): Gio2.Icon {.inline.} =
  wrap(gtk_recent_info_get_gicon(self))
# proc get_gicon*(self: RecentInfo): Gio2.Icon {.inline.} =

# gtk_recent_info_get_groups
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# length 'var uint32' 'ptr uint32' OUT (diff., need sugar) optional
# 'zeroTerminatedArray[ucstring]' 'zeroTerminatedArray[ucstring]'
proc gtk_recent_info_get_groups(self: ptr TRecentInfo, length: ptr uint32): zeroTerminatedArray[ucstring] {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_groups".}
proc get_groups*(self: RecentInfo, length: var uint32): zeroTerminatedArray[ucstring] {.inline.} =
  gtk_recent_info_get_groups(self, addr(length))
# tuple-return
# length: var uint32
# proc get_groups*(self: RecentInfo): zeroTerminatedArray[ucstring] {.inline.} =

# gtk_recent_info_get_icon
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# size 'int32' 'int32' IN
# 'GdkPixbuf2.Pixbuf' 'TransferFull[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_recent_info_get_icon(self: ptr TRecentInfo, size: int32): TransferFull[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_icon".}
proc get_icon*(self: RecentInfo, size: int32): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_recent_info_get_icon(self, size))
# proc get_icon*(self: RecentInfo, size: int32): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_recent_info_get_mime_type
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_recent_info_get_mime_type(self: ptr TRecentInfo): ucstring {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_mime_type".}
proc get_mime_type*(self: RecentInfo): ustring {.inline.} =
  ustring($(gtk_recent_info_get_mime_type(self)))
# proc get_mime_type*(self: RecentInfo): ustring {.inline.} =

# gtk_recent_info_get_modified
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# 'int32' 'int32'
proc gtk_recent_info_get_modified(self: ptr TRecentInfo): int32 {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_modified".}
proc get_modified*(self: RecentInfo): int32 {.inline.} =
  gtk_recent_info_get_modified(self)
# proc get_modified*(self: RecentInfo): int32 {.inline.} =

# gtk_recent_info_get_private_hint
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# 'bool' 'bool'
proc gtk_recent_info_get_private_hint(self: ptr TRecentInfo): bool {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_private_hint".}
proc get_private_hint*(self: RecentInfo): bool {.inline.} =
  gtk_recent_info_get_private_hint(self)
# proc get_private_hint*(self: RecentInfo): bool {.inline.} =

# gtk_recent_info_get_short_name
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_recent_info_get_short_name(self: ptr TRecentInfo): ucstring {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_short_name".}
proc get_short_name*(self: RecentInfo): ustring {.inline.} =
  ustring($(gtk_recent_info_get_short_name(self)))
# proc get_short_name*(self: RecentInfo): ustring {.inline.} =

# gtk_recent_info_get_uri
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_recent_info_get_uri(self: ptr TRecentInfo): ucstring {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_uri".}
proc get_uri*(self: RecentInfo): ustring {.inline.} =
  ustring($(gtk_recent_info_get_uri(self)))
# proc get_uri*(self: RecentInfo): ustring {.inline.} =

# gtk_recent_info_get_uri_display
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_recent_info_get_uri_display(self: ptr TRecentInfo): ucstring {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_uri_display".}
proc get_uri_display*(self: RecentInfo): ustring {.inline.} =
  ustring($(gtk_recent_info_get_uri_display(self)))
# proc get_uri_display*(self: RecentInfo): ustring {.inline.} =

# gtk_recent_info_get_visited
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# 'int32' 'int32'
proc gtk_recent_info_get_visited(self: ptr TRecentInfo): int32 {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_visited".}
proc get_visited*(self: RecentInfo): int32 {.inline.} =
  gtk_recent_info_get_visited(self)
# proc get_visited*(self: RecentInfo): int32 {.inline.} =

# gtk_recent_info_has_application
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# app_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_recent_info_has_application(self: ptr TRecentInfo, app_name: ucstring): bool {.cdecl, dynlib: lib, importc: "gtk_recent_info_has_application".}
proc has_application*(self: RecentInfo, app_name: ustring): bool {.inline.} =
  gtk_recent_info_has_application(self, ucstring(app_name))
# proc has_application*(self: RecentInfo, app_name: ustring): bool {.inline.} =

# gtk_recent_info_has_group
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# group_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_recent_info_has_group(self: ptr TRecentInfo, group_name: ucstring): bool {.cdecl, dynlib: lib, importc: "gtk_recent_info_has_group".}
proc has_group*(self: RecentInfo, group_name: ustring): bool {.inline.} =
  gtk_recent_info_has_group(self, ucstring(group_name))
# proc has_group*(self: RecentInfo, group_name: ustring): bool {.inline.} =

# gtk_recent_info_is_local
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# 'bool' 'bool'
proc gtk_recent_info_is_local(self: ptr TRecentInfo): bool {.cdecl, dynlib: lib, importc: "gtk_recent_info_is_local".}
proc is_local*(self: RecentInfo): bool {.inline.} =
  gtk_recent_info_is_local(self)
# proc is_local*(self: RecentInfo): bool {.inline.} =

# gtk_recent_info_last_application
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_recent_info_last_application(self: ptr TRecentInfo): ucstring {.cdecl, dynlib: lib, importc: "gtk_recent_info_last_application".}
proc last_application*(self: RecentInfo): ustring {.inline.} =
  ustring($(gtk_recent_info_last_application(self)))
# proc last_application*(self: RecentInfo): ustring {.inline.} =

# gtk_recent_info_match
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# info_b 'TRecentInfo' 'ptr TRecentInfo' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_recent_info_match(self: ptr TRecentInfo, info_b: ptr TRecentInfo): bool {.cdecl, dynlib: lib, importc: "gtk_recent_info_match".}
proc match*(self: RecentInfo, info_b: TRecentInfo): bool {.inline.} =
  gtk_recent_info_match(self, myUnsafeAddr(info_b))
# proc match*(self: RecentInfo, info_b: TRecentInfo): bool {.inline.} =

# gtk_recent_info_ref
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# 'TRecentInfo' 'ptr TRecentInfo' (diff., need sugar)
proc gtk_recent_info_ref(self: ptr TRecentInfo): ptr TRecentInfo {.cdecl, dynlib: lib, importc: "gtk_recent_info_ref".}
proc ref_x*(self: RecentInfo): TRecentInfo {.inline.} =
  (gtk_recent_info_ref(self))[]
# proc ref_x*(self: RecentInfo): TRecentInfo {.inline.} =

# gtk_recent_info_unref
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_recent_info_unref(self: ptr TRecentInfo) {.cdecl, dynlib: lib, importc: "gtk_recent_info_unref".}
proc unref*(self: RecentInfo) {.inline.} =
  gtk_recent_info_unref(self)
# proc unref*(self: RecentInfo) {.inline.} =

# struct RecentManagerClass
# struct RecentManagerPrivate
# struct RendererCellAccessibleClass
# struct RendererCellAccessiblePrivate
# struct RequestedSize
# struct Requisition
# gtk_requisition_new
# flags: {isConstructor} container: Requisition
# need sugar: is static method
# 'TRequisition' 'ptr TRequisition' (diff., need sugar)
proc gtk_requisition_new(): ptr TRequisition {.cdecl, dynlib: lib, importc: "gtk_requisition_new".}
proc new_requisition*(): TRequisition {.inline.} =
  (gtk_requisition_new())[]
# proc new_requisition*(): TRequisition {.inline.} =

# gtk_requisition_copy
# flags: {isMethod} container: Requisition
# need sugar: is method
# 'TRequisition' 'ptr TRequisition' (diff., need sugar)
proc gtk_requisition_copy(self: ptr TRequisition): ptr TRequisition {.cdecl, dynlib: lib, importc: "gtk_requisition_copy".}
proc copy*(self: Requisition): TRequisition {.inline.} =
  (gtk_requisition_copy(self))[]
# proc copy*(self: Requisition): TRequisition {.inline.} =

# gtk_requisition_free
# flags: {isMethod} container: Requisition
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_requisition_free(self: ptr TRequisition) {.cdecl, dynlib: lib, importc: "gtk_requisition_free".}
proc free*(self: Requisition) {.inline.} =
  gtk_requisition_free(self)
# proc free*(self: Requisition) {.inline.} =

# struct RevealerClass
# struct ScaleAccessibleClass
# struct ScaleAccessiblePrivate
# struct ScaleButtonAccessibleClass
# struct ScaleButtonAccessiblePrivate
# struct ScaleButtonClass
# struct ScaleButtonPrivate
# struct ScaleClass
# struct ScalePrivate
# struct ScrollableInterface
# struct ScrollbarClass
# struct ScrolledWindowAccessibleClass
# struct ScrolledWindowAccessiblePrivate
# struct ScrolledWindowClass
# struct ScrolledWindowPrivate
# struct SearchBarClass
# struct SearchEntryClass
# struct SelectionData
# gtk_selection_data_copy
# flags: {isMethod} container: SelectionData
# need sugar: is method
# 'TSelectionData' 'ptr TSelectionData' (diff., need sugar)
proc gtk_selection_data_copy(self: ptr TSelectionData): ptr TSelectionData {.cdecl, dynlib: lib, importc: "gtk_selection_data_copy".}
proc copy*(self: SelectionData): TSelectionData {.inline.} =
  (gtk_selection_data_copy(self))[]
# proc copy*(self: SelectionData): TSelectionData {.inline.} =

# gtk_selection_data_free
# flags: {isMethod} container: SelectionData
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_selection_data_free(self: ptr TSelectionData) {.cdecl, dynlib: lib, importc: "gtk_selection_data_free".}
proc free*(self: SelectionData) {.inline.} =
  gtk_selection_data_free(self)
# proc free*(self: SelectionData) {.inline.} =

# gtk_selection_data_get_data_type
# flags: {isMethod} container: SelectionData
# need sugar: is method
# 'Gdk3.TAtom' 'ptr Gdk3.TAtom' (diff., need sugar)
proc gtk_selection_data_get_data_type(self: ptr TSelectionData): ptr Gdk3.TAtom {.cdecl, dynlib: lib, importc: "gtk_selection_data_get_data_type".}
proc get_data_type*(self: SelectionData): Gdk3.TAtom {.inline.} =
  (gtk_selection_data_get_data_type(self))[]
# proc get_data_type*(self: SelectionData): Gdk3.TAtom {.inline.} =

# gtk_selection_data_get_data_with_length
# flags: {isMethod} container: SelectionData
# need sugar: is method
# length 'var int32' 'ptr int32' OUT (diff., need sugar)
# 'string' 'cstring' (diff., need sugar)
proc gtk_selection_data_get_data_with_length(self: ptr TSelectionData, length: ptr int32): cstring {.cdecl, dynlib: lib, importc: "gtk_selection_data_get_data_with_length".}
proc get_data*(self: SelectionData, length: var int32): string {.inline.} =
  $(gtk_selection_data_get_data_with_length(self, addr(length)))
# tuple-return
# length: var int32
# proc get_data*(self: SelectionData): string {.inline.} =

# gtk_selection_data_get_display
# flags: {isMethod} container: SelectionData
# need sugar: is method
# 'Gdk3.Display' 'TransferNone[Gdk3.TDisplay]' (diff., need sugar)
proc gtk_selection_data_get_display(self: ptr TSelectionData): TransferNone[Gdk3.TDisplay] {.cdecl, dynlib: lib, importc: "gtk_selection_data_get_display".}
proc get_display*(self: SelectionData): Gdk3.Display {.inline.} =
  wrap(gtk_selection_data_get_display(self))
# proc get_display*(self: SelectionData): Gdk3.Display {.inline.} =

# gtk_selection_data_get_format
# flags: {isMethod} container: SelectionData
# need sugar: is method
# 'int32' 'int32'
proc gtk_selection_data_get_format(self: ptr TSelectionData): int32 {.cdecl, dynlib: lib, importc: "gtk_selection_data_get_format".}
proc get_format*(self: SelectionData): int32 {.inline.} =
  gtk_selection_data_get_format(self)
# proc get_format*(self: SelectionData): int32 {.inline.} =

# gtk_selection_data_get_length
# flags: {isMethod} container: SelectionData
# need sugar: is method
# 'int32' 'int32'
proc gtk_selection_data_get_length(self: ptr TSelectionData): int32 {.cdecl, dynlib: lib, importc: "gtk_selection_data_get_length".}
proc get_length*(self: SelectionData): int32 {.inline.} =
  gtk_selection_data_get_length(self)
# proc get_length*(self: SelectionData): int32 {.inline.} =

# gtk_selection_data_get_pixbuf
# flags: {isMethod} container: SelectionData
# need sugar: is method
# 'GdkPixbuf2.Pixbuf' 'TransferFull[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_selection_data_get_pixbuf(self: ptr TSelectionData): TransferFull[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_selection_data_get_pixbuf".}
proc get_pixbuf*(self: SelectionData): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_selection_data_get_pixbuf(self))
# proc get_pixbuf*(self: SelectionData): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_selection_data_get_selection
# flags: {isMethod} container: SelectionData
# need sugar: is method
# 'Gdk3.TAtom' 'ptr Gdk3.TAtom' (diff., need sugar)
proc gtk_selection_data_get_selection(self: ptr TSelectionData): ptr Gdk3.TAtom {.cdecl, dynlib: lib, importc: "gtk_selection_data_get_selection".}
proc get_selection*(self: SelectionData): Gdk3.TAtom {.inline.} =
  (gtk_selection_data_get_selection(self))[]
# proc get_selection*(self: SelectionData): Gdk3.TAtom {.inline.} =

# gtk_selection_data_get_target
# flags: {isMethod} container: SelectionData
# need sugar: is method
# 'Gdk3.TAtom' 'ptr Gdk3.TAtom' (diff., need sugar)
proc gtk_selection_data_get_target(self: ptr TSelectionData): ptr Gdk3.TAtom {.cdecl, dynlib: lib, importc: "gtk_selection_data_get_target".}
proc get_target*(self: SelectionData): Gdk3.TAtom {.inline.} =
  (gtk_selection_data_get_target(self))[]
# proc get_target*(self: SelectionData): Gdk3.TAtom {.inline.} =

# gtk_selection_data_get_targets
# flags: {isMethod} container: SelectionData
# need sugar: is method
# targets 'var openarray[ptr Gdk3.TAtom]' 'openarray[ptr Gdk3.TAtom]' OUT (diff., need sugar) array lengthArg: 1
# n_atoms 'var int32' 'ptr int32' OUT (diff., need sugar)
# 'bool' 'bool'
proc gtk_selection_data_get_targets(self: ptr TSelectionData, targets: openarray[ptr Gdk3.TAtom], n_atoms: ptr int32): bool {.cdecl, dynlib: lib, importc: "gtk_selection_data_get_targets".}
proc get_targets*(self: SelectionData, targets: var openarray[ptr Gdk3.TAtom], n_atoms: var int32): bool {.inline.} =
  gtk_selection_data_get_targets(self, targets, addr(n_atoms))
# tuple-return
# targets: var openarray[ptr Gdk3.TAtom]
# n_atoms: var int32
# proc get_targets*(self: SelectionData): bool {.inline.} =

# gtk_selection_data_get_text
# flags: {isMethod} container: SelectionData
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_selection_data_get_text(self: ptr TSelectionData): ucstring {.cdecl, dynlib: lib, importc: "gtk_selection_data_get_text".}
proc get_text*(self: SelectionData): ustring {.inline.} =
  ustring($(gtk_selection_data_get_text(self)))
# proc get_text*(self: SelectionData): ustring {.inline.} =

# gtk_selection_data_get_uris
# flags: {isMethod} container: SelectionData
# need sugar: is method
# 'zeroTerminatedArray[ucstring]' 'zeroTerminatedArray[ucstring]'
proc gtk_selection_data_get_uris(self: ptr TSelectionData): zeroTerminatedArray[ucstring] {.cdecl, dynlib: lib, importc: "gtk_selection_data_get_uris".}
proc get_uris*(self: SelectionData): zeroTerminatedArray[ucstring] {.inline.} =
  gtk_selection_data_get_uris(self)
# proc get_uris*(self: SelectionData): zeroTerminatedArray[ucstring] {.inline.} =

# gtk_selection_data_set
# flags: {isMethod} container: SelectionData
# need sugar: is method
# type 'Gdk3.TAtom' 'ptr Gdk3.TAtom' IN (diff., need sugar)
# format 'int32' 'int32' IN
# data 'string' 'cstring' IN (diff., need sugar) array lengthArg: 3
# length 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_selection_data_set(self: ptr TSelectionData, type_x: ptr Gdk3.TAtom, format: int32, data: cstring, length: int32) {.cdecl, dynlib: lib, importc: "gtk_selection_data_set".}
proc set*(self: SelectionData, type_x: Gdk3.TAtom, format: int32, data: string) {.inline.} =
  gtk_selection_data_set(self, myUnsafeAddr(type_x), format, cstring(data), data.len.int32)
# proc set*(self: SelectionData, type_x: Gdk3.TAtom, format: int32, data: string) {.inline.} =

# gtk_selection_data_set_pixbuf
# flags: {isMethod} container: SelectionData
# need sugar: is method
# pixbuf 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_selection_data_set_pixbuf(self: ptr TSelectionData, pixbuf: ptr GdkPixbuf2.TPixbuf): bool {.cdecl, dynlib: lib, importc: "gtk_selection_data_set_pixbuf".}
proc set_pixbuf*(self: SelectionData, pixbuf: GdkPixbuf2.Pixbuf): bool {.inline.} =
  gtk_selection_data_set_pixbuf(self, pixbuf.getPointer)
# proc set_pixbuf*(self: SelectionData, pixbuf: GdkPixbuf2.Pixbuf): bool {.inline.} =

# gtk_selection_data_set_text
# flags: {isMethod} container: SelectionData
# need sugar: is method
# str 'ustring' 'ucstring' IN (diff., need sugar)
# len 'int32' 'int32' IN
# 'bool' 'bool'
proc gtk_selection_data_set_text(self: ptr TSelectionData, str: ucstring, len: int32): bool {.cdecl, dynlib: lib, importc: "gtk_selection_data_set_text".}
proc set_text*(self: SelectionData, str: ustring, len: int32): bool {.inline.} =
  gtk_selection_data_set_text(self, ucstring(str), len)
# proc set_text*(self: SelectionData, str: ustring, len: int32): bool {.inline.} =

# gtk_selection_data_set_uris
# flags: {isMethod} container: SelectionData
# need sugar: is method
# uris 'uncheckedArray[ucstring]' 'uncheckedArray[ucstring]' IN array zero-terminated
# 'bool' 'bool'
proc gtk_selection_data_set_uris(self: ptr TSelectionData, uris: uncheckedArray[ucstring]): bool {.cdecl, dynlib: lib, importc: "gtk_selection_data_set_uris".}
proc set_uris*(self: SelectionData, uris: uncheckedArray[ucstring]): bool {.inline.} =
  gtk_selection_data_set_uris(self, uris)
# proc set_uris*(self: SelectionData, uris: uncheckedArray[ucstring]): bool {.inline.} =

# gtk_selection_data_targets_include_image
# flags: {isMethod} container: SelectionData
# need sugar: is method
# writable 'bool' 'bool' IN
# 'bool' 'bool'
proc gtk_selection_data_targets_include_image(self: ptr TSelectionData, writable: bool): bool {.cdecl, dynlib: lib, importc: "gtk_selection_data_targets_include_image".}
proc targets_include_image*(self: SelectionData, writable: bool): bool {.inline.} =
  gtk_selection_data_targets_include_image(self, writable)
# proc targets_include_image*(self: SelectionData, writable: bool): bool {.inline.} =

# gtk_selection_data_targets_include_rich_text
# flags: {isMethod} container: SelectionData
# need sugar: is method
# buffer 'TextBuffer' 'ptr TTextBuffer' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_selection_data_targets_include_rich_text(self: ptr TSelectionData, buffer: ptr TTextBuffer): bool {.cdecl, dynlib: lib, importc: "gtk_selection_data_targets_include_rich_text".}
proc targets_include_rich_text*(self: SelectionData, buffer: TextBuffer): bool {.inline.} =
  gtk_selection_data_targets_include_rich_text(self, buffer.getPointer)
# proc targets_include_rich_text*(self: SelectionData, buffer: TextBuffer): bool {.inline.} =

# gtk_selection_data_targets_include_text
# flags: {isMethod} container: SelectionData
# need sugar: is method
# 'bool' 'bool'
proc gtk_selection_data_targets_include_text(self: ptr TSelectionData): bool {.cdecl, dynlib: lib, importc: "gtk_selection_data_targets_include_text".}
proc targets_include_text*(self: SelectionData): bool {.inline.} =
  gtk_selection_data_targets_include_text(self)
# proc targets_include_text*(self: SelectionData): bool {.inline.} =

# gtk_selection_data_targets_include_uri
# flags: {isMethod} container: SelectionData
# need sugar: is method
# 'bool' 'bool'
proc gtk_selection_data_targets_include_uri(self: ptr TSelectionData): bool {.cdecl, dynlib: lib, importc: "gtk_selection_data_targets_include_uri".}
proc targets_include_uri*(self: SelectionData): bool {.inline.} =
  gtk_selection_data_targets_include_uri(self)
# proc targets_include_uri*(self: SelectionData): bool {.inline.} =

# struct SeparatorClass
# struct SeparatorMenuItemClass
# struct SeparatorPrivate
# struct SeparatorToolItemClass
# struct SeparatorToolItemPrivate
# struct SettingsClass
# struct SettingsPrivate
# struct SettingsValue
# struct SizeGroupClass
# struct SizeGroupPrivate
# struct SpinButtonAccessibleClass
# struct SpinButtonAccessiblePrivate
# struct SpinButtonClass
# struct SpinButtonPrivate
# struct SpinnerAccessibleClass
# struct SpinnerAccessiblePrivate
# struct SpinnerClass
# struct SpinnerPrivate
# struct StackClass
# struct StackSwitcherClass
# struct StatusIconClass
# struct StatusIconPrivate
# struct StatusbarAccessibleClass
# struct StatusbarAccessiblePrivate
# struct StatusbarClass
# struct StatusbarPrivate
# struct StockItem
# gtk_stock_item_free
# flags: {isMethod} container: StockItem (deprecated)
# struct StyleClass
# struct StyleContextClass
# struct StyleContextPrivate
# struct StylePropertiesClass
# struct StylePropertiesPrivate
# struct StyleProviderIface
# struct SwitchAccessibleClass
# struct SwitchAccessiblePrivate
# struct SwitchClass
# struct SwitchPrivate
# struct SymbolicColor
# gtk_symbolic_color_new_alpha
# flags: {isConstructor} container: SymbolicColor (deprecated)
# gtk_symbolic_color_new_literal
# flags: {isConstructor} container: SymbolicColor (deprecated)
# gtk_symbolic_color_new_mix
# flags: {isConstructor} container: SymbolicColor (deprecated)
# gtk_symbolic_color_new_name
# flags: {isConstructor} container: SymbolicColor (deprecated)
# gtk_symbolic_color_new_shade
# flags: {isConstructor} container: SymbolicColor (deprecated)
# gtk_symbolic_color_new_win32
# flags: {isConstructor} container: SymbolicColor (deprecated)
# gtk_symbolic_color_ref
# flags: {isMethod} container: SymbolicColor (deprecated)
# gtk_symbolic_color_resolve
# flags: {isMethod} container: SymbolicColor (deprecated)
# gtk_symbolic_color_to_string
# flags: {isMethod} container: SymbolicColor (deprecated)
# gtk_symbolic_color_unref
# flags: {isMethod} container: SymbolicColor (deprecated)
# struct TableChild
# struct TableClass
# struct TablePrivate
# struct TableRowCol
# struct TargetEntry
# gtk_target_entry_new
# flags: {isConstructor} container: TargetEntry
# need sugar: is static method
# target 'ustring' 'ucstring' IN (diff., need sugar)
# flags 'uint32' 'uint32' IN
# info 'uint32' 'uint32' IN
# 'TTargetEntry' 'ptr TTargetEntry' (diff., need sugar)
proc gtk_target_entry_new(target: ucstring, flags: uint32, info: uint32): ptr TTargetEntry {.cdecl, dynlib: lib, importc: "gtk_target_entry_new".}
proc new_targetentry*(target: ustring, flags: uint32, info: uint32): TTargetEntry {.inline.} =
  (gtk_target_entry_new(ucstring(target), flags, info))[]
# proc new_targetentry*(target: ustring, flags: uint32, info: uint32): TTargetEntry {.inline.} =

# gtk_target_entry_copy
# flags: {isMethod} container: TargetEntry
# need sugar: is method
# 'TTargetEntry' 'ptr TTargetEntry' (diff., need sugar)
proc gtk_target_entry_copy(self: ptr TTargetEntry): ptr TTargetEntry {.cdecl, dynlib: lib, importc: "gtk_target_entry_copy".}
proc copy*(self: TargetEntry): TTargetEntry {.inline.} =
  (gtk_target_entry_copy(self))[]
# proc copy*(self: TargetEntry): TTargetEntry {.inline.} =

# gtk_target_entry_free
# flags: {isMethod} container: TargetEntry
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_target_entry_free(self: ptr TTargetEntry) {.cdecl, dynlib: lib, importc: "gtk_target_entry_free".}
proc free*(self: TargetEntry) {.inline.} =
  gtk_target_entry_free(self)
# proc free*(self: TargetEntry) {.inline.} =

# struct TargetList
# gtk_target_list_new
# flags: {isConstructor} container: TargetList
# need sugar: is static method
# targets 'var openarray[TTargetEntry]' 'openarray[TTargetEntry]' IN (diff., need sugar) array lengthArg: 1
# ntargets 'uint32' 'uint32' IN
# 'TTargetList' 'ptr TTargetList' (diff., need sugar)
proc gtk_target_list_new(targets: openarray[TTargetEntry], ntargets: uint32): ptr TTargetList {.cdecl, dynlib: lib, importc: "gtk_target_list_new".}
proc new_targetlist*(targets: var openarray[TTargetEntry]): TTargetList {.inline.} =
  (gtk_target_list_new(targets, targets.len.uint32))[]
# proc new_targetlist*(targets: var openarray[TTargetEntry]): TTargetList {.inline.} =

# gtk_target_list_add
# flags: {isMethod} container: TargetList
# need sugar: is method
# target 'Gdk3.TAtom' 'ptr Gdk3.TAtom' IN (diff., need sugar)
# flags 'uint32' 'uint32' IN
# info 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_target_list_add(self: ptr TTargetList, target: ptr Gdk3.TAtom, flags: uint32, info: uint32) {.cdecl, dynlib: lib, importc: "gtk_target_list_add".}
proc add*(self: TargetList, target: Gdk3.TAtom, flags: uint32, info: uint32) {.inline.} =
  gtk_target_list_add(self, myUnsafeAddr(target), flags, info)
# proc add*(self: TargetList, target: Gdk3.TAtom, flags: uint32, info: uint32) {.inline.} =

# gtk_target_list_add_image_targets
# flags: {isMethod} container: TargetList
# need sugar: is method
# info 'uint32' 'uint32' IN
# writable 'bool' 'bool' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_target_list_add_image_targets(self: ptr TTargetList, info: uint32, writable: bool) {.cdecl, dynlib: lib, importc: "gtk_target_list_add_image_targets".}
proc add_image_targets*(self: TargetList, info: uint32, writable: bool) {.inline.} =
  gtk_target_list_add_image_targets(self, info, writable)
# proc add_image_targets*(self: TargetList, info: uint32, writable: bool) {.inline.} =

# gtk_target_list_add_rich_text_targets
# flags: {isMethod} container: TargetList
# need sugar: is method
# info 'uint32' 'uint32' IN
# deserializable 'bool' 'bool' IN
# buffer 'TextBuffer' 'ptr TTextBuffer' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_target_list_add_rich_text_targets(self: ptr TTargetList, info: uint32, deserializable: bool, buffer: ptr TTextBuffer) {.cdecl, dynlib: lib, importc: "gtk_target_list_add_rich_text_targets".}
proc add_rich_text_targets*(self: TargetList, info: uint32, deserializable: bool, buffer: TextBuffer) {.inline.} =
  gtk_target_list_add_rich_text_targets(self, info, deserializable, buffer.getPointer)
# proc add_rich_text_targets*(self: TargetList, info: uint32, deserializable: bool, buffer: TextBuffer) {.inline.} =

# gtk_target_list_add_table
# flags: {isMethod} container: TargetList
# need sugar: is method
# targets 'var openarray[TTargetEntry]' 'openarray[TTargetEntry]' IN (diff., need sugar) array lengthArg: 1
# ntargets 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_target_list_add_table(self: ptr TTargetList, targets: openarray[TTargetEntry], ntargets: uint32) {.cdecl, dynlib: lib, importc: "gtk_target_list_add_table".}
proc add_table*(self: TargetList, targets: var openarray[TTargetEntry]) {.inline.} =
  gtk_target_list_add_table(self, targets, targets.len.uint32)
# proc add_table*(self: TargetList, targets: var openarray[TTargetEntry]) {.inline.} =

# gtk_target_list_add_text_targets
# flags: {isMethod} container: TargetList
# need sugar: is method
# info 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_target_list_add_text_targets(self: ptr TTargetList, info: uint32) {.cdecl, dynlib: lib, importc: "gtk_target_list_add_text_targets".}
proc add_text_targets*(self: TargetList, info: uint32) {.inline.} =
  gtk_target_list_add_text_targets(self, info)
# proc add_text_targets*(self: TargetList, info: uint32) {.inline.} =

# gtk_target_list_add_uri_targets
# flags: {isMethod} container: TargetList
# need sugar: is method
# info 'uint32' 'uint32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_target_list_add_uri_targets(self: ptr TTargetList, info: uint32) {.cdecl, dynlib: lib, importc: "gtk_target_list_add_uri_targets".}
proc add_uri_targets*(self: TargetList, info: uint32) {.inline.} =
  gtk_target_list_add_uri_targets(self, info)
# proc add_uri_targets*(self: TargetList, info: uint32) {.inline.} =

# gtk_target_list_find
# flags: {isMethod} container: TargetList
# need sugar: is method
# target 'Gdk3.TAtom' 'ptr Gdk3.TAtom' IN (diff., need sugar)
# info 'var uint32' 'ptr uint32' OUT (diff., need sugar) optional
# 'bool' 'bool'
proc gtk_target_list_find(self: ptr TTargetList, target: ptr Gdk3.TAtom, info: ptr uint32): bool {.cdecl, dynlib: lib, importc: "gtk_target_list_find".}
proc find*(self: TargetList, target: Gdk3.TAtom, info: var uint32): bool {.inline.} =
  gtk_target_list_find(self, myUnsafeAddr(target), addr(info))
# tuple-return
# info: var uint32
# proc find*(self: TargetList, target: Gdk3.TAtom): bool {.inline.} =

# gtk_target_list_ref
# flags: {isMethod} container: TargetList
# need sugar: is method
# 'TTargetList' 'ptr TTargetList' (diff., need sugar)
proc gtk_target_list_ref(self: ptr TTargetList): ptr TTargetList {.cdecl, dynlib: lib, importc: "gtk_target_list_ref".}
proc ref_x*(self: TargetList): TTargetList {.inline.} =
  (gtk_target_list_ref(self))[]
# proc ref_x*(self: TargetList): TTargetList {.inline.} =

# gtk_target_list_remove
# flags: {isMethod} container: TargetList
# need sugar: is method
# target 'Gdk3.TAtom' 'ptr Gdk3.TAtom' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_target_list_remove(self: ptr TTargetList, target: ptr Gdk3.TAtom) {.cdecl, dynlib: lib, importc: "gtk_target_list_remove".}
proc remove*(self: TargetList, target: Gdk3.TAtom) {.inline.} =
  gtk_target_list_remove(self, myUnsafeAddr(target))
# proc remove*(self: TargetList, target: Gdk3.TAtom) {.inline.} =

# gtk_target_list_unref
# flags: {isMethod} container: TargetList
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_target_list_unref(self: ptr TTargetList) {.cdecl, dynlib: lib, importc: "gtk_target_list_unref".}
proc unref*(self: TargetList) {.inline.} =
  gtk_target_list_unref(self)
# proc unref*(self: TargetList) {.inline.} =

# struct TargetPair
# struct TearoffMenuItemClass
# struct TearoffMenuItemPrivate
# struct TextAppearance
# struct TextAttributes
# gtk_text_attributes_new
# flags: {isConstructor} container: TextAttributes
# need sugar: is static method
# 'TTextAttributes' 'ptr TTextAttributes' (diff., need sugar)
proc gtk_text_attributes_new(): ptr TTextAttributes {.cdecl, dynlib: lib, importc: "gtk_text_attributes_new".}
proc new_textattributes*(): TTextAttributes {.inline.} =
  (gtk_text_attributes_new())[]
# proc new_textattributes*(): TTextAttributes {.inline.} =

# gtk_text_attributes_copy
# flags: {isMethod} container: TextAttributes
# need sugar: is method
# 'TTextAttributes' 'ptr TTextAttributes' (diff., need sugar)
proc gtk_text_attributes_copy(self: ptr TTextAttributes): ptr TTextAttributes {.cdecl, dynlib: lib, importc: "gtk_text_attributes_copy".}
proc copy*(self: TextAttributes): TTextAttributes {.inline.} =
  (gtk_text_attributes_copy(self))[]
# proc copy*(self: TextAttributes): TTextAttributes {.inline.} =

# gtk_text_attributes_copy_values
# flags: {isMethod} container: TextAttributes
# need sugar: is method
# dest 'TTextAttributes' 'ptr TTextAttributes' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_attributes_copy_values(self: ptr TTextAttributes, dest: ptr TTextAttributes) {.cdecl, dynlib: lib, importc: "gtk_text_attributes_copy_values".}
proc copy_values*(self: TextAttributes, dest: TTextAttributes) {.inline.} =
  gtk_text_attributes_copy_values(self, myUnsafeAddr(dest))
# proc copy_values*(self: TextAttributes, dest: TTextAttributes) {.inline.} =

# gtk_text_attributes_ref
# flags: {isMethod} container: TextAttributes
# need sugar: is method
# 'TTextAttributes' 'ptr TTextAttributes' (diff., need sugar)
proc gtk_text_attributes_ref(self: ptr TTextAttributes): ptr TTextAttributes {.cdecl, dynlib: lib, importc: "gtk_text_attributes_ref".}
proc ref_x*(self: TextAttributes): TTextAttributes {.inline.} =
  (gtk_text_attributes_ref(self))[]
# proc ref_x*(self: TextAttributes): TTextAttributes {.inline.} =

# gtk_text_attributes_unref
# flags: {isMethod} container: TextAttributes
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_attributes_unref(self: ptr TTextAttributes) {.cdecl, dynlib: lib, importc: "gtk_text_attributes_unref".}
proc unref*(self: TextAttributes) {.inline.} =
  gtk_text_attributes_unref(self)
# proc unref*(self: TextAttributes) {.inline.} =

# struct TextBTree
# struct TextBufferClass
# struct TextBufferPrivate
# struct TextCellAccessibleClass
# struct TextCellAccessiblePrivate
# struct TextChildAnchorClass
# struct TextIter
# gtk_text_iter_assign
# flags: {isMethod} container: TextIter
# need sugar: is method
# other 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_iter_assign(self: ptr TTextIter, other: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_iter_assign".}
proc assign*(self: TextIter, other: TTextIter) {.inline.} =
  gtk_text_iter_assign(self, myUnsafeAddr(other))
# proc assign*(self: TextIter, other: TTextIter) {.inline.} =

# gtk_text_iter_backward_char
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_backward_char(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_char".}
proc backward_char*(self: TextIter): bool {.inline.} =
  gtk_text_iter_backward_char(self)
# proc backward_char*(self: TextIter): bool {.inline.} =

# gtk_text_iter_backward_chars
# flags: {isMethod} container: TextIter
# need sugar: is method
# count 'int32' 'int32' IN
# 'bool' 'bool'
proc gtk_text_iter_backward_chars(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_chars".}
proc backward_chars*(self: TextIter, count: int32): bool {.inline.} =
  gtk_text_iter_backward_chars(self, count)
# proc backward_chars*(self: TextIter, count: int32): bool {.inline.} =

# gtk_text_iter_backward_cursor_position
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_backward_cursor_position(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_cursor_position".}
proc backward_cursor_position*(self: TextIter): bool {.inline.} =
  gtk_text_iter_backward_cursor_position(self)
# proc backward_cursor_position*(self: TextIter): bool {.inline.} =

# gtk_text_iter_backward_cursor_positions
# flags: {isMethod} container: TextIter
# need sugar: is method
# count 'int32' 'int32' IN
# 'bool' 'bool'
proc gtk_text_iter_backward_cursor_positions(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_cursor_positions".}
proc backward_cursor_positions*(self: TextIter, count: int32): bool {.inline.} =
  gtk_text_iter_backward_cursor_positions(self, count)
# proc backward_cursor_positions*(self: TextIter, count: int32): bool {.inline.} =

# gtk_text_iter_backward_find_char
# flags: {isMethod} container: TextIter
# need sugar: is method
# pred 'pointer' 'pointer' IN
# user_data 'pointer' 'pointer' IN
# limit 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_text_iter_backward_find_char(self: ptr TTextIter, pred: pointer, user_data: pointer, limit: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_find_char".}
proc backward_find_char*(self: TextIter, pred: pointer, user_data: pointer, limit: TTextIter): bool {.inline.} =
  gtk_text_iter_backward_find_char(self, pred, user_data, myUnsafeAddr(limit))
# proc backward_find_char*(self: TextIter, pred: pointer, user_data: pointer, limit: TTextIter): bool {.inline.} =

# gtk_text_iter_backward_line
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_backward_line(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_line".}
proc backward_line*(self: TextIter): bool {.inline.} =
  gtk_text_iter_backward_line(self)
# proc backward_line*(self: TextIter): bool {.inline.} =

# gtk_text_iter_backward_lines
# flags: {isMethod} container: TextIter
# need sugar: is method
# count 'int32' 'int32' IN
# 'bool' 'bool'
proc gtk_text_iter_backward_lines(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_lines".}
proc backward_lines*(self: TextIter, count: int32): bool {.inline.} =
  gtk_text_iter_backward_lines(self, count)
# proc backward_lines*(self: TextIter, count: int32): bool {.inline.} =

# gtk_text_iter_backward_search
# flags: {isMethod} container: TextIter
# need sugar: is method
# str 'ustring' 'ucstring' IN (diff., need sugar)
# flags 'STextSearchFlags' 'STextSearchFlags' IN
# match_start 'var TTextIter' 'ptr TTextIter' OUT (diff., need sugar) caller-allocates optional
# match_end 'var TTextIter' 'ptr TTextIter' OUT (diff., need sugar) caller-allocates optional
# limit 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_text_iter_backward_search(self: ptr TTextIter, str: ucstring, flags: STextSearchFlags, match_start: ptr TTextIter, match_end: ptr TTextIter, limit: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_search".}
proc backward_search*(self: TextIter, str: ustring, flags: STextSearchFlags, match_start: var TTextIter, match_end: var TTextIter, limit: TTextIter): bool {.inline.} =
  gtk_text_iter_backward_search(self, ucstring(str), flags, addr(match_start), addr(match_end), myUnsafeAddr(limit))
# tuple-return
# match_start: var TTextIter
# match_end: var TTextIter
# proc backward_search*(self: TextIter, str: ustring, flags: STextSearchFlags, limit: TTextIter): bool {.inline.} =

# gtk_text_iter_backward_sentence_start
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_backward_sentence_start(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_sentence_start".}
proc backward_sentence_start*(self: TextIter): bool {.inline.} =
  gtk_text_iter_backward_sentence_start(self)
# proc backward_sentence_start*(self: TextIter): bool {.inline.} =

# gtk_text_iter_backward_sentence_starts
# flags: {isMethod} container: TextIter
# need sugar: is method
# count 'int32' 'int32' IN
# 'bool' 'bool'
proc gtk_text_iter_backward_sentence_starts(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_sentence_starts".}
proc backward_sentence_starts*(self: TextIter, count: int32): bool {.inline.} =
  gtk_text_iter_backward_sentence_starts(self, count)
# proc backward_sentence_starts*(self: TextIter, count: int32): bool {.inline.} =

# gtk_text_iter_backward_to_tag_toggle
# flags: {isMethod} container: TextIter
# need sugar: is method
# tag 'TextTag' 'ptr TTextTag' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_text_iter_backward_to_tag_toggle(self: ptr TTextIter, tag: ptr TTextTag): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_to_tag_toggle".}
proc backward_to_tag_toggle*(self: TextIter, tag: TextTag): bool {.inline.} =
  gtk_text_iter_backward_to_tag_toggle(self, tag.getPointer)
# proc backward_to_tag_toggle*(self: TextIter, tag: TextTag): bool {.inline.} =

# gtk_text_iter_backward_visible_cursor_position
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_backward_visible_cursor_position(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_visible_cursor_position".}
proc backward_visible_cursor_position*(self: TextIter): bool {.inline.} =
  gtk_text_iter_backward_visible_cursor_position(self)
# proc backward_visible_cursor_position*(self: TextIter): bool {.inline.} =

# gtk_text_iter_backward_visible_cursor_positions
# flags: {isMethod} container: TextIter
# need sugar: is method
# count 'int32' 'int32' IN
# 'bool' 'bool'
proc gtk_text_iter_backward_visible_cursor_positions(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_visible_cursor_positions".}
proc backward_visible_cursor_positions*(self: TextIter, count: int32): bool {.inline.} =
  gtk_text_iter_backward_visible_cursor_positions(self, count)
# proc backward_visible_cursor_positions*(self: TextIter, count: int32): bool {.inline.} =

# gtk_text_iter_backward_visible_line
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_backward_visible_line(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_visible_line".}
proc backward_visible_line*(self: TextIter): bool {.inline.} =
  gtk_text_iter_backward_visible_line(self)
# proc backward_visible_line*(self: TextIter): bool {.inline.} =

# gtk_text_iter_backward_visible_lines
# flags: {isMethod} container: TextIter
# need sugar: is method
# count 'int32' 'int32' IN
# 'bool' 'bool'
proc gtk_text_iter_backward_visible_lines(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_visible_lines".}
proc backward_visible_lines*(self: TextIter, count: int32): bool {.inline.} =
  gtk_text_iter_backward_visible_lines(self, count)
# proc backward_visible_lines*(self: TextIter, count: int32): bool {.inline.} =

# gtk_text_iter_backward_visible_word_start
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_backward_visible_word_start(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_visible_word_start".}
proc backward_visible_word_start*(self: TextIter): bool {.inline.} =
  gtk_text_iter_backward_visible_word_start(self)
# proc backward_visible_word_start*(self: TextIter): bool {.inline.} =

# gtk_text_iter_backward_visible_word_starts
# flags: {isMethod} container: TextIter
# need sugar: is method
# count 'int32' 'int32' IN
# 'bool' 'bool'
proc gtk_text_iter_backward_visible_word_starts(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_visible_word_starts".}
proc backward_visible_word_starts*(self: TextIter, count: int32): bool {.inline.} =
  gtk_text_iter_backward_visible_word_starts(self, count)
# proc backward_visible_word_starts*(self: TextIter, count: int32): bool {.inline.} =

# gtk_text_iter_backward_word_start
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_backward_word_start(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_word_start".}
proc backward_word_start*(self: TextIter): bool {.inline.} =
  gtk_text_iter_backward_word_start(self)
# proc backward_word_start*(self: TextIter): bool {.inline.} =

# gtk_text_iter_backward_word_starts
# flags: {isMethod} container: TextIter
# need sugar: is method
# count 'int32' 'int32' IN
# 'bool' 'bool'
proc gtk_text_iter_backward_word_starts(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_word_starts".}
proc backward_word_starts*(self: TextIter, count: int32): bool {.inline.} =
  gtk_text_iter_backward_word_starts(self, count)
# proc backward_word_starts*(self: TextIter, count: int32): bool {.inline.} =

# gtk_text_iter_begins_tag
# flags: {isMethod} container: TextIter
# need sugar: is method
# tag 'TextTag' 'ptr TTextTag' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_text_iter_begins_tag(self: ptr TTextIter, tag: ptr TTextTag): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_begins_tag".}
proc begins_tag*(self: TextIter, tag: TextTag): bool {.inline.} =
  gtk_text_iter_begins_tag(self, tag.getPointer)
# proc begins_tag*(self: TextIter, tag: TextTag): bool {.inline.} =

# gtk_text_iter_can_insert
# flags: {isMethod} container: TextIter
# need sugar: is method
# default_editability 'bool' 'bool' IN
# 'bool' 'bool'
proc gtk_text_iter_can_insert(self: ptr TTextIter, default_editability: bool): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_can_insert".}
proc can_insert*(self: TextIter, default_editability: bool): bool {.inline.} =
  gtk_text_iter_can_insert(self, default_editability)
# proc can_insert*(self: TextIter, default_editability: bool): bool {.inline.} =

# gtk_text_iter_compare
# flags: {isMethod} container: TextIter
# need sugar: is method
# rhs 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'int32' 'int32'
proc gtk_text_iter_compare(self: ptr TTextIter, rhs: ptr TTextIter): int32 {.cdecl, dynlib: lib, importc: "gtk_text_iter_compare".}
proc compare*(self: TextIter, rhs: TTextIter): int32 {.inline.} =
  gtk_text_iter_compare(self, myUnsafeAddr(rhs))
# proc compare*(self: TextIter, rhs: TTextIter): int32 {.inline.} =

# gtk_text_iter_copy
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'TTextIter' 'ptr TTextIter' (diff., need sugar)
proc gtk_text_iter_copy(self: ptr TTextIter): ptr TTextIter {.cdecl, dynlib: lib, importc: "gtk_text_iter_copy".}
proc copy*(self: TextIter): TTextIter {.inline.} =
  (gtk_text_iter_copy(self))[]
# proc copy*(self: TextIter): TTextIter {.inline.} =

# gtk_text_iter_editable
# flags: {isMethod} container: TextIter
# need sugar: is method
# default_setting 'bool' 'bool' IN
# 'bool' 'bool'
proc gtk_text_iter_editable(self: ptr TTextIter, default_setting: bool): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_editable".}
proc editable*(self: TextIter, default_setting: bool): bool {.inline.} =
  gtk_text_iter_editable(self, default_setting)
# proc editable*(self: TextIter, default_setting: bool): bool {.inline.} =

# gtk_text_iter_ends_line
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_ends_line(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_ends_line".}
proc ends_line*(self: TextIter): bool {.inline.} =
  gtk_text_iter_ends_line(self)
# proc ends_line*(self: TextIter): bool {.inline.} =

# gtk_text_iter_ends_sentence
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_ends_sentence(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_ends_sentence".}
proc ends_sentence*(self: TextIter): bool {.inline.} =
  gtk_text_iter_ends_sentence(self)
# proc ends_sentence*(self: TextIter): bool {.inline.} =

# gtk_text_iter_ends_tag
# flags: {isMethod} container: TextIter
# need sugar: is method
# tag 'TextTag' 'ptr TTextTag' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_text_iter_ends_tag(self: ptr TTextIter, tag: ptr TTextTag): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_ends_tag".}
proc ends_tag*(self: TextIter, tag: TextTag): bool {.inline.} =
  gtk_text_iter_ends_tag(self, tag.getPointer)
# proc ends_tag*(self: TextIter, tag: TextTag): bool {.inline.} =

# gtk_text_iter_ends_word
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_ends_word(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_ends_word".}
proc ends_word*(self: TextIter): bool {.inline.} =
  gtk_text_iter_ends_word(self)
# proc ends_word*(self: TextIter): bool {.inline.} =

# gtk_text_iter_equal
# flags: {isMethod} container: TextIter
# need sugar: is method
# rhs 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_text_iter_equal(self: ptr TTextIter, rhs: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_equal".}
proc equal*(self: TextIter, rhs: TTextIter): bool {.inline.} =
  gtk_text_iter_equal(self, myUnsafeAddr(rhs))
# proc equal*(self: TextIter, rhs: TTextIter): bool {.inline.} =

# gtk_text_iter_forward_char
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_forward_char(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_char".}
proc forward_char*(self: TextIter): bool {.inline.} =
  gtk_text_iter_forward_char(self)
# proc forward_char*(self: TextIter): bool {.inline.} =

# gtk_text_iter_forward_chars
# flags: {isMethod} container: TextIter
# need sugar: is method
# count 'int32' 'int32' IN
# 'bool' 'bool'
proc gtk_text_iter_forward_chars(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_chars".}
proc forward_chars*(self: TextIter, count: int32): bool {.inline.} =
  gtk_text_iter_forward_chars(self, count)
# proc forward_chars*(self: TextIter, count: int32): bool {.inline.} =

# gtk_text_iter_forward_cursor_position
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_forward_cursor_position(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_cursor_position".}
proc forward_cursor_position*(self: TextIter): bool {.inline.} =
  gtk_text_iter_forward_cursor_position(self)
# proc forward_cursor_position*(self: TextIter): bool {.inline.} =

# gtk_text_iter_forward_cursor_positions
# flags: {isMethod} container: TextIter
# need sugar: is method
# count 'int32' 'int32' IN
# 'bool' 'bool'
proc gtk_text_iter_forward_cursor_positions(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_cursor_positions".}
proc forward_cursor_positions*(self: TextIter, count: int32): bool {.inline.} =
  gtk_text_iter_forward_cursor_positions(self, count)
# proc forward_cursor_positions*(self: TextIter, count: int32): bool {.inline.} =

# gtk_text_iter_forward_find_char
# flags: {isMethod} container: TextIter
# need sugar: is method
# pred 'pointer' 'pointer' IN
# user_data 'pointer' 'pointer' IN
# limit 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_text_iter_forward_find_char(self: ptr TTextIter, pred: pointer, user_data: pointer, limit: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_find_char".}
proc forward_find_char*(self: TextIter, pred: pointer, user_data: pointer, limit: TTextIter): bool {.inline.} =
  gtk_text_iter_forward_find_char(self, pred, user_data, myUnsafeAddr(limit))
# proc forward_find_char*(self: TextIter, pred: pointer, user_data: pointer, limit: TTextIter): bool {.inline.} =

# gtk_text_iter_forward_line
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_forward_line(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_line".}
proc forward_line*(self: TextIter): bool {.inline.} =
  gtk_text_iter_forward_line(self)
# proc forward_line*(self: TextIter): bool {.inline.} =

# gtk_text_iter_forward_lines
# flags: {isMethod} container: TextIter
# need sugar: is method
# count 'int32' 'int32' IN
# 'bool' 'bool'
proc gtk_text_iter_forward_lines(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_lines".}
proc forward_lines*(self: TextIter, count: int32): bool {.inline.} =
  gtk_text_iter_forward_lines(self, count)
# proc forward_lines*(self: TextIter, count: int32): bool {.inline.} =

# gtk_text_iter_forward_search
# flags: {isMethod} container: TextIter
# need sugar: is method
# str 'ustring' 'ucstring' IN (diff., need sugar)
# flags 'STextSearchFlags' 'STextSearchFlags' IN
# match_start 'var TTextIter' 'ptr TTextIter' OUT (diff., need sugar) caller-allocates optional
# match_end 'var TTextIter' 'ptr TTextIter' OUT (diff., need sugar) caller-allocates optional
# limit 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_text_iter_forward_search(self: ptr TTextIter, str: ucstring, flags: STextSearchFlags, match_start: ptr TTextIter, match_end: ptr TTextIter, limit: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_search".}
proc forward_search*(self: TextIter, str: ustring, flags: STextSearchFlags, match_start: var TTextIter, match_end: var TTextIter, limit: TTextIter): bool {.inline.} =
  gtk_text_iter_forward_search(self, ucstring(str), flags, addr(match_start), addr(match_end), myUnsafeAddr(limit))
# tuple-return
# match_start: var TTextIter
# match_end: var TTextIter
# proc forward_search*(self: TextIter, str: ustring, flags: STextSearchFlags, limit: TTextIter): bool {.inline.} =

# gtk_text_iter_forward_sentence_end
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_forward_sentence_end(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_sentence_end".}
proc forward_sentence_end*(self: TextIter): bool {.inline.} =
  gtk_text_iter_forward_sentence_end(self)
# proc forward_sentence_end*(self: TextIter): bool {.inline.} =

# gtk_text_iter_forward_sentence_ends
# flags: {isMethod} container: TextIter
# need sugar: is method
# count 'int32' 'int32' IN
# 'bool' 'bool'
proc gtk_text_iter_forward_sentence_ends(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_sentence_ends".}
proc forward_sentence_ends*(self: TextIter, count: int32): bool {.inline.} =
  gtk_text_iter_forward_sentence_ends(self, count)
# proc forward_sentence_ends*(self: TextIter, count: int32): bool {.inline.} =

# gtk_text_iter_forward_to_end
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_iter_forward_to_end(self: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_to_end".}
proc forward_to_end*(self: TextIter) {.inline.} =
  gtk_text_iter_forward_to_end(self)
# proc forward_to_end*(self: TextIter) {.inline.} =

# gtk_text_iter_forward_to_line_end
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_forward_to_line_end(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_to_line_end".}
proc forward_to_line_end*(self: TextIter): bool {.inline.} =
  gtk_text_iter_forward_to_line_end(self)
# proc forward_to_line_end*(self: TextIter): bool {.inline.} =

# gtk_text_iter_forward_to_tag_toggle
# flags: {isMethod} container: TextIter
# need sugar: is method
# tag 'TextTag' 'ptr TTextTag' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_text_iter_forward_to_tag_toggle(self: ptr TTextIter, tag: ptr TTextTag): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_to_tag_toggle".}
proc forward_to_tag_toggle*(self: TextIter, tag: TextTag): bool {.inline.} =
  gtk_text_iter_forward_to_tag_toggle(self, tag.getPointer)
# proc forward_to_tag_toggle*(self: TextIter, tag: TextTag): bool {.inline.} =

# gtk_text_iter_forward_visible_cursor_position
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_forward_visible_cursor_position(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_visible_cursor_position".}
proc forward_visible_cursor_position*(self: TextIter): bool {.inline.} =
  gtk_text_iter_forward_visible_cursor_position(self)
# proc forward_visible_cursor_position*(self: TextIter): bool {.inline.} =

# gtk_text_iter_forward_visible_cursor_positions
# flags: {isMethod} container: TextIter
# need sugar: is method
# count 'int32' 'int32' IN
# 'bool' 'bool'
proc gtk_text_iter_forward_visible_cursor_positions(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_visible_cursor_positions".}
proc forward_visible_cursor_positions*(self: TextIter, count: int32): bool {.inline.} =
  gtk_text_iter_forward_visible_cursor_positions(self, count)
# proc forward_visible_cursor_positions*(self: TextIter, count: int32): bool {.inline.} =

# gtk_text_iter_forward_visible_line
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_forward_visible_line(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_visible_line".}
proc forward_visible_line*(self: TextIter): bool {.inline.} =
  gtk_text_iter_forward_visible_line(self)
# proc forward_visible_line*(self: TextIter): bool {.inline.} =

# gtk_text_iter_forward_visible_lines
# flags: {isMethod} container: TextIter
# need sugar: is method
# count 'int32' 'int32' IN
# 'bool' 'bool'
proc gtk_text_iter_forward_visible_lines(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_visible_lines".}
proc forward_visible_lines*(self: TextIter, count: int32): bool {.inline.} =
  gtk_text_iter_forward_visible_lines(self, count)
# proc forward_visible_lines*(self: TextIter, count: int32): bool {.inline.} =

# gtk_text_iter_forward_visible_word_end
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_forward_visible_word_end(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_visible_word_end".}
proc forward_visible_word_end*(self: TextIter): bool {.inline.} =
  gtk_text_iter_forward_visible_word_end(self)
# proc forward_visible_word_end*(self: TextIter): bool {.inline.} =

# gtk_text_iter_forward_visible_word_ends
# flags: {isMethod} container: TextIter
# need sugar: is method
# count 'int32' 'int32' IN
# 'bool' 'bool'
proc gtk_text_iter_forward_visible_word_ends(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_visible_word_ends".}
proc forward_visible_word_ends*(self: TextIter, count: int32): bool {.inline.} =
  gtk_text_iter_forward_visible_word_ends(self, count)
# proc forward_visible_word_ends*(self: TextIter, count: int32): bool {.inline.} =

# gtk_text_iter_forward_word_end
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_forward_word_end(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_word_end".}
proc forward_word_end*(self: TextIter): bool {.inline.} =
  gtk_text_iter_forward_word_end(self)
# proc forward_word_end*(self: TextIter): bool {.inline.} =

# gtk_text_iter_forward_word_ends
# flags: {isMethod} container: TextIter
# need sugar: is method
# count 'int32' 'int32' IN
# 'bool' 'bool'
proc gtk_text_iter_forward_word_ends(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_word_ends".}
proc forward_word_ends*(self: TextIter, count: int32): bool {.inline.} =
  gtk_text_iter_forward_word_ends(self, count)
# proc forward_word_ends*(self: TextIter, count: int32): bool {.inline.} =

# gtk_text_iter_free
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_iter_free(self: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_iter_free".}
proc free*(self: TextIter) {.inline.} =
  gtk_text_iter_free(self)
# proc free*(self: TextIter) {.inline.} =

# gtk_text_iter_get_attributes
# flags: {isMethod} container: TextIter
# need sugar: is method
# values 'var TTextAttributes' 'ptr TTextAttributes' OUT (diff., need sugar) caller-allocates
# 'bool' 'bool'
proc gtk_text_iter_get_attributes(self: ptr TTextIter, values: ptr TTextAttributes): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_attributes".}
proc get_attributes*(self: TextIter, values: var TTextAttributes): bool {.inline.} =
  gtk_text_iter_get_attributes(self, addr(values))
# tuple-return
# values: var TTextAttributes
# proc get_attributes*(self: TextIter): bool {.inline.} =

# gtk_text_iter_get_buffer
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'TextBuffer' 'TransferNone[TTextBuffer]' (diff., need sugar)
proc gtk_text_iter_get_buffer(self: ptr TTextIter): TransferNone[TTextBuffer] {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_buffer".}
proc get_buffer*(self: TextIter): TextBuffer {.inline.} =
  wrap(gtk_text_iter_get_buffer(self))
# proc get_buffer*(self: TextIter): TextBuffer {.inline.} =

# gtk_text_iter_get_bytes_in_line
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'int32' 'int32'
proc gtk_text_iter_get_bytes_in_line(self: ptr TTextIter): int32 {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_bytes_in_line".}
proc get_bytes_in_line*(self: TextIter): int32 {.inline.} =
  gtk_text_iter_get_bytes_in_line(self)
# proc get_bytes_in_line*(self: TextIter): int32 {.inline.} =

# gtk_text_iter_get_char
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'unichar' 'unichar'
proc gtk_text_iter_get_char(self: ptr TTextIter): unichar {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_char".}
proc get_char*(self: TextIter): unichar {.inline.} =
  gtk_text_iter_get_char(self)
# proc get_char*(self: TextIter): unichar {.inline.} =

# gtk_text_iter_get_chars_in_line
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'int32' 'int32'
proc gtk_text_iter_get_chars_in_line(self: ptr TTextIter): int32 {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_chars_in_line".}
proc get_chars_in_line*(self: TextIter): int32 {.inline.} =
  gtk_text_iter_get_chars_in_line(self)
# proc get_chars_in_line*(self: TextIter): int32 {.inline.} =

# gtk_text_iter_get_child_anchor
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'TextChildAnchor' 'TransferNone[TTextChildAnchor]' (diff., need sugar)
proc gtk_text_iter_get_child_anchor(self: ptr TTextIter): TransferNone[TTextChildAnchor] {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_child_anchor".}
proc get_child_anchor*(self: TextIter): TextChildAnchor {.inline.} =
  wrap(gtk_text_iter_get_child_anchor(self))
# proc get_child_anchor*(self: TextIter): TextChildAnchor {.inline.} =

# gtk_text_iter_get_language
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'Pango1.TLanguage' 'ptr Pango1.TLanguage' (diff., need sugar)
proc gtk_text_iter_get_language(self: ptr TTextIter): ptr Pango1.TLanguage {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_language".}
proc get_language*(self: TextIter): Pango1.TLanguage {.inline.} =
  (gtk_text_iter_get_language(self))[]
# proc get_language*(self: TextIter): Pango1.TLanguage {.inline.} =

# gtk_text_iter_get_line
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'int32' 'int32'
proc gtk_text_iter_get_line(self: ptr TTextIter): int32 {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_line".}
proc get_line*(self: TextIter): int32 {.inline.} =
  gtk_text_iter_get_line(self)
# proc get_line*(self: TextIter): int32 {.inline.} =

# gtk_text_iter_get_line_index
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'int32' 'int32'
proc gtk_text_iter_get_line_index(self: ptr TTextIter): int32 {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_line_index".}
proc get_line_index*(self: TextIter): int32 {.inline.} =
  gtk_text_iter_get_line_index(self)
# proc get_line_index*(self: TextIter): int32 {.inline.} =

# gtk_text_iter_get_line_offset
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'int32' 'int32'
proc gtk_text_iter_get_line_offset(self: ptr TTextIter): int32 {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_line_offset".}
proc get_line_offset*(self: TextIter): int32 {.inline.} =
  gtk_text_iter_get_line_offset(self)
# proc get_line_offset*(self: TextIter): int32 {.inline.} =

# gtk_text_iter_get_marks
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'ptr GSLIST_TODO' 'ptr GSLIST_TODO'
proc gtk_text_iter_get_marks(self: ptr TTextIter): ptr GSLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_marks".}
proc get_marks*(self: TextIter): ptr GSLIST_TODO {.inline.} =
  gtk_text_iter_get_marks(self)
# proc get_marks*(self: TextIter): ptr GSLIST_TODO {.inline.} =

# gtk_text_iter_get_offset
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'int32' 'int32'
proc gtk_text_iter_get_offset(self: ptr TTextIter): int32 {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_offset".}
proc get_offset*(self: TextIter): int32 {.inline.} =
  gtk_text_iter_get_offset(self)
# proc get_offset*(self: TextIter): int32 {.inline.} =

# gtk_text_iter_get_pixbuf
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'GdkPixbuf2.Pixbuf' 'TransferNone[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_text_iter_get_pixbuf(self: ptr TTextIter): TransferNone[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_pixbuf".}
proc get_pixbuf*(self: TextIter): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_text_iter_get_pixbuf(self))
# proc get_pixbuf*(self: TextIter): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_text_iter_get_slice
# flags: {isMethod} container: TextIter
# need sugar: is method
# end 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_text_iter_get_slice(self: ptr TTextIter, end_x: ptr TTextIter): ucstring {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_slice".}
proc get_slice*(self: TextIter, end_x: TTextIter): ustring {.inline.} =
  ustring($(gtk_text_iter_get_slice(self, myUnsafeAddr(end_x))))
# proc get_slice*(self: TextIter, end_x: TTextIter): ustring {.inline.} =

# gtk_text_iter_get_tags
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'ptr GSLIST_TODO' 'ptr GSLIST_TODO'
proc gtk_text_iter_get_tags(self: ptr TTextIter): ptr GSLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_tags".}
proc get_tags*(self: TextIter): ptr GSLIST_TODO {.inline.} =
  gtk_text_iter_get_tags(self)
# proc get_tags*(self: TextIter): ptr GSLIST_TODO {.inline.} =

# gtk_text_iter_get_text
# flags: {isMethod} container: TextIter
# need sugar: is method
# end 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_text_iter_get_text(self: ptr TTextIter, end_x: ptr TTextIter): ucstring {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_text".}
proc get_text*(self: TextIter, end_x: TTextIter): ustring {.inline.} =
  ustring($(gtk_text_iter_get_text(self, myUnsafeAddr(end_x))))
# proc get_text*(self: TextIter, end_x: TTextIter): ustring {.inline.} =

# gtk_text_iter_get_toggled_tags
# flags: {isMethod} container: TextIter
# need sugar: is method
# toggled_on 'bool' 'bool' IN
# 'ptr GSLIST_TODO' 'ptr GSLIST_TODO'
proc gtk_text_iter_get_toggled_tags(self: ptr TTextIter, toggled_on: bool): ptr GSLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_toggled_tags".}
proc get_toggled_tags*(self: TextIter, toggled_on: bool): ptr GSLIST_TODO {.inline.} =
  gtk_text_iter_get_toggled_tags(self, toggled_on)
# proc get_toggled_tags*(self: TextIter, toggled_on: bool): ptr GSLIST_TODO {.inline.} =

# gtk_text_iter_get_visible_line_index
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'int32' 'int32'
proc gtk_text_iter_get_visible_line_index(self: ptr TTextIter): int32 {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_visible_line_index".}
proc get_visible_line_index*(self: TextIter): int32 {.inline.} =
  gtk_text_iter_get_visible_line_index(self)
# proc get_visible_line_index*(self: TextIter): int32 {.inline.} =

# gtk_text_iter_get_visible_line_offset
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'int32' 'int32'
proc gtk_text_iter_get_visible_line_offset(self: ptr TTextIter): int32 {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_visible_line_offset".}
proc get_visible_line_offset*(self: TextIter): int32 {.inline.} =
  gtk_text_iter_get_visible_line_offset(self)
# proc get_visible_line_offset*(self: TextIter): int32 {.inline.} =

# gtk_text_iter_get_visible_slice
# flags: {isMethod} container: TextIter
# need sugar: is method
# end 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_text_iter_get_visible_slice(self: ptr TTextIter, end_x: ptr TTextIter): ucstring {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_visible_slice".}
proc get_visible_slice*(self: TextIter, end_x: TTextIter): ustring {.inline.} =
  ustring($(gtk_text_iter_get_visible_slice(self, myUnsafeAddr(end_x))))
# proc get_visible_slice*(self: TextIter, end_x: TTextIter): ustring {.inline.} =

# gtk_text_iter_get_visible_text
# flags: {isMethod} container: TextIter
# need sugar: is method
# end 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_text_iter_get_visible_text(self: ptr TTextIter, end_x: ptr TTextIter): ucstring {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_visible_text".}
proc get_visible_text*(self: TextIter, end_x: TTextIter): ustring {.inline.} =
  ustring($(gtk_text_iter_get_visible_text(self, myUnsafeAddr(end_x))))
# proc get_visible_text*(self: TextIter, end_x: TTextIter): ustring {.inline.} =

# gtk_text_iter_has_tag
# flags: {isMethod} container: TextIter
# need sugar: is method
# tag 'TextTag' 'ptr TTextTag' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_text_iter_has_tag(self: ptr TTextIter, tag: ptr TTextTag): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_has_tag".}
proc has_tag*(self: TextIter, tag: TextTag): bool {.inline.} =
  gtk_text_iter_has_tag(self, tag.getPointer)
# proc has_tag*(self: TextIter, tag: TextTag): bool {.inline.} =

# gtk_text_iter_in_range
# flags: {isMethod} container: TextIter
# need sugar: is method
# start 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# end 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_text_iter_in_range(self: ptr TTextIter, start: ptr TTextIter, end_x: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_in_range".}
proc in_range*(self: TextIter, start: TTextIter, end_x: TTextIter): bool {.inline.} =
  gtk_text_iter_in_range(self, myUnsafeAddr(start), myUnsafeAddr(end_x))
# proc in_range*(self: TextIter, start: TTextIter, end_x: TTextIter): bool {.inline.} =

# gtk_text_iter_inside_sentence
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_inside_sentence(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_inside_sentence".}
proc inside_sentence*(self: TextIter): bool {.inline.} =
  gtk_text_iter_inside_sentence(self)
# proc inside_sentence*(self: TextIter): bool {.inline.} =

# gtk_text_iter_inside_word
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_inside_word(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_inside_word".}
proc inside_word*(self: TextIter): bool {.inline.} =
  gtk_text_iter_inside_word(self)
# proc inside_word*(self: TextIter): bool {.inline.} =

# gtk_text_iter_is_cursor_position
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_is_cursor_position(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_is_cursor_position".}
proc is_cursor_position*(self: TextIter): bool {.inline.} =
  gtk_text_iter_is_cursor_position(self)
# proc is_cursor_position*(self: TextIter): bool {.inline.} =

# gtk_text_iter_is_end
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_is_end(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_is_end".}
proc is_end*(self: TextIter): bool {.inline.} =
  gtk_text_iter_is_end(self)
# proc is_end*(self: TextIter): bool {.inline.} =

# gtk_text_iter_is_start
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_is_start(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_is_start".}
proc is_start*(self: TextIter): bool {.inline.} =
  gtk_text_iter_is_start(self)
# proc is_start*(self: TextIter): bool {.inline.} =

# gtk_text_iter_order
# flags: {isMethod} container: TextIter
# need sugar: is method
# second 'TTextIter' 'ptr TTextIter' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_iter_order(self: ptr TTextIter, second: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_iter_order".}
proc order*(self: TextIter, second: TTextIter) {.inline.} =
  gtk_text_iter_order(self, myUnsafeAddr(second))
# proc order*(self: TextIter, second: TTextIter) {.inline.} =

# gtk_text_iter_set_line
# flags: {isMethod} container: TextIter
# need sugar: is method
# line_number 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_iter_set_line(self: ptr TTextIter, line_number: int32) {.cdecl, dynlib: lib, importc: "gtk_text_iter_set_line".}
proc set_line*(self: TextIter, line_number: int32) {.inline.} =
  gtk_text_iter_set_line(self, line_number)
# proc set_line*(self: TextIter, line_number: int32) {.inline.} =

# gtk_text_iter_set_line_index
# flags: {isMethod} container: TextIter
# need sugar: is method
# byte_on_line 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_iter_set_line_index(self: ptr TTextIter, byte_on_line: int32) {.cdecl, dynlib: lib, importc: "gtk_text_iter_set_line_index".}
proc set_line_index*(self: TextIter, byte_on_line: int32) {.inline.} =
  gtk_text_iter_set_line_index(self, byte_on_line)
# proc set_line_index*(self: TextIter, byte_on_line: int32) {.inline.} =

# gtk_text_iter_set_line_offset
# flags: {isMethod} container: TextIter
# need sugar: is method
# char_on_line 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_iter_set_line_offset(self: ptr TTextIter, char_on_line: int32) {.cdecl, dynlib: lib, importc: "gtk_text_iter_set_line_offset".}
proc set_line_offset*(self: TextIter, char_on_line: int32) {.inline.} =
  gtk_text_iter_set_line_offset(self, char_on_line)
# proc set_line_offset*(self: TextIter, char_on_line: int32) {.inline.} =

# gtk_text_iter_set_offset
# flags: {isMethod} container: TextIter
# need sugar: is method
# char_offset 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_iter_set_offset(self: ptr TTextIter, char_offset: int32) {.cdecl, dynlib: lib, importc: "gtk_text_iter_set_offset".}
proc set_offset*(self: TextIter, char_offset: int32) {.inline.} =
  gtk_text_iter_set_offset(self, char_offset)
# proc set_offset*(self: TextIter, char_offset: int32) {.inline.} =

# gtk_text_iter_set_visible_line_index
# flags: {isMethod} container: TextIter
# need sugar: is method
# byte_on_line 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_iter_set_visible_line_index(self: ptr TTextIter, byte_on_line: int32) {.cdecl, dynlib: lib, importc: "gtk_text_iter_set_visible_line_index".}
proc set_visible_line_index*(self: TextIter, byte_on_line: int32) {.inline.} =
  gtk_text_iter_set_visible_line_index(self, byte_on_line)
# proc set_visible_line_index*(self: TextIter, byte_on_line: int32) {.inline.} =

# gtk_text_iter_set_visible_line_offset
# flags: {isMethod} container: TextIter
# need sugar: is method
# char_on_line 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_text_iter_set_visible_line_offset(self: ptr TTextIter, char_on_line: int32) {.cdecl, dynlib: lib, importc: "gtk_text_iter_set_visible_line_offset".}
proc set_visible_line_offset*(self: TextIter, char_on_line: int32) {.inline.} =
  gtk_text_iter_set_visible_line_offset(self, char_on_line)
# proc set_visible_line_offset*(self: TextIter, char_on_line: int32) {.inline.} =

# gtk_text_iter_starts_line
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_starts_line(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_starts_line".}
proc starts_line*(self: TextIter): bool {.inline.} =
  gtk_text_iter_starts_line(self)
# proc starts_line*(self: TextIter): bool {.inline.} =

# gtk_text_iter_starts_sentence
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_starts_sentence(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_starts_sentence".}
proc starts_sentence*(self: TextIter): bool {.inline.} =
  gtk_text_iter_starts_sentence(self)
# proc starts_sentence*(self: TextIter): bool {.inline.} =

# gtk_text_iter_starts_word
# flags: {isMethod} container: TextIter
# need sugar: is method
# 'bool' 'bool'
proc gtk_text_iter_starts_word(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_starts_word".}
proc starts_word*(self: TextIter): bool {.inline.} =
  gtk_text_iter_starts_word(self)
# proc starts_word*(self: TextIter): bool {.inline.} =

# gtk_text_iter_toggles_tag
# flags: {isMethod} container: TextIter
# need sugar: is method
# tag 'TextTag' 'ptr TTextTag' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_text_iter_toggles_tag(self: ptr TTextIter, tag: ptr TTextTag): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_toggles_tag".}
proc toggles_tag*(self: TextIter, tag: TextTag): bool {.inline.} =
  gtk_text_iter_toggles_tag(self, tag.getPointer)
# proc toggles_tag*(self: TextIter, tag: TextTag): bool {.inline.} =

# struct TextMarkClass
# struct TextTagClass
# struct TextTagPrivate
# struct TextTagTableClass
# struct TextTagTablePrivate
# struct TextViewAccessibleClass
# struct TextViewAccessiblePrivate
# struct TextViewClass
# struct TextViewPrivate
# struct ThemeEngine
# struct ThemingEngineClass
# struct ThemingEnginePrivate
# struct ToggleActionClass
# struct ToggleActionEntry
# struct ToggleActionPrivate
# struct ToggleButtonAccessibleClass
# struct ToggleButtonAccessiblePrivate
# struct ToggleButtonClass
# struct ToggleButtonPrivate
# struct ToggleToolButtonClass
# struct ToggleToolButtonPrivate
# struct ToolButtonClass
# struct ToolButtonPrivate
# struct ToolItemClass
# struct ToolItemGroupClass
# struct ToolItemGroupPrivate
# struct ToolItemPrivate
# struct ToolPaletteClass
# struct ToolPalettePrivate
# struct ToolShellIface
# struct ToolbarClass
# struct ToolbarPrivate
# struct ToplevelAccessibleClass
# struct ToplevelAccessiblePrivate
# struct TreeDragDestIface
# struct TreeDragSourceIface
# struct TreeIter
# gtk_tree_iter_copy
# flags: {isMethod} container: TreeIter
# need sugar: is method
# 'TTreeIter' 'ptr TTreeIter' (diff., need sugar)
proc gtk_tree_iter_copy(self: ptr TTreeIter): ptr TTreeIter {.cdecl, dynlib: lib, importc: "gtk_tree_iter_copy".}
proc copy*(self: TreeIter): TTreeIter {.inline.} =
  (gtk_tree_iter_copy(self))[]
# proc copy*(self: TreeIter): TTreeIter {.inline.} =

# gtk_tree_iter_free
# flags: {isMethod} container: TreeIter
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_iter_free(self: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_tree_iter_free".}
proc free*(self: TreeIter) {.inline.} =
  gtk_tree_iter_free(self)
# proc free*(self: TreeIter) {.inline.} =

# struct TreeModelFilterClass
# struct TreeModelFilterPrivate
# struct TreeModelIface
# struct TreeModelSortClass
# struct TreeModelSortPrivate
# struct TreePath
# gtk_tree_path_new
# flags: {isConstructor} container: TreePath
# need sugar: is static method
# 'TTreePath' 'ptr TTreePath' (diff., need sugar)
proc gtk_tree_path_new(): ptr TTreePath {.cdecl, dynlib: lib, importc: "gtk_tree_path_new".}
proc new_treepath*(): TTreePath {.inline.} =
  (gtk_tree_path_new())[]
# proc new_treepath*(): TTreePath {.inline.} =

# gtk_tree_path_new_first
# flags: {isConstructor} container: TreePath
# need sugar: is static method
# 'TTreePath' 'ptr TTreePath' (diff., need sugar)
proc gtk_tree_path_new_first(): ptr TTreePath {.cdecl, dynlib: lib, importc: "gtk_tree_path_new_first".}
proc new_treepath_first*(): TTreePath {.inline.} =
  (gtk_tree_path_new_first())[]
# proc new_treepath_first*(): TTreePath {.inline.} =

# gtk_tree_path_new_from_indicesv
# flags: {isConstructor} container: TreePath
# need sugar: is static method
# indices 'var openarray[int32]' 'openarray[int32]' IN (diff., need sugar) array lengthArg: 1
# length 'uint32' 'uint32' IN
# 'TTreePath' 'ptr TTreePath' (diff., need sugar)
proc gtk_tree_path_new_from_indicesv(indices: openarray[int32], length: uint32): ptr TTreePath {.cdecl, dynlib: lib, importc: "gtk_tree_path_new_from_indicesv".}
proc new_treepath_from_indices*(indices: var openarray[int32]): TTreePath {.inline.} =
  (gtk_tree_path_new_from_indicesv(indices, indices.len.uint32))[]
# proc new_treepath_from_indices*(indices: var openarray[int32]): TTreePath {.inline.} =

# gtk_tree_path_new_from_string
# flags: {isConstructor} container: TreePath
# need sugar: is static method
# path 'ustring' 'ucstring' IN (diff., need sugar)
# 'TTreePath' 'ptr TTreePath' (diff., need sugar)
proc gtk_tree_path_new_from_string(path: ucstring): ptr TTreePath {.cdecl, dynlib: lib, importc: "gtk_tree_path_new_from_string".}
proc new_treepath_from_string*(path: ustring): TTreePath {.inline.} =
  (gtk_tree_path_new_from_string(ucstring(path)))[]
# proc new_treepath_from_string*(path: ustring): TTreePath {.inline.} =

# gtk_tree_path_append_index
# flags: {isMethod} container: TreePath
# need sugar: is method
# index_ 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_path_append_index(self: ptr TTreePath, index_x: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_path_append_index".}
proc append_index*(self: TreePath, index_x: int32) {.inline.} =
  gtk_tree_path_append_index(self, index_x)
# proc append_index*(self: TreePath, index_x: int32) {.inline.} =

# gtk_tree_path_compare
# flags: {isMethod} container: TreePath
# need sugar: is method
# b 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'int32' 'int32'
proc gtk_tree_path_compare(self: ptr TTreePath, b: ptr TTreePath): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_path_compare".}
proc compare*(self: TreePath, b: TTreePath): int32 {.inline.} =
  gtk_tree_path_compare(self, myUnsafeAddr(b))
# proc compare*(self: TreePath, b: TTreePath): int32 {.inline.} =

# gtk_tree_path_copy
# flags: {isMethod} container: TreePath
# need sugar: is method
# 'TTreePath' 'ptr TTreePath' (diff., need sugar)
proc gtk_tree_path_copy(self: ptr TTreePath): ptr TTreePath {.cdecl, dynlib: lib, importc: "gtk_tree_path_copy".}
proc copy*(self: TreePath): TTreePath {.inline.} =
  (gtk_tree_path_copy(self))[]
# proc copy*(self: TreePath): TTreePath {.inline.} =

# gtk_tree_path_down
# flags: {isMethod} container: TreePath
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_path_down(self: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_tree_path_down".}
proc down*(self: TreePath) {.inline.} =
  gtk_tree_path_down(self)
# proc down*(self: TreePath) {.inline.} =

# gtk_tree_path_free
# flags: {isMethod} container: TreePath
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_path_free(self: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_tree_path_free".}
proc free*(self: TreePath) {.inline.} =
  gtk_tree_path_free(self)
# proc free*(self: TreePath) {.inline.} =

# gtk_tree_path_get_depth
# flags: {isMethod} container: TreePath
# need sugar: is method
# 'int32' 'int32'
proc gtk_tree_path_get_depth(self: ptr TTreePath): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_path_get_depth".}
proc get_depth*(self: TreePath): int32 {.inline.} =
  gtk_tree_path_get_depth(self)
# proc get_depth*(self: TreePath): int32 {.inline.} =

# gtk_tree_path_get_indices_with_depth
# flags: {isMethod} container: TreePath
# need sugar: is method
# depth 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# 'zeroTerminatedArray[int32]' 'zeroTerminatedArray[int32]'
proc gtk_tree_path_get_indices_with_depth(self: ptr TTreePath, depth: ptr int32): zeroTerminatedArray[int32] {.cdecl, dynlib: lib, importc: "gtk_tree_path_get_indices_with_depth".}
proc get_indices*(self: TreePath, depth: var int32): zeroTerminatedArray[int32] {.inline.} =
  gtk_tree_path_get_indices_with_depth(self, addr(depth))
# tuple-return
# depth: var int32
# proc get_indices*(self: TreePath): zeroTerminatedArray[int32] {.inline.} =

# gtk_tree_path_is_ancestor
# flags: {isMethod} container: TreePath
# need sugar: is method
# descendant 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_tree_path_is_ancestor(self: ptr TTreePath, descendant: ptr TTreePath): bool {.cdecl, dynlib: lib, importc: "gtk_tree_path_is_ancestor".}
proc is_ancestor*(self: TreePath, descendant: TTreePath): bool {.inline.} =
  gtk_tree_path_is_ancestor(self, myUnsafeAddr(descendant))
# proc is_ancestor*(self: TreePath, descendant: TTreePath): bool {.inline.} =

# gtk_tree_path_is_descendant
# flags: {isMethod} container: TreePath
# need sugar: is method
# ancestor 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_tree_path_is_descendant(self: ptr TTreePath, ancestor: ptr TTreePath): bool {.cdecl, dynlib: lib, importc: "gtk_tree_path_is_descendant".}
proc is_descendant*(self: TreePath, ancestor: TTreePath): bool {.inline.} =
  gtk_tree_path_is_descendant(self, myUnsafeAddr(ancestor))
# proc is_descendant*(self: TreePath, ancestor: TTreePath): bool {.inline.} =

# gtk_tree_path_next
# flags: {isMethod} container: TreePath
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_path_next(self: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_tree_path_next".}
proc next*(self: TreePath) {.inline.} =
  gtk_tree_path_next(self)
# proc next*(self: TreePath) {.inline.} =

# gtk_tree_path_prepend_index
# flags: {isMethod} container: TreePath
# need sugar: is method
# index_ 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_path_prepend_index(self: ptr TTreePath, index_x: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_path_prepend_index".}
proc prepend_index*(self: TreePath, index_x: int32) {.inline.} =
  gtk_tree_path_prepend_index(self, index_x)
# proc prepend_index*(self: TreePath, index_x: int32) {.inline.} =

# gtk_tree_path_prev
# flags: {isMethod} container: TreePath
# need sugar: is method
# 'bool' 'bool'
proc gtk_tree_path_prev(self: ptr TTreePath): bool {.cdecl, dynlib: lib, importc: "gtk_tree_path_prev".}
proc prev*(self: TreePath): bool {.inline.} =
  gtk_tree_path_prev(self)
# proc prev*(self: TreePath): bool {.inline.} =

# gtk_tree_path_to_string
# flags: {isMethod} container: TreePath
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_tree_path_to_string(self: ptr TTreePath): ucstring {.cdecl, dynlib: lib, importc: "gtk_tree_path_to_string".}
proc to_string*(self: TreePath): ustring {.inline.} =
  ustring($(gtk_tree_path_to_string(self)))
# proc to_string*(self: TreePath): ustring {.inline.} =

# gtk_tree_path_up
# flags: {isMethod} container: TreePath
# need sugar: is method
# 'bool' 'bool'
proc gtk_tree_path_up(self: ptr TTreePath): bool {.cdecl, dynlib: lib, importc: "gtk_tree_path_up".}
proc up*(self: TreePath): bool {.inline.} =
  gtk_tree_path_up(self)
# proc up*(self: TreePath): bool {.inline.} =

# struct TreeRowReference
# gtk_tree_row_reference_new
# flags: {isConstructor} container: TreeRowReference
# need sugar: is static method
# model 'TreeModel' 'ptr TTreeModel' IN (diff., need sugar)
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'TTreeRowReference' 'ptr TTreeRowReference' (diff., need sugar)
proc gtk_tree_row_reference_new(model: ptr TTreeModel, path: ptr TTreePath): ptr TTreeRowReference {.cdecl, dynlib: lib, importc: "gtk_tree_row_reference_new".}
proc new_treerowreference*(model: TreeModel, path: TTreePath): TTreeRowReference {.inline.} =
  (gtk_tree_row_reference_new(unwrap(model), myUnsafeAddr(path)))[]
# proc new_treerowreference*(model: TreeModel, path: TTreePath): TTreeRowReference {.inline.} =

# gtk_tree_row_reference_new_proxy
# flags: {isConstructor} container: TreeRowReference
# need sugar: is static method
# proxy 'GObject2.Object' 'ptr GObject2.TObject' IN (diff., need sugar)
# model 'TreeModel' 'ptr TTreeModel' IN (diff., need sugar)
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'TTreeRowReference' 'ptr TTreeRowReference' (diff., need sugar)
proc gtk_tree_row_reference_new_proxy(proxy: ptr GObject2.TObject, model: ptr TTreeModel, path: ptr TTreePath): ptr TTreeRowReference {.cdecl, dynlib: lib, importc: "gtk_tree_row_reference_new_proxy".}
proc new_treerowreference_proxy*(proxy: GObject2.Object, model: TreeModel, path: TTreePath): TTreeRowReference {.inline.} =
  (gtk_tree_row_reference_new_proxy(proxy.getPointer, unwrap(model), myUnsafeAddr(path)))[]
# proc new_treerowreference_proxy*(proxy: GObject2.Object, model: TreeModel, path: TTreePath): TTreeRowReference {.inline.} =

# gtk_tree_row_reference_copy
# flags: {isMethod} container: TreeRowReference
# need sugar: is method
# 'TTreeRowReference' 'ptr TTreeRowReference' (diff., need sugar)
proc gtk_tree_row_reference_copy(self: ptr TTreeRowReference): ptr TTreeRowReference {.cdecl, dynlib: lib, importc: "gtk_tree_row_reference_copy".}
proc copy*(self: TreeRowReference): TTreeRowReference {.inline.} =
  (gtk_tree_row_reference_copy(self))[]
# proc copy*(self: TreeRowReference): TTreeRowReference {.inline.} =

# gtk_tree_row_reference_free
# flags: {isMethod} container: TreeRowReference
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_row_reference_free(self: ptr TTreeRowReference) {.cdecl, dynlib: lib, importc: "gtk_tree_row_reference_free".}
proc free*(self: TreeRowReference) {.inline.} =
  gtk_tree_row_reference_free(self)
# proc free*(self: TreeRowReference) {.inline.} =

# gtk_tree_row_reference_get_model
# flags: {isMethod} container: TreeRowReference
# need sugar: is method
# 'TreeModel' 'TransferNone[TTreeModel]' (diff., need sugar)
proc gtk_tree_row_reference_get_model(self: ptr TTreeRowReference): TransferNone[TTreeModel] {.cdecl, dynlib: lib, importc: "gtk_tree_row_reference_get_model".}
proc get_model*(self: TreeRowReference): TreeModel {.inline.} =
  wrap(gtk_tree_row_reference_get_model(self))
# proc get_model*(self: TreeRowReference): TreeModel {.inline.} =

# gtk_tree_row_reference_get_path
# flags: {isMethod} container: TreeRowReference
# need sugar: is method
# 'TTreePath' 'ptr TTreePath' (diff., need sugar)
proc gtk_tree_row_reference_get_path(self: ptr TTreeRowReference): ptr TTreePath {.cdecl, dynlib: lib, importc: "gtk_tree_row_reference_get_path".}
proc get_path*(self: TreeRowReference): TTreePath {.inline.} =
  (gtk_tree_row_reference_get_path(self))[]
# proc get_path*(self: TreeRowReference): TTreePath {.inline.} =

# gtk_tree_row_reference_valid
# flags: {isMethod} container: TreeRowReference
# need sugar: is method
# 'bool' 'bool'
proc gtk_tree_row_reference_valid(self: ptr TTreeRowReference): bool {.cdecl, dynlib: lib, importc: "gtk_tree_row_reference_valid".}
proc valid*(self: TreeRowReference): bool {.inline.} =
  gtk_tree_row_reference_valid(self)
# proc valid*(self: TreeRowReference): bool {.inline.} =

# gtk_tree_row_reference_deleted
# flags: {} container: TreeRowReference
# need sugar: is static method
# proxy 'GObject2.Object' 'ptr GObject2.TObject' IN (diff., need sugar)
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
# warning, already written a prototype with the name of gtk_tree_row_reference_deleted
# proc gtk_tree_row_reference_deleted(proxy: ptr GObject2.TObject, path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_tree_row_reference_deleted".}
template deleted*(klass_parameter: typedesc[TreeRowReference], proxy: GObject2.Object, path: TTreePath) =
  gtk_tree_row_reference_deleted(proxy.getPointer, myUnsafeAddr(path))
# template deleted*(klass_parameter: typedesc[TreeRowReference], proxy: GObject2.Object, path: TTreePath) =

# gtk_tree_row_reference_inserted
# flags: {} container: TreeRowReference
# need sugar: is static method
# proxy 'GObject2.Object' 'ptr GObject2.TObject' IN (diff., need sugar)
# path 'TTreePath' 'ptr TTreePath' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
# warning, already written a prototype with the name of gtk_tree_row_reference_inserted
# proc gtk_tree_row_reference_inserted(proxy: ptr GObject2.TObject, path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_tree_row_reference_inserted".}
template inserted*(klass_parameter: typedesc[TreeRowReference], proxy: GObject2.Object, path: TTreePath) =
  gtk_tree_row_reference_inserted(proxy.getPointer, myUnsafeAddr(path))
# template inserted*(klass_parameter: typedesc[TreeRowReference], proxy: GObject2.Object, path: TTreePath) =

# struct TreeSelectionClass
# struct TreeSelectionPrivate
# struct TreeSortableIface
# struct TreeStoreClass
# struct TreeStorePrivate
# struct TreeViewAccessibleClass
# struct TreeViewAccessiblePrivate
# struct TreeViewClass
# struct TreeViewColumnClass
# struct TreeViewColumnPrivate
# struct TreeViewPrivate
# struct UIManagerClass
# struct UIManagerPrivate
# struct VBoxClass
# struct VButtonBoxClass
# struct VPanedClass
# struct VScaleClass
# struct VScrollbarClass
# struct VSeparatorClass
# struct ViewportClass
# struct ViewportPrivate
# struct VolumeButtonClass
# struct WidgetAccessibleClass
# struct WidgetAccessiblePrivate
# struct WidgetAuxInfo
# struct WidgetClass
# gtk_widget_class_bind_template_callback_full
# flags: {isMethod} container: WidgetClass
# need sugar: is method
# callback_name 'ustring' 'ucstring' IN (diff., need sugar)
# callback_symbol 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_class_bind_template_callback_full(self: ptr TWidgetClass, callback_name: ucstring, callback_symbol: pointer) {.cdecl, dynlib: lib, importc: "gtk_widget_class_bind_template_callback_full".}
proc bind_template_callback_full*(self: WidgetClass, callback_name: ustring, callback_symbol: pointer) {.inline.} =
  gtk_widget_class_bind_template_callback_full(self, ucstring(callback_name), callback_symbol)
# proc bind_template_callback_full*(self: WidgetClass, callback_name: ustring, callback_symbol: pointer) {.inline.} =

# gtk_widget_class_bind_template_child_full
# flags: {isMethod} container: WidgetClass
# need sugar: is method
# name 'ustring' 'ucstring' IN (diff., need sugar)
# internal_child 'bool' 'bool' IN
# struct_offset 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_class_bind_template_child_full(self: ptr TWidgetClass, name: ucstring, internal_child: bool, struct_offset: int32) {.cdecl, dynlib: lib, importc: "gtk_widget_class_bind_template_child_full".}
proc bind_template_child_full*(self: WidgetClass, name: ustring, internal_child: bool, struct_offset: int32) {.inline.} =
  gtk_widget_class_bind_template_child_full(self, ucstring(name), internal_child, struct_offset)
# proc bind_template_child_full*(self: WidgetClass, name: ustring, internal_child: bool, struct_offset: int32) {.inline.} =

# gtk_widget_class_find_style_property
# flags: {isMethod} container: WidgetClass
# need sugar: is method
# property_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'GObject2.ParamSpec' 'TransferNone[GObject2.TParamSpec]' (diff., need sugar)
proc gtk_widget_class_find_style_property(self: ptr TWidgetClass, property_name: ucstring): TransferNone[GObject2.TParamSpec] {.cdecl, dynlib: lib, importc: "gtk_widget_class_find_style_property".}
proc find_style_property*(self: WidgetClass, property_name: ustring): GObject2.ParamSpec {.inline.} =
  wrap(gtk_widget_class_find_style_property(self, ucstring(property_name)))
# proc find_style_property*(self: WidgetClass, property_name: ustring): GObject2.ParamSpec {.inline.} =

# gtk_widget_class_install_style_property
# flags: {isMethod} container: WidgetClass
# need sugar: is method
# pspec 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_class_install_style_property(self: ptr TWidgetClass, pspec: ptr GObject2.TParamSpec) {.cdecl, dynlib: lib, importc: "gtk_widget_class_install_style_property".}
proc install_style_property*(self: WidgetClass, pspec: GObject2.ParamSpec) {.inline.} =
  gtk_widget_class_install_style_property(self, pspec.getPointer)
# proc install_style_property*(self: WidgetClass, pspec: GObject2.ParamSpec) {.inline.} =

# gtk_widget_class_list_style_properties
# flags: {isMethod} container: WidgetClass
# need sugar: is method
# n_properties 'var uint32' 'ptr uint32' OUT (diff., need sugar)
# 'zeroTerminatedArray[ptr GObject2.TParamSpec]' 'zeroTerminatedArray[ptr GObject2.TParamSpec]'
proc gtk_widget_class_list_style_properties(self: ptr TWidgetClass, n_properties: ptr uint32): zeroTerminatedArray[ptr GObject2.TParamSpec] {.cdecl, dynlib: lib, importc: "gtk_widget_class_list_style_properties".}
proc list_style_properties*(self: WidgetClass, n_properties: var uint32): zeroTerminatedArray[ptr GObject2.TParamSpec] {.inline.} =
  gtk_widget_class_list_style_properties(self, addr(n_properties))
# tuple-return
# n_properties: var uint32
# proc list_style_properties*(self: WidgetClass): zeroTerminatedArray[ptr GObject2.TParamSpec] {.inline.} =

# gtk_widget_class_set_accessible_role
# flags: {isMethod} container: WidgetClass
# need sugar: is method
# role 'Atk1.Role' 'Atk1.Role' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_class_set_accessible_role(self: ptr TWidgetClass, role: Atk1.Role) {.cdecl, dynlib: lib, importc: "gtk_widget_class_set_accessible_role".}
proc set_accessible_role*(self: WidgetClass, role: Atk1.Role) {.inline.} =
  gtk_widget_class_set_accessible_role(self, role)
# proc set_accessible_role*(self: WidgetClass, role: Atk1.Role) {.inline.} =

# gtk_widget_class_set_accessible_type
# flags: {isMethod} container: WidgetClass
# need sugar: is method
# type 'GType' 'GType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_class_set_accessible_type(self: ptr TWidgetClass, type_x: GType) {.cdecl, dynlib: lib, importc: "gtk_widget_class_set_accessible_type".}
proc set_accessible_type*(self: WidgetClass, type_x: GType) {.inline.} =
  gtk_widget_class_set_accessible_type(self, type_x)
# proc set_accessible_type*(self: WidgetClass, type_x: GType) {.inline.} =

# gtk_widget_class_set_connect_func
# flags: {isMethod} container: WidgetClass
# need sugar: is method
# connect_func 'pointer' 'pointer' IN
# connect_data 'pointer' 'pointer' IN
# connect_data_destroy 'pointer' 'pointer' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_class_set_connect_func(self: ptr TWidgetClass, connect_func: pointer, connect_data: pointer, connect_data_destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_widget_class_set_connect_func".}
proc set_connect_func*(self: WidgetClass, connect_func: pointer, connect_data: pointer, connect_data_destroy: pointer) {.inline.} =
  gtk_widget_class_set_connect_func(self, connect_func, connect_data, connect_data_destroy)
# proc set_connect_func*(self: WidgetClass, connect_func: pointer, connect_data: pointer, connect_data_destroy: pointer) {.inline.} =

# gtk_widget_class_set_template
# flags: {isMethod} container: WidgetClass
# need sugar: is method
# template_bytes 'GLib2.TBytes' 'ptr GLib2.TBytes' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_class_set_template(self: ptr TWidgetClass, template_bytes: ptr GLib2.TBytes) {.cdecl, dynlib: lib, importc: "gtk_widget_class_set_template".}
proc set_template*(self: WidgetClass, template_bytes: GLib2.TBytes) {.inline.} =
  gtk_widget_class_set_template(self, myUnsafeAddr(template_bytes))
# proc set_template*(self: WidgetClass, template_bytes: GLib2.TBytes) {.inline.} =

# gtk_widget_class_set_template_from_resource
# flags: {isMethod} container: WidgetClass
# need sugar: is method
# resource_name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_class_set_template_from_resource(self: ptr TWidgetClass, resource_name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_widget_class_set_template_from_resource".}
proc set_template_from_resource*(self: WidgetClass, resource_name: ustring) {.inline.} =
  gtk_widget_class_set_template_from_resource(self, ucstring(resource_name))
# proc set_template_from_resource*(self: WidgetClass, resource_name: ustring) {.inline.} =

# struct WidgetClassPrivate
# struct WidgetPath
# gtk_widget_path_new
# flags: {isConstructor} container: WidgetPath
# need sugar: is static method
# 'TWidgetPath' 'ptr TWidgetPath' (diff., need sugar)
proc gtk_widget_path_new(): ptr TWidgetPath {.cdecl, dynlib: lib, importc: "gtk_widget_path_new".}
proc new_widgetpath*(): TWidgetPath {.inline.} =
  (gtk_widget_path_new())[]
# proc new_widgetpath*(): TWidgetPath {.inline.} =

# gtk_widget_path_append_for_widget
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# widget 'Widget' 'ptr TWidget' IN (diff., need sugar)
# 'int32' 'int32'
proc gtk_widget_path_append_for_widget(self: ptr TWidgetPath, widget: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_path_append_for_widget".}
proc append_for_widget*(self: WidgetPath, widget: Widget): int32 {.inline.} =
  gtk_widget_path_append_for_widget(self, widget.getPointer)
# proc append_for_widget*(self: WidgetPath, widget: Widget): int32 {.inline.} =

# gtk_widget_path_append_type
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# type 'GType' 'GType' IN
# 'int32' 'int32'
proc gtk_widget_path_append_type(self: ptr TWidgetPath, type_x: GType): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_path_append_type".}
proc append_type*(self: WidgetPath, type_x: GType): int32 {.inline.} =
  gtk_widget_path_append_type(self, type_x)
# proc append_type*(self: WidgetPath, type_x: GType): int32 {.inline.} =

# gtk_widget_path_append_with_siblings
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# siblings 'TWidgetPath' 'ptr TWidgetPath' IN (diff., need sugar)
# sibling_index 'uint32' 'uint32' IN
# 'int32' 'int32'
proc gtk_widget_path_append_with_siblings(self: ptr TWidgetPath, siblings: ptr TWidgetPath, sibling_index: uint32): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_path_append_with_siblings".}
proc append_with_siblings*(self: WidgetPath, siblings: TWidgetPath, sibling_index: uint32): int32 {.inline.} =
  gtk_widget_path_append_with_siblings(self, myUnsafeAddr(siblings), sibling_index)
# proc append_with_siblings*(self: WidgetPath, siblings: TWidgetPath, sibling_index: uint32): int32 {.inline.} =

# gtk_widget_path_copy
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# 'TWidgetPath' 'ptr TWidgetPath' (diff., need sugar)
proc gtk_widget_path_copy(self: ptr TWidgetPath): ptr TWidgetPath {.cdecl, dynlib: lib, importc: "gtk_widget_path_copy".}
proc copy*(self: WidgetPath): TWidgetPath {.inline.} =
  (gtk_widget_path_copy(self))[]
# proc copy*(self: WidgetPath): TWidgetPath {.inline.} =

# gtk_widget_path_free
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_path_free(self: ptr TWidgetPath) {.cdecl, dynlib: lib, importc: "gtk_widget_path_free".}
proc free*(self: WidgetPath) {.inline.} =
  gtk_widget_path_free(self)
# proc free*(self: WidgetPath) {.inline.} =

# gtk_widget_path_get_object_type
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# 'GType' 'GType'
proc gtk_widget_path_get_object_type(self: ptr TWidgetPath): GType {.cdecl, dynlib: lib, importc: "gtk_widget_path_get_object_type".}
proc get_object_type*(self: WidgetPath): GType {.inline.} =
  gtk_widget_path_get_object_type(self)
# proc get_object_type*(self: WidgetPath): GType {.inline.} =

# gtk_widget_path_has_parent
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# type 'GType' 'GType' IN
# 'bool' 'bool'
proc gtk_widget_path_has_parent(self: ptr TWidgetPath, type_x: GType): bool {.cdecl, dynlib: lib, importc: "gtk_widget_path_has_parent".}
proc has_parent*(self: WidgetPath, type_x: GType): bool {.inline.} =
  gtk_widget_path_has_parent(self, type_x)
# proc has_parent*(self: WidgetPath, type_x: GType): bool {.inline.} =

# gtk_widget_path_is_type
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# type 'GType' 'GType' IN
# 'bool' 'bool'
proc gtk_widget_path_is_type(self: ptr TWidgetPath, type_x: GType): bool {.cdecl, dynlib: lib, importc: "gtk_widget_path_is_type".}
proc is_type*(self: WidgetPath, type_x: GType): bool {.inline.} =
  gtk_widget_path_is_type(self, type_x)
# proc is_type*(self: WidgetPath, type_x: GType): bool {.inline.} =

# gtk_widget_path_iter_add_class
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# pos 'int32' 'int32' IN
# name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_path_iter_add_class(self: ptr TWidgetPath, pos: int32, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_add_class".}
proc iter_add_class*(self: WidgetPath, pos: int32, name: ustring) {.inline.} =
  gtk_widget_path_iter_add_class(self, pos, ucstring(name))
# proc iter_add_class*(self: WidgetPath, pos: int32, name: ustring) {.inline.} =

# gtk_widget_path_iter_add_region
# flags: {isMethod} container: WidgetPath (deprecated)
# gtk_widget_path_iter_clear_classes
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# pos 'int32' 'int32' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_path_iter_clear_classes(self: ptr TWidgetPath, pos: int32) {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_clear_classes".}
proc iter_clear_classes*(self: WidgetPath, pos: int32) {.inline.} =
  gtk_widget_path_iter_clear_classes(self, pos)
# proc iter_clear_classes*(self: WidgetPath, pos: int32) {.inline.} =

# gtk_widget_path_iter_clear_regions
# flags: {isMethod} container: WidgetPath (deprecated)
# gtk_widget_path_iter_get_name
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# pos 'int32' 'int32' IN
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_widget_path_iter_get_name(self: ptr TWidgetPath, pos: int32): ucstring {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_get_name".}
proc iter_get_name*(self: WidgetPath, pos: int32): ustring {.inline.} =
  ustring($(gtk_widget_path_iter_get_name(self, pos)))
# proc iter_get_name*(self: WidgetPath, pos: int32): ustring {.inline.} =

# gtk_widget_path_iter_get_object_type
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# pos 'int32' 'int32' IN
# 'GType' 'GType'
proc gtk_widget_path_iter_get_object_type(self: ptr TWidgetPath, pos: int32): GType {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_get_object_type".}
proc iter_get_object_type*(self: WidgetPath, pos: int32): GType {.inline.} =
  gtk_widget_path_iter_get_object_type(self, pos)
# proc iter_get_object_type*(self: WidgetPath, pos: int32): GType {.inline.} =

# gtk_widget_path_iter_get_sibling_index
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# pos 'int32' 'int32' IN
# 'uint32' 'uint32'
proc gtk_widget_path_iter_get_sibling_index(self: ptr TWidgetPath, pos: int32): uint32 {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_get_sibling_index".}
proc iter_get_sibling_index*(self: WidgetPath, pos: int32): uint32 {.inline.} =
  gtk_widget_path_iter_get_sibling_index(self, pos)
# proc iter_get_sibling_index*(self: WidgetPath, pos: int32): uint32 {.inline.} =

# gtk_widget_path_iter_get_siblings
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# pos 'int32' 'int32' IN
# 'TWidgetPath' 'ptr TWidgetPath' (diff., need sugar)
proc gtk_widget_path_iter_get_siblings(self: ptr TWidgetPath, pos: int32): ptr TWidgetPath {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_get_siblings".}
proc iter_get_siblings*(self: WidgetPath, pos: int32): TWidgetPath {.inline.} =
  (gtk_widget_path_iter_get_siblings(self, pos))[]
# proc iter_get_siblings*(self: WidgetPath, pos: int32): TWidgetPath {.inline.} =

# gtk_widget_path_iter_get_state
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# pos 'int32' 'int32' IN
# 'SStateFlags' 'SStateFlags'
proc gtk_widget_path_iter_get_state(self: ptr TWidgetPath, pos: int32): SStateFlags {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_get_state".}
proc iter_get_state*(self: WidgetPath, pos: int32): SStateFlags {.inline.} =
  gtk_widget_path_iter_get_state(self, pos)
# proc iter_get_state*(self: WidgetPath, pos: int32): SStateFlags {.inline.} =

# gtk_widget_path_iter_has_class
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# pos 'int32' 'int32' IN
# name 'ustring' 'ucstring' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_widget_path_iter_has_class(self: ptr TWidgetPath, pos: int32, name: ucstring): bool {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_has_class".}
proc iter_has_class*(self: WidgetPath, pos: int32, name: ustring): bool {.inline.} =
  gtk_widget_path_iter_has_class(self, pos, ucstring(name))
# proc iter_has_class*(self: WidgetPath, pos: int32, name: ustring): bool {.inline.} =

# gtk_widget_path_iter_has_name
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# pos 'int32' 'int32' IN
# name 'ustring' 'ucstring' IN (diff., need sugar)
# 'bool' 'bool'
proc gtk_widget_path_iter_has_name(self: ptr TWidgetPath, pos: int32, name: ucstring): bool {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_has_name".}
proc iter_has_name*(self: WidgetPath, pos: int32, name: ustring): bool {.inline.} =
  gtk_widget_path_iter_has_name(self, pos, ucstring(name))
# proc iter_has_name*(self: WidgetPath, pos: int32, name: ustring): bool {.inline.} =

# gtk_widget_path_iter_has_qclass
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# pos 'int32' 'int32' IN
# qname 'uint32' 'uint32' IN
# 'bool' 'bool'
proc gtk_widget_path_iter_has_qclass(self: ptr TWidgetPath, pos: int32, qname: uint32): bool {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_has_qclass".}
proc iter_has_qclass*(self: WidgetPath, pos: int32, qname: uint32): bool {.inline.} =
  gtk_widget_path_iter_has_qclass(self, pos, qname)
# proc iter_has_qclass*(self: WidgetPath, pos: int32, qname: uint32): bool {.inline.} =

# gtk_widget_path_iter_has_qname
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# pos 'int32' 'int32' IN
# qname 'uint32' 'uint32' IN
# 'bool' 'bool'
proc gtk_widget_path_iter_has_qname(self: ptr TWidgetPath, pos: int32, qname: uint32): bool {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_has_qname".}
proc iter_has_qname*(self: WidgetPath, pos: int32, qname: uint32): bool {.inline.} =
  gtk_widget_path_iter_has_qname(self, pos, qname)
# proc iter_has_qname*(self: WidgetPath, pos: int32, qname: uint32): bool {.inline.} =

# gtk_widget_path_iter_has_qregion
# flags: {isMethod} container: WidgetPath (deprecated)
# gtk_widget_path_iter_has_region
# flags: {isMethod} container: WidgetPath (deprecated)
# gtk_widget_path_iter_list_classes
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# pos 'int32' 'int32' IN
# 'ptr GSLIST_TODO' 'ptr GSLIST_TODO'
proc gtk_widget_path_iter_list_classes(self: ptr TWidgetPath, pos: int32): ptr GSLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_list_classes".}
proc iter_list_classes*(self: WidgetPath, pos: int32): ptr GSLIST_TODO {.inline.} =
  gtk_widget_path_iter_list_classes(self, pos)
# proc iter_list_classes*(self: WidgetPath, pos: int32): ptr GSLIST_TODO {.inline.} =

# gtk_widget_path_iter_list_regions
# flags: {isMethod} container: WidgetPath (deprecated)
# gtk_widget_path_iter_remove_class
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# pos 'int32' 'int32' IN
# name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_path_iter_remove_class(self: ptr TWidgetPath, pos: int32, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_remove_class".}
proc iter_remove_class*(self: WidgetPath, pos: int32, name: ustring) {.inline.} =
  gtk_widget_path_iter_remove_class(self, pos, ucstring(name))
# proc iter_remove_class*(self: WidgetPath, pos: int32, name: ustring) {.inline.} =

# gtk_widget_path_iter_remove_region
# flags: {isMethod} container: WidgetPath (deprecated)
# gtk_widget_path_iter_set_name
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# pos 'int32' 'int32' IN
# name 'ustring' 'ucstring' IN (diff., need sugar)
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_path_iter_set_name(self: ptr TWidgetPath, pos: int32, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_set_name".}
proc iter_set_name*(self: WidgetPath, pos: int32, name: ustring) {.inline.} =
  gtk_widget_path_iter_set_name(self, pos, ucstring(name))
# proc iter_set_name*(self: WidgetPath, pos: int32, name: ustring) {.inline.} =

# gtk_widget_path_iter_set_object_type
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# pos 'int32' 'int32' IN
# type 'GType' 'GType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_path_iter_set_object_type(self: ptr TWidgetPath, pos: int32, type_x: GType) {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_set_object_type".}
proc iter_set_object_type*(self: WidgetPath, pos: int32, type_x: GType) {.inline.} =
  gtk_widget_path_iter_set_object_type(self, pos, type_x)
# proc iter_set_object_type*(self: WidgetPath, pos: int32, type_x: GType) {.inline.} =

# gtk_widget_path_iter_set_state
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# pos 'int32' 'int32' IN
# state 'SStateFlags' 'SStateFlags' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_path_iter_set_state(self: ptr TWidgetPath, pos: int32, state: SStateFlags) {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_set_state".}
proc iter_set_state*(self: WidgetPath, pos: int32, state: SStateFlags) {.inline.} =
  gtk_widget_path_iter_set_state(self, pos, state)
# proc iter_set_state*(self: WidgetPath, pos: int32, state: SStateFlags) {.inline.} =

# gtk_widget_path_length
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# 'int32' 'int32'
proc gtk_widget_path_length(self: ptr TWidgetPath): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_path_length".}
proc length*(self: WidgetPath): int32 {.inline.} =
  gtk_widget_path_length(self)
# proc length*(self: WidgetPath): int32 {.inline.} =

# gtk_widget_path_prepend_type
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# type 'GType' 'GType' IN
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_path_prepend_type(self: ptr TWidgetPath, type_x: GType) {.cdecl, dynlib: lib, importc: "gtk_widget_path_prepend_type".}
proc prepend_type*(self: WidgetPath, type_x: GType) {.inline.} =
  gtk_widget_path_prepend_type(self, type_x)
# proc prepend_type*(self: WidgetPath, type_x: GType) {.inline.} =

# gtk_widget_path_ref
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# 'TWidgetPath' 'ptr TWidgetPath' (diff., need sugar)
proc gtk_widget_path_ref(self: ptr TWidgetPath): ptr TWidgetPath {.cdecl, dynlib: lib, importc: "gtk_widget_path_ref".}
proc ref_x*(self: WidgetPath): TWidgetPath {.inline.} =
  (gtk_widget_path_ref(self))[]
# proc ref_x*(self: WidgetPath): TWidgetPath {.inline.} =

# gtk_widget_path_to_string
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# 'ustring' 'ucstring' (diff., need sugar)
proc gtk_widget_path_to_string(self: ptr TWidgetPath): ucstring {.cdecl, dynlib: lib, importc: "gtk_widget_path_to_string".}
proc to_string*(self: WidgetPath): ustring {.inline.} =
  ustring($(gtk_widget_path_to_string(self)))
# proc to_string*(self: WidgetPath): ustring {.inline.} =

# gtk_widget_path_unref
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_path_unref(self: ptr TWidgetPath) {.cdecl, dynlib: lib, importc: "gtk_widget_path_unref".}
proc unref*(self: WidgetPath) {.inline.} =
  gtk_widget_path_unref(self)
# proc unref*(self: WidgetPath) {.inline.} =

# struct WidgetPrivate
# struct WindowAccessibleClass
# struct WindowAccessiblePrivate
# struct WindowClass
# struct WindowGeometryInfo
# struct WindowGroupClass
# struct WindowGroupPrivate
# struct WindowPrivate
