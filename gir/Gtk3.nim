# generated bindings for Gtk 3.0
# module is gir.Gtk3
{. deadCodeElim: on .}
import gobjectutils
import gir.Pango1 as Pango1 # 1.0 dep:Pango-1.0
import gir.cairo1 as cairo1 # 1.0 dep:cairo-1.0
import gir.GLib2 as GLib2 # 2.0 dep:GLib-2.0
import gir.GObject2 as GObject2 # 2.0 dep:GObject-2.0
import gir.Gdk3 as Gdk3 # 3.0 dep:Gdk-3.0
import gir.Gio2 as Gio2 # 2.0 dep:Gio-2.0
import gir.GdkPixbuf2 as GdkPixbuf2 # 2.0 dep:GdkPixbuf-2.0
import gir.GModule2 as GModule2 # 2.0 dep:GModule-2.0
import gir.Atk1 as Atk1 # 1.0 dep:Atk-1.0

# libraries: libgtk-3-0.dll,libgdk-3-0.dll
const lib = "libgtk-3-0.dll"
type
  # classes
  #------------------
  # x
  # 
  Widget* = ref GSmartPtr[TWidget]
  TWidget* = object of GObject2.TInitiallyUnowned
    # omitted field for base class:
    # parent_instance_gtkwidget: ptr GObject2.TInitiallyUnowned
    priv_gtkwidget: ptr TWidgetPrivate

  # x
  # 
  Container* = ref GSmartPtr[TContainer]
  TContainer* = object of TWidget
    # omitted field for base class:
    # widget_gtkcontainer: ptr TWidget
    priv_gtkcontainer: ptr TContainerPrivate

  # x
  # 
  Bin* = ref GSmartPtr[TBin]
  TBin* = object of TContainer
    # omitted field for base class:
    # container_gtkbin: ptr TContainer
    priv_gtkbin: ptr TBinPrivate

  # x
  # 
  Window* = ref GSmartPtr[TWindow]
  TWindow* = object of TBin
    # omitted field for base class:
    # bin_gtkwindow: ptr TBin
    priv_gtkwindow: ptr TWindowPrivate

  # x
  # 
  Dialog* = ref GSmartPtr[TDialog]
  TDialog* = object of TWindow
    # omitted field for base class:
    # window_gtkdialog: ptr TWindow
    priv_gtkdialog: ptr TDialogPrivate

  # x
  # 
  AboutDialog* = ref GSmartPtr[TAboutDialog]
  TAboutDialog* = object of TDialog
    # omitted field for base class:
    # parent_instance_gtkaboutdialog: ptr TDialog
    priv_gtkaboutdialog: ptr TAboutDialogPrivate

  # x
  # 
  AccelGroup* = ref GSmartPtr[TAccelGroup]
  TAccelGroup* = object of GObject2.TObject
    # omitted field for base class:
    # parent_gtkaccelgroup: ptr GObject2.TObject
    priv_gtkaccelgroup: ptr TAccelGroupPrivate

  # x
  # 
  Misc* = ref GSmartPtr[TMisc]
  TMisc* = object of TWidget
    # omitted field for base class:
    # widget_gtkmisc: ptr TWidget
    priv_gtkmisc: ptr TMiscPrivate

  # x
  # 
  Label* = ref GSmartPtr[TLabel]
  TLabel* = object of TMisc
    # omitted field for base class:
    # misc_gtklabel: ptr TMisc
    priv_gtklabel: ptr TLabelPrivate

  # x
  # 
  AccelLabel* = ref GSmartPtr[TAccelLabel]
  TAccelLabel* = object of TLabel
    # omitted field for base class:
    # label_gtkaccellabel: ptr TLabel
    priv_gtkaccellabel: ptr TAccelLabelPrivate

  # x
  # 
  AccelMap* = ref GSmartPtr[TAccelMap]
  TAccelMap* = object of GObject2.TObject

  # x
  # 
  Accessible* = ref GSmartPtr[TAccessible]
  TAccessible* = object of Atk1.TObject
    # omitted field for base class:
    # parent_gtkaccessible: ptr Atk1.TObject
    priv_gtkaccessible: ptr TAccessiblePrivate

  # x
  # 
  Action* = ref GSmartPtr[TAction]
  TAction* = object of GObject2.TObject
    # omitted field for base class:
    # object_x_gtkaction: ptr GObject2.TObject
    private_data_gtkaction: ptr TActionPrivate

  # x
  # 
  ActionBar* = ref GSmartPtr[TActionBar]
  TActionBar* = object of TBin
    # omitted field for base class:
    # bin_gtkactionbar: ptr TBin

  # x
  # 
  ActionGroup* = ref GSmartPtr[TActionGroup]
  TActionGroup* = object of GObject2.TObject
    # omitted field for base class:
    # parent_gtkactiongroup: ptr GObject2.TObject
    priv_gtkactiongroup: ptr TActionGroupPrivate

  # x
  # 
  Adjustment* = ref GSmartPtr[TAdjustment]
  TAdjustment* = object of GObject2.TInitiallyUnowned
    # omitted field for base class:
    # parent_instance_gtkadjustment: ptr GObject2.TInitiallyUnowned
    priv_gtkadjustment: ptr TAdjustmentPrivate

  # x
  # 
  Alignment* = ref GSmartPtr[TAlignment]
  TAlignment* = object of TBin
    # omitted field for base class:
    # bin_gtkalignment: ptr TBin
    priv_gtkalignment: ptr TAlignmentPrivate

  # x
  # 
  ComboBox* = ref GSmartPtr[TComboBox]
  TComboBox* = object of TBin
    # omitted field for base class:
    # parent_instance_gtkcombobox: ptr TBin
    priv_gtkcombobox: ptr TComboBoxPrivate

  # x
  # 
  AppChooserButton* = ref GSmartPtr[TAppChooserButton]
  TAppChooserButton* = object of TComboBox
    # omitted field for base class:
    # parent_gtkappchooserbutton: ptr TComboBox
    priv_gtkappchooserbutton: ptr TAppChooserButtonPrivate

  # x
  # 
  AppChooserDialog* = ref GSmartPtr[TAppChooserDialog]
  TAppChooserDialog* = object of TDialog
    # omitted field for base class:
    # parent_gtkappchooserdialog: ptr TDialog
    priv_gtkappchooserdialog: ptr TAppChooserDialogPrivate

  # x
  # 
  Box* = ref GSmartPtr[TBox]
  TBox* = object of TContainer
    # omitted field for base class:
    # container_gtkbox: ptr TContainer
    priv_gtkbox: ptr TBoxPrivate

  # x
  # 
  AppChooserWidget* = ref GSmartPtr[TAppChooserWidget]
  TAppChooserWidget* = object of TBox
    # omitted field for base class:
    # parent_gtkappchooserwidget: ptr TBox
    priv_gtkappchooserwidget: ptr TAppChooserWidgetPrivate

  # x
  # 
  Application* = ref GSmartPtr[TApplication]
  TApplication* = object of Gio2.TApplication
    # omitted field for base class:
    # parent_gtkapplication: ptr Gio2.TApplication
    priv_gtkapplication: ptr TApplicationPrivate

  # x
  # 
  ApplicationWindow* = ref GSmartPtr[TApplicationWindow]
  TApplicationWindow* = object of TWindow
    # omitted field for base class:
    # parent_instance_gtkapplicationwindow: ptr TWindow
    priv_gtkapplicationwindow: ptr TApplicationWindowPrivate

  # x
  # 
  Arrow* = ref GSmartPtr[TArrow]
  TArrow* = object of TMisc
    # omitted field for base class:
    # misc_gtkarrow: ptr TMisc
    priv_gtkarrow: ptr TArrowPrivate

  # x
  # 
  WidgetAccessible* = ref GSmartPtr[TWidgetAccessible]
  TWidgetAccessible* = object of TAccessible
    # omitted field for base class:
    # parent_gtkwidgetaccessible: ptr TAccessible
    priv_gtkwidgetaccessible: ptr TWidgetAccessiblePrivate

  # x
  # 
  ArrowAccessible* = ref GSmartPtr[TArrowAccessible]
  TArrowAccessible* = object of TWidgetAccessible
    # omitted field for base class:
    # parent_gtkarrowaccessible: ptr TWidgetAccessible
    priv_gtkarrowaccessible: ptr TArrowAccessiblePrivate

  # x
  # 
  Frame* = ref GSmartPtr[TFrame]
  TFrame* = object of TBin
    # omitted field for base class:
    # bin_gtkframe: ptr TBin
    priv_gtkframe: ptr TFramePrivate

  # x
  # 
  AspectFrame* = ref GSmartPtr[TAspectFrame]
  TAspectFrame* = object of TFrame
    # omitted field for base class:
    # frame_gtkaspectframe: ptr TFrame
    priv_gtkaspectframe: ptr TAspectFramePrivate

  # x
  # 
  Assistant* = ref GSmartPtr[TAssistant]
  TAssistant* = object of TWindow
    # omitted field for base class:
    # parent_gtkassistant: ptr TWindow
    priv_gtkassistant: ptr TAssistantPrivate

  # x
  # 
  CellAccessible* = ref GSmartPtr[TCellAccessible]
  TCellAccessible* = object of TAccessible
    # omitted field for base class:
    # parent_gtkcellaccessible: ptr TAccessible
    priv_gtkcellaccessible: ptr TCellAccessiblePrivate

  # x
  # 
  RendererCellAccessible* = ref GSmartPtr[TRendererCellAccessible]
  TRendererCellAccessible* = object of TCellAccessible
    # omitted field for base class:
    # parent_gtkrenderercellaccessible: ptr TCellAccessible
    priv_gtkrenderercellaccessible: ptr TRendererCellAccessiblePrivate

  # x
  # 
  BooleanCellAccessible* = ref GSmartPtr[TBooleanCellAccessible]
  TBooleanCellAccessible* = object of TRendererCellAccessible
    # omitted field for base class:
    # parent_gtkbooleancellaccessible: ptr TRendererCellAccessible
    priv_gtkbooleancellaccessible: ptr TBooleanCellAccessiblePrivate

  # x
  # 
  Builder* = ref GSmartPtr[TBuilder]
  TBuilder* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkbuilder: ptr GObject2.TObject
    priv_gtkbuilder: ptr TBuilderPrivate

  # x
  # 
  Button* = ref GSmartPtr[TButton]
  TButton* = object of TBin
    # omitted field for base class:
    # bin_gtkbutton: ptr TBin
    priv_gtkbutton: ptr TButtonPrivate

  # x
  # 
  ContainerAccessible* = ref GSmartPtr[TContainerAccessible]
  TContainerAccessible* = object of TWidgetAccessible
    # omitted field for base class:
    # parent_gtkcontaineraccessible: ptr TWidgetAccessible
    priv_gtkcontaineraccessible: ptr TContainerAccessiblePrivate

  # x
  # 
  ButtonAccessible* = ref GSmartPtr[TButtonAccessible]
  TButtonAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkbuttonaccessible: ptr TContainerAccessible
    priv_gtkbuttonaccessible: ptr TButtonAccessiblePrivate

  # x
  # 
  ButtonBox* = ref GSmartPtr[TButtonBox]
  TButtonBox* = object of TBox
    # omitted field for base class:
    # box_gtkbuttonbox: ptr TBox
    priv_gtkbuttonbox: ptr TButtonBoxPrivate

  # x
  # 
  Calendar* = ref GSmartPtr[TCalendar]
  TCalendar* = object of TWidget
    # omitted field for base class:
    # widget_gtkcalendar: ptr TWidget
    priv_gtkcalendar: ptr TCalendarPrivate

  # x
  # 
  CellArea* = ref GSmartPtr[TCellArea]
  TCellArea* = object of GObject2.TInitiallyUnowned
    # omitted field for base class:
    # parent_instance_gtkcellarea: ptr GObject2.TInitiallyUnowned
    priv_gtkcellarea: ptr TCellAreaPrivate

  # x
  # 
  CellAreaBox* = ref GSmartPtr[TCellAreaBox]
  TCellAreaBox* = object of TCellArea
    # omitted field for base class:
    # parent_instance_gtkcellareabox: ptr TCellArea
    priv_gtkcellareabox: ptr TCellAreaBoxPrivate

  # x
  # 
  CellAreaContext* = ref GSmartPtr[TCellAreaContext]
  TCellAreaContext* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkcellareacontext: ptr GObject2.TObject
    priv_gtkcellareacontext: ptr TCellAreaContextPrivate

  # x
  # 
  CellRenderer* = ref GSmartPtr[TCellRenderer]
  TCellRenderer* = object of GObject2.TInitiallyUnowned
    # omitted field for base class:
    # parent_instance_gtkcellrenderer: ptr GObject2.TInitiallyUnowned
    priv_gtkcellrenderer: ptr TCellRendererPrivate

  # x
  # 
  CellRendererText* = ref GSmartPtr[TCellRendererText]
  TCellRendererText* = object of TCellRenderer
    # omitted field for base class:
    # parent_gtkcellrenderertext: ptr TCellRenderer
    priv_gtkcellrenderertext: ptr TCellRendererTextPrivate

  # x
  # 
  CellRendererAccel* = ref GSmartPtr[TCellRendererAccel]
  TCellRendererAccel* = object of TCellRendererText
    # omitted field for base class:
    # parent_gtkcellrendereraccel: ptr TCellRendererText
    priv_gtkcellrendereraccel: ptr TCellRendererAccelPrivate

  # x
  # 
  CellRendererCombo* = ref GSmartPtr[TCellRendererCombo]
  TCellRendererCombo* = object of TCellRendererText
    # omitted field for base class:
    # parent_gtkcellrenderercombo: ptr TCellRendererText
    priv_gtkcellrenderercombo: ptr TCellRendererComboPrivate

  # x
  # 
  CellRendererPixbuf* = ref GSmartPtr[TCellRendererPixbuf]
  TCellRendererPixbuf* = object of TCellRenderer
    # omitted field for base class:
    # parent_gtkcellrendererpixbuf: ptr TCellRenderer
    priv_gtkcellrendererpixbuf: ptr TCellRendererPixbufPrivate

  # x
  # 
  CellRendererProgress* = ref GSmartPtr[TCellRendererProgress]
  TCellRendererProgress* = object of TCellRenderer
    # omitted field for base class:
    # parent_instance_gtkcellrendererprogress: ptr TCellRenderer
    priv_gtkcellrendererprogress: ptr TCellRendererProgressPrivate

  # x
  # 
  CellRendererSpin* = ref GSmartPtr[TCellRendererSpin]
  TCellRendererSpin* = object of TCellRendererText
    # omitted field for base class:
    # parent_gtkcellrendererspin: ptr TCellRendererText
    priv_gtkcellrendererspin: ptr TCellRendererSpinPrivate

  # x
  # 
  CellRendererSpinner* = ref GSmartPtr[TCellRendererSpinner]
  TCellRendererSpinner* = object of TCellRenderer
    # omitted field for base class:
    # parent_gtkcellrendererspinner: ptr TCellRenderer
    priv_gtkcellrendererspinner: ptr TCellRendererSpinnerPrivate

  # x
  # 
  CellRendererToggle* = ref GSmartPtr[TCellRendererToggle]
  TCellRendererToggle* = object of TCellRenderer
    # omitted field for base class:
    # parent_gtkcellrenderertoggle: ptr TCellRenderer
    priv_gtkcellrenderertoggle: ptr TCellRendererTogglePrivate

  # x
  # 
  CellView* = ref GSmartPtr[TCellView]
  TCellView* = object of TWidget
    # omitted field for base class:
    # parent_instance_gtkcellview: ptr TWidget
    priv_gtkcellview: ptr TCellViewPrivate

  # x
  # 
  ToggleButton* = ref GSmartPtr[TToggleButton]
  TToggleButton* = object of TButton
    # omitted field for base class:
    # button_gtktogglebutton: ptr TButton
    priv_gtktogglebutton: ptr TToggleButtonPrivate

  # x
  # 
  CheckButton* = ref GSmartPtr[TCheckButton]
  TCheckButton* = object of TToggleButton
    # omitted field for base class:
    # toggle_button_gtkcheckbutton: ptr TToggleButton

  # x
  # 
  MenuItem* = ref GSmartPtr[TMenuItem]
  TMenuItem* = object of TBin
    # omitted field for base class:
    # bin_gtkmenuitem: ptr TBin
    priv_gtkmenuitem: ptr TMenuItemPrivate

  # x
  # 
  CheckMenuItem* = ref GSmartPtr[TCheckMenuItem]
  TCheckMenuItem* = object of TMenuItem
    # omitted field for base class:
    # menu_item_gtkcheckmenuitem: ptr TMenuItem
    priv_gtkcheckmenuitem: ptr TCheckMenuItemPrivate

  # x
  # 
  MenuItemAccessible* = ref GSmartPtr[TMenuItemAccessible]
  TMenuItemAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkmenuitemaccessible: ptr TContainerAccessible
    priv_gtkmenuitemaccessible: ptr TMenuItemAccessiblePrivate

  # x
  # 
  CheckMenuItemAccessible* = ref GSmartPtr[TCheckMenuItemAccessible]
  TCheckMenuItemAccessible* = object of TMenuItemAccessible
    # omitted field for base class:
    # parent_gtkcheckmenuitemaccessible: ptr TMenuItemAccessible
    priv_gtkcheckmenuitemaccessible: ptr TCheckMenuItemAccessiblePrivate

  # x
  # 
  Clipboard* = ref GSmartPtr[TClipboard]
  TClipboard* = object of GObject2.TObject

  # x
  # 
  ColorButton* = ref GSmartPtr[TColorButton]
  TColorButton* = object of TButton
    # omitted field for base class:
    # button_gtkcolorbutton: ptr TButton
    priv_gtkcolorbutton: ptr TColorButtonPrivate

  # x
  # 
  ColorChooserDialog* = ref GSmartPtr[TColorChooserDialog]
  TColorChooserDialog* = object of TDialog
    # omitted field for base class:
    # parent_instance_gtkcolorchooserdialog: ptr TDialog
    priv_gtkcolorchooserdialog: ptr TColorChooserDialogPrivate

  # x
  # 
  ColorChooserWidget* = ref GSmartPtr[TColorChooserWidget]
  TColorChooserWidget* = object of TBox
    # omitted field for base class:
    # parent_instance_gtkcolorchooserwidget: ptr TBox
    priv_gtkcolorchooserwidget: ptr TColorChooserWidgetPrivate

  # x
  # 
  ColorSelection* = ref GSmartPtr[TColorSelection]
  TColorSelection* = object of TBox
    # omitted field for base class:
    # parent_instance_gtkcolorselection: ptr TBox
    private_data_gtkcolorselection: ptr TColorSelectionPrivate

  # x
  # 
  ColorSelectionDialog* = ref GSmartPtr[TColorSelectionDialog]
  TColorSelectionDialog* = object of TDialog
    # omitted field for base class:
    # parent_instance_gtkcolorselectiondialog: ptr TDialog
    priv_gtkcolorselectiondialog: ptr TColorSelectionDialogPrivate

  # x
  # 
  ComboBoxAccessible* = ref GSmartPtr[TComboBoxAccessible]
  TComboBoxAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkcomboboxaccessible: ptr TContainerAccessible
    priv_gtkcomboboxaccessible: ptr TComboBoxAccessiblePrivate

  # x
  # 
  ComboBoxText* = ref GSmartPtr[TComboBoxText]
  TComboBoxText* = object of TComboBox
    # omitted field for base class:
    # parent_instance_gtkcomboboxtext: ptr TComboBox
    priv_gtkcomboboxtext: ptr TComboBoxTextPrivate

  # x
  # 
  ContainerCellAccessible* = ref GSmartPtr[TContainerCellAccessible]
  TContainerCellAccessible* = object of TCellAccessible
    # omitted field for base class:
    # parent_gtkcontainercellaccessible: ptr TCellAccessible
    priv_gtkcontainercellaccessible: ptr TContainerCellAccessiblePrivate

  # x
  # 
  CssProvider* = ref GSmartPtr[TCssProvider]
  TCssProvider* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkcssprovider: ptr GObject2.TObject
    priv_gtkcssprovider: ptr TCssProviderPrivate

  # x
  # 
  DrawingArea* = ref GSmartPtr[TDrawingArea]
  TDrawingArea* = object of TWidget
    # omitted field for base class:
    # widget_gtkdrawingarea: ptr TWidget
    dummy_gtkdrawingarea: pointer

  # x
  # 
  Entry* = ref GSmartPtr[TEntry]
  TEntry* = object of TWidget
    # omitted field for base class:
    # parent_instance_gtkentry: ptr TWidget
    priv_gtkentry: ptr TEntryPrivate

  # x
  # 
  EntryAccessible* = ref GSmartPtr[TEntryAccessible]
  TEntryAccessible* = object of TWidgetAccessible
    # omitted field for base class:
    # parent_gtkentryaccessible: ptr TWidgetAccessible
    priv_gtkentryaccessible: ptr TEntryAccessiblePrivate

  # x
  # 
  EntryBuffer* = ref GSmartPtr[TEntryBuffer]
  TEntryBuffer* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkentrybuffer: ptr GObject2.TObject
    priv_gtkentrybuffer: ptr TEntryBufferPrivate

  # x
  # 
  EntryCompletion* = ref GSmartPtr[TEntryCompletion]
  TEntryCompletion* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkentrycompletion: ptr GObject2.TObject
    priv_gtkentrycompletion: ptr TEntryCompletionPrivate

  # x
  # 
  EntryIconAccessible* = ref GSmartPtr[TEntryIconAccessible]
  TEntryIconAccessible* = object of Atk1.TObject

  # x
  # 
  EventBox* = ref GSmartPtr[TEventBox]
  TEventBox* = object of TBin
    # omitted field for base class:
    # bin_gtkeventbox: ptr TBin
    priv_gtkeventbox: ptr TEventBoxPrivate

  # x
  # 
  EventController* = ref GSmartPtr[TEventController]
  TEventController* = object of GObject2.TObject

  # x
  # 
  Expander* = ref GSmartPtr[TExpander]
  TExpander* = object of TBin
    # omitted field for base class:
    # bin_gtkexpander: ptr TBin
    priv_gtkexpander: ptr TExpanderPrivate

  # x
  # 
  ExpanderAccessible* = ref GSmartPtr[TExpanderAccessible]
  TExpanderAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkexpanderaccessible: ptr TContainerAccessible
    priv_gtkexpanderaccessible: ptr TExpanderAccessiblePrivate

  # x
  # 
  FileChooserButton* = ref GSmartPtr[TFileChooserButton]
  TFileChooserButton* = object of TBox
    # omitted field for base class:
    # parent_gtkfilechooserbutton: ptr TBox
    priv_gtkfilechooserbutton: ptr TFileChooserButtonPrivate

  # x
  # 
  FileChooserDialog* = ref GSmartPtr[TFileChooserDialog]
  TFileChooserDialog* = object of TDialog
    # omitted field for base class:
    # parent_instance_gtkfilechooserdialog: ptr TDialog
    priv_gtkfilechooserdialog: ptr TFileChooserDialogPrivate

  # x
  # 
  FileChooserWidget* = ref GSmartPtr[TFileChooserWidget]
  TFileChooserWidget* = object of TBox
    # omitted field for base class:
    # parent_instance_gtkfilechooserwidget: ptr TBox
    priv_gtkfilechooserwidget: ptr TFileChooserWidgetPrivate

  # x
  # 
  FileFilter* = ref GSmartPtr[TFileFilter]
  TFileFilter* = object of GObject2.TInitiallyUnowned

  # x
  # 
  Fixed* = ref GSmartPtr[TFixed]
  TFixed* = object of TContainer
    # omitted field for base class:
    # container_gtkfixed: ptr TContainer
    priv_gtkfixed: ptr TFixedPrivate

  # x
  # 
  FlowBox* = ref GSmartPtr[TFlowBox]
  TFlowBox* = object of TContainer
    # omitted field for base class:
    # container_gtkflowbox: ptr TContainer

  # x
  # 
  FlowBoxAccessible* = ref GSmartPtr[TFlowBoxAccessible]
  TFlowBoxAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkflowboxaccessible: ptr TContainerAccessible
    priv_gtkflowboxaccessible: ptr TFlowBoxAccessiblePrivate

  # x
  # 
  FlowBoxChild* = ref GSmartPtr[TFlowBoxChild]
  TFlowBoxChild* = object of TBin
    # omitted field for base class:
    # parent_instance_gtkflowboxchild: ptr TBin

  # x
  # 
  FlowBoxChildAccessible* = ref GSmartPtr[TFlowBoxChildAccessible]
  TFlowBoxChildAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkflowboxchildaccessible: ptr TContainerAccessible

  # x
  # 
  FontButton* = ref GSmartPtr[TFontButton]
  TFontButton* = object of TButton
    # omitted field for base class:
    # button_gtkfontbutton: ptr TButton
    priv_gtkfontbutton: ptr TFontButtonPrivate

  # x
  # 
  FontChooserDialog* = ref GSmartPtr[TFontChooserDialog]
  TFontChooserDialog* = object of TDialog
    # omitted field for base class:
    # parent_instance_gtkfontchooserdialog: ptr TDialog
    priv_gtkfontchooserdialog: ptr TFontChooserDialogPrivate

  # x
  # 
  FontChooserWidget* = ref GSmartPtr[TFontChooserWidget]
  TFontChooserWidget* = object of TBox
    # omitted field for base class:
    # parent_instance_gtkfontchooserwidget: ptr TBox
    priv_gtkfontchooserwidget: ptr TFontChooserWidgetPrivate

  # x
  # 
  FontSelection* = ref GSmartPtr[TFontSelection]
  TFontSelection* = object of TBox
    # omitted field for base class:
    # parent_instance_gtkfontselection: ptr TBox
    priv_gtkfontselection: ptr TFontSelectionPrivate

  # x
  # 
  FontSelectionDialog* = ref GSmartPtr[TFontSelectionDialog]
  TFontSelectionDialog* = object of TDialog
    # omitted field for base class:
    # parent_instance_gtkfontselectiondialog: ptr TDialog
    priv_gtkfontselectiondialog: ptr TFontSelectionDialogPrivate

  # x
  # 
  FrameAccessible* = ref GSmartPtr[TFrameAccessible]
  TFrameAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkframeaccessible: ptr TContainerAccessible
    priv_gtkframeaccessible: ptr TFrameAccessiblePrivate

  # x
  # 
  GLArea* = ref GSmartPtr[TGLArea]
  TGLArea* = object of TWidget
    # omitted field for base class:
    # parent_instance_gtkglarea: ptr TWidget

  # x
  # 
  Gesture* = ref GSmartPtr[TGesture]
  TGesture* = object of TEventController

  # x
  # 
  GestureSingle* = ref GSmartPtr[TGestureSingle]
  TGestureSingle* = object of TGesture

  # x
  # 
  GestureDrag* = ref GSmartPtr[TGestureDrag]
  TGestureDrag* = object of TGestureSingle

  # x
  # 
  GestureLongPress* = ref GSmartPtr[TGestureLongPress]
  TGestureLongPress* = object of TGestureSingle

  # x
  # 
  GestureMultiPress* = ref GSmartPtr[TGestureMultiPress]
  TGestureMultiPress* = object of TGestureSingle

  # x
  # 
  GesturePan* = ref GSmartPtr[TGesturePan]
  TGesturePan* = object of TGestureDrag

  # x
  # 
  GestureRotate* = ref GSmartPtr[TGestureRotate]
  TGestureRotate* = object of TGesture

  # x
  # 
  GestureSwipe* = ref GSmartPtr[TGestureSwipe]
  TGestureSwipe* = object of TGestureSingle

  # x
  # 
  GestureZoom* = ref GSmartPtr[TGestureZoom]
  TGestureZoom* = object of TGesture

  # x
  # 
  Grid* = ref GSmartPtr[TGrid]
  TGrid* = object of TContainer
    # omitted field for base class:
    # container_gtkgrid: ptr TContainer
    priv_gtkgrid: ptr TGridPrivate

  # x
  # 
  HBox* = ref GSmartPtr[THBox]
  THBox* = object of TBox
    # omitted field for base class:
    # box_gtkhbox: ptr TBox

  # x
  # 
  HButtonBox* = ref GSmartPtr[THButtonBox]
  THButtonBox* = object of TButtonBox
    # omitted field for base class:
    # button_box_gtkhbuttonbox: ptr TButtonBox

  # x
  # 
  Paned* = ref GSmartPtr[TPaned]
  TPaned* = object of TContainer
    # omitted field for base class:
    # container_gtkpaned: ptr TContainer
    priv_gtkpaned: ptr TPanedPrivate

  # x
  # 
  HPaned* = ref GSmartPtr[THPaned]
  THPaned* = object of TPaned
    # omitted field for base class:
    # paned_gtkhpaned: ptr TPaned

  # x
  # 
  HSV* = ref GSmartPtr[THSV]
  THSV* = object of TWidget
    # omitted field for base class:
    # parent_instance_gtkhsv: ptr TWidget
    priv_gtkhsv: ptr THSVPrivate

  # x
  # 
  Range* = ref GSmartPtr[TRange]
  TRange* = object of TWidget
    # omitted field for base class:
    # widget_gtkrange: ptr TWidget
    priv_gtkrange: ptr TRangePrivate

  # x
  # 
  Scale* = ref GSmartPtr[TScale]
  TScale* = object of TRange
    # omitted field for base class:
    # range_gtkscale: ptr TRange
    priv_gtkscale: ptr TScalePrivate

  # x
  # 
  HScale* = ref GSmartPtr[THScale]
  THScale* = object of TScale
    # omitted field for base class:
    # scale_gtkhscale: ptr TScale

  # x
  # 
  Scrollbar* = ref GSmartPtr[TScrollbar]
  TScrollbar* = object of TRange
    # omitted field for base class:
    # range_gtkscrollbar: ptr TRange

  # x
  # 
  HScrollbar* = ref GSmartPtr[THScrollbar]
  THScrollbar* = object of TScrollbar
    # omitted field for base class:
    # scrollbar_gtkhscrollbar: ptr TScrollbar

  # x
  # 
  Separator* = ref GSmartPtr[TSeparator]
  TSeparator* = object of TWidget
    # omitted field for base class:
    # widget_gtkseparator: ptr TWidget
    priv_gtkseparator: ptr TSeparatorPrivate

  # x
  # 
  HSeparator* = ref GSmartPtr[THSeparator]
  THSeparator* = object of TSeparator
    # omitted field for base class:
    # separator_gtkhseparator: ptr TSeparator

  # x
  # 
  HandleBox* = ref GSmartPtr[THandleBox]
  THandleBox* = object of TBin
    # omitted field for base class:
    # bin_gtkhandlebox: ptr TBin
    priv_gtkhandlebox: ptr THandleBoxPrivate

  # x
  # 
  HeaderBar* = ref GSmartPtr[THeaderBar]
  THeaderBar* = object of TContainer
    # omitted field for base class:
    # container_gtkheaderbar: ptr TContainer

  # x
  # 
  IMContext* = ref GSmartPtr[TIMContext]
  TIMContext* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkimcontext: ptr GObject2.TObject

  # x
  # 
  IMContextSimple* = ref GSmartPtr[TIMContextSimple]
  TIMContextSimple* = object of TIMContext
    # omitted field for base class:
    # object_x_gtkimcontextsimple: ptr TIMContext
    priv_gtkimcontextsimple: ptr TIMContextSimplePrivate

  # x
  # 
  IMMulticontext* = ref GSmartPtr[TIMMulticontext]
  TIMMulticontext* = object of TIMContext
    # omitted field for base class:
    # object_x_gtkimmulticontext: ptr TIMContext
    priv_gtkimmulticontext: ptr TIMMulticontextPrivate

  # x
  # 
  IconFactory* = ref GSmartPtr[TIconFactory]
  TIconFactory* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkiconfactory: ptr GObject2.TObject
    priv_gtkiconfactory: ptr TIconFactoryPrivate

  # x
  # 
  IconInfo* = ref GSmartPtr[TIconInfo]
  TIconInfo* = object of GObject2.TObject

  # x
  # 
  IconTheme* = ref GSmartPtr[TIconTheme]
  TIconTheme* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkicontheme: ptr GObject2.TObject
    priv_gtkicontheme: ptr TIconThemePrivate

  # x
  # 
  IconView* = ref GSmartPtr[TIconView]
  TIconView* = object of TContainer
    # omitted field for base class:
    # parent_gtkiconview: ptr TContainer
    priv_gtkiconview: ptr TIconViewPrivate

  # x
  # 
  IconViewAccessible* = ref GSmartPtr[TIconViewAccessible]
  TIconViewAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkiconviewaccessible: ptr TContainerAccessible
    priv_gtkiconviewaccessible: ptr TIconViewAccessiblePrivate

  # x
  # 
  Image* = ref GSmartPtr[TImage]
  TImage* = object of TMisc
    # omitted field for base class:
    # misc_gtkimage: ptr TMisc
    priv_gtkimage: ptr TImagePrivate

  # x
  # 
  ImageAccessible* = ref GSmartPtr[TImageAccessible]
  TImageAccessible* = object of TWidgetAccessible
    # omitted field for base class:
    # parent_gtkimageaccessible: ptr TWidgetAccessible
    priv_gtkimageaccessible: ptr TImageAccessiblePrivate

  # x
  # 
  ImageCellAccessible* = ref GSmartPtr[TImageCellAccessible]
  TImageCellAccessible* = object of TRendererCellAccessible
    # omitted field for base class:
    # parent_gtkimagecellaccessible: ptr TRendererCellAccessible
    priv_gtkimagecellaccessible: ptr TImageCellAccessiblePrivate

  # x
  # 
  ImageMenuItem* = ref GSmartPtr[TImageMenuItem]
  TImageMenuItem* = object of TMenuItem
    # omitted field for base class:
    # menu_item_gtkimagemenuitem: ptr TMenuItem
    priv_gtkimagemenuitem: ptr TImageMenuItemPrivate

  # x
  # 
  InfoBar* = ref GSmartPtr[TInfoBar]
  TInfoBar* = object of TBox
    # omitted field for base class:
    # parent_gtkinfobar: ptr TBox
    priv_gtkinfobar: ptr TInfoBarPrivate

  # x
  # 
  Invisible* = ref GSmartPtr[TInvisible]
  TInvisible* = object of TWidget
    # omitted field for base class:
    # widget_gtkinvisible: ptr TWidget
    priv_gtkinvisible: ptr TInvisiblePrivate

  # x
  # 
  LabelAccessible* = ref GSmartPtr[TLabelAccessible]
  TLabelAccessible* = object of TWidgetAccessible
    # omitted field for base class:
    # parent_gtklabelaccessible: ptr TWidgetAccessible
    priv_gtklabelaccessible: ptr TLabelAccessiblePrivate

  # x
  # 
  Layout* = ref GSmartPtr[TLayout]
  TLayout* = object of TContainer
    # omitted field for base class:
    # container_gtklayout: ptr TContainer
    priv_gtklayout: ptr TLayoutPrivate

  # x
  # 
  LevelBar* = ref GSmartPtr[TLevelBar]
  TLevelBar* = object of TWidget
    # omitted field for base class:
    # parent_gtklevelbar: ptr TWidget
    priv_gtklevelbar: ptr TLevelBarPrivate

  # x
  # 
  LevelBarAccessible* = ref GSmartPtr[TLevelBarAccessible]
  TLevelBarAccessible* = object of TWidgetAccessible
    # omitted field for base class:
    # parent_gtklevelbaraccessible: ptr TWidgetAccessible
    priv_gtklevelbaraccessible: ptr TLevelBarAccessiblePrivate

  # x
  # 
  LinkButton* = ref GSmartPtr[TLinkButton]
  TLinkButton* = object of TButton
    # omitted field for base class:
    # parent_instance_gtklinkbutton: ptr TButton
    priv_gtklinkbutton: ptr TLinkButtonPrivate

  # x
  # 
  LinkButtonAccessible* = ref GSmartPtr[TLinkButtonAccessible]
  TLinkButtonAccessible* = object of TButtonAccessible
    # omitted field for base class:
    # parent_gtklinkbuttonaccessible: ptr TButtonAccessible
    priv_gtklinkbuttonaccessible: ptr TLinkButtonAccessiblePrivate

  # x
  # 
  ListBox* = ref GSmartPtr[TListBox]
  TListBox* = object of TContainer
    # omitted field for base class:
    # parent_instance_gtklistbox: ptr TContainer

  # x
  # 
  ListBoxAccessible* = ref GSmartPtr[TListBoxAccessible]
  TListBoxAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtklistboxaccessible: ptr TContainerAccessible
    priv_gtklistboxaccessible: ptr TListBoxAccessiblePrivate

  # x
  # 
  ListBoxRow* = ref GSmartPtr[TListBoxRow]
  TListBoxRow* = object of TBin
    # omitted field for base class:
    # parent_instance_gtklistboxrow: ptr TBin

  # x
  # 
  ListBoxRowAccessible* = ref GSmartPtr[TListBoxRowAccessible]
  TListBoxRowAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtklistboxrowaccessible: ptr TContainerAccessible

  # x
  # 
  ListStore* = ref GSmartPtr[TListStore]
  TListStore* = object of GObject2.TObject
    # omitted field for base class:
    # parent_gtkliststore: ptr GObject2.TObject
    priv_gtkliststore: ptr TListStorePrivate

  # x
  # 
  LockButton* = ref GSmartPtr[TLockButton]
  TLockButton* = object of TButton
    # omitted field for base class:
    # parent_gtklockbutton: ptr TButton
    priv_gtklockbutton: ptr TLockButtonPrivate

  # x
  # 
  LockButtonAccessible* = ref GSmartPtr[TLockButtonAccessible]
  TLockButtonAccessible* = object of TButtonAccessible
    # omitted field for base class:
    # parent_gtklockbuttonaccessible: ptr TButtonAccessible
    priv_gtklockbuttonaccessible: ptr TLockButtonAccessiblePrivate

  # x
  # 
  MenuShell* = ref GSmartPtr[TMenuShell]
  TMenuShell* = object of TContainer
    # omitted field for base class:
    # container_gtkmenushell: ptr TContainer
    priv_gtkmenushell: ptr TMenuShellPrivate

  # x
  # 
  Menu* = ref GSmartPtr[TMenu]
  TMenu* = object of TMenuShell
    # omitted field for base class:
    # menu_shell_gtkmenu: ptr TMenuShell
    priv_gtkmenu: ptr TMenuPrivate

  # x
  # 
  MenuShellAccessible* = ref GSmartPtr[TMenuShellAccessible]
  TMenuShellAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkmenushellaccessible: ptr TContainerAccessible
    priv_gtkmenushellaccessible: ptr TMenuShellAccessiblePrivate

  # x
  # 
  MenuAccessible* = ref GSmartPtr[TMenuAccessible]
  TMenuAccessible* = object of TMenuShellAccessible
    # omitted field for base class:
    # parent_gtkmenuaccessible: ptr TMenuShellAccessible
    priv_gtkmenuaccessible: ptr TMenuAccessiblePrivate

  # x
  # 
  MenuBar* = ref GSmartPtr[TMenuBar]
  TMenuBar* = object of TMenuShell
    # omitted field for base class:
    # menu_shell_gtkmenubar: ptr TMenuShell
    priv_gtkmenubar: ptr TMenuBarPrivate

  # x
  # 
  MenuButton* = ref GSmartPtr[TMenuButton]
  TMenuButton* = object of TToggleButton
    # omitted field for base class:
    # parent_gtkmenubutton: ptr TToggleButton
    priv_gtkmenubutton: ptr TMenuButtonPrivate

  # x
  # 
  ToggleButtonAccessible* = ref GSmartPtr[TToggleButtonAccessible]
  TToggleButtonAccessible* = object of TButtonAccessible
    # omitted field for base class:
    # parent_gtktogglebuttonaccessible: ptr TButtonAccessible
    priv_gtktogglebuttonaccessible: ptr TToggleButtonAccessiblePrivate

  # x
  # 
  MenuButtonAccessible* = ref GSmartPtr[TMenuButtonAccessible]
  TMenuButtonAccessible* = object of TToggleButtonAccessible
    # omitted field for base class:
    # parent_gtkmenubuttonaccessible: ptr TToggleButtonAccessible
    priv_gtkmenubuttonaccessible: ptr TMenuButtonAccessiblePrivate

  # x
  # 
  ToolItem* = ref GSmartPtr[TToolItem]
  TToolItem* = object of TBin
    # omitted field for base class:
    # parent_gtktoolitem: ptr TBin
    priv_gtktoolitem: ptr TToolItemPrivate

  # x
  # 
  ToolButton* = ref GSmartPtr[TToolButton]
  TToolButton* = object of TToolItem
    # omitted field for base class:
    # parent_gtktoolbutton: ptr TToolItem
    priv_gtktoolbutton: ptr TToolButtonPrivate

  # x
  # 
  MenuToolButton* = ref GSmartPtr[TMenuToolButton]
  TMenuToolButton* = object of TToolButton
    # omitted field for base class:
    # parent_gtkmenutoolbutton: ptr TToolButton
    priv_gtkmenutoolbutton: ptr TMenuToolButtonPrivate

  # x
  # 
  MessageDialog* = ref GSmartPtr[TMessageDialog]
  TMessageDialog* = object of TDialog
    # omitted field for base class:
    # parent_instance_gtkmessagedialog: ptr TDialog
    priv_gtkmessagedialog: ptr TMessageDialogPrivate

  # x
  # 
  ModelButton* = ref GSmartPtr[TModelButton]
  TModelButton* = object of TButton

  # x
  # 
  MountOperation* = ref GSmartPtr[TMountOperation]
  TMountOperation* = object of Gio2.TMountOperation
    # omitted field for base class:
    # parent_instance_gtkmountoperation: ptr Gio2.TMountOperation
    priv_gtkmountoperation: ptr TMountOperationPrivate

  # x
  # 
  Notebook* = ref GSmartPtr[TNotebook]
  TNotebook* = object of TContainer
    # omitted field for base class:
    # container_gtknotebook: ptr TContainer
    priv_gtknotebook: ptr TNotebookPrivate

  # x
  # 
  NotebookAccessible* = ref GSmartPtr[TNotebookAccessible]
  TNotebookAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtknotebookaccessible: ptr TContainerAccessible
    priv_gtknotebookaccessible: ptr TNotebookAccessiblePrivate

  # x
  # 
  NotebookPageAccessible* = ref GSmartPtr[TNotebookPageAccessible]
  TNotebookPageAccessible* = object of Atk1.TObject
    # omitted field for base class:
    # parent_gtknotebookpageaccessible: ptr Atk1.TObject
    priv_gtknotebookpageaccessible: ptr TNotebookPageAccessiblePrivate

  # x
  # 
  NumerableIcon* = ref GSmartPtr[TNumerableIcon]
  TNumerableIcon* = object of Gio2.TEmblemedIcon
    # omitted field for base class:
    # parent_gtknumerableicon: ptr Gio2.TEmblemedIcon
    priv_gtknumerableicon: ptr TNumerableIconPrivate

  # x
  # 
  OffscreenWindow* = ref GSmartPtr[TOffscreenWindow]
  TOffscreenWindow* = object of TWindow
    # omitted field for base class:
    # parent_object_gtkoffscreenwindow: ptr TWindow

  # x
  # 
  Overlay* = ref GSmartPtr[TOverlay]
  TOverlay* = object of TBin
    # omitted field for base class:
    # parent_gtkoverlay: ptr TBin
    priv_gtkoverlay: ptr TOverlayPrivate

  # x
  # 
  PageSetup* = ref GSmartPtr[TPageSetup]
  TPageSetup* = object of GObject2.TObject

  # x
  # 
  PanedAccessible* = ref GSmartPtr[TPanedAccessible]
  TPanedAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkpanedaccessible: ptr TContainerAccessible
    priv_gtkpanedaccessible: ptr TPanedAccessiblePrivate

  # x
  # 
  ScrolledWindow* = ref GSmartPtr[TScrolledWindow]
  TScrolledWindow* = object of TBin
    # omitted field for base class:
    # container_gtkscrolledwindow: ptr TBin
    priv_gtkscrolledwindow: ptr TScrolledWindowPrivate

  # x
  # 
  PlacesSidebar* = ref GSmartPtr[TPlacesSidebar]
  TPlacesSidebar* = object of TScrolledWindow

  # x
  # 
  Popover* = ref GSmartPtr[TPopover]
  TPopover* = object of TBin
    # omitted field for base class:
    # parent_instance_gtkpopover: ptr TBin
    priv_gtkpopover: ptr TPopoverPrivate

  # x
  # 
  PopoverAccessible* = ref GSmartPtr[TPopoverAccessible]
  TPopoverAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkpopoveraccessible: ptr TContainerAccessible

  # x
  # 
  PopoverMenu* = ref GSmartPtr[TPopoverMenu]
  TPopoverMenu* = object of TPopover

  # x
  # 
  PrintContext* = ref GSmartPtr[TPrintContext]
  TPrintContext* = object of GObject2.TObject

  # x
  # 
  PrintOperation* = ref GSmartPtr[TPrintOperation]
  TPrintOperation* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkprintoperation: ptr GObject2.TObject
    priv_gtkprintoperation: ptr TPrintOperationPrivate

  # x
  # 
  PrintSettings* = ref GSmartPtr[TPrintSettings]
  TPrintSettings* = object of GObject2.TObject

  # x
  # 
  ProgressBar* = ref GSmartPtr[TProgressBar]
  TProgressBar* = object of TWidget
    # omitted field for base class:
    # parent_gtkprogressbar: ptr TWidget
    priv_gtkprogressbar: ptr TProgressBarPrivate

  # x
  # 
  ProgressBarAccessible* = ref GSmartPtr[TProgressBarAccessible]
  TProgressBarAccessible* = object of TWidgetAccessible
    # omitted field for base class:
    # parent_gtkprogressbaraccessible: ptr TWidgetAccessible
    priv_gtkprogressbaraccessible: ptr TProgressBarAccessiblePrivate

  # x
  # 
  ToggleAction* = ref GSmartPtr[TToggleAction]
  TToggleAction* = object of TAction
    # omitted field for base class:
    # parent_gtktoggleaction: ptr TAction
    private_data_gtktoggleaction: ptr TToggleActionPrivate

  # x
  # 
  RadioAction* = ref GSmartPtr[TRadioAction]
  TRadioAction* = object of TToggleAction
    # omitted field for base class:
    # parent_gtkradioaction: ptr TToggleAction
    private_data_gtkradioaction: ptr TRadioActionPrivate

  # x
  # 
  RadioButton* = ref GSmartPtr[TRadioButton]
  TRadioButton* = object of TCheckButton
    # omitted field for base class:
    # check_button_gtkradiobutton: ptr TCheckButton
    priv_gtkradiobutton: ptr TRadioButtonPrivate

  # x
  # 
  RadioButtonAccessible* = ref GSmartPtr[TRadioButtonAccessible]
  TRadioButtonAccessible* = object of TToggleButtonAccessible
    # omitted field for base class:
    # parent_gtkradiobuttonaccessible: ptr TToggleButtonAccessible
    priv_gtkradiobuttonaccessible: ptr TRadioButtonAccessiblePrivate

  # x
  # 
  RadioMenuItem* = ref GSmartPtr[TRadioMenuItem]
  TRadioMenuItem* = object of TCheckMenuItem
    # omitted field for base class:
    # check_menu_item_gtkradiomenuitem: ptr TCheckMenuItem
    priv_gtkradiomenuitem: ptr TRadioMenuItemPrivate

  # x
  # 
  RadioMenuItemAccessible* = ref GSmartPtr[TRadioMenuItemAccessible]
  TRadioMenuItemAccessible* = object of TCheckMenuItemAccessible
    # omitted field for base class:
    # parent_gtkradiomenuitemaccessible: ptr TCheckMenuItemAccessible
    priv_gtkradiomenuitemaccessible: ptr TRadioMenuItemAccessiblePrivate

  # x
  # 
  ToggleToolButton* = ref GSmartPtr[TToggleToolButton]
  TToggleToolButton* = object of TToolButton
    # omitted field for base class:
    # parent_gtktoggletoolbutton: ptr TToolButton
    priv_gtktoggletoolbutton: ptr TToggleToolButtonPrivate

  # x
  # 
  RadioToolButton* = ref GSmartPtr[TRadioToolButton]
  TRadioToolButton* = object of TToggleToolButton
    # omitted field for base class:
    # parent_gtkradiotoolbutton: ptr TToggleToolButton

  # x
  # 
  RangeAccessible* = ref GSmartPtr[TRangeAccessible]
  TRangeAccessible* = object of TWidgetAccessible
    # omitted field for base class:
    # parent_gtkrangeaccessible: ptr TWidgetAccessible
    priv_gtkrangeaccessible: ptr TRangeAccessiblePrivate

  # x
  # 
  RcStyle* = ref GSmartPtr[TRcStyle]
  TRcStyle* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkrcstyle: ptr GObject2.TObject
    name_gtkrcstyle: ucstring
    bg_pixmap_name_gtkrcstyle: array[5, ucstring]
    font_desc_gtkrcstyle: ptr Pango1.TFontDescription
    color_flags_gtkrcstyle: array[5, SRcFlags]
    fg_gtkrcstyle: array[5, Gdk3.TColor]
    bg_gtkrcstyle: array[5, Gdk3.TColor]
    text_gtkrcstyle: array[5, Gdk3.TColor]
    base_gtkrcstyle: array[5, Gdk3.TColor]
    xthickness_gtkrcstyle: int32
    ythickness_gtkrcstyle: int32
    rc_properties_gtkrcstyle: ptr array[-1, pointer]
    rc_style_lists_gtkrcstyle: ptr GSLIST_TODO
    icon_factories_gtkrcstyle: ptr GSLIST_TODO
    engine_specified_gtkrcstyle: uint32

  # x
  # 
  RecentAction* = ref GSmartPtr[TRecentAction]
  TRecentAction* = object of TAction
    # omitted field for base class:
    # parent_instance_gtkrecentaction: ptr TAction
    priv_gtkrecentaction: ptr TRecentActionPrivate

  # x
  # 
  RecentChooserDialog* = ref GSmartPtr[TRecentChooserDialog]
  TRecentChooserDialog* = object of TDialog
    # omitted field for base class:
    # parent_instance_gtkrecentchooserdialog: ptr TDialog
    priv_gtkrecentchooserdialog: ptr TRecentChooserDialogPrivate

  # x
  # 
  RecentChooserMenu* = ref GSmartPtr[TRecentChooserMenu]
  TRecentChooserMenu* = object of TMenu
    # omitted field for base class:
    # parent_instance_gtkrecentchoosermenu: ptr TMenu
    priv_gtkrecentchoosermenu: ptr TRecentChooserMenuPrivate

  # x
  # 
  RecentChooserWidget* = ref GSmartPtr[TRecentChooserWidget]
  TRecentChooserWidget* = object of TBox
    # omitted field for base class:
    # parent_instance_gtkrecentchooserwidget: ptr TBox
    priv_gtkrecentchooserwidget: ptr TRecentChooserWidgetPrivate

  # x
  # 
  RecentFilter* = ref GSmartPtr[TRecentFilter]
  TRecentFilter* = object of GObject2.TInitiallyUnowned

  # x
  # 
  RecentManager* = ref GSmartPtr[TRecentManager]
  TRecentManager* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkrecentmanager: ptr GObject2.TObject
    priv_gtkrecentmanager: ptr TRecentManagerPrivate

  # x
  # 
  Revealer* = ref GSmartPtr[TRevealer]
  TRevealer* = object of TBin
    # omitted field for base class:
    # parent_instance_gtkrevealer: ptr TBin

  # x
  # 
  ScaleAccessible* = ref GSmartPtr[TScaleAccessible]
  TScaleAccessible* = object of TRangeAccessible
    # omitted field for base class:
    # parent_gtkscaleaccessible: ptr TRangeAccessible
    priv_gtkscaleaccessible: ptr TScaleAccessiblePrivate

  # x
  # 
  ScaleButton* = ref GSmartPtr[TScaleButton]
  TScaleButton* = object of TButton
    # omitted field for base class:
    # parent_gtkscalebutton: ptr TButton
    priv_gtkscalebutton: ptr TScaleButtonPrivate

  # x
  # 
  ScaleButtonAccessible* = ref GSmartPtr[TScaleButtonAccessible]
  TScaleButtonAccessible* = object of TButtonAccessible
    # omitted field for base class:
    # parent_gtkscalebuttonaccessible: ptr TButtonAccessible
    priv_gtkscalebuttonaccessible: ptr TScaleButtonAccessiblePrivate

  # x
  # 
  ScrolledWindowAccessible* = ref GSmartPtr[TScrolledWindowAccessible]
  TScrolledWindowAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkscrolledwindowaccessible: ptr TContainerAccessible
    priv_gtkscrolledwindowaccessible: ptr TScrolledWindowAccessiblePrivate

  # x
  # 
  SearchBar* = ref GSmartPtr[TSearchBar]
  TSearchBar* = object of TBin
    # omitted field for base class:
    # parent_gtksearchbar: ptr TBin

  # x
  # 
  SearchEntry* = ref GSmartPtr[TSearchEntry]
  TSearchEntry* = object of TEntry
    # omitted field for base class:
    # parent_gtksearchentry: ptr TEntry

  # x
  # 
  SeparatorMenuItem* = ref GSmartPtr[TSeparatorMenuItem]
  TSeparatorMenuItem* = object of TMenuItem
    # omitted field for base class:
    # menu_item_gtkseparatormenuitem: ptr TMenuItem

  # x
  # 
  SeparatorToolItem* = ref GSmartPtr[TSeparatorToolItem]
  TSeparatorToolItem* = object of TToolItem
    # omitted field for base class:
    # parent_gtkseparatortoolitem: ptr TToolItem
    priv_gtkseparatortoolitem: ptr TSeparatorToolItemPrivate

  # x
  # 
  Settings* = ref GSmartPtr[TSettings]
  TSettings* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtksettings: ptr GObject2.TObject
    priv_gtksettings: ptr TSettingsPrivate

  # x
  # 
  SizeGroup* = ref GSmartPtr[TSizeGroup]
  TSizeGroup* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtksizegroup: ptr GObject2.TObject
    priv_gtksizegroup: ptr TSizeGroupPrivate

  # x
  # 
  SpinButton* = ref GSmartPtr[TSpinButton]
  TSpinButton* = object of TEntry
    # omitted field for base class:
    # entry_gtkspinbutton: ptr TEntry
    priv_gtkspinbutton: ptr TSpinButtonPrivate

  # x
  # 
  SpinButtonAccessible* = ref GSmartPtr[TSpinButtonAccessible]
  TSpinButtonAccessible* = object of TEntryAccessible
    # omitted field for base class:
    # parent_gtkspinbuttonaccessible: ptr TEntryAccessible
    priv_gtkspinbuttonaccessible: ptr TSpinButtonAccessiblePrivate

  # x
  # 
  Spinner* = ref GSmartPtr[TSpinner]
  TSpinner* = object of TWidget
    # omitted field for base class:
    # parent_gtkspinner: ptr TWidget
    priv_gtkspinner: ptr TSpinnerPrivate

  # x
  # 
  SpinnerAccessible* = ref GSmartPtr[TSpinnerAccessible]
  TSpinnerAccessible* = object of TWidgetAccessible
    # omitted field for base class:
    # parent_gtkspinneraccessible: ptr TWidgetAccessible
    priv_gtkspinneraccessible: ptr TSpinnerAccessiblePrivate

  # x
  # 
  Stack* = ref GSmartPtr[TStack]
  TStack* = object of TContainer
    # omitted field for base class:
    # parent_instance_gtkstack: ptr TContainer

  # x
  # 
  StackSidebar* = ref GSmartPtr[TStackSidebar]
  TStackSidebar* = object of TBin
    # omitted field for base class:
    # parent_gtkstacksidebar: ptr TBin

  # x
  # 
  StackSwitcher* = ref GSmartPtr[TStackSwitcher]
  TStackSwitcher* = object of TBox
    # omitted field for base class:
    # widget_gtkstackswitcher: ptr TBox

  # x
  # 
  StatusIcon* = ref GSmartPtr[TStatusIcon]
  TStatusIcon* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkstatusicon: ptr GObject2.TObject
    priv_gtkstatusicon: ptr TStatusIconPrivate

  # x
  # 
  Statusbar* = ref GSmartPtr[TStatusbar]
  TStatusbar* = object of TBox
    # omitted field for base class:
    # parent_widget_gtkstatusbar: ptr TBox
    priv_gtkstatusbar: ptr TStatusbarPrivate

  # x
  # 
  StatusbarAccessible* = ref GSmartPtr[TStatusbarAccessible]
  TStatusbarAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkstatusbaraccessible: ptr TContainerAccessible
    priv_gtkstatusbaraccessible: ptr TStatusbarAccessiblePrivate

  # x
  # 
  Style* = ref GSmartPtr[TStyle]
  TStyle* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkstyle: ptr GObject2.TObject
    fg_gtkstyle: array[5, Gdk3.TColor]
    bg_gtkstyle: array[5, Gdk3.TColor]
    light_gtkstyle: array[5, Gdk3.TColor]
    dark_gtkstyle: array[5, Gdk3.TColor]
    mid_gtkstyle: array[5, Gdk3.TColor]
    text_gtkstyle: array[5, Gdk3.TColor]
    base_gtkstyle: array[5, Gdk3.TColor]
    text_aa_gtkstyle: array[5, Gdk3.TColor]
    black_gtkstyle: Gdk3.TColor
    white_gtkstyle: Gdk3.TColor
    font_desc_gtkstyle: ptr Pango1.TFontDescription
    xthickness_gtkstyle: int32
    ythickness_gtkstyle: int32
    background_gtkstyle: array[5, ptr cairo1.TPattern]
    attach_count_gtkstyle: int32
    visual_gtkstyle: ptr Gdk3.TVisual
    private_font_desc_gtkstyle: ptr Pango1.TFontDescription
    rc_style_gtkstyle: ptr TRcStyle
    styles_gtkstyle: ptr GSLIST_TODO
    property_cache_gtkstyle: ptr array[-1, pointer]
    icon_factories_gtkstyle: ptr GSLIST_TODO

  # x
  # 
  StyleContext* = ref GSmartPtr[TStyleContext]
  TStyleContext* = object of GObject2.TObject
    # omitted field for base class:
    # parent_object_gtkstylecontext: ptr GObject2.TObject
    priv_gtkstylecontext: ptr TStyleContextPrivate

  # x
  # 
  StyleProperties* = ref GSmartPtr[TStyleProperties]
  TStyleProperties* = object of GObject2.TObject
    # omitted field for base class:
    # parent_object_gtkstyleproperties: ptr GObject2.TObject
    priv_gtkstyleproperties: ptr TStylePropertiesPrivate

  # x
  # 
  Switch* = ref GSmartPtr[TSwitch]
  TSwitch* = object of TWidget
    # omitted field for base class:
    # parent_instance_gtkswitch: ptr TWidget
    priv_gtkswitch: ptr TSwitchPrivate

  # x
  # 
  SwitchAccessible* = ref GSmartPtr[TSwitchAccessible]
  TSwitchAccessible* = object of TWidgetAccessible
    # omitted field for base class:
    # parent_gtkswitchaccessible: ptr TWidgetAccessible
    priv_gtkswitchaccessible: ptr TSwitchAccessiblePrivate

  # x
  # 
  Table* = ref GSmartPtr[TTable]
  TTable* = object of TContainer
    # omitted field for base class:
    # container_gtktable: ptr TContainer
    priv_gtktable: ptr TTablePrivate

  # x
  # 
  TearoffMenuItem* = ref GSmartPtr[TTearoffMenuItem]
  TTearoffMenuItem* = object of TMenuItem
    # omitted field for base class:
    # menu_item_gtktearoffmenuitem: ptr TMenuItem
    priv_gtktearoffmenuitem: ptr TTearoffMenuItemPrivate

  # x
  # 
  TextBuffer* = ref GSmartPtr[TTextBuffer]
  TTextBuffer* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtktextbuffer: ptr GObject2.TObject
    priv_gtktextbuffer: ptr TTextBufferPrivate

  # x
  # 
  TextCellAccessible* = ref GSmartPtr[TTextCellAccessible]
  TTextCellAccessible* = object of TRendererCellAccessible
    # omitted field for base class:
    # parent_gtktextcellaccessible: ptr TRendererCellAccessible
    priv_gtktextcellaccessible: ptr TTextCellAccessiblePrivate

  # x
  # 
  TextChildAnchor* = ref GSmartPtr[TTextChildAnchor]
  TTextChildAnchor* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtktextchildanchor: ptr GObject2.TObject
    segment_gtktextchildanchor: pointer

  # x
  # 
  TextMark* = ref GSmartPtr[TTextMark]
  TTextMark* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtktextmark: ptr GObject2.TObject
    segment_gtktextmark: pointer

  # x
  # 
  TextTag* = ref GSmartPtr[TTextTag]
  TTextTag* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtktexttag: ptr GObject2.TObject
    priv_gtktexttag: ptr TTextTagPrivate

  # x
  # 
  TextTagTable* = ref GSmartPtr[TTextTagTable]
  TTextTagTable* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtktexttagtable: ptr GObject2.TObject
    priv_gtktexttagtable: ptr TTextTagTablePrivate

  # x
  # 
  TextView* = ref GSmartPtr[TTextView]
  TTextView* = object of TContainer
    # omitted field for base class:
    # parent_instance_gtktextview: ptr TContainer
    priv_gtktextview: ptr TTextViewPrivate

  # x
  # 
  TextViewAccessible* = ref GSmartPtr[TTextViewAccessible]
  TTextViewAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtktextviewaccessible: ptr TContainerAccessible
    priv_gtktextviewaccessible: ptr TTextViewAccessiblePrivate

  # x
  # 
  ThemingEngine* = ref GSmartPtr[TThemingEngine]
  TThemingEngine* = object of GObject2.TObject
    # omitted field for base class:
    # parent_object_gtkthemingengine: ptr GObject2.TObject
    priv_gtkthemingengine: ptr TThemingEnginePrivate

  # x
  # 
  ToolItemGroup* = ref GSmartPtr[TToolItemGroup]
  TToolItemGroup* = object of TContainer
    # omitted field for base class:
    # parent_instance_gtktoolitemgroup: ptr TContainer
    priv_gtktoolitemgroup: ptr TToolItemGroupPrivate

  # x
  # 
  ToolPalette* = ref GSmartPtr[TToolPalette]
  TToolPalette* = object of TContainer
    # omitted field for base class:
    # parent_instance_gtktoolpalette: ptr TContainer
    priv_gtktoolpalette: ptr TToolPalettePrivate

  # x
  # 
  Toolbar* = ref GSmartPtr[TToolbar]
  TToolbar* = object of TContainer
    # omitted field for base class:
    # container_gtktoolbar: ptr TContainer
    priv_gtktoolbar: ptr TToolbarPrivate

  # x
  # 
  Tooltip* = ref GSmartPtr[TTooltip]
  TTooltip* = object of GObject2.TObject

  # x
  # 
  ToplevelAccessible* = ref GSmartPtr[TToplevelAccessible]
  TToplevelAccessible* = object of Atk1.TObject
    # omitted field for base class:
    # parent_gtktoplevelaccessible: ptr Atk1.TObject
    priv_gtktoplevelaccessible: ptr TToplevelAccessiblePrivate

  # x
  # 
  TreeModelFilter* = ref GSmartPtr[TTreeModelFilter]
  TTreeModelFilter* = object of GObject2.TObject
    # omitted field for base class:
    # parent_gtktreemodelfilter: ptr GObject2.TObject
    priv_gtktreemodelfilter: ptr TTreeModelFilterPrivate

  # x
  # 
  TreeModelSort* = ref GSmartPtr[TTreeModelSort]
  TTreeModelSort* = object of GObject2.TObject
    # omitted field for base class:
    # parent_gtktreemodelsort: ptr GObject2.TObject
    priv_gtktreemodelsort: ptr TTreeModelSortPrivate

  # x
  # 
  TreeSelection* = ref GSmartPtr[TTreeSelection]
  TTreeSelection* = object of GObject2.TObject
    # omitted field for base class:
    # parent_gtktreeselection: ptr GObject2.TObject
    priv_gtktreeselection: ptr TTreeSelectionPrivate

  # x
  # 
  TreeStore* = ref GSmartPtr[TTreeStore]
  TTreeStore* = object of GObject2.TObject
    # omitted field for base class:
    # parent_gtktreestore: ptr GObject2.TObject
    priv_gtktreestore: ptr TTreeStorePrivate

  # x
  # 
  TreeView* = ref GSmartPtr[TTreeView]
  TTreeView* = object of TContainer
    # omitted field for base class:
    # parent_gtktreeview: ptr TContainer
    priv_gtktreeview: ptr TTreeViewPrivate

  # x
  # 
  TreeViewAccessible* = ref GSmartPtr[TTreeViewAccessible]
  TTreeViewAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtktreeviewaccessible: ptr TContainerAccessible
    priv_gtktreeviewaccessible: ptr TTreeViewAccessiblePrivate

  # x
  # 
  TreeViewColumn* = ref GSmartPtr[TTreeViewColumn]
  TTreeViewColumn* = object of GObject2.TInitiallyUnowned
    # omitted field for base class:
    # parent_instance_gtktreeviewcolumn: ptr GObject2.TInitiallyUnowned
    priv_gtktreeviewcolumn: ptr TTreeViewColumnPrivate

  # x
  # 
  UIManager* = ref GSmartPtr[TUIManager]
  TUIManager* = object of GObject2.TObject
    # omitted field for base class:
    # parent_gtkuimanager: ptr GObject2.TObject
    private_data_gtkuimanager: ptr TUIManagerPrivate

  # x
  # 
  VBox* = ref GSmartPtr[TVBox]
  TVBox* = object of TBox
    # omitted field for base class:
    # box_gtkvbox: ptr TBox

  # x
  # 
  VButtonBox* = ref GSmartPtr[TVButtonBox]
  TVButtonBox* = object of TButtonBox
    # omitted field for base class:
    # button_box_gtkvbuttonbox: ptr TButtonBox

  # x
  # 
  VPaned* = ref GSmartPtr[TVPaned]
  TVPaned* = object of TPaned
    # omitted field for base class:
    # paned_gtkvpaned: ptr TPaned

  # x
  # 
  VScale* = ref GSmartPtr[TVScale]
  TVScale* = object of TScale
    # omitted field for base class:
    # scale_gtkvscale: ptr TScale

  # x
  # 
  VScrollbar* = ref GSmartPtr[TVScrollbar]
  TVScrollbar* = object of TScrollbar
    # omitted field for base class:
    # scrollbar_gtkvscrollbar: ptr TScrollbar

  # x
  # 
  VSeparator* = ref GSmartPtr[TVSeparator]
  TVSeparator* = object of TSeparator
    # omitted field for base class:
    # separator_gtkvseparator: ptr TSeparator

  # x
  # 
  Viewport* = ref GSmartPtr[TViewport]
  TViewport* = object of TBin
    # omitted field for base class:
    # bin_gtkviewport: ptr TBin
    priv_gtkviewport: ptr TViewportPrivate

  # x
  # 
  VolumeButton* = ref GSmartPtr[TVolumeButton]
  TVolumeButton* = object of TScaleButton
    # omitted field for base class:
    # parent_gtkvolumebutton: ptr TScaleButton

  # x
  # 
  WindowAccessible* = ref GSmartPtr[TWindowAccessible]
  TWindowAccessible* = object of TContainerAccessible
    # omitted field for base class:
    # parent_gtkwindowaccessible: ptr TContainerAccessible
    priv_gtkwindowaccessible: ptr TWindowAccessiblePrivate

  # x
  # 
  WindowGroup* = ref GSmartPtr[TWindowGroup]
  TWindowGroup* = object of GObject2.TObject
    # omitted field for base class:
    # parent_instance_gtkwindowgroup: ptr GObject2.TObject
    priv_gtkwindowgroup: ptr TWindowGroupPrivate

  # structs
  #------------------
# wrapped: TAboutDialogClass
# unwrapped: TAboutDialogClass
  TAboutDialogClass* {.pure,inheritable.} = object
    parent_class*: TDialogClass
    activate_link*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TAboutDialogPrivate
# unwrapped: TAboutDialogPrivate
  TAboutDialogPrivate* {.pure,inheritable.} = object

# wrapped: TAccelGroupClass
# unwrapped: TAccelGroupClass
  TAccelGroupClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    accel_changed*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TAccelGroupEntry
# unwrapped: TAccelGroupEntry
  TAccelGroupEntry* {.pure,inheritable.} = object
    key*: TAccelKey
    closure*: ptr GObject2.TClosure
    accel_path_quark*: uint32

# wrapped: TAccelGroupPrivate
# unwrapped: TAccelGroupPrivate
  TAccelGroupPrivate* {.pure,inheritable.} = object

# wrapped: TAccelKey
# unwrapped: TAccelKey
  TAccelKey* {.pure,inheritable.} = object
    accel_key*: uint32
    accel_mods*: Gdk3.SModifierType
    accel_flags*: uint32

# wrapped: TAccelLabelClass
# unwrapped: TAccelLabelClass
  TAccelLabelClass* {.pure,inheritable.} = object
    parent_class*: TLabelClass
    signal_quote1*: ucstring
    signal_quote2*: ucstring
    mod_name_shift*: ucstring
    mod_name_control*: ucstring
    mod_name_alt*: ucstring
    mod_separator*: ucstring
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TAccelLabelPrivate
# unwrapped: TAccelLabelPrivate
  TAccelLabelPrivate* {.pure,inheritable.} = object

# wrapped: TAccelMapClass
# unwrapped: TAccelMapClass
  TAccelMapClass* {.pure,inheritable.} = object

# wrapped: TAccessibleClass
# unwrapped: TAccessibleClass
  TAccessibleClass* {.pure,inheritable.} = object
    parent_class*: Atk1.TObjectClass
    connect_widget_destroyed*: pointer
    widget_set*: pointer
    widget_unset*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TAccessiblePrivate
# unwrapped: TAccessiblePrivate
  TAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TActionBarClass
# unwrapped: TActionBarClass
  TActionBarClass* {.pure,inheritable.} = object
    parent_class*: TBinClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TActionBarPrivate
# unwrapped: TActionBarPrivate
  TActionBarPrivate* {.pure,inheritable.} = object

# wrapped: TActionClass
# unwrapped: TActionClass
  TActionClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    activate*: pointer
    menu_item_type*: GType
    toolbar_item_type*: GType
    create_menu_item*: pointer
    create_tool_item*: pointer
    connect_proxy*: pointer
    disconnect_proxy*: pointer
    create_menu*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TActionEntry
# unwrapped: TActionEntry
  TActionEntry* {.pure,inheritable.} = object
    name*: ucstring
    stock_id*: ucstring
    label*: ucstring
    accelerator*: ucstring
    tooltip*: ucstring
    callback*: pointer

# wrapped: TActionGroupClass
# unwrapped: TActionGroupClass
  TActionGroupClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    get_action*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TActionGroupPrivate
# unwrapped: TActionGroupPrivate
  TActionGroupPrivate* {.pure,inheritable.} = object

# wrapped: TActionPrivate
# unwrapped: TActionPrivate
  TActionPrivate* {.pure,inheritable.} = object

# wrapped: TActionableInterface
# unwrapped: TActionableInterface
  TActionableInterface* {.pure,inheritable.} = object
    g_iface*: GObject2.TTypeInterface
    get_action_name*: pointer
    set_action_name*: pointer
    get_action_target_value*: pointer
    set_action_target_value*: pointer

# wrapped: TActivatableIface
# unwrapped: TActivatableIface
  TActivatableIface* {.pure,inheritable.} = object
    g_iface*: GObject2.TTypeInterface
    update*: pointer
    sync_action_properties*: pointer

# wrapped: TAdjustmentClass
# unwrapped: TAdjustmentClass
  TAdjustmentClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TInitiallyUnownedClass
    changed*: pointer
    value_changed*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TAdjustmentPrivate
# unwrapped: TAdjustmentPrivate
  TAdjustmentPrivate* {.pure,inheritable.} = object

# wrapped: TAlignmentClass
# unwrapped: TAlignmentClass
  TAlignmentClass* {.pure,inheritable.} = object
    parent_class*: TBinClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TAlignmentPrivate
# unwrapped: TAlignmentPrivate
  TAlignmentPrivate* {.pure,inheritable.} = object

# wrapped: TAppChooserButtonClass
# unwrapped: TAppChooserButtonClass
  TAppChooserButtonClass* {.pure,inheritable.} = object
    parent_class*: TComboBoxClass
    custom_item_activated*: pointer
    padding*: array[16, pointer]

# wrapped: TAppChooserButtonPrivate
# unwrapped: TAppChooserButtonPrivate
  TAppChooserButtonPrivate* {.pure,inheritable.} = object

# wrapped: TAppChooserDialogClass
# unwrapped: TAppChooserDialogClass
  TAppChooserDialogClass* {.pure,inheritable.} = object
    parent_class*: TDialogClass
    padding*: array[16, pointer]

# wrapped: TAppChooserDialogPrivate
# unwrapped: TAppChooserDialogPrivate
  TAppChooserDialogPrivate* {.pure,inheritable.} = object

# wrapped: TAppChooserWidgetClass
# unwrapped: TAppChooserWidgetClass
  TAppChooserWidgetClass* {.pure,inheritable.} = object
    parent_class*: TBoxClass
    application_selected*: pointer
    application_activated*: pointer
    populate_popup*: pointer
    padding*: array[16, pointer]

# wrapped: TAppChooserWidgetPrivate
# unwrapped: TAppChooserWidgetPrivate
  TAppChooserWidgetPrivate* {.pure,inheritable.} = object

# wrapped: TApplicationClass
# unwrapped: TApplicationClass
  TApplicationClass* {.pure,inheritable.} = object
    parent_class*: Gio2.TApplicationClass
    window_added*: pointer
    window_removed*: pointer
    padding*: array[12, pointer]

# wrapped: TApplicationPrivate
# unwrapped: TApplicationPrivate
  TApplicationPrivate* {.pure,inheritable.} = object

# wrapped: TApplicationWindowClass
# unwrapped: TApplicationWindowClass
  TApplicationWindowClass* {.pure,inheritable.} = object
    parent_class*: TWindowClass
    padding*: array[14, pointer]

# wrapped: TApplicationWindowPrivate
# unwrapped: TApplicationWindowPrivate
  TApplicationWindowPrivate* {.pure,inheritable.} = object

# wrapped: TArrowAccessibleClass
# unwrapped: TArrowAccessibleClass
  TArrowAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TWidgetAccessibleClass

# wrapped: TArrowAccessiblePrivate
# unwrapped: TArrowAccessiblePrivate
  TArrowAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TArrowClass
# unwrapped: TArrowClass
  TArrowClass* {.pure,inheritable.} = object
    parent_class*: TMiscClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TArrowPrivate
# unwrapped: TArrowPrivate
  TArrowPrivate* {.pure,inheritable.} = object

# wrapped: TAspectFrameClass
# unwrapped: TAspectFrameClass
  TAspectFrameClass* {.pure,inheritable.} = object
    parent_class*: TFrameClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TAspectFramePrivate
# unwrapped: TAspectFramePrivate
  TAspectFramePrivate* {.pure,inheritable.} = object

# wrapped: TAssistantClass
# unwrapped: TAssistantClass
  TAssistantClass* {.pure,inheritable.} = object
    parent_class*: TWindowClass
    prepare*: pointer
    apply*: pointer
    close*: pointer
    cancel*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer
    gtk_reserved5*: pointer

# wrapped: TAssistantPrivate
# unwrapped: TAssistantPrivate
  TAssistantPrivate* {.pure,inheritable.} = object

# wrapped: TBinClass
# unwrapped: TBinClass
  TBinClass* {.pure,inheritable.} = object
    parent_class*: TContainerClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TBinPrivate
# unwrapped: TBinPrivate
  TBinPrivate* {.pure,inheritable.} = object

# wrapped: TBindingArg
# unwrapped: TBindingArg
  TBindingArg* {.pure,inheritable.} = object
    arg_type*: GType

# wrapped: TBindingEntry
# unwrapped: TBindingEntry
  TBindingEntry* {.pure,inheritable.} = object
    keyval*: uint32
    modifiers*: Gdk3.SModifierType
    binding_set*: ptr TBindingSet
    destroyed*: uint32
    in_emission*: uint32
    marks_unbound*: uint32
    set_next*: ptr TBindingEntry
    hash_next*: ptr TBindingEntry
    signals*: ptr TBindingSignal

# wrapped: TBindingSet
# unwrapped: TBindingSet
  TBindingSet* {.pure,inheritable.} = object
    set_name*: ucstring
    priority*: int32
    widget_path_pspecs*: ptr GSLIST_TODO
    widget_class_pspecs*: ptr GSLIST_TODO
    class_branch_pspecs*: ptr GSLIST_TODO
    entries*: ptr TBindingEntry
    current*: ptr TBindingEntry
    parsed*: uint32

# wrapped: TBindingSignal
# unwrapped: TBindingSignal
  TBindingSignal* {.pure,inheritable.} = object
    next*: ptr TBindingSignal
    signal_name*: ucstring
    n_args*: uint32
    args*: ptr array[-1, TBindingArg]

# wrapped: TBooleanCellAccessibleClass
# unwrapped: TBooleanCellAccessibleClass
  TBooleanCellAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TRendererCellAccessibleClass

# wrapped: TBooleanCellAccessiblePrivate
# unwrapped: TBooleanCellAccessiblePrivate
  TBooleanCellAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TBorder
# unwrapped: TBorder
  TBorder* {.pure,inheritable.} = object
    left*: int16
    right*: int16
    top*: int16
    bottom*: int16

# wrapped: TBoxClass
# unwrapped: TBoxClass
  TBoxClass* {.pure,inheritable.} = object
    parent_class*: TContainerClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TBoxPrivate
# unwrapped: TBoxPrivate
  TBoxPrivate* {.pure,inheritable.} = object

# wrapped: TBuildableIface
# unwrapped: TBuildableIface
  TBuildableIface* {.pure,inheritable.} = object
    g_iface*: GObject2.TTypeInterface
    set_name*: pointer
    get_name*: pointer
    add_child*: pointer
    set_buildable_property*: pointer
    construct_child*: pointer
    custom_tag_start*: pointer
    custom_tag_end*: pointer
    custom_finished*: pointer
    parser_finished*: pointer
    get_internal_child*: pointer

# wrapped: TBuilderClass
# unwrapped: TBuilderClass
  TBuilderClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    get_type_from_name*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer
    gtk_reserved5*: pointer
    gtk_reserved6*: pointer
    gtk_reserved7*: pointer
    gtk_reserved8*: pointer

# wrapped: TBuilderPrivate
# unwrapped: TBuilderPrivate
  TBuilderPrivate* {.pure,inheritable.} = object

# wrapped: TButtonAccessibleClass
# unwrapped: TButtonAccessibleClass
  TButtonAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TContainerAccessibleClass

# wrapped: TButtonAccessiblePrivate
# unwrapped: TButtonAccessiblePrivate
  TButtonAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TButtonBoxClass
# unwrapped: TButtonBoxClass
  TButtonBoxClass* {.pure,inheritable.} = object
    parent_class*: TBoxClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TButtonBoxPrivate
# unwrapped: TButtonBoxPrivate
  TButtonBoxPrivate* {.pure,inheritable.} = object

# wrapped: TButtonClass
# unwrapped: TButtonClass
  TButtonClass* {.pure,inheritable.} = object
    parent_class*: TBinClass
    pressed*: pointer
    released*: pointer
    clicked*: pointer
    enter*: pointer
    leave*: pointer
    activate*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TButtonPrivate
# unwrapped: TButtonPrivate
  TButtonPrivate* {.pure,inheritable.} = object

# wrapped: TCalendarClass
# unwrapped: TCalendarClass
  TCalendarClass* {.pure,inheritable.} = object
    parent_class*: TWidgetClass
    month_changed*: pointer
    day_selected*: pointer
    day_selected_double_click*: pointer
    prev_month*: pointer
    next_month*: pointer
    prev_year*: pointer
    next_year*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TCalendarPrivate
# unwrapped: TCalendarPrivate
  TCalendarPrivate* {.pure,inheritable.} = object

# wrapped: TCellAccessibleClass
# unwrapped: TCellAccessibleClass
  TCellAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TAccessibleClass
    update_cache*: pointer

# wrapped: TCellAccessibleParentIface
# unwrapped: TCellAccessibleParentIface
  TCellAccessibleParentIface* {.pure,inheritable.} = object
    parent*: GObject2.TTypeInterface
    get_cell_extents*: pointer
    get_cell_area*: pointer
    grab_focus*: pointer
    get_child_index*: pointer
    get_renderer_state*: pointer
    expand_collapse*: pointer
    activate*: pointer
    edit*: pointer
    update_relationset*: pointer

# wrapped: TCellAccessiblePrivate
# unwrapped: TCellAccessiblePrivate
  TCellAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TCellAreaBoxClass
# unwrapped: TCellAreaBoxClass
  TCellAreaBoxClass* {.pure,inheritable.} = object
    parent_class*: TCellAreaClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TCellAreaBoxPrivate
# unwrapped: TCellAreaBoxPrivate
  TCellAreaBoxPrivate* {.pure,inheritable.} = object

# wrapped: TCellAreaClass
# unwrapped: TCellAreaClass
  TCellAreaClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TInitiallyUnownedClass
    add*: pointer
    remove*: pointer
    foreach*: pointer
    foreach_alloc*: pointer
    event*: pointer
    render*: pointer
    apply_attributes*: pointer
    create_context*: pointer
    copy_context*: pointer
    get_request_mode*: pointer
    get_preferred_width*: pointer
    get_preferred_height_for_width*: pointer
    get_preferred_height*: pointer
    get_preferred_width_for_height*: pointer
    set_cell_property*: pointer
    get_cell_property*: pointer
    focus*: pointer
    is_activatable*: pointer
    activate*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer
    gtk_reserved5*: pointer
    gtk_reserved6*: pointer
    gtk_reserved7*: pointer
    gtk_reserved8*: pointer

# wrapped: TCellAreaContextClass
# unwrapped: TCellAreaContextClass
  TCellAreaContextClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    allocate*: pointer
    reset*: pointer
    get_preferred_height_for_width*: pointer
    get_preferred_width_for_height*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer
    gtk_reserved5*: pointer
    gtk_reserved6*: pointer

# wrapped: TCellAreaContextPrivate
# unwrapped: TCellAreaContextPrivate
  TCellAreaContextPrivate* {.pure,inheritable.} = object

# wrapped: TCellAreaPrivate
# unwrapped: TCellAreaPrivate
  TCellAreaPrivate* {.pure,inheritable.} = object

# wrapped: TCellEditableIface
# unwrapped: TCellEditableIface
  TCellEditableIface* {.pure,inheritable.} = object
    g_iface*: GObject2.TTypeInterface
    editing_done*: pointer
    remove_widget*: pointer
    start_editing*: pointer

# wrapped: TCellLayoutIface
# unwrapped: TCellLayoutIface
  TCellLayoutIface* {.pure,inheritable.} = object
    g_iface*: GObject2.TTypeInterface
    pack_start*: pointer
    pack_end*: pointer
    clear*: pointer
    add_attribute*: pointer
    set_cell_data_func*: pointer
    clear_attributes*: pointer
    reorder*: pointer
    get_cells*: pointer
    get_area*: pointer

# wrapped: TCellRendererAccelClass
# unwrapped: TCellRendererAccelClass
  TCellRendererAccelClass* {.pure,inheritable.} = object
    parent_class*: TCellRendererTextClass
    accel_edited*: pointer
    accel_cleared*: pointer
    gtk_reserved0*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TCellRendererAccelPrivate
# unwrapped: TCellRendererAccelPrivate
  TCellRendererAccelPrivate* {.pure,inheritable.} = object

# wrapped: TCellRendererClass
# unwrapped: TCellRendererClass
  TCellRendererClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TInitiallyUnownedClass
    get_request_mode*: pointer
    get_preferred_width*: pointer
    get_preferred_height_for_width*: pointer
    get_preferred_height*: pointer
    get_preferred_width_for_height*: pointer
    get_aligned_area*: pointer
    get_size*: pointer
    render*: pointer
    activate*: pointer
    start_editing*: pointer
    editing_canceled*: pointer
    editing_started*: pointer
    priv*: ptr TCellRendererClassPrivate
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TCellRendererClassPrivate
# unwrapped: TCellRendererClassPrivate
  TCellRendererClassPrivate* {.pure,inheritable.} = object

# wrapped: TCellRendererComboClass
# unwrapped: TCellRendererComboClass
  TCellRendererComboClass* {.pure,inheritable.} = object
    parent*: TCellRendererTextClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TCellRendererComboPrivate
# unwrapped: TCellRendererComboPrivate
  TCellRendererComboPrivate* {.pure,inheritable.} = object

# wrapped: TCellRendererPixbufClass
# unwrapped: TCellRendererPixbufClass
  TCellRendererPixbufClass* {.pure,inheritable.} = object
    parent_class*: TCellRendererClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TCellRendererPixbufPrivate
# unwrapped: TCellRendererPixbufPrivate
  TCellRendererPixbufPrivate* {.pure,inheritable.} = object

# wrapped: TCellRendererPrivate
# unwrapped: TCellRendererPrivate
  TCellRendererPrivate* {.pure,inheritable.} = object

# wrapped: TCellRendererProgressClass
# unwrapped: TCellRendererProgressClass
  TCellRendererProgressClass* {.pure,inheritable.} = object
    parent_class*: TCellRendererClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TCellRendererProgressPrivate
# unwrapped: TCellRendererProgressPrivate
  TCellRendererProgressPrivate* {.pure,inheritable.} = object

# wrapped: TCellRendererSpinClass
# unwrapped: TCellRendererSpinClass
  TCellRendererSpinClass* {.pure,inheritable.} = object
    parent*: TCellRendererTextClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TCellRendererSpinPrivate
# unwrapped: TCellRendererSpinPrivate
  TCellRendererSpinPrivate* {.pure,inheritable.} = object

# wrapped: TCellRendererSpinnerClass
# unwrapped: TCellRendererSpinnerClass
  TCellRendererSpinnerClass* {.pure,inheritable.} = object
    parent_class*: TCellRendererClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TCellRendererSpinnerPrivate
# unwrapped: TCellRendererSpinnerPrivate
  TCellRendererSpinnerPrivate* {.pure,inheritable.} = object

# wrapped: TCellRendererTextClass
# unwrapped: TCellRendererTextClass
  TCellRendererTextClass* {.pure,inheritable.} = object
    parent_class*: TCellRendererClass
    edited*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TCellRendererTextPrivate
# unwrapped: TCellRendererTextPrivate
  TCellRendererTextPrivate* {.pure,inheritable.} = object

# wrapped: TCellRendererToggleClass
# unwrapped: TCellRendererToggleClass
  TCellRendererToggleClass* {.pure,inheritable.} = object
    parent_class*: TCellRendererClass
    toggled*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TCellRendererTogglePrivate
# unwrapped: TCellRendererTogglePrivate
  TCellRendererTogglePrivate* {.pure,inheritable.} = object

# wrapped: TCellViewClass
# unwrapped: TCellViewClass
  TCellViewClass* {.pure,inheritable.} = object
    parent_class*: TWidgetClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TCellViewPrivate
# unwrapped: TCellViewPrivate
  TCellViewPrivate* {.pure,inheritable.} = object

# wrapped: TCheckButtonClass
# unwrapped: TCheckButtonClass
  TCheckButtonClass* {.pure,inheritable.} = object
    parent_class*: TToggleButtonClass
    draw_indicator*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TCheckMenuItemAccessibleClass
# unwrapped: TCheckMenuItemAccessibleClass
  TCheckMenuItemAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TMenuItemAccessibleClass

# wrapped: TCheckMenuItemAccessiblePrivate
# unwrapped: TCheckMenuItemAccessiblePrivate
  TCheckMenuItemAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TCheckMenuItemClass
# unwrapped: TCheckMenuItemClass
  TCheckMenuItemClass* {.pure,inheritable.} = object
    parent_class*: TMenuItemClass
    toggled*: pointer
    draw_indicator*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TCheckMenuItemPrivate
# unwrapped: TCheckMenuItemPrivate
  TCheckMenuItemPrivate* {.pure,inheritable.} = object

# wrapped: TColorButtonClass
# unwrapped: TColorButtonClass
  TColorButtonClass* {.pure,inheritable.} = object
    parent_class*: TButtonClass
    color_set*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TColorButtonPrivate
# unwrapped: TColorButtonPrivate
  TColorButtonPrivate* {.pure,inheritable.} = object

# wrapped: TColorChooserDialogClass
# unwrapped: TColorChooserDialogClass
  TColorChooserDialogClass* {.pure,inheritable.} = object
    parent_class*: TDialogClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TColorChooserDialogPrivate
# unwrapped: TColorChooserDialogPrivate
  TColorChooserDialogPrivate* {.pure,inheritable.} = object

# wrapped: TColorChooserInterface
# unwrapped: TColorChooserInterface
  TColorChooserInterface* {.pure,inheritable.} = object
    base_interface*: GObject2.TTypeInterface
    get_rgba*: pointer
    set_rgba*: pointer
    add_palette*: pointer
    color_activated*: pointer
    padding*: array[12, pointer]

# wrapped: TColorChooserWidgetClass
# unwrapped: TColorChooserWidgetClass
  TColorChooserWidgetClass* {.pure,inheritable.} = object
    parent_class*: TBoxClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer
    gtk_reserved5*: pointer
    gtk_reserved6*: pointer
    gtk_reserved7*: pointer
    gtk_reserved8*: pointer

# wrapped: TColorChooserWidgetPrivate
# unwrapped: TColorChooserWidgetPrivate
  TColorChooserWidgetPrivate* {.pure,inheritable.} = object

# wrapped: TColorSelectionClass
# unwrapped: TColorSelectionClass
  TColorSelectionClass* {.pure,inheritable.} = object
    parent_class*: TBoxClass
    color_changed*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TColorSelectionDialogClass
# unwrapped: TColorSelectionDialogClass
  TColorSelectionDialogClass* {.pure,inheritable.} = object
    parent_class*: TDialogClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TColorSelectionDialogPrivate
# unwrapped: TColorSelectionDialogPrivate
  TColorSelectionDialogPrivate* {.pure,inheritable.} = object

# wrapped: TColorSelectionPrivate
# unwrapped: TColorSelectionPrivate
  TColorSelectionPrivate* {.pure,inheritable.} = object

# wrapped: TComboBoxAccessibleClass
# unwrapped: TComboBoxAccessibleClass
  TComboBoxAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TContainerAccessibleClass

# wrapped: TComboBoxAccessiblePrivate
# unwrapped: TComboBoxAccessiblePrivate
  TComboBoxAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TComboBoxClass
# unwrapped: TComboBoxClass
  TComboBoxClass* {.pure,inheritable.} = object
    parent_class*: TBinClass
    changed*: pointer
    format_entry_text*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer

# wrapped: TComboBoxPrivate
# unwrapped: TComboBoxPrivate
  TComboBoxPrivate* {.pure,inheritable.} = object

# wrapped: TComboBoxTextClass
# unwrapped: TComboBoxTextClass
  TComboBoxTextClass* {.pure,inheritable.} = object
    parent_class*: TComboBoxClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TComboBoxTextPrivate
# unwrapped: TComboBoxTextPrivate
  TComboBoxTextPrivate* {.pure,inheritable.} = object

# wrapped: TContainerAccessibleClass
# unwrapped: TContainerAccessibleClass
  TContainerAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TWidgetAccessibleClass
    add_gtk*: pointer
    remove_gtk*: pointer

# wrapped: TContainerAccessiblePrivate
# unwrapped: TContainerAccessiblePrivate
  TContainerAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TContainerCellAccessibleClass
# unwrapped: TContainerCellAccessibleClass
  TContainerCellAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TCellAccessibleClass

# wrapped: TContainerCellAccessiblePrivate
# unwrapped: TContainerCellAccessiblePrivate
  TContainerCellAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TContainerClass
# unwrapped: TContainerClass
  TContainerClass* {.pure,inheritable.} = object
    parent_class*: TWidgetClass
    add*: pointer
    remove*: pointer
    check_resize*: pointer
    forall*: pointer
    set_focus_child*: pointer
    child_type*: pointer
    composite_name*: pointer
    set_child_property*: pointer
    get_child_property*: pointer
    get_path_for_child*: pointer
    handle_border_width*: uint32
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer
    gtk_reserved5*: pointer
    gtk_reserved6*: pointer
    gtk_reserved7*: pointer
    gtk_reserved8*: pointer

# wrapped: TContainerPrivate
# unwrapped: TContainerPrivate
  TContainerPrivate* {.pure,inheritable.} = object

# wrapped: TCssProviderClass
# unwrapped: TCssProviderClass
  TCssProviderClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    parsing_error*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TCssProviderPrivate
# unwrapped: TCssProviderPrivate
  TCssProviderPrivate* {.pure,inheritable.} = object

# wrapped: TCssSection
# unwrapped: TCssSection
  TCssSection* {.pure,inheritable.} = object

# wrapped: TDialogClass
# unwrapped: TDialogClass
  TDialogClass* {.pure,inheritable.} = object
    parent_class*: TWindowClass
    response*: pointer
    close*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TDialogPrivate
# unwrapped: TDialogPrivate
  TDialogPrivate* {.pure,inheritable.} = object

# wrapped: TDrawingAreaClass
# unwrapped: TDrawingAreaClass
  TDrawingAreaClass* {.pure,inheritable.} = object
    parent_class*: TWidgetClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TEditableInterface
# unwrapped: TEditableInterface
  TEditableInterface* {.pure,inheritable.} = object
    base_iface*: GObject2.TTypeInterface
    insert_text*: pointer
    delete_text*: pointer
    changed*: pointer
    do_insert_text*: pointer
    do_delete_text*: pointer
    get_chars*: pointer
    set_selection_bounds*: pointer
    get_selection_bounds*: pointer
    set_position*: pointer
    get_position*: pointer

# wrapped: TEntryAccessibleClass
# unwrapped: TEntryAccessibleClass
  TEntryAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TWidgetAccessibleClass

# wrapped: TEntryAccessiblePrivate
# unwrapped: TEntryAccessiblePrivate
  TEntryAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TEntryBufferClass
# unwrapped: TEntryBufferClass
  TEntryBufferClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    inserted_text*: pointer
    deleted_text*: pointer
    get_text*: pointer
    get_length*: pointer
    insert_text*: pointer
    delete_text*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer
    gtk_reserved5*: pointer
    gtk_reserved6*: pointer
    gtk_reserved7*: pointer
    gtk_reserved8*: pointer

# wrapped: TEntryBufferPrivate
# unwrapped: TEntryBufferPrivate
  TEntryBufferPrivate* {.pure,inheritable.} = object

# wrapped: TEntryClass
# unwrapped: TEntryClass
  TEntryClass* {.pure,inheritable.} = object
    parent_class*: TWidgetClass
    populate_popup*: pointer
    activate*: pointer
    move_cursor*: pointer
    insert_at_cursor*: pointer
    delete_from_cursor*: pointer
    backspace*: pointer
    cut_clipboard*: pointer
    copy_clipboard*: pointer
    paste_clipboard*: pointer
    toggle_overwrite*: pointer
    get_text_area_size*: pointer
    get_frame_size*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer
    gtk_reserved5*: pointer
    gtk_reserved6*: pointer
    gtk_reserved7*: pointer

# wrapped: TEntryCompletionClass
# unwrapped: TEntryCompletionClass
  TEntryCompletionClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    match_selected*: pointer
    action_activated*: pointer
    insert_prefix*: pointer
    cursor_on_match*: pointer
    no_matches*: pointer
    gtk_reserved0*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer

# wrapped: TEntryCompletionPrivate
# unwrapped: TEntryCompletionPrivate
  TEntryCompletionPrivate* {.pure,inheritable.} = object

# wrapped: TEntryPrivate
# unwrapped: TEntryPrivate
  TEntryPrivate* {.pure,inheritable.} = object

# wrapped: TEventBoxClass
# unwrapped: TEventBoxClass
  TEventBoxClass* {.pure,inheritable.} = object
    parent_class*: TBinClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TEventBoxPrivate
# unwrapped: TEventBoxPrivate
  TEventBoxPrivate* {.pure,inheritable.} = object

# wrapped: TEventControllerClass
# unwrapped: TEventControllerClass
  TEventControllerClass* {.pure,inheritable.} = object

# wrapped: TExpanderAccessibleClass
# unwrapped: TExpanderAccessibleClass
  TExpanderAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TContainerAccessibleClass

# wrapped: TExpanderAccessiblePrivate
# unwrapped: TExpanderAccessiblePrivate
  TExpanderAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TExpanderClass
# unwrapped: TExpanderClass
  TExpanderClass* {.pure,inheritable.} = object
    parent_class*: TBinClass
    activate*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TExpanderPrivate
# unwrapped: TExpanderPrivate
  TExpanderPrivate* {.pure,inheritable.} = object

# wrapped: TFileChooserButtonClass
# unwrapped: TFileChooserButtonClass
  TFileChooserButtonClass* {.pure,inheritable.} = object
    parent_class*: TBoxClass
    file_set*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TFileChooserButtonPrivate
# unwrapped: TFileChooserButtonPrivate
  TFileChooserButtonPrivate* {.pure,inheritable.} = object

# wrapped: TFileChooserDialogClass
# unwrapped: TFileChooserDialogClass
  TFileChooserDialogClass* {.pure,inheritable.} = object
    parent_class*: TDialogClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TFileChooserDialogPrivate
# unwrapped: TFileChooserDialogPrivate
  TFileChooserDialogPrivate* {.pure,inheritable.} = object

# wrapped: TFileChooserWidgetClass
# unwrapped: TFileChooserWidgetClass
  TFileChooserWidgetClass* {.pure,inheritable.} = object
    parent_class*: TBoxClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TFileChooserWidgetPrivate
# unwrapped: TFileChooserWidgetPrivate
  TFileChooserWidgetPrivate* {.pure,inheritable.} = object

# wrapped: TFileFilterInfo
# unwrapped: TFileFilterInfo
  TFileFilterInfo* {.pure,inheritable.} = object
    contains*: SFileFilterFlags
    filename*: ucstring
    uri*: ucstring
    display_name*: ucstring
    mime_type*: ucstring

# wrapped: TFixedChild
# unwrapped: TFixedChild
  TFixedChild* {.pure,inheritable.} = object
    widget*: ptr TWidget
    x*: int32
    y*: int32

# wrapped: TFixedClass
# unwrapped: TFixedClass
  TFixedClass* {.pure,inheritable.} = object
    parent_class*: TContainerClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TFixedPrivate
# unwrapped: TFixedPrivate
  TFixedPrivate* {.pure,inheritable.} = object

# wrapped: TFlowBoxAccessibleClass
# unwrapped: TFlowBoxAccessibleClass
  TFlowBoxAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TContainerAccessibleClass

# wrapped: TFlowBoxAccessiblePrivate
# unwrapped: TFlowBoxAccessiblePrivate
  TFlowBoxAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TFlowBoxChildAccessibleClass
# unwrapped: TFlowBoxChildAccessibleClass
  TFlowBoxChildAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TContainerAccessibleClass

# wrapped: TFlowBoxChildClass
# unwrapped: TFlowBoxChildClass
  TFlowBoxChildClass* {.pure,inheritable.} = object
    parent_class*: TBinClass
    activate*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer

# wrapped: TFlowBoxClass
# unwrapped: TFlowBoxClass
  TFlowBoxClass* {.pure,inheritable.} = object
    parent_class*: TContainerClass
    child_activated*: pointer
    selected_children_changed*: pointer
    activate_cursor_child*: pointer
    toggle_cursor_child*: pointer
    move_cursor*: pointer
    select_all*: pointer
    unselect_all*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer
    gtk_reserved5*: pointer
    gtk_reserved6*: pointer

# wrapped: TFontButtonClass
# unwrapped: TFontButtonClass
  TFontButtonClass* {.pure,inheritable.} = object
    parent_class*: TButtonClass
    font_set*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TFontButtonPrivate
# unwrapped: TFontButtonPrivate
  TFontButtonPrivate* {.pure,inheritable.} = object

# wrapped: TFontChooserDialogClass
# unwrapped: TFontChooserDialogClass
  TFontChooserDialogClass* {.pure,inheritable.} = object
    parent_class*: TDialogClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TFontChooserDialogPrivate
# unwrapped: TFontChooserDialogPrivate
  TFontChooserDialogPrivate* {.pure,inheritable.} = object

# wrapped: TFontChooserIface
# unwrapped: TFontChooserIface
  TFontChooserIface* {.pure,inheritable.} = object
    base_iface*: GObject2.TTypeInterface
    get_font_family*: pointer
    get_font_face*: pointer
    get_font_size*: pointer
    set_filter_func*: pointer
    font_activated*: pointer
    set_font_map*: pointer
    get_font_map*: pointer
    padding*: array[10, pointer]

# wrapped: TFontChooserWidgetClass
# unwrapped: TFontChooserWidgetClass
  TFontChooserWidgetClass* {.pure,inheritable.} = object
    parent_class*: TBoxClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer
    gtk_reserved5*: pointer
    gtk_reserved6*: pointer
    gtk_reserved7*: pointer
    gtk_reserved8*: pointer

# wrapped: TFontChooserWidgetPrivate
# unwrapped: TFontChooserWidgetPrivate
  TFontChooserWidgetPrivate* {.pure,inheritable.} = object

# wrapped: TFontSelectionClass
# unwrapped: TFontSelectionClass
  TFontSelectionClass* {.pure,inheritable.} = object
    parent_class*: TBoxClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TFontSelectionDialogClass
# unwrapped: TFontSelectionDialogClass
  TFontSelectionDialogClass* {.pure,inheritable.} = object
    parent_class*: TDialogClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TFontSelectionDialogPrivate
# unwrapped: TFontSelectionDialogPrivate
  TFontSelectionDialogPrivate* {.pure,inheritable.} = object

# wrapped: TFontSelectionPrivate
# unwrapped: TFontSelectionPrivate
  TFontSelectionPrivate* {.pure,inheritable.} = object

# wrapped: TFrameAccessibleClass
# unwrapped: TFrameAccessibleClass
  TFrameAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TContainerAccessibleClass

# wrapped: TFrameAccessiblePrivate
# unwrapped: TFrameAccessiblePrivate
  TFrameAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TFrameClass
# unwrapped: TFrameClass
  TFrameClass* {.pure,inheritable.} = object
    parent_class*: TBinClass
    compute_child_allocation*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TFramePrivate
# unwrapped: TFramePrivate
  TFramePrivate* {.pure,inheritable.} = object

# wrapped: TGLAreaClass
# unwrapped: TGLAreaClass
  TGLAreaClass* {.pure,inheritable.} = object
    parent_class*: TWidgetClass
    render*: pointer
    resize*: pointer
    create_context*: pointer
    padding*: array[6, pointer]

# wrapped: TGestureClass
# unwrapped: TGestureClass
  TGestureClass* {.pure,inheritable.} = object

# wrapped: TGestureDragClass
# unwrapped: TGestureDragClass
  TGestureDragClass* {.pure,inheritable.} = object

# wrapped: TGestureLongPressClass
# unwrapped: TGestureLongPressClass
  TGestureLongPressClass* {.pure,inheritable.} = object

# wrapped: TGestureMultiPressClass
# unwrapped: TGestureMultiPressClass
  TGestureMultiPressClass* {.pure,inheritable.} = object

# wrapped: TGesturePanClass
# unwrapped: TGesturePanClass
  TGesturePanClass* {.pure,inheritable.} = object

# wrapped: TGestureRotateClass
# unwrapped: TGestureRotateClass
  TGestureRotateClass* {.pure,inheritable.} = object

# wrapped: TGestureSingleClass
# unwrapped: TGestureSingleClass
  TGestureSingleClass* {.pure,inheritable.} = object

# wrapped: TGestureSwipeClass
# unwrapped: TGestureSwipeClass
  TGestureSwipeClass* {.pure,inheritable.} = object

# wrapped: TGestureZoomClass
# unwrapped: TGestureZoomClass
  TGestureZoomClass* {.pure,inheritable.} = object

# wrapped: TGradient
# unwrapped: TGradient
  TGradient* {.pure,inheritable.} = object

# wrapped: TGridClass
# unwrapped: TGridClass
  TGridClass* {.pure,inheritable.} = object
    parent_class*: TContainerClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer
    gtk_reserved5*: pointer
    gtk_reserved6*: pointer
    gtk_reserved7*: pointer
    gtk_reserved8*: pointer

# wrapped: TGridPrivate
# unwrapped: TGridPrivate
  TGridPrivate* {.pure,inheritable.} = object

# wrapped: THBoxClass
# unwrapped: THBoxClass
  THBoxClass* {.pure,inheritable.} = object
    parent_class*: TBoxClass

# wrapped: THButtonBoxClass
# unwrapped: THButtonBoxClass
  THButtonBoxClass* {.pure,inheritable.} = object
    parent_class*: TButtonBoxClass

# wrapped: THPanedClass
# unwrapped: THPanedClass
  THPanedClass* {.pure,inheritable.} = object
    parent_class*: TPanedClass

# wrapped: THSVClass
# unwrapped: THSVClass
  THSVClass* {.pure,inheritable.} = object
    parent_class*: TWidgetClass
    changed*: pointer
    move*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: THSVPrivate
# unwrapped: THSVPrivate
  THSVPrivate* {.pure,inheritable.} = object

# wrapped: THScaleClass
# unwrapped: THScaleClass
  THScaleClass* {.pure,inheritable.} = object
    parent_class*: TScaleClass

# wrapped: THScrollbarClass
# unwrapped: THScrollbarClass
  THScrollbarClass* {.pure,inheritable.} = object
    parent_class*: TScrollbarClass

# wrapped: THSeparatorClass
# unwrapped: THSeparatorClass
  THSeparatorClass* {.pure,inheritable.} = object
    parent_class*: TSeparatorClass

# wrapped: THandleBoxClass
# unwrapped: THandleBoxClass
  THandleBoxClass* {.pure,inheritable.} = object
    parent_class*: TBinClass
    child_attached*: pointer
    child_detached*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: THandleBoxPrivate
# unwrapped: THandleBoxPrivate
  THandleBoxPrivate* {.pure,inheritable.} = object

# wrapped: THeaderBarClass
# unwrapped: THeaderBarClass
  THeaderBarClass* {.pure,inheritable.} = object
    parent_class*: TContainerClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: THeaderBarPrivate
# unwrapped: THeaderBarPrivate
  THeaderBarPrivate* {.pure,inheritable.} = object

# wrapped: TIMContextClass
# unwrapped: TIMContextClass
  TIMContextClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    preedit_start*: pointer
    preedit_end*: pointer
    preedit_changed*: pointer
    commit*: pointer
    retrieve_surrounding*: pointer
    delete_surrounding*: pointer
    set_client_window*: pointer
    get_preedit_string*: pointer
    filter_keypress*: pointer
    focus_in*: pointer
    focus_out*: pointer
    reset*: pointer
    set_cursor_location*: pointer
    set_use_preedit*: pointer
    set_surrounding*: pointer
    get_surrounding*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer
    gtk_reserved5*: pointer
    gtk_reserved6*: pointer

# wrapped: TIMContextInfo
# unwrapped: TIMContextInfo
  TIMContextInfo* {.pure,inheritable.} = object
    context_id*: ucstring
    context_name*: ucstring
    domain*: ucstring
    domain_dirname*: ucstring
    default_locales*: ucstring

# wrapped: TIMContextSimpleClass
# unwrapped: TIMContextSimpleClass
  TIMContextSimpleClass* {.pure,inheritable.} = object
    parent_class*: TIMContextClass

# wrapped: TIMContextSimplePrivate
# unwrapped: TIMContextSimplePrivate
  TIMContextSimplePrivate* {.pure,inheritable.} = object

# wrapped: TIMMulticontextClass
# unwrapped: TIMMulticontextClass
  TIMMulticontextClass* {.pure,inheritable.} = object
    parent_class*: TIMContextClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TIMMulticontextPrivate
# unwrapped: TIMMulticontextPrivate
  TIMMulticontextPrivate* {.pure,inheritable.} = object

# wrapped: TIconFactoryClass
# unwrapped: TIconFactoryClass
  TIconFactoryClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TIconFactoryPrivate
# unwrapped: TIconFactoryPrivate
  TIconFactoryPrivate* {.pure,inheritable.} = object

# wrapped: TIconInfoClass
# unwrapped: TIconInfoClass
  TIconInfoClass* {.pure,inheritable.} = object

# wrapped: TIconSet
# unwrapped: TIconSet
  TIconSet* {.pure,inheritable.} = object

# wrapped: TIconSource
# unwrapped: TIconSource
  TIconSource* {.pure,inheritable.} = object

# wrapped: TIconThemeClass
# unwrapped: TIconThemeClass
  TIconThemeClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    changed*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TIconThemePrivate
# unwrapped: TIconThemePrivate
  TIconThemePrivate* {.pure,inheritable.} = object

# wrapped: TIconViewAccessibleClass
# unwrapped: TIconViewAccessibleClass
  TIconViewAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TContainerAccessibleClass

# wrapped: TIconViewAccessiblePrivate
# unwrapped: TIconViewAccessiblePrivate
  TIconViewAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TIconViewClass
# unwrapped: TIconViewClass
  TIconViewClass* {.pure,inheritable.} = object
    parent_class*: TContainerClass
    item_activated*: pointer
    selection_changed*: pointer
    select_all*: pointer
    unselect_all*: pointer
    select_cursor_item*: pointer
    toggle_cursor_item*: pointer
    move_cursor*: pointer
    activate_cursor_item*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TIconViewPrivate
# unwrapped: TIconViewPrivate
  TIconViewPrivate* {.pure,inheritable.} = object

# wrapped: TImageAccessibleClass
# unwrapped: TImageAccessibleClass
  TImageAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TWidgetAccessibleClass

# wrapped: TImageAccessiblePrivate
# unwrapped: TImageAccessiblePrivate
  TImageAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TImageCellAccessibleClass
# unwrapped: TImageCellAccessibleClass
  TImageCellAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TRendererCellAccessibleClass

# wrapped: TImageCellAccessiblePrivate
# unwrapped: TImageCellAccessiblePrivate
  TImageCellAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TImageClass
# unwrapped: TImageClass
  TImageClass* {.pure,inheritable.} = object
    parent_class*: TMiscClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TImageMenuItemClass
# unwrapped: TImageMenuItemClass
  TImageMenuItemClass* {.pure,inheritable.} = object
    parent_class*: TMenuItemClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TImageMenuItemPrivate
# unwrapped: TImageMenuItemPrivate
  TImageMenuItemPrivate* {.pure,inheritable.} = object

# wrapped: TImagePrivate
# unwrapped: TImagePrivate
  TImagePrivate* {.pure,inheritable.} = object

# wrapped: TInfoBarClass
# unwrapped: TInfoBarClass
  TInfoBarClass* {.pure,inheritable.} = object
    parent_class*: TBoxClass
    response*: pointer
    close*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TInfoBarPrivate
# unwrapped: TInfoBarPrivate
  TInfoBarPrivate* {.pure,inheritable.} = object

# wrapped: TInvisibleClass
# unwrapped: TInvisibleClass
  TInvisibleClass* {.pure,inheritable.} = object
    parent_class*: TWidgetClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TInvisiblePrivate
# unwrapped: TInvisiblePrivate
  TInvisiblePrivate* {.pure,inheritable.} = object

# wrapped: TLabelAccessibleClass
# unwrapped: TLabelAccessibleClass
  TLabelAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TWidgetAccessibleClass

# wrapped: TLabelAccessiblePrivate
# unwrapped: TLabelAccessiblePrivate
  TLabelAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TLabelClass
# unwrapped: TLabelClass
  TLabelClass* {.pure,inheritable.} = object
    parent_class*: TMiscClass
    move_cursor*: pointer
    copy_clipboard*: pointer
    populate_popup*: pointer
    activate_link*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer
    gtk_reserved5*: pointer
    gtk_reserved6*: pointer
    gtk_reserved7*: pointer
    gtk_reserved8*: pointer

# wrapped: TLabelPrivate
# unwrapped: TLabelPrivate
  TLabelPrivate* {.pure,inheritable.} = object

# wrapped: TLabelSelectionInfo
# unwrapped: TLabelSelectionInfo
  TLabelSelectionInfo* {.pure,inheritable.} = object

# wrapped: TLayoutClass
# unwrapped: TLayoutClass
  TLayoutClass* {.pure,inheritable.} = object
    parent_class*: TContainerClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TLayoutPrivate
# unwrapped: TLayoutPrivate
  TLayoutPrivate* {.pure,inheritable.} = object

# wrapped: TLevelBarAccessibleClass
# unwrapped: TLevelBarAccessibleClass
  TLevelBarAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TWidgetAccessibleClass

# wrapped: TLevelBarAccessiblePrivate
# unwrapped: TLevelBarAccessiblePrivate
  TLevelBarAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TLevelBarClass
# unwrapped: TLevelBarClass
  TLevelBarClass* {.pure,inheritable.} = object
    parent_class*: TWidgetClass
    offset_changed*: pointer
    padding*: array[16, pointer]

# wrapped: TLevelBarPrivate
# unwrapped: TLevelBarPrivate
  TLevelBarPrivate* {.pure,inheritable.} = object

# wrapped: TLinkButtonAccessibleClass
# unwrapped: TLinkButtonAccessibleClass
  TLinkButtonAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TButtonAccessibleClass

# wrapped: TLinkButtonAccessiblePrivate
# unwrapped: TLinkButtonAccessiblePrivate
  TLinkButtonAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TLinkButtonClass
# unwrapped: TLinkButtonClass
  TLinkButtonClass* {.pure,inheritable.} = object
    parent_class*: TButtonClass
    activate_link*: pointer
    gtk_padding1*: pointer
    gtk_padding2*: pointer
    gtk_padding3*: pointer
    gtk_padding4*: pointer

# wrapped: TLinkButtonPrivate
# unwrapped: TLinkButtonPrivate
  TLinkButtonPrivate* {.pure,inheritable.} = object

# wrapped: TListBoxAccessibleClass
# unwrapped: TListBoxAccessibleClass
  TListBoxAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TContainerAccessibleClass

# wrapped: TListBoxAccessiblePrivate
# unwrapped: TListBoxAccessiblePrivate
  TListBoxAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TListBoxClass
# unwrapped: TListBoxClass
  TListBoxClass* {.pure,inheritable.} = object
    parent_class*: TContainerClass
    row_selected*: pointer
    row_activated*: pointer
    activate_cursor_row*: pointer
    toggle_cursor_row*: pointer
    move_cursor*: pointer
    selected_rows_changed*: pointer
    select_all*: pointer
    unselect_all*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer

# wrapped: TListBoxRowAccessibleClass
# unwrapped: TListBoxRowAccessibleClass
  TListBoxRowAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TContainerAccessibleClass

# wrapped: TListBoxRowClass
# unwrapped: TListBoxRowClass
  TListBoxRowClass* {.pure,inheritable.} = object
    parent_class*: TBinClass
    activate*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer

# wrapped: TListStoreClass
# unwrapped: TListStoreClass
  TListStoreClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TListStorePrivate
# unwrapped: TListStorePrivate
  TListStorePrivate* {.pure,inheritable.} = object

# wrapped: TLockButtonAccessibleClass
# unwrapped: TLockButtonAccessibleClass
  TLockButtonAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TButtonAccessibleClass

# wrapped: TLockButtonAccessiblePrivate
# unwrapped: TLockButtonAccessiblePrivate
  TLockButtonAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TLockButtonClass
# unwrapped: TLockButtonClass
  TLockButtonClass* {.pure,inheritable.} = object
    parent_class*: TButtonClass
    reserved0*: pointer
    reserved1*: pointer
    reserved2*: pointer
    reserved3*: pointer
    reserved4*: pointer
    reserved5*: pointer
    reserved6*: pointer
    reserved7*: pointer

# wrapped: TLockButtonPrivate
# unwrapped: TLockButtonPrivate
  TLockButtonPrivate* {.pure,inheritable.} = object

# wrapped: TMenuAccessibleClass
# unwrapped: TMenuAccessibleClass
  TMenuAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TMenuShellAccessibleClass

# wrapped: TMenuAccessiblePrivate
# unwrapped: TMenuAccessiblePrivate
  TMenuAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TMenuBarClass
# unwrapped: TMenuBarClass
  TMenuBarClass* {.pure,inheritable.} = object
    parent_class*: TMenuShellClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TMenuBarPrivate
# unwrapped: TMenuBarPrivate
  TMenuBarPrivate* {.pure,inheritable.} = object

# wrapped: TMenuButtonAccessibleClass
# unwrapped: TMenuButtonAccessibleClass
  TMenuButtonAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TToggleButtonAccessibleClass

# wrapped: TMenuButtonAccessiblePrivate
# unwrapped: TMenuButtonAccessiblePrivate
  TMenuButtonAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TMenuButtonClass
# unwrapped: TMenuButtonClass
  TMenuButtonClass* {.pure,inheritable.} = object
    parent_class*: TToggleButtonClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TMenuButtonPrivate
# unwrapped: TMenuButtonPrivate
  TMenuButtonPrivate* {.pure,inheritable.} = object

# wrapped: TMenuClass
# unwrapped: TMenuClass
  TMenuClass* {.pure,inheritable.} = object
    parent_class*: TMenuShellClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TMenuItemAccessibleClass
# unwrapped: TMenuItemAccessibleClass
  TMenuItemAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TContainerAccessibleClass

# wrapped: TMenuItemAccessiblePrivate
# unwrapped: TMenuItemAccessiblePrivate
  TMenuItemAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TMenuItemClass
# unwrapped: TMenuItemClass
  TMenuItemClass* {.pure,inheritable.} = object
    parent_class*: TBinClass
    hide_on_activate*: uint32
    activate*: pointer
    activate_item*: pointer
    toggle_size_request*: pointer
    toggle_size_allocate*: pointer
    set_label*: pointer
    get_label*: pointer
    select*: pointer
    deselect*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TMenuItemPrivate
# unwrapped: TMenuItemPrivate
  TMenuItemPrivate* {.pure,inheritable.} = object

# wrapped: TMenuPrivate
# unwrapped: TMenuPrivate
  TMenuPrivate* {.pure,inheritable.} = object

# wrapped: TMenuShellAccessibleClass
# unwrapped: TMenuShellAccessibleClass
  TMenuShellAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TContainerAccessibleClass

# wrapped: TMenuShellAccessiblePrivate
# unwrapped: TMenuShellAccessiblePrivate
  TMenuShellAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TMenuShellClass
# unwrapped: TMenuShellClass
  TMenuShellClass* {.pure,inheritable.} = object
    parent_class*: TContainerClass
    submenu_placement*: uint32
    deactivate*: pointer
    selection_done*: pointer
    move_current*: pointer
    activate_current*: pointer
    cancel*: pointer
    select_item*: pointer
    insert*: pointer
    get_popup_delay*: pointer
    move_selected*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TMenuShellPrivate
# unwrapped: TMenuShellPrivate
  TMenuShellPrivate* {.pure,inheritable.} = object

# wrapped: TMenuToolButtonClass
# unwrapped: TMenuToolButtonClass
  TMenuToolButtonClass* {.pure,inheritable.} = object
    parent_class*: TToolButtonClass
    show_menu*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TMenuToolButtonPrivate
# unwrapped: TMenuToolButtonPrivate
  TMenuToolButtonPrivate* {.pure,inheritable.} = object

# wrapped: TMessageDialogClass
# unwrapped: TMessageDialogClass
  TMessageDialogClass* {.pure,inheritable.} = object
    parent_class*: TDialogClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TMessageDialogPrivate
# unwrapped: TMessageDialogPrivate
  TMessageDialogPrivate* {.pure,inheritable.} = object

# wrapped: TMiscClass
# unwrapped: TMiscClass
  TMiscClass* {.pure,inheritable.} = object
    parent_class*: TWidgetClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TMiscPrivate
# unwrapped: TMiscPrivate
  TMiscPrivate* {.pure,inheritable.} = object

# wrapped: TMountOperationClass
# unwrapped: TMountOperationClass
  TMountOperationClass* {.pure,inheritable.} = object
    parent_class*: Gio2.TMountOperationClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TMountOperationPrivate
# unwrapped: TMountOperationPrivate
  TMountOperationPrivate* {.pure,inheritable.} = object

# wrapped: TNotebookAccessibleClass
# unwrapped: TNotebookAccessibleClass
  TNotebookAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TContainerAccessibleClass

# wrapped: TNotebookAccessiblePrivate
# unwrapped: TNotebookAccessiblePrivate
  TNotebookAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TNotebookClass
# unwrapped: TNotebookClass
  TNotebookClass* {.pure,inheritable.} = object
    parent_class*: TContainerClass
    switch_page*: pointer
    select_page*: pointer
    focus_tab*: pointer
    change_current_page*: pointer
    move_focus_out*: pointer
    reorder_tab*: pointer
    insert_page*: pointer
    create_window*: pointer
    page_reordered*: pointer
    page_removed*: pointer
    page_added*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer
    gtk_reserved5*: pointer
    gtk_reserved6*: pointer
    gtk_reserved7*: pointer
    gtk_reserved8*: pointer

# wrapped: TNotebookPageAccessibleClass
# unwrapped: TNotebookPageAccessibleClass
  TNotebookPageAccessibleClass* {.pure,inheritable.} = object
    parent_class*: Atk1.TObjectClass

# wrapped: TNotebookPageAccessiblePrivate
# unwrapped: TNotebookPageAccessiblePrivate
  TNotebookPageAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TNotebookPrivate
# unwrapped: TNotebookPrivate
  TNotebookPrivate* {.pure,inheritable.} = object

# wrapped: TNumerableIconClass
# unwrapped: TNumerableIconClass
  TNumerableIconClass* {.pure,inheritable.} = object
    parent_class*: Gio2.TEmblemedIconClass
    padding*: array[16, pointer]

# wrapped: TNumerableIconPrivate
# unwrapped: TNumerableIconPrivate
  TNumerableIconPrivate* {.pure,inheritable.} = object

# wrapped: TOffscreenWindowClass
# unwrapped: TOffscreenWindowClass
  TOffscreenWindowClass* {.pure,inheritable.} = object
    parent_class*: TWindowClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TOrientableIface
# unwrapped: TOrientableIface
  TOrientableIface* {.pure,inheritable.} = object
    base_iface*: GObject2.TTypeInterface

# wrapped: TOverlayClass
# unwrapped: TOverlayClass
  TOverlayClass* {.pure,inheritable.} = object
    parent_class*: TBinClass
    get_child_position*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer
    gtk_reserved5*: pointer
    gtk_reserved6*: pointer
    gtk_reserved7*: pointer
    gtk_reserved8*: pointer

# wrapped: TOverlayPrivate
# unwrapped: TOverlayPrivate
  TOverlayPrivate* {.pure,inheritable.} = object

# wrapped: TPageRange
# unwrapped: TPageRange
  TPageRange* {.pure,inheritable.} = object
    start*: int32
    end_x*: int32

# wrapped: TPanedAccessibleClass
# unwrapped: TPanedAccessibleClass
  TPanedAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TContainerAccessibleClass

# wrapped: TPanedAccessiblePrivate
# unwrapped: TPanedAccessiblePrivate
  TPanedAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TPanedClass
# unwrapped: TPanedClass
  TPanedClass* {.pure,inheritable.} = object
    parent_class*: TContainerClass
    cycle_child_focus*: pointer
    toggle_handle_focus*: pointer
    move_handle*: pointer
    cycle_handle_focus*: pointer
    accept_position*: pointer
    cancel_position*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TPanedPrivate
# unwrapped: TPanedPrivate
  TPanedPrivate* {.pure,inheritable.} = object

# wrapped: TPaperSize
# unwrapped: TPaperSize
  TPaperSize* {.pure,inheritable.} = object

# wrapped: TPlacesSidebarClass
# unwrapped: TPlacesSidebarClass
  TPlacesSidebarClass* {.pure,inheritable.} = object

# wrapped: TPopoverAccessibleClass
# unwrapped: TPopoverAccessibleClass
  TPopoverAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TContainerAccessibleClass

# wrapped: TPopoverClass
# unwrapped: TPopoverClass
  TPopoverClass* {.pure,inheritable.} = object
    parent_class*: TBinClass
    closed*: pointer
    reserved*: array[10, pointer]

# wrapped: TPopoverMenuClass
# unwrapped: TPopoverMenuClass
  TPopoverMenuClass* {.pure,inheritable.} = object
    parent_class*: TPopoverClass
    reserved*: array[10, pointer]

# wrapped: TPopoverPrivate
# unwrapped: TPopoverPrivate
  TPopoverPrivate* {.pure,inheritable.} = object

# wrapped: TPrintOperationClass
# unwrapped: TPrintOperationClass
  TPrintOperationClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    done*: pointer
    begin_print*: pointer
    paginate*: pointer
    request_page_setup*: pointer
    draw_page*: pointer
    end_print*: pointer
    status_changed*: pointer
    create_custom_widget*: pointer
    custom_widget_apply*: pointer
    preview*: pointer
    update_custom_widget*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer
    gtk_reserved5*: pointer
    gtk_reserved6*: pointer
    gtk_reserved7*: pointer
    gtk_reserved8*: pointer

# wrapped: TPrintOperationPreviewIface
# unwrapped: TPrintOperationPreviewIface
  TPrintOperationPreviewIface* {.pure,inheritable.} = object
    g_iface*: GObject2.TTypeInterface
    ready*: pointer
    got_page_size*: pointer
    render_page*: pointer
    is_selected*: pointer
    end_preview*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer
    gtk_reserved5*: pointer
    gtk_reserved6*: pointer
    gtk_reserved7*: pointer
    gtk_reserved8*: pointer

# wrapped: TPrintOperationPrivate
# unwrapped: TPrintOperationPrivate
  TPrintOperationPrivate* {.pure,inheritable.} = object

# wrapped: TProgressBarAccessibleClass
# unwrapped: TProgressBarAccessibleClass
  TProgressBarAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TWidgetAccessibleClass

# wrapped: TProgressBarAccessiblePrivate
# unwrapped: TProgressBarAccessiblePrivate
  TProgressBarAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TProgressBarClass
# unwrapped: TProgressBarClass
  TProgressBarClass* {.pure,inheritable.} = object
    parent_class*: TWidgetClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TProgressBarPrivate
# unwrapped: TProgressBarPrivate
  TProgressBarPrivate* {.pure,inheritable.} = object

# wrapped: TRadioActionClass
# unwrapped: TRadioActionClass
  TRadioActionClass* {.pure,inheritable.} = object
    parent_class*: TToggleActionClass
    changed*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TRadioActionEntry
# unwrapped: TRadioActionEntry
  TRadioActionEntry* {.pure,inheritable.} = object
    name*: ucstring
    stock_id*: ucstring
    label*: ucstring
    accelerator*: ucstring
    tooltip*: ucstring
    value*: int32

# wrapped: TRadioActionPrivate
# unwrapped: TRadioActionPrivate
  TRadioActionPrivate* {.pure,inheritable.} = object

# wrapped: TRadioButtonAccessibleClass
# unwrapped: TRadioButtonAccessibleClass
  TRadioButtonAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TToggleButtonAccessibleClass

# wrapped: TRadioButtonAccessiblePrivate
# unwrapped: TRadioButtonAccessiblePrivate
  TRadioButtonAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TRadioButtonClass
# unwrapped: TRadioButtonClass
  TRadioButtonClass* {.pure,inheritable.} = object
    parent_class*: TCheckButtonClass
    group_changed*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TRadioButtonPrivate
# unwrapped: TRadioButtonPrivate
  TRadioButtonPrivate* {.pure,inheritable.} = object

# wrapped: TRadioMenuItemAccessibleClass
# unwrapped: TRadioMenuItemAccessibleClass
  TRadioMenuItemAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TCheckMenuItemAccessibleClass

# wrapped: TRadioMenuItemAccessiblePrivate
# unwrapped: TRadioMenuItemAccessiblePrivate
  TRadioMenuItemAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TRadioMenuItemClass
# unwrapped: TRadioMenuItemClass
  TRadioMenuItemClass* {.pure,inheritable.} = object
    parent_class*: TCheckMenuItemClass
    group_changed*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TRadioMenuItemPrivate
# unwrapped: TRadioMenuItemPrivate
  TRadioMenuItemPrivate* {.pure,inheritable.} = object

# wrapped: TRadioToolButtonClass
# unwrapped: TRadioToolButtonClass
  TRadioToolButtonClass* {.pure,inheritable.} = object
    parent_class*: TToggleToolButtonClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TRangeAccessibleClass
# unwrapped: TRangeAccessibleClass
  TRangeAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TWidgetAccessibleClass

# wrapped: TRangeAccessiblePrivate
# unwrapped: TRangeAccessiblePrivate
  TRangeAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TRangeClass
# unwrapped: TRangeClass
  TRangeClass* {.pure,inheritable.} = object
    parent_class*: TWidgetClass
    slider_detail*: ucstring
    stepper_detail*: ucstring
    value_changed*: pointer
    adjust_bounds*: pointer
    move_slider*: pointer
    get_range_border*: pointer
    change_value*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TRangePrivate
# unwrapped: TRangePrivate
  TRangePrivate* {.pure,inheritable.} = object

# wrapped: TRcContext
# unwrapped: TRcContext
  TRcContext* {.pure,inheritable.} = object

# wrapped: TRcProperty
# unwrapped: TRcProperty
  TRcProperty* {.pure,inheritable.} = object
    type_name*: uint32
    property_name*: uint32
    origin*: ucstring
    value*: GObject2.TValue

# wrapped: TRcStyleClass
# unwrapped: TRcStyleClass
  TRcStyleClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    create_rc_style*: pointer
    parse*: pointer
    merge*: pointer
    create_style*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TRecentActionClass
# unwrapped: TRecentActionClass
  TRecentActionClass* {.pure,inheritable.} = object
    parent_class*: TActionClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TRecentActionPrivate
# unwrapped: TRecentActionPrivate
  TRecentActionPrivate* {.pure,inheritable.} = object

# wrapped: TRecentChooserDialogClass
# unwrapped: TRecentChooserDialogClass
  TRecentChooserDialogClass* {.pure,inheritable.} = object
    parent_class*: TDialogClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TRecentChooserDialogPrivate
# unwrapped: TRecentChooserDialogPrivate
  TRecentChooserDialogPrivate* {.pure,inheritable.} = object

# wrapped: TRecentChooserIface
# unwrapped: TRecentChooserIface
  TRecentChooserIface* {.pure,inheritable.} = object
    base_iface*: GObject2.TTypeInterface
    set_current_uri*: pointer
    get_current_uri*: pointer
    select_uri*: pointer
    unselect_uri*: pointer
    select_all*: pointer
    unselect_all*: pointer
    get_items*: pointer
    get_recent_manager*: pointer
    add_filter*: pointer
    remove_filter*: pointer
    list_filters*: pointer
    set_sort_func*: pointer
    item_activated*: pointer
    selection_changed*: pointer

# wrapped: TRecentChooserMenuClass
# unwrapped: TRecentChooserMenuClass
  TRecentChooserMenuClass* {.pure,inheritable.} = object
    parent_class*: TMenuClass
    gtk_recent1*: pointer
    gtk_recent2*: pointer
    gtk_recent3*: pointer
    gtk_recent4*: pointer

# wrapped: TRecentChooserMenuPrivate
# unwrapped: TRecentChooserMenuPrivate
  TRecentChooserMenuPrivate* {.pure,inheritable.} = object

# wrapped: TRecentChooserWidgetClass
# unwrapped: TRecentChooserWidgetClass
  TRecentChooserWidgetClass* {.pure,inheritable.} = object
    parent_class*: TBoxClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TRecentChooserWidgetPrivate
# unwrapped: TRecentChooserWidgetPrivate
  TRecentChooserWidgetPrivate* {.pure,inheritable.} = object

# wrapped: TRecentData
# unwrapped: TRecentData
  TRecentData* {.pure,inheritable.} = object
    display_name*: ucstring
    description*: ucstring
    mime_type*: ucstring
    app_name*: ucstring
    app_exec*: ucstring
    groups*: ptr zeroTerminatedArray[ucstring]
    is_private*: bool

# wrapped: TRecentFilterInfo
# unwrapped: TRecentFilterInfo
  TRecentFilterInfo* {.pure,inheritable.} = object
    contains*: SRecentFilterFlags
    uri*: ucstring
    display_name*: ucstring
    mime_type*: ucstring
    applications*: ptr zeroTerminatedArray[ucstring]
    groups*: ptr zeroTerminatedArray[ucstring]
    age*: int32

# wrapped: TRecentInfo
# unwrapped: TRecentInfo
  TRecentInfo* {.pure,inheritable.} = object

# wrapped: TRecentManagerClass
# unwrapped: TRecentManagerClass
  TRecentManagerClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    changed*: pointer
    gtk_recent1*: pointer
    gtk_recent2*: pointer
    gtk_recent3*: pointer
    gtk_recent4*: pointer

# wrapped: TRecentManagerPrivate
# unwrapped: TRecentManagerPrivate
  TRecentManagerPrivate* {.pure,inheritable.} = object

# wrapped: TRendererCellAccessibleClass
# unwrapped: TRendererCellAccessibleClass
  TRendererCellAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TCellAccessibleClass

# wrapped: TRendererCellAccessiblePrivate
# unwrapped: TRendererCellAccessiblePrivate
  TRendererCellAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TRequestedSize
# unwrapped: TRequestedSize
  TRequestedSize* {.pure,inheritable.} = object
    data*: pointer
    minimum_size*: int32
    natural_size*: int32

# wrapped: TRequisition
# unwrapped: TRequisition
  TRequisition* {.pure,inheritable.} = object
    width*: int32
    height*: int32

# wrapped: TRevealerClass
# unwrapped: TRevealerClass
  TRevealerClass* {.pure,inheritable.} = object
    parent_class*: TBinClass

# wrapped: TScaleAccessibleClass
# unwrapped: TScaleAccessibleClass
  TScaleAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TRangeAccessibleClass

# wrapped: TScaleAccessiblePrivate
# unwrapped: TScaleAccessiblePrivate
  TScaleAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TScaleButtonAccessibleClass
# unwrapped: TScaleButtonAccessibleClass
  TScaleButtonAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TButtonAccessibleClass

# wrapped: TScaleButtonAccessiblePrivate
# unwrapped: TScaleButtonAccessiblePrivate
  TScaleButtonAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TScaleButtonClass
# unwrapped: TScaleButtonClass
  TScaleButtonClass* {.pure,inheritable.} = object
    parent_class*: TButtonClass
    value_changed*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TScaleButtonPrivate
# unwrapped: TScaleButtonPrivate
  TScaleButtonPrivate* {.pure,inheritable.} = object

# wrapped: TScaleClass
# unwrapped: TScaleClass
  TScaleClass* {.pure,inheritable.} = object
    parent_class*: TRangeClass
    format_value*: pointer
    draw_value*: pointer
    get_layout_offsets*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TScalePrivate
# unwrapped: TScalePrivate
  TScalePrivate* {.pure,inheritable.} = object

# wrapped: TScrollableInterface
# unwrapped: TScrollableInterface
  TScrollableInterface* {.pure,inheritable.} = object
    base_iface*: GObject2.TTypeInterface
    get_border*: pointer

# wrapped: TScrollbarClass
# unwrapped: TScrollbarClass
  TScrollbarClass* {.pure,inheritable.} = object
    parent_class*: TRangeClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TScrolledWindowAccessibleClass
# unwrapped: TScrolledWindowAccessibleClass
  TScrolledWindowAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TContainerAccessibleClass

# wrapped: TScrolledWindowAccessiblePrivate
# unwrapped: TScrolledWindowAccessiblePrivate
  TScrolledWindowAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TScrolledWindowClass
# unwrapped: TScrolledWindowClass
  TScrolledWindowClass* {.pure,inheritable.} = object
    parent_class*: TBinClass
    scrollbar_spacing*: int32
    scroll_child*: pointer
    move_focus_out*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TScrolledWindowPrivate
# unwrapped: TScrolledWindowPrivate
  TScrolledWindowPrivate* {.pure,inheritable.} = object

# wrapped: TSearchBarClass
# unwrapped: TSearchBarClass
  TSearchBarClass* {.pure,inheritable.} = object
    parent_class*: TBinClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TSearchEntryClass
# unwrapped: TSearchEntryClass
  TSearchEntryClass* {.pure,inheritable.} = object
    parent_class*: TEntryClass
    search_changed*: pointer
    next_match*: pointer
    previous_match*: pointer
    stop_search*: pointer

# wrapped: TSelectionData
# unwrapped: TSelectionData
  TSelectionData* {.pure,inheritable.} = object

# wrapped: TSeparatorClass
# unwrapped: TSeparatorClass
  TSeparatorClass* {.pure,inheritable.} = object
    parent_class*: TWidgetClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TSeparatorMenuItemClass
# unwrapped: TSeparatorMenuItemClass
  TSeparatorMenuItemClass* {.pure,inheritable.} = object
    parent_class*: TMenuItemClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TSeparatorPrivate
# unwrapped: TSeparatorPrivate
  TSeparatorPrivate* {.pure,inheritable.} = object

# wrapped: TSeparatorToolItemClass
# unwrapped: TSeparatorToolItemClass
  TSeparatorToolItemClass* {.pure,inheritable.} = object
    parent_class*: TToolItemClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TSeparatorToolItemPrivate
# unwrapped: TSeparatorToolItemPrivate
  TSeparatorToolItemPrivate* {.pure,inheritable.} = object

# wrapped: TSettingsClass
# unwrapped: TSettingsClass
  TSettingsClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TSettingsPrivate
# unwrapped: TSettingsPrivate
  TSettingsPrivate* {.pure,inheritable.} = object

# wrapped: TSettingsValue
# unwrapped: TSettingsValue
  TSettingsValue* {.pure,inheritable.} = object
    origin*: ucstring
    value*: GObject2.TValue

# wrapped: TSizeGroupClass
# unwrapped: TSizeGroupClass
  TSizeGroupClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TSizeGroupPrivate
# unwrapped: TSizeGroupPrivate
  TSizeGroupPrivate* {.pure,inheritable.} = object

# wrapped: TSpinButtonAccessibleClass
# unwrapped: TSpinButtonAccessibleClass
  TSpinButtonAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TEntryAccessibleClass

# wrapped: TSpinButtonAccessiblePrivate
# unwrapped: TSpinButtonAccessiblePrivate
  TSpinButtonAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TSpinButtonClass
# unwrapped: TSpinButtonClass
  TSpinButtonClass* {.pure,inheritable.} = object
    parent_class*: TEntryClass
    input*: pointer
    output*: pointer
    value_changed*: pointer
    change_value*: pointer
    wrapped*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TSpinButtonPrivate
# unwrapped: TSpinButtonPrivate
  TSpinButtonPrivate* {.pure,inheritable.} = object

# wrapped: TSpinnerAccessibleClass
# unwrapped: TSpinnerAccessibleClass
  TSpinnerAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TWidgetAccessibleClass

# wrapped: TSpinnerAccessiblePrivate
# unwrapped: TSpinnerAccessiblePrivate
  TSpinnerAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TSpinnerClass
# unwrapped: TSpinnerClass
  TSpinnerClass* {.pure,inheritable.} = object
    parent_class*: TWidgetClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TSpinnerPrivate
# unwrapped: TSpinnerPrivate
  TSpinnerPrivate* {.pure,inheritable.} = object

# wrapped: TStackClass
# unwrapped: TStackClass
  TStackClass* {.pure,inheritable.} = object
    parent_class*: TContainerClass

# wrapped: TStackSidebarClass
# unwrapped: TStackSidebarClass
  TStackSidebarClass* {.pure,inheritable.} = object
    parent_class*: TBinClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TStackSidebarPrivate
# unwrapped: TStackSidebarPrivate
  TStackSidebarPrivate* {.pure,inheritable.} = object

# wrapped: TStackSwitcherClass
# unwrapped: TStackSwitcherClass
  TStackSwitcherClass* {.pure,inheritable.} = object
    parent_class*: TBoxClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TStatusIconClass
# unwrapped: TStatusIconClass
  TStatusIconClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    activate*: pointer
    popup_menu*: pointer
    size_changed*: pointer
    button_press_event*: pointer
    button_release_event*: pointer
    scroll_event*: pointer
    query_tooltip*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TStatusIconPrivate
# unwrapped: TStatusIconPrivate
  TStatusIconPrivate* {.pure,inheritable.} = object

# wrapped: TStatusbarAccessibleClass
# unwrapped: TStatusbarAccessibleClass
  TStatusbarAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TContainerAccessibleClass

# wrapped: TStatusbarAccessiblePrivate
# unwrapped: TStatusbarAccessiblePrivate
  TStatusbarAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TStatusbarClass
# unwrapped: TStatusbarClass
  TStatusbarClass* {.pure,inheritable.} = object
    parent_class*: TBoxClass
    reserved*: pointer
    text_pushed*: pointer
    text_popped*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TStatusbarPrivate
# unwrapped: TStatusbarPrivate
  TStatusbarPrivate* {.pure,inheritable.} = object

# wrapped: TStockItem
# unwrapped: TStockItem
  TStockItem* {.pure,inheritable.} = object
    stock_id*: ucstring
    label*: ucstring
    modifier*: Gdk3.SModifierType
    keyval*: uint32
    translation_domain*: ucstring

# wrapped: TStyleClass
# unwrapped: TStyleClass
  TStyleClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    realize*: pointer
    unrealize*: pointer
    copy*: pointer
    clone*: pointer
    init_from_rc*: pointer
    set_background*: pointer
    render_icon*: pointer
    draw_hline*: pointer
    draw_vline*: pointer
    draw_shadow*: pointer
    draw_arrow*: pointer
    draw_diamond*: pointer
    draw_box*: pointer
    draw_flat_box*: pointer
    draw_check*: pointer
    draw_option*: pointer
    draw_tab*: pointer
    draw_shadow_gap*: pointer
    draw_box_gap*: pointer
    draw_extension*: pointer
    draw_focus*: pointer
    draw_slider*: pointer
    draw_handle*: pointer
    draw_expander*: pointer
    draw_layout*: pointer
    draw_resize_grip*: pointer
    draw_spinner*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer
    gtk_reserved5*: pointer
    gtk_reserved6*: pointer
    gtk_reserved7*: pointer
    gtk_reserved8*: pointer
    gtk_reserved9*: pointer
    gtk_reserved10*: pointer
    gtk_reserved11*: pointer

# wrapped: TStyleContextClass
# unwrapped: TStyleContextClass
  TStyleContextClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    changed*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TStyleContextPrivate
# unwrapped: TStyleContextPrivate
  TStyleContextPrivate* {.pure,inheritable.} = object

# wrapped: TStylePropertiesClass
# unwrapped: TStylePropertiesClass
  TStylePropertiesClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TStylePropertiesPrivate
# unwrapped: TStylePropertiesPrivate
  TStylePropertiesPrivate* {.pure,inheritable.} = object

# wrapped: TStyleProviderIface
# unwrapped: TStyleProviderIface
  TStyleProviderIface* {.pure,inheritable.} = object
    g_iface*: GObject2.TTypeInterface
    get_style*: pointer
    get_style_property*: pointer
    get_icon_factory*: pointer

# wrapped: TSwitchAccessibleClass
# unwrapped: TSwitchAccessibleClass
  TSwitchAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TWidgetAccessibleClass

# wrapped: TSwitchAccessiblePrivate
# unwrapped: TSwitchAccessiblePrivate
  TSwitchAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TSwitchClass
# unwrapped: TSwitchClass
  TSwitchClass* {.pure,inheritable.} = object
    parent_class*: TWidgetClass
    activate*: pointer
    state_set*: pointer
    switch_padding_1*: pointer
    switch_padding_2*: pointer
    switch_padding_3*: pointer
    switch_padding_4*: pointer
    switch_padding_5*: pointer

# wrapped: TSwitchPrivate
# unwrapped: TSwitchPrivate
  TSwitchPrivate* {.pure,inheritable.} = object

# wrapped: TSymbolicColor
# unwrapped: TSymbolicColor
  TSymbolicColor* {.pure,inheritable.} = object

# wrapped: TTableChild
# unwrapped: TTableChild
  TTableChild* {.pure,inheritable.} = object
    widget*: ptr TWidget
    left_attach*: uint16
    right_attach*: uint16
    top_attach*: uint16
    bottom_attach*: uint16
    xpadding*: uint16
    ypadding*: uint16
    xexpand*: uint32
    yexpand*: uint32
    xshrink*: uint32
    yshrink*: uint32
    xfill*: uint32
    yfill*: uint32

# wrapped: TTableClass
# unwrapped: TTableClass
  TTableClass* {.pure,inheritable.} = object
    parent_class*: TContainerClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TTablePrivate
# unwrapped: TTablePrivate
  TTablePrivate* {.pure,inheritable.} = object

# wrapped: TTableRowCol
# unwrapped: TTableRowCol
  TTableRowCol* {.pure,inheritable.} = object
    requisition*: uint16
    allocation*: uint16
    spacing*: uint16
    need_expand*: uint32
    need_shrink*: uint32
    expand*: uint32
    shrink*: uint32
    empty*: uint32

# wrapped: TTargetEntry
# unwrapped: TTargetEntry
  TTargetEntry* {.pure,inheritable.} = object
    target*: ucstring
    flags*: uint32
    info*: uint32

# wrapped: TTargetList
# unwrapped: TTargetList
  TTargetList* {.pure,inheritable.} = object

# wrapped: TTargetPair
# unwrapped: TTargetPair
  TTargetPair* {.pure,inheritable.} = object
    target*: ptr Gdk3.TAtom
    flags*: uint32
    info*: uint32

# wrapped: TTearoffMenuItemClass
# unwrapped: TTearoffMenuItemClass
  TTearoffMenuItemClass* {.pure,inheritable.} = object
    parent_class*: TMenuItemClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TTearoffMenuItemPrivate
# unwrapped: TTearoffMenuItemPrivate
  TTearoffMenuItemPrivate* {.pure,inheritable.} = object

# wrapped: TTextAppearance
# unwrapped: TTextAppearance
  TTextAppearance* {.pure,inheritable.} = object
    bg_color*: Gdk3.TColor
    fg_color*: Gdk3.TColor
    rise*: int32
    underline*: uint32
    strikethrough*: uint32
    draw_bg*: uint32
    inside_selection*: uint32
    is_text*: uint32

# wrapped: TTextAttributes
# unwrapped: TTextAttributes
  TTextAttributes* {.pure,inheritable.} = object
    refcount*: uint32
    appearance*: TTextAppearance
    justification*: Justification
    direction*: TextDirection
    font*: ptr Pango1.TFontDescription
    font_scale*: float64
    left_margin*: int32
    right_margin*: int32
    indent*: int32
    pixels_above_lines*: int32
    pixels_below_lines*: int32
    pixels_inside_wrap*: int32
    tabs*: ptr Pango1.TTabArray
    wrap_mode*: WrapMode
    language*: ptr Pango1.TLanguage
    pg_bg_color*: ptr Gdk3.TColor
    invisible*: uint32
    bg_full_height*: uint32
    editable*: uint32
    no_fallback*: uint32
    pg_bg_rgba*: ptr Gdk3.TRGBA
    letter_spacing*: int32

# wrapped: TTextBTree
# unwrapped: TTextBTree
  TTextBTree* {.pure,inheritable.} = object

# wrapped: TTextBufferClass
# unwrapped: TTextBufferClass
  TTextBufferClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    insert_text*: pointer
    insert_pixbuf*: pointer
    insert_child_anchor*: pointer
    delete_range*: pointer
    changed*: pointer
    modified_changed*: pointer
    mark_set*: pointer
    mark_deleted*: pointer
    apply_tag*: pointer
    remove_tag*: pointer
    begin_user_action*: pointer
    end_user_action*: pointer
    paste_done*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TTextBufferPrivate
# unwrapped: TTextBufferPrivate
  TTextBufferPrivate* {.pure,inheritable.} = object

# wrapped: TTextCellAccessibleClass
# unwrapped: TTextCellAccessibleClass
  TTextCellAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TRendererCellAccessibleClass

# wrapped: TTextCellAccessiblePrivate
# unwrapped: TTextCellAccessiblePrivate
  TTextCellAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TTextChildAnchorClass
# unwrapped: TTextChildAnchorClass
  TTextChildAnchorClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TTextIter
# unwrapped: TTextIter
  TTextIter* {.pure,inheritable.} = object
    dummy1*: pointer
    dummy2*: pointer
    dummy3*: int32
    dummy4*: int32
    dummy5*: int32
    dummy6*: int32
    dummy7*: int32
    dummy8*: int32
    dummy9*: pointer
    dummy10*: pointer
    dummy11*: int32
    dummy12*: int32
    dummy13*: int32
    dummy14*: pointer

# wrapped: TTextMarkClass
# unwrapped: TTextMarkClass
  TTextMarkClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TTextTagClass
# unwrapped: TTextTagClass
  TTextTagClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    event*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TTextTagPrivate
# unwrapped: TTextTagPrivate
  TTextTagPrivate* {.pure,inheritable.} = object

# wrapped: TTextTagTableClass
# unwrapped: TTextTagTableClass
  TTextTagTableClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    tag_changed*: pointer
    tag_added*: pointer
    tag_removed*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TTextTagTablePrivate
# unwrapped: TTextTagTablePrivate
  TTextTagTablePrivate* {.pure,inheritable.} = object

# wrapped: TTextViewAccessibleClass
# unwrapped: TTextViewAccessibleClass
  TTextViewAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TContainerAccessibleClass

# wrapped: TTextViewAccessiblePrivate
# unwrapped: TTextViewAccessiblePrivate
  TTextViewAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TTextViewClass
# unwrapped: TTextViewClass
  TTextViewClass* {.pure,inheritable.} = object
    parent_class*: TContainerClass
    populate_popup*: pointer
    move_cursor*: pointer
    set_anchor*: pointer
    insert_at_cursor*: pointer
    delete_from_cursor*: pointer
    backspace*: pointer
    cut_clipboard*: pointer
    copy_clipboard*: pointer
    paste_clipboard*: pointer
    toggle_overwrite*: pointer
    create_buffer*: pointer
    draw_layer*: pointer
    extend_selection*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer
    gtk_reserved5*: pointer

# wrapped: TTextViewPrivate
# unwrapped: TTextViewPrivate
  TTextViewPrivate* {.pure,inheritable.} = object

# wrapped: TThemeEngine
# unwrapped: TThemeEngine
  TThemeEngine* {.pure,inheritable.} = object

# wrapped: TThemingEngineClass
# unwrapped: TThemingEngineClass
  TThemingEngineClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    render_line*: pointer
    render_background*: pointer
    render_frame*: pointer
    render_frame_gap*: pointer
    render_extension*: pointer
    render_check*: pointer
    render_option*: pointer
    render_arrow*: pointer
    render_expander*: pointer
    render_focus*: pointer
    render_layout*: pointer
    render_slider*: pointer
    render_handle*: pointer
    render_activity*: pointer
    render_icon_pixbuf*: pointer
    render_icon*: pointer
    render_icon_surface*: pointer
    padding*: array[14, pointer]

# wrapped: TThemingEnginePrivate
# unwrapped: TThemingEnginePrivate
  TThemingEnginePrivate* {.pure,inheritable.} = object

# wrapped: TToggleActionClass
# unwrapped: TToggleActionClass
  TToggleActionClass* {.pure,inheritable.} = object
    parent_class*: TActionClass
    toggled*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TToggleActionEntry
# unwrapped: TToggleActionEntry
  TToggleActionEntry* {.pure,inheritable.} = object
    name*: ucstring
    stock_id*: ucstring
    label*: ucstring
    accelerator*: ucstring
    tooltip*: ucstring
    callback*: pointer
    is_active*: bool

# wrapped: TToggleActionPrivate
# unwrapped: TToggleActionPrivate
  TToggleActionPrivate* {.pure,inheritable.} = object

# wrapped: TToggleButtonAccessibleClass
# unwrapped: TToggleButtonAccessibleClass
  TToggleButtonAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TButtonAccessibleClass

# wrapped: TToggleButtonAccessiblePrivate
# unwrapped: TToggleButtonAccessiblePrivate
  TToggleButtonAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TToggleButtonClass
# unwrapped: TToggleButtonClass
  TToggleButtonClass* {.pure,inheritable.} = object
    parent_class*: TButtonClass
    toggled*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TToggleButtonPrivate
# unwrapped: TToggleButtonPrivate
  TToggleButtonPrivate* {.pure,inheritable.} = object

# wrapped: TToggleToolButtonClass
# unwrapped: TToggleToolButtonClass
  TToggleToolButtonClass* {.pure,inheritable.} = object
    parent_class*: TToolButtonClass
    toggled*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TToggleToolButtonPrivate
# unwrapped: TToggleToolButtonPrivate
  TToggleToolButtonPrivate* {.pure,inheritable.} = object

# wrapped: TToolButtonClass
# unwrapped: TToolButtonClass
  TToolButtonClass* {.pure,inheritable.} = object
    parent_class*: TToolItemClass
    button_type*: GType
    clicked*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TToolButtonPrivate
# unwrapped: TToolButtonPrivate
  TToolButtonPrivate* {.pure,inheritable.} = object

# wrapped: TToolItemClass
# unwrapped: TToolItemClass
  TToolItemClass* {.pure,inheritable.} = object
    parent_class*: TBinClass
    create_menu_proxy*: pointer
    toolbar_reconfigured*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TToolItemGroupClass
# unwrapped: TToolItemGroupClass
  TToolItemGroupClass* {.pure,inheritable.} = object
    parent_class*: TContainerClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TToolItemGroupPrivate
# unwrapped: TToolItemGroupPrivate
  TToolItemGroupPrivate* {.pure,inheritable.} = object

# wrapped: TToolItemPrivate
# unwrapped: TToolItemPrivate
  TToolItemPrivate* {.pure,inheritable.} = object

# wrapped: TToolPaletteClass
# unwrapped: TToolPaletteClass
  TToolPaletteClass* {.pure,inheritable.} = object
    parent_class*: TContainerClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TToolPalettePrivate
# unwrapped: TToolPalettePrivate
  TToolPalettePrivate* {.pure,inheritable.} = object

# wrapped: TToolShellIface
# unwrapped: TToolShellIface
  TToolShellIface* {.pure,inheritable.} = object
    g_iface*: GObject2.TTypeInterface
    get_icon_size*: pointer
    get_orientation*: pointer
    get_style*: pointer
    get_relief_style*: pointer
    rebuild_menu*: pointer
    get_text_orientation*: pointer
    get_text_alignment*: pointer
    get_ellipsize_mode*: pointer
    get_text_size_group*: pointer

# wrapped: TToolbarClass
# unwrapped: TToolbarClass
  TToolbarClass* {.pure,inheritable.} = object
    parent_class*: TContainerClass
    orientation_changed*: pointer
    style_changed*: pointer
    popup_context_menu*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TToolbarPrivate
# unwrapped: TToolbarPrivate
  TToolbarPrivate* {.pure,inheritable.} = object

# wrapped: TToplevelAccessibleClass
# unwrapped: TToplevelAccessibleClass
  TToplevelAccessibleClass* {.pure,inheritable.} = object
    parent_class*: Atk1.TObjectClass

# wrapped: TToplevelAccessiblePrivate
# unwrapped: TToplevelAccessiblePrivate
  TToplevelAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TTreeDragDestIface
# unwrapped: TTreeDragDestIface
  TTreeDragDestIface* {.pure,inheritable.} = object
    g_iface*: GObject2.TTypeInterface
    drag_data_received*: pointer
    row_drop_possible*: pointer

# wrapped: TTreeDragSourceIface
# unwrapped: TTreeDragSourceIface
  TTreeDragSourceIface* {.pure,inheritable.} = object
    g_iface*: GObject2.TTypeInterface
    row_draggable*: pointer
    drag_data_get*: pointer
    drag_data_delete*: pointer

# wrapped: TTreeIter
# unwrapped: TTreeIter
  TTreeIter* {.pure,inheritable.} = object
    stamp*: int32
    user_data*: pointer
    user_data2*: pointer
    user_data3*: pointer

# wrapped: TTreeModelFilterClass
# unwrapped: TTreeModelFilterClass
  TTreeModelFilterClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    visible*: pointer
    modify*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TTreeModelFilterPrivate
# unwrapped: TTreeModelFilterPrivate
  TTreeModelFilterPrivate* {.pure,inheritable.} = object

# wrapped: TTreeModelIface
# unwrapped: TTreeModelIface
  TTreeModelIface* {.pure,inheritable.} = object
    g_iface*: GObject2.TTypeInterface
    row_changed*: pointer
    row_inserted*: pointer
    row_has_child_toggled*: pointer
    row_deleted*: pointer
    rows_reordered*: pointer
    get_flags*: pointer
    get_n_columns*: pointer
    get_column_type*: pointer
    get_iter*: pointer
    get_path*: pointer
    get_value*: pointer
    iter_next*: pointer
    iter_previous*: pointer
    iter_children*: pointer
    iter_has_child*: pointer
    iter_n_children*: pointer
    iter_nth_child*: pointer
    iter_parent*: pointer
    ref_node*: pointer
    unref_node*: pointer

# wrapped: TTreeModelSortClass
# unwrapped: TTreeModelSortClass
  TTreeModelSortClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TTreeModelSortPrivate
# unwrapped: TTreeModelSortPrivate
  TTreeModelSortPrivate* {.pure,inheritable.} = object

# wrapped: TTreePath
# unwrapped: TTreePath
  TTreePath* {.pure,inheritable.} = object

# wrapped: TTreeRowReference
# unwrapped: TTreeRowReference
  TTreeRowReference* {.pure,inheritable.} = object

# wrapped: TTreeSelectionClass
# unwrapped: TTreeSelectionClass
  TTreeSelectionClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    changed*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TTreeSelectionPrivate
# unwrapped: TTreeSelectionPrivate
  TTreeSelectionPrivate* {.pure,inheritable.} = object

# wrapped: TTreeSortableIface
# unwrapped: TTreeSortableIface
  TTreeSortableIface* {.pure,inheritable.} = object
    g_iface*: GObject2.TTypeInterface
    sort_column_changed*: pointer
    get_sort_column_id*: pointer
    set_sort_column_id*: pointer
    set_sort_func*: pointer
    set_default_sort_func*: pointer
    has_default_sort_func*: pointer

# wrapped: TTreeStoreClass
# unwrapped: TTreeStoreClass
  TTreeStoreClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TTreeStorePrivate
# unwrapped: TTreeStorePrivate
  TTreeStorePrivate* {.pure,inheritable.} = object

# wrapped: TTreeViewAccessibleClass
# unwrapped: TTreeViewAccessibleClass
  TTreeViewAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TContainerAccessibleClass

# wrapped: TTreeViewAccessiblePrivate
# unwrapped: TTreeViewAccessiblePrivate
  TTreeViewAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TTreeViewClass
# unwrapped: TTreeViewClass
  TTreeViewClass* {.pure,inheritable.} = object
    parent_class*: TContainerClass
    row_activated*: pointer
    test_expand_row*: pointer
    test_collapse_row*: pointer
    row_expanded*: pointer
    row_collapsed*: pointer
    columns_changed*: pointer
    cursor_changed*: pointer
    move_cursor*: pointer
    select_all*: pointer
    unselect_all*: pointer
    select_cursor_row*: pointer
    toggle_cursor_row*: pointer
    expand_collapse_cursor_row*: pointer
    select_cursor_parent*: pointer
    start_interactive_search*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer
    gtk_reserved5*: pointer
    gtk_reserved6*: pointer
    gtk_reserved7*: pointer
    gtk_reserved8*: pointer

# wrapped: TTreeViewColumnClass
# unwrapped: TTreeViewColumnClass
  TTreeViewColumnClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TInitiallyUnownedClass
    clicked*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TTreeViewColumnPrivate
# unwrapped: TTreeViewColumnPrivate
  TTreeViewColumnPrivate* {.pure,inheritable.} = object

# wrapped: TTreeViewPrivate
# unwrapped: TTreeViewPrivate
  TTreeViewPrivate* {.pure,inheritable.} = object

# wrapped: TUIManagerClass
# unwrapped: TUIManagerClass
  TUIManagerClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    add_widget*: pointer
    actions_changed*: pointer
    connect_proxy*: pointer
    disconnect_proxy*: pointer
    pre_activate*: pointer
    post_activate*: pointer
    get_widget*: pointer
    get_action*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TUIManagerPrivate
# unwrapped: TUIManagerPrivate
  TUIManagerPrivate* {.pure,inheritable.} = object

# wrapped: TVBoxClass
# unwrapped: TVBoxClass
  TVBoxClass* {.pure,inheritable.} = object
    parent_class*: TBoxClass

# wrapped: TVButtonBoxClass
# unwrapped: TVButtonBoxClass
  TVButtonBoxClass* {.pure,inheritable.} = object
    parent_class*: TButtonBoxClass

# wrapped: TVPanedClass
# unwrapped: TVPanedClass
  TVPanedClass* {.pure,inheritable.} = object
    parent_class*: TPanedClass

# wrapped: TVScaleClass
# unwrapped: TVScaleClass
  TVScaleClass* {.pure,inheritable.} = object
    parent_class*: TScaleClass

# wrapped: TVScrollbarClass
# unwrapped: TVScrollbarClass
  TVScrollbarClass* {.pure,inheritable.} = object
    parent_class*: TScrollbarClass

# wrapped: TVSeparatorClass
# unwrapped: TVSeparatorClass
  TVSeparatorClass* {.pure,inheritable.} = object
    parent_class*: TSeparatorClass

# wrapped: TViewportClass
# unwrapped: TViewportClass
  TViewportClass* {.pure,inheritable.} = object
    parent_class*: TBinClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TViewportPrivate
# unwrapped: TViewportPrivate
  TViewportPrivate* {.pure,inheritable.} = object

# wrapped: TVolumeButtonClass
# unwrapped: TVolumeButtonClass
  TVolumeButtonClass* {.pure,inheritable.} = object
    parent_class*: TScaleButtonClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TWidgetAccessibleClass
# unwrapped: TWidgetAccessibleClass
  TWidgetAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TAccessibleClass
    notify_gtk*: pointer

# wrapped: TWidgetAccessiblePrivate
# unwrapped: TWidgetAccessiblePrivate
  TWidgetAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TWidgetClass
# unwrapped: TWidgetClass
  TWidgetClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TInitiallyUnownedClass
    activate_signal*: uint32
    dispatch_child_properties_changed*: pointer
    destroy*: pointer
    show*: pointer
    show_all*: pointer
    hide*: pointer
    map*: pointer
    unmap*: pointer
    realize*: pointer
    unrealize*: pointer
    size_allocate*: pointer
    state_changed*: pointer
    state_flags_changed*: pointer
    parent_set*: pointer
    hierarchy_changed*: pointer
    style_set*: pointer
    direction_changed*: pointer
    grab_notify*: pointer
    child_notify*: pointer
    draw*: pointer
    get_request_mode*: pointer
    get_preferred_height*: pointer
    get_preferred_width_for_height*: pointer
    get_preferred_width*: pointer
    get_preferred_height_for_width*: pointer
    mnemonic_activate*: pointer
    grab_focus*: pointer
    focus*: pointer
    move_focus*: pointer
    keynav_failed*: pointer
    event*: pointer
    button_press_event*: pointer
    button_release_event*: pointer
    scroll_event*: pointer
    motion_notify_event*: pointer
    delete_event*: pointer
    destroy_event*: pointer
    key_press_event*: pointer
    key_release_event*: pointer
    enter_notify_event*: pointer
    leave_notify_event*: pointer
    configure_event*: pointer
    focus_in_event*: pointer
    focus_out_event*: pointer
    map_event*: pointer
    unmap_event*: pointer
    property_notify_event*: pointer
    selection_clear_event*: pointer
    selection_request_event*: pointer
    selection_notify_event*: pointer
    proximity_in_event*: pointer
    proximity_out_event*: pointer
    visibility_notify_event*: pointer
    window_state_event*: pointer
    damage_event*: pointer
    grab_broken_event*: pointer
    selection_get*: pointer
    selection_received*: pointer
    drag_begin*: pointer
    drag_end*: pointer
    drag_data_get*: pointer
    drag_data_delete*: pointer
    drag_leave*: pointer
    drag_motion*: pointer
    drag_drop*: pointer
    drag_data_received*: pointer
    drag_failed*: pointer
    popup_menu*: pointer
    show_help*: pointer
    get_accessible*: pointer
    screen_changed*: pointer
    can_activate_accel*: pointer
    composited_changed*: pointer
    query_tooltip*: pointer
    compute_expand*: pointer
    adjust_size_request*: pointer
    adjust_size_allocation*: pointer
    style_updated*: pointer
    touch_event*: pointer
    get_preferred_height_and_baseline_for_width*: pointer
    adjust_baseline_request*: pointer
    adjust_baseline_allocation*: pointer
    queue_draw_region*: pointer
    priv*: ptr TWidgetClassPrivate
    gtk_reserved6*: pointer
    gtk_reserved7*: pointer

# wrapped: TWidgetClassPrivate
# unwrapped: TWidgetClassPrivate
  TWidgetClassPrivate* {.pure,inheritable.} = object

# wrapped: TWidgetPath
# unwrapped: TWidgetPath
  TWidgetPath* {.pure,inheritable.} = object

# wrapped: TWidgetPrivate
# unwrapped: TWidgetPrivate
  TWidgetPrivate* {.pure,inheritable.} = object

# wrapped: TWindowAccessibleClass
# unwrapped: TWindowAccessibleClass
  TWindowAccessibleClass* {.pure,inheritable.} = object
    parent_class*: TContainerAccessibleClass

# wrapped: TWindowAccessiblePrivate
# unwrapped: TWindowAccessiblePrivate
  TWindowAccessiblePrivate* {.pure,inheritable.} = object

# wrapped: TWindowClass
# unwrapped: TWindowClass
  TWindowClass* {.pure,inheritable.} = object
    parent_class*: TBinClass
    set_focus*: pointer
    activate_focus*: pointer
    activate_default*: pointer
    keys_changed*: pointer
    enable_debugging*: pointer
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer

# wrapped: TWindowGeometryInfo
# unwrapped: TWindowGeometryInfo
  TWindowGeometryInfo* {.pure,inheritable.} = object

# wrapped: TWindowGroupClass
# unwrapped: TWindowGroupClass
  TWindowGroupClass* {.pure,inheritable.} = object
    parent_class*: GObject2.TObjectClass
    gtk_reserved1*: pointer
    gtk_reserved2*: pointer
    gtk_reserved3*: pointer
    gtk_reserved4*: pointer

# wrapped: TWindowGroupPrivate
# unwrapped: TWindowGroupPrivate
  TWindowGroupPrivate* {.pure,inheritable.} = object

# wrapped: TWindowPrivate
# unwrapped: TWindowPrivate
  TWindowPrivate* {.pure,inheritable.} = object

  # unions
  #------------------
  # interfaces
  #------------------
# wrapped: TActionable
# unwrapped: TActionable
  TActionable* {.pure,inheritable.} = object

# wrapped: TActivatable
# unwrapped: TActivatable
  TActivatable* {.pure,inheritable.} = object

# wrapped: TAppChooser
# unwrapped: TAppChooser
  TAppChooser* {.pure,inheritable.} = object

# wrapped: TBuildable
# unwrapped: TBuildable
  TBuildable* {.pure,inheritable.} = object

# wrapped: TCellAccessibleParent
# unwrapped: TCellAccessibleParent
  TCellAccessibleParent* {.pure,inheritable.} = object

# wrapped: TCellEditable
# unwrapped: TCellEditable
  TCellEditable* {.pure,inheritable.} = object

# wrapped: TCellLayout
# unwrapped: TCellLayout
  TCellLayout* {.pure,inheritable.} = object

# wrapped: TColorChooser
# unwrapped: TColorChooser
  TColorChooser* {.pure,inheritable.} = object

# wrapped: TEditable
# unwrapped: TEditable
  TEditable* {.pure,inheritable.} = object

# wrapped: TFileChooser
# unwrapped: TFileChooser
  TFileChooser* {.pure,inheritable.} = object

# wrapped: TFontChooser
# unwrapped: TFontChooser
  TFontChooser* {.pure,inheritable.} = object

# wrapped: TOrientable
# unwrapped: TOrientable
  TOrientable* {.pure,inheritable.} = object

# wrapped: TPrintOperationPreview
# unwrapped: TPrintOperationPreview
  TPrintOperationPreview* {.pure,inheritable.} = object

# wrapped: TRecentChooser
# unwrapped: TRecentChooser
  TRecentChooser* {.pure,inheritable.} = object

# wrapped: TScrollable
# unwrapped: TScrollable
  TScrollable* {.pure,inheritable.} = object

# wrapped: TStyleProvider
# unwrapped: TStyleProvider
  TStyleProvider* {.pure,inheritable.} = object

# wrapped: TToolShell
# unwrapped: TToolShell
  TToolShell* {.pure,inheritable.} = object

# wrapped: TTreeDragDest
# unwrapped: TTreeDragDest
  TTreeDragDest* {.pure,inheritable.} = object

# wrapped: TTreeDragSource
# unwrapped: TTreeDragSource
  TTreeDragSource* {.pure,inheritable.} = object

# wrapped: TTreeModel
# unwrapped: TTreeModel
  TTreeModel* {.pure,inheritable.} = object

# wrapped: TTreeSortable
# unwrapped: TTreeSortable
  TTreeSortable* {.pure,inheritable.} = object

  # enums
  #------------------
  Align* {.pure,size: sizeof(uint32).} = enum
    fill,
    start,
    `end`,
    center,
    baseline,


  ArrowPlacement* {.pure,size: sizeof(uint32).} = enum
    both,
    start,
    `end`,


  ArrowType* {.pure,size: sizeof(uint32).} = enum
    up,
    down,
    left,
    right,
    none,


  AssistantPageType* {.pure,size: sizeof(uint32).} = enum
    content,
    intro,
    confirm,
    summary,
    progress,
    custom,


  BaselinePosition* {.pure,size: sizeof(uint32).} = enum
    top,
    center,
    bottom,


  BorderStyle* {.pure,size: sizeof(uint32).} = enum
    none,
    solid,
    inset,
    outset,
    hidden,
    dotted,
    dashed,
    double,
    groove,
    ridge,


  BuilderError* {.pure,size: sizeof(uint32).} = enum
    invalid_type_function,
    unhandled_tag,
    missing_attribute,
    invalid_attribute,
    invalid_tag,
    missing_property_value,
    invalid_value,
    version_mismatch,
    duplicate_id,
    object_type_refused,
    template_mismatch,
    invalid_property,
    invalid_signal,
    invalid_id,


  ButtonBoxStyle* {.pure,size: sizeof(uint32).} = enum
    spread = 1,
    edge,
    start,
    `end`,
    center,
    expand,


  ButtonRole* {.pure,size: sizeof(uint32).} = enum
    normal,
    check,
    radio,


  ButtonsType* {.pure,size: sizeof(uint32).} = enum
    none,
    ok,
    close,
    cancel,
    yes_no,
    ok_cancel,


  CellRendererAccelMode* {.pure,size: sizeof(uint32).} = enum
    gtk,
    other,


  CellRendererMode* {.pure,size: sizeof(uint32).} = enum
    inert,
    activatable,
    editable,


  CornerType* {.pure,size: sizeof(uint32).} = enum
    top_left,
    bottom_left,
    top_right,
    bottom_right,


  CssProviderError* {.pure,size: sizeof(uint32).} = enum
    failed,
    syntax,
    `import`,
    name,
    deprecated,
    unknown_value,


  CssSectionType* {.pure,size: sizeof(uint32).} = enum
    document,
    `import`,
    color_definition,
    binding_set,
    ruleset,
    selector,
    declaration,
    value,
    keyframes,


  DeleteType* {.pure,size: sizeof(uint32).} = enum
    chars,
    word_ends,
    words,
    display_lines,
    display_line_ends,
    paragraph_ends,
    paragraphs,
    whitespace,


  DirectionType* {.pure,size: sizeof(uint32).} = enum
    tab_forward,
    tab_backward,
    up,
    down,
    left,
    right,


  DragResult* {.pure,size: sizeof(uint32).} = enum
    success,
    no_target,
    user_cancelled,
    timeout_expired,
    grab_broken,
    error,


  EntryIconPosition* {.pure,size: sizeof(uint32).} = enum
    primary,
    secondary,


  EventSequenceState* {.pure,size: sizeof(uint32).} = enum
    none,
    claimed,
    denied,


  ExpanderStyle* {.pure,size: sizeof(uint32).} = enum
    collapsed,
    semi_collapsed,
    semi_expanded,
    expanded,


  FileChooserAction* {.pure,size: sizeof(uint32).} = enum
    open,
    save,
    select_folder,
    create_folder,


  FileChooserConfirmation* {.pure,size: sizeof(uint32).} = enum
    confirm,
    accept_filename,
    select_again,


  FileChooserError* {.pure,size: sizeof(uint32).} = enum
    nonexistent,
    bad_filename,
    already_exists,
    incomplete_hostname,


  IMPreeditStyle* {.pure,size: sizeof(uint32).} = enum
    nothing,
    callback,
    none,


  IMStatusStyle* {.pure,size: sizeof(uint32).} = enum
    nothing,
    callback,
    none,


  IconSize* {.pure,size: sizeof(uint32).} = enum
    invalid,
    menu,
    small_toolbar,
    large_toolbar,
    button,
    dnd,
    dialog,


  IconThemeError* {.pure,size: sizeof(uint32).} = enum
    not_found,
    failed,


  IconViewDropPosition* {.pure,size: sizeof(uint32).} = enum
    no_drop,
    drop_into,
    drop_left,
    drop_right,
    drop_above,
    drop_below,


  ImageType* {.pure,size: sizeof(uint32).} = enum
    empty,
    pixbuf,
    stock,
    icon_set,
    animation,
    icon_name,
    gicon,
    surface,


  InputPurpose* {.pure,size: sizeof(uint32).} = enum
    free_form,
    alpha,
    digits,
    number,
    phone,
    url,
    email,
    name,
    password,
    pin,


  Justification* {.pure,size: sizeof(uint32).} = enum
    left,
    right,
    center,
    fill,


  LevelBarMode* {.pure,size: sizeof(uint32).} = enum
    continuous,
    discrete,


  License* {.pure,size: sizeof(uint32).} = enum
    unknown,
    custom,
    gpl_2_0,
    gpl_3_0,
    lgpl_2_1,
    lgpl_3_0,
    bsd,
    mit_x11,
    artistic,
    gpl_2_0_only,
    gpl_3_0_only,
    lgpl_2_1_only,
    lgpl_3_0_only,


  MenuDirectionType* {.pure,size: sizeof(uint32).} = enum
    parent,
    child,
    next,
    prev,


  MessageType* {.pure,size: sizeof(uint32).} = enum
    info,
    warning,
    question,
    error,
    other,


  MovementStep* {.pure,size: sizeof(uint32).} = enum
    logical_positions,
    visual_positions,
    words,
    display_lines,
    display_line_ends,
    paragraphs,
    paragraph_ends,
    pages,
    buffer_ends,
    horizontal_pages,


  NotebookTab* {.pure,size: sizeof(uint32).} = enum
    first,
    last,


  NumberUpLayout* {.pure,size: sizeof(uint32).} = enum
    lrtb,
    lrbt,
    rltb,
    rlbt,
    tblr,
    tbrl,
    btlr,
    btrl,


  Orientation* {.pure,size: sizeof(uint32).} = enum
    horizontal,
    vertical,


  PackDirection* {.pure,size: sizeof(uint32).} = enum
    ltr,
    rtl,
    ttb,
    btt,


  PackType* {.pure,size: sizeof(uint32).} = enum
    start,
    `end`,


  PageOrientation* {.pure,size: sizeof(uint32).} = enum
    portrait,
    landscape,
    reverse_portrait,
    reverse_landscape,


  PageSet* {.pure,size: sizeof(uint32).} = enum
    all,
    even,
    odd,


  PanDirection* {.pure,size: sizeof(uint32).} = enum
    left,
    right,
    up,
    down,


  PathPriorityType* {.pure,size: sizeof(uint32).} = enum
    lowest,
    gtk = 4,
    application = 8,
    theme = 10,
    rc = 12,
    highest = 15,


  PathType* {.pure,size: sizeof(uint32).} = enum
    widget,
    widget_class,
    class,


  PolicyType* {.pure,size: sizeof(uint32).} = enum
    always,
    automatic,
    never,
    external,


  PositionType* {.pure,size: sizeof(uint32).} = enum
    left,
    right,
    top,
    bottom,


  PrintDuplex* {.pure,size: sizeof(uint32).} = enum
    simplex,
    horizontal,
    vertical,


  PrintError* {.pure,size: sizeof(uint32).} = enum
    general,
    internal_error,
    nomem,
    invalid_file,


  PrintOperationAction* {.pure,size: sizeof(uint32).} = enum
    print_dialog,
    print,
    preview,
    `export`,


  PrintOperationResult* {.pure,size: sizeof(uint32).} = enum
    error,
    apply,
    cancel,
    in_progress,


  PrintPages* {.pure,size: sizeof(uint32).} = enum
    all,
    current,
    ranges,
    selection,


  PrintQuality* {.pure,size: sizeof(uint32).} = enum
    low,
    normal,
    high,
    draft,


  PrintStatus* {.pure,size: sizeof(uint32).} = enum
    initial,
    preparing,
    generating_data,
    sending_data,
    pending,
    pending_issue,
    printing,
    finished,
    finished_aborted,


  PropagationPhase* {.pure,size: sizeof(uint32).} = enum
    none,
    capture,
    bubble,
    target,


  RcTokenType* {.pure,size: sizeof(uint32).} = enum
    invalid = 270,
    `include`,
    normal,
    active,
    prelight,
    selected,
    insensitive,
    fg,
    bg,
    text,
    base,
    xthickness,
    ythickness,
    font,
    fontset,
    font_name,
    bg_pixmap,
    pixmap_path,
    style,
    binding,
    `bind`,
    widget,
    widget_class,
    class,
    lowest,
    gtk,
    application,
    theme,
    rc,
    highest,
    engine,
    module_path,
    im_module_path,
    im_module_file,
    stock,
    ltr,
    rtl,
    color,
    unbind,
    last,


  RecentChooserError* {.pure,size: sizeof(uint32).} = enum
    not_found,
    invalid_uri,


  RecentManagerError* {.pure,size: sizeof(uint32).} = enum
    not_found,
    invalid_uri,
    invalid_encoding,
    not_registered,
    read,
    write,
    unknown,


  RecentSortType* {.pure,size: sizeof(uint32).} = enum
    none,
    mru,
    lru,
    custom,


  ReliefStyle* {.pure,size: sizeof(uint32).} = enum
    normal,
    half,
    none,


  ResizeMode* {.pure,size: sizeof(uint32).} = enum
    parent,
    queue,
    immediate,


  ResponseType* {.pure,size: sizeof(int32).} = enum
    help = -11,
    apply,
    no,
    yes,
    close,
    cancel,
    ok,
    delete_event,
    accept,
    reject,
    none,


  RevealerTransitionType* {.pure,size: sizeof(uint32).} = enum
    none,
    crossfade,
    slide_right,
    slide_left,
    slide_up,
    slide_down,


  ScrollStep* {.pure,size: sizeof(uint32).} = enum
    steps,
    pages,
    ends,
    horizontal_steps,
    horizontal_pages,
    horizontal_ends,


  ScrollType* {.pure,size: sizeof(uint32).} = enum
    none,
    jump,
    step_backward,
    step_forward,
    page_backward,
    page_forward,
    step_up,
    step_down,
    page_up,
    page_down,
    step_left,
    step_right,
    page_left,
    page_right,
    start,
    `end`,


  ScrollablePolicy* {.pure,size: sizeof(uint32).} = enum
    minimum,
    natural,


  SelectionMode* {.pure,size: sizeof(uint32).} = enum
    none,
    single,
    browse,
    multiple,


  SensitivityType* {.pure,size: sizeof(uint32).} = enum
    auto,
    on,
    off,


  ShadowType* {.pure,size: sizeof(uint32).} = enum
    none,
    `in`,
    `out`,
    etched_in,
    etched_out,


  SizeGroupMode* {.pure,size: sizeof(uint32).} = enum
    none,
    horizontal,
    vertical,
    both,


  SizeRequestMode* {.pure,size: sizeof(uint32).} = enum
    height_for_width,
    width_for_height,
    constant_size,


  SortType* {.pure,size: sizeof(uint32).} = enum
    ascending,
    descending,


  SpinButtonUpdatePolicy* {.pure,size: sizeof(uint32).} = enum
    always,
    if_valid,


  SpinType* {.pure,size: sizeof(uint32).} = enum
    step_forward,
    step_backward,
    page_forward,
    page_backward,
    home,
    `end`,
    user_defined,


  StackTransitionType* {.pure,size: sizeof(uint32).} = enum
    none,
    crossfade,
    slide_right,
    slide_left,
    slide_up,
    slide_down,
    slide_left_right,
    slide_up_down,
    over_up,
    over_down,
    over_left,
    over_right,
    under_up,
    under_down,
    under_left,
    under_right,
    over_up_down,
    over_down_up,
    over_left_right,
    over_right_left,


  StateType* {.pure,size: sizeof(uint32).} = enum
    normal,
    active,
    prelight,
    selected,
    insensitive,
    inconsistent,
    focused,


  TextBufferTargetInfo* {.pure,size: sizeof(int32).} = enum
    text = -3,
    rich_text,
    buffer_contents,


  TextDirection* {.pure,size: sizeof(uint32).} = enum
    none,
    ltr,
    rtl,


  TextExtendSelection* {.pure,size: sizeof(uint32).} = enum
    word,
    line,


  TextViewLayer* {.pure,size: sizeof(uint32).} = enum
    below,
    above,


  TextWindowType* {.pure,size: sizeof(uint32).} = enum
    private,
    widget,
    text,
    left,
    right,
    top,
    bottom,


  ToolbarSpaceStyle* {.pure,size: sizeof(uint32).} = enum
    empty,
    line,


  ToolbarStyle* {.pure,size: sizeof(uint32).} = enum
    icons,
    text,
    both,
    both_horiz,


  TreeViewColumnSizing* {.pure,size: sizeof(uint32).} = enum
    grow_only,
    autosize,
    fixed,


  TreeViewDropPosition* {.pure,size: sizeof(uint32).} = enum
    before,
    after,
    into_or_before,
    into_or_after,


  TreeViewGridLines* {.pure,size: sizeof(uint32).} = enum
    none,
    horizontal,
    vertical,
    both,


  Unit* {.pure,size: sizeof(uint32).} = enum
    none,
    points,
    inch,
    mm,


  WidgetHelpType* {.pure,size: sizeof(uint32).} = enum
    tooltip,
    whats_this,


  WindowPosition* {.pure,size: sizeof(uint32).} = enum
    none,
    center,
    mouse,
    center_always,
    center_on_parent,


  WindowType* {.pure,size: sizeof(uint32).} = enum
    toplevel,
    popup,


  WrapMode* {.pure,size: sizeof(uint32).} = enum
    none,
    char,
    word,
    word_char,


  # flags
  SAccelFlags* = uint32
  AccelFlags* {.pure,size: sizeof(uint32).} = enum
    visible = 1,
    locked = 2,
    mask = 7,


  # flags
  SApplicationInhibitFlags* = uint32
  ApplicationInhibitFlags* {.pure,size: sizeof(uint32).} = enum
    logout = 1,
    switch = 2,
    suspend = 4,
    idle = 8,


  # flags
  SAttachOptions* = uint32
  AttachOptions* {.pure,size: sizeof(uint32).} = enum
    expand = 1,
    shrink = 2,
    fill = 4,


  # flags
  SCalendarDisplayOptions* = uint32
  CalendarDisplayOptions* {.pure,size: sizeof(uint32).} = enum
    show_heading = 1,
    show_day_names = 2,
    no_month_change = 4,
    show_week_numbers = 8,
    show_details = 32,


  # flags
  SCellRendererState* = uint32
  CellRendererState* {.pure,size: sizeof(uint32).} = enum
    selected = 1,
    prelit = 2,
    insensitive = 4,
    sorted = 8,
    focused = 16,
    expandable = 32,
    expanded = 64,


  # flags
  SDebugFlag* = uint32
  DebugFlag* {.pure,size: sizeof(uint32).} = enum
    misc = 1,
    plugsocket = 2,
    text = 4,
    tree = 8,
    updates = 16,
    keybindings = 32,
    multihead = 64,
    modules = 128,
    geometry = 256,
    icontheme = 512,
    printing = 1024,
    builder = 2048,
    size_request = 4096,
    no_css_cache = 8192,
    baselines = 16384,
    pixel_cache = 32768,
    no_pixel_cache = 65536,
    interactive = 131072,
    touchscreen = 262144,
    actions = 524288,


  # flags
  SDestDefaults* = uint32
  DestDefaults* {.pure,size: sizeof(uint32).} = enum
    motion = 1,
    highlight = 2,
    drop = 4,
    all = 7,


  # flags
  SDialogFlags* = uint32
  DialogFlags* {.pure,size: sizeof(uint32).} = enum
    modal = 1,
    destroy_with_parent = 2,
    use_header_bar = 4,


  # flags
  SFileFilterFlags* = uint32
  FileFilterFlags* {.pure,size: sizeof(uint32).} = enum
    filename = 1,
    uri = 2,
    display_name = 4,
    mime_type = 8,


  # flags
  SIconLookupFlags* = uint32
  IconLookupFlags* {.pure,size: sizeof(uint32).} = enum
    no_svg = 1,
    force_svg = 2,
    use_builtin = 4,
    generic_fallback = 8,
    force_size = 16,
    force_regular = 32,
    force_symbolic = 64,
    dir_ltr = 128,
    dir_rtl = 256,


  # flags
  SInputHints* = uint32
  InputHints* {.pure,size: sizeof(uint32).} = enum
    none = 0,
    spellcheck = 1,
    no_spellcheck = 2,
    word_completion = 4,
    lowercase = 8,
    uppercase_chars = 16,
    uppercase_words = 32,
    uppercase_sentences = 64,
    inhibit_osk = 128,
    vertical_writing = 256,


  # flags
  SJunctionSides* = uint32
  JunctionSides* {.pure,size: sizeof(uint32).} = enum
    none = 0,
    corner_topleft = 1,
    corner_topright = 2,
    top = 3,
    corner_bottomleft = 4,
    left = 5,
    corner_bottomright = 8,
    right = 10,
    bottom = 12,


  # flags
  SPlacesOpenFlags* = uint32
  PlacesOpenFlags* {.pure,size: sizeof(uint32).} = enum
    normal = 1,
    new_tab = 2,
    new_window = 4,


  # flags
  SRcFlags* = uint32
  RcFlags* {.pure,size: sizeof(uint32).} = enum
    fg = 1,
    bg = 2,
    text = 4,
    base = 8,


  # flags
  SRecentFilterFlags* = uint32
  RecentFilterFlags* {.pure,size: sizeof(uint32).} = enum
    uri = 1,
    display_name = 2,
    mime_type = 4,
    application = 8,
    group = 16,
    age = 32,


  # flags
  SRegionFlags* = uint32
  RegionFlags* {.pure,size: sizeof(uint32).} = enum
    even = 1,
    odd = 2,
    first = 4,
    last = 8,
    only = 16,
    sorted = 32,


  # flags
  SStateFlags* = uint32
  StateFlags* {.pure,size: sizeof(uint32).} = enum
    normal = 0,
    active = 1,
    prelight = 2,
    selected = 4,
    insensitive = 8,
    inconsistent = 16,
    focused = 32,
    backdrop = 64,
    dir_ltr = 128,
    dir_rtl = 256,
    link = 512,
    visited = 1024,
    checked = 2048,


  # flags
  STargetFlags* = uint32
  TargetFlags* {.pure,size: sizeof(uint32).} = enum
    same_app = 1,
    same_widget = 2,
    other_app = 4,
    other_widget = 8,


  # flags
  STextSearchFlags* = uint32
  TextSearchFlags* {.pure,size: sizeof(uint32).} = enum
    visible_only = 1,
    text_only = 2,
    case_insensitive = 4,


  # flags
  SToolPaletteDragTargets* = uint32
  ToolPaletteDragTargets* {.pure,size: sizeof(uint32).} = enum
    items = 1,
    groups = 2,


  # flags
  STreeModelFlags* = uint32
  TreeModelFlags* {.pure,size: sizeof(uint32).} = enum
    iters_persist = 1,
    list_only = 2,


  # flags
  SUIManagerItemType* = uint32
  UIManagerItemType* {.pure,size: sizeof(uint32).} = enum
    auto = 0,
    menubar = 1,
    menu = 2,
    toolbar = 4,
    placeholder = 8,
    popup = 16,
    menuitem = 32,
    toolitem = 64,
    separator = 128,
    accelerator = 256,
    popup_with_accels = 512,


  # constants
  #------------------
# BINARY_AGE
# INPUT_ERROR
# INTERFACE_AGE
# LEVEL_BAR_OFFSET_HIGH
# LEVEL_BAR_OFFSET_LOW
# MAJOR_VERSION
# MAX_COMPOSE_LEN
# MICRO_VERSION
# MINOR_VERSION
# PAPER_NAME_A3
# PAPER_NAME_A4
# PAPER_NAME_A5
# PAPER_NAME_B5
# PAPER_NAME_EXECUTIVE
# PAPER_NAME_LEGAL
# PAPER_NAME_LETTER
# PATH_PRIO_MASK
# PRINT_SETTINGS_COLLATE
# PRINT_SETTINGS_DEFAULT_SOURCE
# PRINT_SETTINGS_DITHER
# PRINT_SETTINGS_DUPLEX
# PRINT_SETTINGS_FINISHINGS
# PRINT_SETTINGS_MEDIA_TYPE
# PRINT_SETTINGS_NUMBER_UP
# PRINT_SETTINGS_NUMBER_UP_LAYOUT
# PRINT_SETTINGS_N_COPIES
# PRINT_SETTINGS_ORIENTATION
# PRINT_SETTINGS_OUTPUT_BASENAME
# PRINT_SETTINGS_OUTPUT_BIN
# PRINT_SETTINGS_OUTPUT_DIR
# PRINT_SETTINGS_OUTPUT_FILE_FORMAT
# PRINT_SETTINGS_OUTPUT_URI
# PRINT_SETTINGS_PAGE_RANGES
# PRINT_SETTINGS_PAGE_SET
# PRINT_SETTINGS_PAPER_FORMAT
# PRINT_SETTINGS_PAPER_HEIGHT
# PRINT_SETTINGS_PAPER_WIDTH
# PRINT_SETTINGS_PRINTER
# PRINT_SETTINGS_PRINTER_LPI
# PRINT_SETTINGS_PRINT_PAGES
# PRINT_SETTINGS_QUALITY
# PRINT_SETTINGS_RESOLUTION
# PRINT_SETTINGS_RESOLUTION_X
# PRINT_SETTINGS_RESOLUTION_Y
# PRINT_SETTINGS_REVERSE
# PRINT_SETTINGS_SCALE
# PRINT_SETTINGS_USE_COLOR
# PRINT_SETTINGS_WIN32_DRIVER_EXTRA
# PRINT_SETTINGS_WIN32_DRIVER_VERSION
# PRIORITY_RESIZE
# STOCK_ABOUT
# STOCK_ADD
# STOCK_APPLY
# STOCK_BOLD
# STOCK_CANCEL
# STOCK_CAPS_LOCK_WARNING
# STOCK_CDROM
# STOCK_CLEAR
# STOCK_CLOSE
# STOCK_COLOR_PICKER
# STOCK_CONNECT
# STOCK_CONVERT
# STOCK_COPY
# STOCK_CUT
# STOCK_DELETE
# STOCK_DIALOG_AUTHENTICATION
# STOCK_DIALOG_ERROR
# STOCK_DIALOG_INFO
# STOCK_DIALOG_QUESTION
# STOCK_DIALOG_WARNING
# STOCK_DIRECTORY
# STOCK_DISCARD
# STOCK_DISCONNECT
# STOCK_DND
# STOCK_DND_MULTIPLE
# STOCK_EDIT
# STOCK_EXECUTE
# STOCK_FILE
# STOCK_FIND
# STOCK_FIND_AND_REPLACE
# STOCK_FLOPPY
# STOCK_FULLSCREEN
# STOCK_GOTO_BOTTOM
# STOCK_GOTO_FIRST
# STOCK_GOTO_LAST
# STOCK_GOTO_TOP
# STOCK_GO_BACK
# STOCK_GO_DOWN
# STOCK_GO_FORWARD
# STOCK_GO_UP
# STOCK_HARDDISK
# STOCK_HELP
# STOCK_HOME
# STOCK_INDENT
# STOCK_INDEX
# STOCK_INFO
# STOCK_ITALIC
# STOCK_JUMP_TO
# STOCK_JUSTIFY_CENTER
# STOCK_JUSTIFY_FILL
# STOCK_JUSTIFY_LEFT
# STOCK_JUSTIFY_RIGHT
# STOCK_LEAVE_FULLSCREEN
# STOCK_MEDIA_FORWARD
# STOCK_MEDIA_NEXT
# STOCK_MEDIA_PAUSE
# STOCK_MEDIA_PLAY
# STOCK_MEDIA_PREVIOUS
# STOCK_MEDIA_RECORD
# STOCK_MEDIA_REWIND
# STOCK_MEDIA_STOP
# STOCK_MISSING_IMAGE
# STOCK_NETWORK
# STOCK_NEW
# STOCK_NO
# STOCK_OK
# STOCK_OPEN
# STOCK_ORIENTATION_LANDSCAPE
# STOCK_ORIENTATION_PORTRAIT
# STOCK_ORIENTATION_REVERSE_LANDSCAPE
# STOCK_ORIENTATION_REVERSE_PORTRAIT
# STOCK_PAGE_SETUP
# STOCK_PASTE
# STOCK_PREFERENCES
# STOCK_PRINT
# STOCK_PRINT_ERROR
# STOCK_PRINT_PAUSED
# STOCK_PRINT_PREVIEW
# STOCK_PRINT_REPORT
# STOCK_PRINT_WARNING
# STOCK_PROPERTIES
# STOCK_QUIT
# STOCK_REDO
# STOCK_REFRESH
# STOCK_REMOVE
# STOCK_REVERT_TO_SAVED
# STOCK_SAVE
# STOCK_SAVE_AS
# STOCK_SELECT_ALL
# STOCK_SELECT_COLOR
# STOCK_SELECT_FONT
# STOCK_SORT_ASCENDING
# STOCK_SORT_DESCENDING
# STOCK_SPELL_CHECK
# STOCK_STOP
# STOCK_STRIKETHROUGH
# STOCK_UNDELETE
# STOCK_UNDERLINE
# STOCK_UNDO
# STOCK_UNINDENT
# STOCK_YES
# STOCK_ZOOM_100
# STOCK_ZOOM_FIT
# STOCK_ZOOM_IN
# STOCK_ZOOM_OUT
# STYLE_CLASS_ACCELERATOR
# STYLE_CLASS_ARROW
# STYLE_CLASS_BACKGROUND
# STYLE_CLASS_BOTTOM
# STYLE_CLASS_BUTTON
# STYLE_CLASS_CALENDAR
# STYLE_CLASS_CELL
# STYLE_CLASS_CHECK
# STYLE_CLASS_COMBOBOX_ENTRY
# STYLE_CLASS_CONTEXT_MENU
# STYLE_CLASS_CSD
# STYLE_CLASS_CURSOR_HANDLE
# STYLE_CLASS_DEFAULT
# STYLE_CLASS_DESTRUCTIVE_ACTION
# STYLE_CLASS_DIM_LABEL
# STYLE_CLASS_DND
# STYLE_CLASS_DOCK
# STYLE_CLASS_ENTRY
# STYLE_CLASS_ERROR
# STYLE_CLASS_EXPANDER
# STYLE_CLASS_FLAT
# STYLE_CLASS_FRAME
# STYLE_CLASS_GRIP
# STYLE_CLASS_HEADER
# STYLE_CLASS_HIGHLIGHT
# STYLE_CLASS_HORIZONTAL
# STYLE_CLASS_IMAGE
# STYLE_CLASS_INFO
# STYLE_CLASS_INLINE_TOOLBAR
# STYLE_CLASS_INSERTION_CURSOR
# STYLE_CLASS_LABEL
# STYLE_CLASS_LEFT
# STYLE_CLASS_LEVEL_BAR
# STYLE_CLASS_LINKED
# STYLE_CLASS_LIST
# STYLE_CLASS_LIST_ROW
# STYLE_CLASS_MARK
# STYLE_CLASS_MENU
# STYLE_CLASS_MENUBAR
# STYLE_CLASS_MENUITEM
# STYLE_CLASS_MESSAGE_DIALOG
# STYLE_CLASS_MONOSPACE
# STYLE_CLASS_NEEDS_ATTENTION
# STYLE_CLASS_NOTEBOOK
# STYLE_CLASS_OSD
# STYLE_CLASS_OVERSHOOT
# STYLE_CLASS_PANE_SEPARATOR
# STYLE_CLASS_PAPER
# STYLE_CLASS_POPOVER
# STYLE_CLASS_POPUP
# STYLE_CLASS_PRIMARY_TOOLBAR
# STYLE_CLASS_PROGRESSBAR
# STYLE_CLASS_PULSE
# STYLE_CLASS_QUESTION
# STYLE_CLASS_RADIO
# STYLE_CLASS_RAISED
# STYLE_CLASS_READ_ONLY
# STYLE_CLASS_RIGHT
# STYLE_CLASS_RUBBERBAND
# STYLE_CLASS_SCALE
# STYLE_CLASS_SCALE_HAS_MARKS_ABOVE
# STYLE_CLASS_SCALE_HAS_MARKS_BELOW
# STYLE_CLASS_SCROLLBAR
# STYLE_CLASS_SCROLLBARS_JUNCTION
# STYLE_CLASS_SEPARATOR
# STYLE_CLASS_SIDEBAR
# STYLE_CLASS_SLIDER
# STYLE_CLASS_SPINBUTTON
# STYLE_CLASS_SPINNER
# STYLE_CLASS_STATUSBAR
# STYLE_CLASS_SUBTITLE
# STYLE_CLASS_SUGGESTED_ACTION
# STYLE_CLASS_TITLE
# STYLE_CLASS_TITLEBAR
# STYLE_CLASS_TOOLBAR
# STYLE_CLASS_TOOLTIP
# STYLE_CLASS_TOP
# STYLE_CLASS_TOUCH_SELECTION
# STYLE_CLASS_TROUGH
# STYLE_CLASS_UNDERSHOOT
# STYLE_CLASS_VERTICAL
# STYLE_CLASS_VIEW
# STYLE_CLASS_WARNING
# STYLE_CLASS_WIDE
# STYLE_PROPERTY_BACKGROUND_COLOR
# STYLE_PROPERTY_BACKGROUND_IMAGE
# STYLE_PROPERTY_BORDER_COLOR
# STYLE_PROPERTY_BORDER_RADIUS
# STYLE_PROPERTY_BORDER_STYLE
# STYLE_PROPERTY_BORDER_WIDTH
# STYLE_PROPERTY_COLOR
# STYLE_PROPERTY_FONT
# STYLE_PROPERTY_MARGIN
# STYLE_PROPERTY_PADDING
# STYLE_PROVIDER_PRIORITY_APPLICATION
# STYLE_PROVIDER_PRIORITY_FALLBACK
# STYLE_PROVIDER_PRIORITY_SETTINGS
# STYLE_PROVIDER_PRIORITY_THEME
# STYLE_PROVIDER_PRIORITY_USER
# STYLE_REGION_COLUMN
# STYLE_REGION_COLUMN_HEADER
# STYLE_REGION_ROW
# STYLE_REGION_TAB
# TEXT_VIEW_PRIORITY_VALIDATE
# TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID
# TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID
declareSubclass(TWidget, GObject2.TInitiallyUnowned)
declareSubclass(TContainer, TWidget)
declareSubclass(TBin, TContainer)
declareSubclass(TWindow, TBin)
declareSubclass(TDialog, TWindow)
declareSubclass(TAboutDialog, TDialog)
declareSubclass(TAccelGroup, GObject2.TObject)
declareSubclass(TMisc, TWidget)
declareSubclass(TLabel, TMisc)
declareSubclass(TAccelLabel, TLabel)
declareSubclass(TAccelMap, GObject2.TObject)
declareSubclass(TAccessible, Atk1.TObject)
declareSubclass(TAction, GObject2.TObject)
declareSubclass(TActionBar, TBin)
declareSubclass(TActionGroup, GObject2.TObject)
declareSubclass(TAdjustment, GObject2.TInitiallyUnowned)
declareSubclass(TAlignment, TBin)
declareSubclass(TComboBox, TBin)
declareSubclass(TAppChooserButton, TComboBox)
declareSubclass(TAppChooserDialog, TDialog)
declareSubclass(TBox, TContainer)
declareSubclass(TAppChooserWidget, TBox)
declareSubclass(TApplication, Gio2.TApplication)
declareSubclass(TApplicationWindow, TWindow)
declareSubclass(TArrow, TMisc)
declareSubclass(TWidgetAccessible, TAccessible)
declareSubclass(TArrowAccessible, TWidgetAccessible)
declareSubclass(TFrame, TBin)
declareSubclass(TAspectFrame, TFrame)
declareSubclass(TAssistant, TWindow)
declareSubclass(TCellAccessible, TAccessible)
declareSubclass(TRendererCellAccessible, TCellAccessible)
declareSubclass(TBooleanCellAccessible, TRendererCellAccessible)
declareSubclass(TBuilder, GObject2.TObject)
declareSubclass(TButton, TBin)
declareSubclass(TContainerAccessible, TWidgetAccessible)
declareSubclass(TButtonAccessible, TContainerAccessible)
declareSubclass(TButtonBox, TBox)
declareSubclass(TCalendar, TWidget)
declareSubclass(TCellArea, GObject2.TInitiallyUnowned)
declareSubclass(TCellAreaBox, TCellArea)
declareSubclass(TCellAreaContext, GObject2.TObject)
declareSubclass(TCellRenderer, GObject2.TInitiallyUnowned)
declareSubclass(TCellRendererText, TCellRenderer)
declareSubclass(TCellRendererAccel, TCellRendererText)
declareSubclass(TCellRendererCombo, TCellRendererText)
declareSubclass(TCellRendererPixbuf, TCellRenderer)
declareSubclass(TCellRendererProgress, TCellRenderer)
declareSubclass(TCellRendererSpin, TCellRendererText)
declareSubclass(TCellRendererSpinner, TCellRenderer)
declareSubclass(TCellRendererToggle, TCellRenderer)
declareSubclass(TCellView, TWidget)
declareSubclass(TToggleButton, TButton)
declareSubclass(TCheckButton, TToggleButton)
declareSubclass(TMenuItem, TBin)
declareSubclass(TCheckMenuItem, TMenuItem)
declareSubclass(TMenuItemAccessible, TContainerAccessible)
declareSubclass(TCheckMenuItemAccessible, TMenuItemAccessible)
declareSubclass(TClipboard, GObject2.TObject)
declareSubclass(TColorButton, TButton)
declareSubclass(TColorChooserDialog, TDialog)
declareSubclass(TColorChooserWidget, TBox)
declareSubclass(TColorSelection, TBox)
declareSubclass(TColorSelectionDialog, TDialog)
declareSubclass(TComboBoxAccessible, TContainerAccessible)
declareSubclass(TComboBoxText, TComboBox)
declareSubclass(TContainerCellAccessible, TCellAccessible)
declareSubclass(TCssProvider, GObject2.TObject)
declareSubclass(TDrawingArea, TWidget)
declareSubclass(TEntry, TWidget)
declareSubclass(TEntryAccessible, TWidgetAccessible)
declareSubclass(TEntryBuffer, GObject2.TObject)
declareSubclass(TEntryCompletion, GObject2.TObject)
declareSubclass(TEntryIconAccessible, Atk1.TObject)
declareSubclass(TEventBox, TBin)
declareSubclass(TEventController, GObject2.TObject)
declareSubclass(TExpander, TBin)
declareSubclass(TExpanderAccessible, TContainerAccessible)
declareSubclass(TFileChooserButton, TBox)
declareSubclass(TFileChooserDialog, TDialog)
declareSubclass(TFileChooserWidget, TBox)
declareSubclass(TFileFilter, GObject2.TInitiallyUnowned)
declareSubclass(TFixed, TContainer)
declareSubclass(TFlowBox, TContainer)
declareSubclass(TFlowBoxAccessible, TContainerAccessible)
declareSubclass(TFlowBoxChild, TBin)
declareSubclass(TFlowBoxChildAccessible, TContainerAccessible)
declareSubclass(TFontButton, TButton)
declareSubclass(TFontChooserDialog, TDialog)
declareSubclass(TFontChooserWidget, TBox)
declareSubclass(TFontSelection, TBox)
declareSubclass(TFontSelectionDialog, TDialog)
declareSubclass(TFrameAccessible, TContainerAccessible)
declareSubclass(TGLArea, TWidget)
declareSubclass(TGesture, TEventController)
declareSubclass(TGestureSingle, TGesture)
declareSubclass(TGestureDrag, TGestureSingle)
declareSubclass(TGestureLongPress, TGestureSingle)
declareSubclass(TGestureMultiPress, TGestureSingle)
declareSubclass(TGesturePan, TGestureDrag)
declareSubclass(TGestureRotate, TGesture)
declareSubclass(TGestureSwipe, TGestureSingle)
declareSubclass(TGestureZoom, TGesture)
declareSubclass(TGrid, TContainer)
declareSubclass(THBox, TBox)
declareSubclass(THButtonBox, TButtonBox)
declareSubclass(TPaned, TContainer)
declareSubclass(THPaned, TPaned)
declareSubclass(THSV, TWidget)
declareSubclass(TRange, TWidget)
declareSubclass(TScale, TRange)
declareSubclass(THScale, TScale)
declareSubclass(TScrollbar, TRange)
declareSubclass(THScrollbar, TScrollbar)
declareSubclass(TSeparator, TWidget)
declareSubclass(THSeparator, TSeparator)
declareSubclass(THandleBox, TBin)
declareSubclass(THeaderBar, TContainer)
declareSubclass(TIMContext, GObject2.TObject)
declareSubclass(TIMContextSimple, TIMContext)
declareSubclass(TIMMulticontext, TIMContext)
declareSubclass(TIconFactory, GObject2.TObject)
declareSubclass(TIconInfo, GObject2.TObject)
declareSubclass(TIconTheme, GObject2.TObject)
declareSubclass(TIconView, TContainer)
declareSubclass(TIconViewAccessible, TContainerAccessible)
declareSubclass(TImage, TMisc)
declareSubclass(TImageAccessible, TWidgetAccessible)
declareSubclass(TImageCellAccessible, TRendererCellAccessible)
declareSubclass(TImageMenuItem, TMenuItem)
declareSubclass(TInfoBar, TBox)
declareSubclass(TInvisible, TWidget)
declareSubclass(TLabelAccessible, TWidgetAccessible)
declareSubclass(TLayout, TContainer)
declareSubclass(TLevelBar, TWidget)
declareSubclass(TLevelBarAccessible, TWidgetAccessible)
declareSubclass(TLinkButton, TButton)
declareSubclass(TLinkButtonAccessible, TButtonAccessible)
declareSubclass(TListBox, TContainer)
declareSubclass(TListBoxAccessible, TContainerAccessible)
declareSubclass(TListBoxRow, TBin)
declareSubclass(TListBoxRowAccessible, TContainerAccessible)
declareSubclass(TListStore, GObject2.TObject)
declareSubclass(TLockButton, TButton)
declareSubclass(TLockButtonAccessible, TButtonAccessible)
declareSubclass(TMenuShell, TContainer)
declareSubclass(TMenu, TMenuShell)
declareSubclass(TMenuShellAccessible, TContainerAccessible)
declareSubclass(TMenuAccessible, TMenuShellAccessible)
declareSubclass(TMenuBar, TMenuShell)
declareSubclass(TMenuButton, TToggleButton)
declareSubclass(TToggleButtonAccessible, TButtonAccessible)
declareSubclass(TMenuButtonAccessible, TToggleButtonAccessible)
declareSubclass(TToolItem, TBin)
declareSubclass(TToolButton, TToolItem)
declareSubclass(TMenuToolButton, TToolButton)
declareSubclass(TMessageDialog, TDialog)
declareSubclass(TModelButton, TButton)
declareSubclass(TMountOperation, Gio2.TMountOperation)
declareSubclass(TNotebook, TContainer)
declareSubclass(TNotebookAccessible, TContainerAccessible)
declareSubclass(TNotebookPageAccessible, Atk1.TObject)
declareSubclass(TNumerableIcon, Gio2.TEmblemedIcon)
declareSubclass(TOffscreenWindow, TWindow)
declareSubclass(TOverlay, TBin)
declareSubclass(TPageSetup, GObject2.TObject)
declareSubclass(TPanedAccessible, TContainerAccessible)
declareSubclass(TScrolledWindow, TBin)
declareSubclass(TPlacesSidebar, TScrolledWindow)
declareSubclass(TPopover, TBin)
declareSubclass(TPopoverAccessible, TContainerAccessible)
declareSubclass(TPopoverMenu, TPopover)
declareSubclass(TPrintContext, GObject2.TObject)
declareSubclass(TPrintOperation, GObject2.TObject)
declareSubclass(TPrintSettings, GObject2.TObject)
declareSubclass(TProgressBar, TWidget)
declareSubclass(TProgressBarAccessible, TWidgetAccessible)
declareSubclass(TToggleAction, TAction)
declareSubclass(TRadioAction, TToggleAction)
declareSubclass(TRadioButton, TCheckButton)
declareSubclass(TRadioButtonAccessible, TToggleButtonAccessible)
declareSubclass(TRadioMenuItem, TCheckMenuItem)
declareSubclass(TRadioMenuItemAccessible, TCheckMenuItemAccessible)
declareSubclass(TToggleToolButton, TToolButton)
declareSubclass(TRadioToolButton, TToggleToolButton)
declareSubclass(TRangeAccessible, TWidgetAccessible)
declareSubclass(TRcStyle, GObject2.TObject)
declareSubclass(TRecentAction, TAction)
declareSubclass(TRecentChooserDialog, TDialog)
declareSubclass(TRecentChooserMenu, TMenu)
declareSubclass(TRecentChooserWidget, TBox)
declareSubclass(TRecentFilter, GObject2.TInitiallyUnowned)
declareSubclass(TRecentManager, GObject2.TObject)
declareSubclass(TRevealer, TBin)
declareSubclass(TScaleAccessible, TRangeAccessible)
declareSubclass(TScaleButton, TButton)
declareSubclass(TScaleButtonAccessible, TButtonAccessible)
declareSubclass(TScrolledWindowAccessible, TContainerAccessible)
declareSubclass(TSearchBar, TBin)
declareSubclass(TSearchEntry, TEntry)
declareSubclass(TSeparatorMenuItem, TMenuItem)
declareSubclass(TSeparatorToolItem, TToolItem)
declareSubclass(TSettings, GObject2.TObject)
declareSubclass(TSizeGroup, GObject2.TObject)
declareSubclass(TSpinButton, TEntry)
declareSubclass(TSpinButtonAccessible, TEntryAccessible)
declareSubclass(TSpinner, TWidget)
declareSubclass(TSpinnerAccessible, TWidgetAccessible)
declareSubclass(TStack, TContainer)
declareSubclass(TStackSidebar, TBin)
declareSubclass(TStackSwitcher, TBox)
declareSubclass(TStatusIcon, GObject2.TObject)
declareSubclass(TStatusbar, TBox)
declareSubclass(TStatusbarAccessible, TContainerAccessible)
declareSubclass(TStyle, GObject2.TObject)
declareSubclass(TStyleContext, GObject2.TObject)
declareSubclass(TStyleProperties, GObject2.TObject)
declareSubclass(TSwitch, TWidget)
declareSubclass(TSwitchAccessible, TWidgetAccessible)
declareSubclass(TTable, TContainer)
declareSubclass(TTearoffMenuItem, TMenuItem)
declareSubclass(TTextBuffer, GObject2.TObject)
declareSubclass(TTextCellAccessible, TRendererCellAccessible)
declareSubclass(TTextChildAnchor, GObject2.TObject)
declareSubclass(TTextMark, GObject2.TObject)
declareSubclass(TTextTag, GObject2.TObject)
declareSubclass(TTextTagTable, GObject2.TObject)
declareSubclass(TTextView, TContainer)
declareSubclass(TTextViewAccessible, TContainerAccessible)
declareSubclass(TThemingEngine, GObject2.TObject)
declareSubclass(TToolItemGroup, TContainer)
declareSubclass(TToolPalette, TContainer)
declareSubclass(TToolbar, TContainer)
declareSubclass(TTooltip, GObject2.TObject)
declareSubclass(TToplevelAccessible, Atk1.TObject)
declareSubclass(TTreeModelFilter, GObject2.TObject)
declareSubclass(TTreeModelSort, GObject2.TObject)
declareSubclass(TTreeSelection, GObject2.TObject)
declareSubclass(TTreeStore, GObject2.TObject)
declareSubclass(TTreeView, TContainer)
declareSubclass(TTreeViewAccessible, TContainerAccessible)
declareSubclass(TTreeViewColumn, GObject2.TInitiallyUnowned)
declareSubclass(TUIManager, GObject2.TObject)
declareSubclass(TVBox, TBox)
declareSubclass(TVButtonBox, TButtonBox)
declareSubclass(TVPaned, TPaned)
declareSubclass(TVScale, TScale)
declareSubclass(TVScrollbar, TScrollbar)
declareSubclass(TVSeparator, TSeparator)
declareSubclass(TViewport, TBin)
declareSubclass(TVolumeButton, TScaleButton)
declareSubclass(TWindowAccessible, TContainerAccessible)
declareSubclass(TWindowGroup, GObject2.TObject)

# # implicit unwrapping
# # for some reason, this is not picked up from gobjectutils (bug?)
# converter unwrap[T](s: ref GSmartPtr[T]): ptr T = s.pointer
  # free functions
  #------------------
# gtk_accel_groups_activate
# flags: {} container: -
# arg object: INTERFACE (OBJECT) 'GObject2.Object' 'ptr GObject2.TObject' IN (diff., need sugar)
# arg accel_key: UINT32 'uint32' 'uint32' IN
# arg accel_mods: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_accel_groups_activate(object_x: ptr GObject2.TObject, accel_key: uint32, accel_mods: Gdk3.SModifierType): bool {.cdecl, dynlib: lib, importc: "gtk_accel_groups_activate".}
proc gtk_accel_groups_activate*(object_x: GObject2.Object, accel_key: uint32, accel_mods: Gdk3.SModifierType): bool {.inline.} =
  gtk_accel_groups_activate(object_x.getPointer, accel_key, accel_mods)
# proc gtk_accel_groups_activate*(object_x: GObject2.Object, accel_key: uint32, accel_mods: Gdk3.SModifierType): bool {.inline.} =

# gtk_accel_groups_from_object
# flags: {} container: -
# arg object: INTERFACE (OBJECT) 'GObject2.Object' 'ptr GObject2.TObject' IN (diff., need sugar)
# return: GSLIST 'ptr GSLIST_TODO' 'ptr GSLIST_TODO'
proc gtk_accel_groups_from_object(object_x: ptr GObject2.TObject): ptr GSLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_accel_groups_from_object".}
proc gtk_accel_groups_from_object*(object_x: GObject2.Object): ptr GSLIST_TODO {.inline.} =
  gtk_accel_groups_from_object(object_x.getPointer)
# proc gtk_accel_groups_from_object*(object_x: GObject2.Object): ptr GSLIST_TODO {.inline.} =

# gtk_accelerator_get_default_mod_mask
# flags: {} container: -
# return: INTERFACE 'Gdk3.SModifierType' 'Gdk3.SModifierType'
proc gtk_accelerator_get_default_mod_mask*(): Gdk3.SModifierType {.cdecl, dynlib: lib, importc: "gtk_accelerator_get_default_mod_mask".}
# gtk_accelerator_get_label
# flags: {} container: -
# arg accelerator_key: UINT32 'uint32' 'uint32' IN
# arg accelerator_mods: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# return: UTF8 'ucstring' 'ucstring'
proc gtk_accelerator_get_label*(accelerator_key: uint32, accelerator_mods: Gdk3.SModifierType): ucstring {.cdecl, dynlib: lib, importc: "gtk_accelerator_get_label".}
# gtk_accelerator_get_label_with_keycode
# flags: {} container: -
# arg display: INTERFACE (OBJECT) 'Gdk3.Display' 'ptr Gdk3.TDisplay' IN (diff., need sugar)
# arg accelerator_key: UINT32 'uint32' 'uint32' IN
# arg keycode: UINT32 'uint32' 'uint32' IN
# arg accelerator_mods: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# return: UTF8 'ucstring' 'ucstring'
proc gtk_accelerator_get_label_with_keycode(display: ptr Gdk3.TDisplay, accelerator_key: uint32, keycode: uint32, accelerator_mods: Gdk3.SModifierType): ucstring {.cdecl, dynlib: lib, importc: "gtk_accelerator_get_label_with_keycode".}
proc gtk_accelerator_get_label_with_keycode*(display: Gdk3.Display, accelerator_key: uint32, keycode: uint32, accelerator_mods: Gdk3.SModifierType): ucstring {.inline.} =
  gtk_accelerator_get_label_with_keycode(display.getPointer, accelerator_key, keycode, accelerator_mods)
# proc gtk_accelerator_get_label_with_keycode*(display: Gdk3.Display, accelerator_key: uint32, keycode: uint32, accelerator_mods: Gdk3.SModifierType): ucstring {.inline.} =

# gtk_accelerator_name
# flags: {} container: -
# arg accelerator_key: UINT32 'uint32' 'uint32' IN
# arg accelerator_mods: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# return: UTF8 'ucstring' 'ucstring'
proc gtk_accelerator_name*(accelerator_key: uint32, accelerator_mods: Gdk3.SModifierType): ucstring {.cdecl, dynlib: lib, importc: "gtk_accelerator_name".}
# gtk_accelerator_name_with_keycode
# flags: {} container: -
# arg display: INTERFACE (OBJECT) 'Gdk3.Display' 'ptr Gdk3.TDisplay' IN (diff., need sugar)
# arg accelerator_key: UINT32 'uint32' 'uint32' IN
# arg keycode: UINT32 'uint32' 'uint32' IN
# arg accelerator_mods: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# return: UTF8 'ucstring' 'ucstring'
proc gtk_accelerator_name_with_keycode(display: ptr Gdk3.TDisplay, accelerator_key: uint32, keycode: uint32, accelerator_mods: Gdk3.SModifierType): ucstring {.cdecl, dynlib: lib, importc: "gtk_accelerator_name_with_keycode".}
proc gtk_accelerator_name_with_keycode*(display: Gdk3.Display, accelerator_key: uint32, keycode: uint32, accelerator_mods: Gdk3.SModifierType): ucstring {.inline.} =
  gtk_accelerator_name_with_keycode(display.getPointer, accelerator_key, keycode, accelerator_mods)
# proc gtk_accelerator_name_with_keycode*(display: Gdk3.Display, accelerator_key: uint32, keycode: uint32, accelerator_mods: Gdk3.SModifierType): ucstring {.inline.} =

# gtk_accelerator_parse
# flags: {} container: -
# arg accelerator: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg accelerator_key: UINT32 'var uint32' 'ptr uint32' OUT (diff., need sugar) optional
# arg accelerator_mods: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' OUT optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_accelerator_parse(accelerator: ucstring, accelerator_key: ptr uint32, accelerator_mods: Gdk3.SModifierType) {.cdecl, dynlib: lib, importc: "gtk_accelerator_parse".}
proc gtk_accelerator_parse*(accelerator: ustring, accelerator_key: var uint32, accelerator_mods: Gdk3.SModifierType) {.inline.} =
  gtk_accelerator_parse(ucstring(accelerator), addr(accelerator_key), accelerator_mods)
# tuple-return
# accelerator_key: var uint32
# accelerator_mods: Gdk3.SModifierType
# proc gtk_accelerator_parse*(accelerator: ustring) {.inline.} =

# gtk_accelerator_parse_with_keycode
# flags: {} container: -
# arg accelerator: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg accelerator_key: UINT32 'var uint32' 'ptr uint32' OUT (diff., need sugar) optional
# arg accelerator_codes: ARRAY 'uncheckedArray[uint32]' 'uncheckedArray[uint32]' OUT array zero-terminated optional
# arg accelerator_mods: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' OUT optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_accelerator_parse_with_keycode(accelerator: ucstring, accelerator_key: ptr uint32, accelerator_codes: uncheckedArray[uint32], accelerator_mods: Gdk3.SModifierType) {.cdecl, dynlib: lib, importc: "gtk_accelerator_parse_with_keycode".}
proc gtk_accelerator_parse_with_keycode*(accelerator: ustring, accelerator_key: var uint32, accelerator_codes: uncheckedArray[uint32], accelerator_mods: Gdk3.SModifierType) {.inline.} =
  gtk_accelerator_parse_with_keycode(ucstring(accelerator), addr(accelerator_key), accelerator_codes, accelerator_mods)
# tuple-return
# accelerator_key: var uint32
# accelerator_codes: uncheckedArray[uint32]
# accelerator_mods: Gdk3.SModifierType
# proc gtk_accelerator_parse_with_keycode*(accelerator: ustring) {.inline.} =

# gtk_accelerator_set_default_mod_mask
# flags: {} container: -
# arg default_mod_mask: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_accelerator_set_default_mod_mask*(default_mod_mask: Gdk3.SModifierType) {.cdecl, dynlib: lib, importc: "gtk_accelerator_set_default_mod_mask".}
# gtk_accelerator_valid
# flags: {} container: -
# arg keyval: UINT32 'uint32' 'uint32' IN
# arg modifiers: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_accelerator_valid*(keyval: uint32, modifiers: Gdk3.SModifierType): bool {.cdecl, dynlib: lib, importc: "gtk_accelerator_valid".}
# gtk_alternative_dialog_button_order
# flags: {} container: - (deprecated)
# gtk_binding_entry_add_signal_from_string
# flags: {} container: -
# arg binding_set: INTERFACE (STRUCT) 'ptr TBindingSet' 'ptr TBindingSet' IN
# arg signal_desc: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'GLib2.TokenType' 'GLib2.TokenType'
proc gtk_binding_entry_add_signal_from_string(binding_set: ptr TBindingSet, signal_desc: ucstring): GLib2.TokenType {.cdecl, dynlib: lib, importc: "gtk_binding_entry_add_signal_from_string".}
proc gtk_binding_entry_add_signal_from_string*(binding_set: ptr TBindingSet, signal_desc: ustring): GLib2.TokenType {.inline.} =
  gtk_binding_entry_add_signal_from_string(binding_set, ucstring(signal_desc))
# proc gtk_binding_entry_add_signal_from_string*(binding_set: ptr TBindingSet, signal_desc: ustring): GLib2.TokenType {.inline.} =

# gtk_binding_entry_add_signall
# flags: {} container: -
# arg binding_set: INTERFACE (STRUCT) 'ptr TBindingSet' 'ptr TBindingSet' IN
# arg keyval: UINT32 'uint32' 'uint32' IN
# arg modifiers: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# arg signal_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg binding_args: GSLIST 'ptr GSLIST_TODO' 'ptr GSLIST_TODO' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_binding_entry_add_signall(binding_set: ptr TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType, signal_name: ucstring, binding_args: ptr GSLIST_TODO) {.cdecl, dynlib: lib, importc: "gtk_binding_entry_add_signall".}
proc gtk_binding_entry_add_signall*(binding_set: ptr TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType, signal_name: ustring, binding_args: ptr GSLIST_TODO) {.inline.} =
  gtk_binding_entry_add_signall(binding_set, keyval, modifiers, ucstring(signal_name), binding_args)
# proc gtk_binding_entry_add_signall*(binding_set: ptr TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType, signal_name: ustring, binding_args: ptr GSLIST_TODO) {.inline.} =

# gtk_binding_entry_remove
# flags: {} container: -
# arg binding_set: INTERFACE (STRUCT) 'ptr TBindingSet' 'ptr TBindingSet' IN
# arg keyval: UINT32 'uint32' 'uint32' IN
# arg modifiers: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_binding_entry_remove*(binding_set: ptr TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType) {.cdecl, dynlib: lib, importc: "gtk_binding_entry_remove".}
# gtk_binding_entry_skip
# flags: {} container: -
# arg binding_set: INTERFACE (STRUCT) 'ptr TBindingSet' 'ptr TBindingSet' IN
# arg keyval: UINT32 'uint32' 'uint32' IN
# arg modifiers: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_binding_entry_skip*(binding_set: ptr TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType) {.cdecl, dynlib: lib, importc: "gtk_binding_entry_skip".}
# gtk_binding_set_find
# flags: {} container: -
# arg set_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'ptr TBindingSet' 'ptr TBindingSet'
proc gtk_binding_set_find(set_name: ucstring): ptr TBindingSet {.cdecl, dynlib: lib, importc: "gtk_binding_set_find".}
proc gtk_binding_set_find*(set_name: ustring): ptr TBindingSet {.inline.} =
  gtk_binding_set_find(ucstring(set_name))
# proc gtk_binding_set_find*(set_name: ustring): ptr TBindingSet {.inline.} =

# gtk_bindings_activate
# flags: {} container: -
# arg object: INTERFACE (OBJECT) 'GObject2.Object' 'ptr GObject2.TObject' IN (diff., need sugar)
# arg keyval: UINT32 'uint32' 'uint32' IN
# arg modifiers: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_bindings_activate(object_x: ptr GObject2.TObject, keyval: uint32, modifiers: Gdk3.SModifierType): bool {.cdecl, dynlib: lib, importc: "gtk_bindings_activate".}
proc gtk_bindings_activate*(object_x: GObject2.Object, keyval: uint32, modifiers: Gdk3.SModifierType): bool {.inline.} =
  gtk_bindings_activate(object_x.getPointer, keyval, modifiers)
# proc gtk_bindings_activate*(object_x: GObject2.Object, keyval: uint32, modifiers: Gdk3.SModifierType): bool {.inline.} =

# gtk_bindings_activate_event
# flags: {} container: -
# arg object: INTERFACE (OBJECT) 'GObject2.Object' 'ptr GObject2.TObject' IN (diff., need sugar)
# arg event: INTERFACE (STRUCT) 'ptr Gdk3.TEventKey' 'ptr Gdk3.TEventKey' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_bindings_activate_event(object_x: ptr GObject2.TObject, event: ptr Gdk3.TEventKey): bool {.cdecl, dynlib: lib, importc: "gtk_bindings_activate_event".}
proc gtk_bindings_activate_event*(object_x: GObject2.Object, event: ptr Gdk3.TEventKey): bool {.inline.} =
  gtk_bindings_activate_event(object_x.getPointer, event)
# proc gtk_bindings_activate_event*(object_x: GObject2.Object, event: ptr Gdk3.TEventKey): bool {.inline.} =

# gtk_builder_error_quark
# flags: {} container: -
# return: UINT32 'uint32' 'uint32'
proc gtk_builder_error_quark*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_builder_error_quark".}
# gtk_cairo_should_draw_window
# flags: {} container: -
# arg cr: INTERFACE (STRUCT) 'ptr cairo1.TContext' 'ptr cairo1.TContext' IN
# arg window: INTERFACE (OBJECT) 'Gdk3.Window' 'ptr Gdk3.TWindow' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_cairo_should_draw_window(cr: ptr cairo1.TContext, window: ptr Gdk3.TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_cairo_should_draw_window".}
proc gtk_cairo_should_draw_window*(cr: ptr cairo1.TContext, window: Gdk3.Window): bool {.inline.} =
  gtk_cairo_should_draw_window(cr, window.getPointer)
# proc gtk_cairo_should_draw_window*(cr: ptr cairo1.TContext, window: Gdk3.Window): bool {.inline.} =

# gtk_cairo_transform_to_window
# flags: {} container: -
# arg cr: INTERFACE (STRUCT) 'ptr cairo1.TContext' 'ptr cairo1.TContext' IN
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg window: INTERFACE (OBJECT) 'Gdk3.Window' 'ptr Gdk3.TWindow' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cairo_transform_to_window(cr: ptr cairo1.TContext, widget: ptr TWidget, window: ptr Gdk3.TWindow) {.cdecl, dynlib: lib, importc: "gtk_cairo_transform_to_window".}
proc gtk_cairo_transform_to_window*(cr: ptr cairo1.TContext, widget: Widget, window: Gdk3.Window) {.inline.} =
  gtk_cairo_transform_to_window(cr, widget.getPointer, window.getPointer)
# proc gtk_cairo_transform_to_window*(cr: ptr cairo1.TContext, widget: Widget, window: Gdk3.Window) {.inline.} =

# gtk_check_version
# flags: {} container: -
# arg required_major: UINT32 'uint32' 'uint32' IN
# arg required_minor: UINT32 'uint32' 'uint32' IN
# arg required_micro: UINT32 'uint32' 'uint32' IN
# return: UTF8 'ucstring' 'ucstring'
proc gtk_check_version*(required_major: uint32, required_minor: uint32, required_micro: uint32): ucstring {.cdecl, dynlib: lib, importc: "gtk_check_version".}
# gtk_css_provider_error_quark
# flags: {} container: -
# return: UINT32 'uint32' 'uint32'
proc gtk_css_provider_error_quark*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_css_provider_error_quark".}
# gtk_device_grab_add
# flags: {} container: -
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg device: INTERFACE (OBJECT) 'Gdk3.Device' 'ptr Gdk3.TDevice' IN (diff., need sugar)
# arg block_others: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_device_grab_add(widget: ptr TWidget, device: ptr Gdk3.TDevice, block_others: bool) {.cdecl, dynlib: lib, importc: "gtk_device_grab_add".}
proc gtk_device_grab_add*(widget: Widget, device: Gdk3.Device, block_others: bool) {.inline.} =
  gtk_device_grab_add(widget.getPointer, device.getPointer, block_others)
# proc gtk_device_grab_add*(widget: Widget, device: Gdk3.Device, block_others: bool) {.inline.} =

# gtk_device_grab_remove
# flags: {} container: -
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg device: INTERFACE (OBJECT) 'Gdk3.Device' 'ptr Gdk3.TDevice' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_device_grab_remove(widget: ptr TWidget, device: ptr Gdk3.TDevice) {.cdecl, dynlib: lib, importc: "gtk_device_grab_remove".}
proc gtk_device_grab_remove*(widget: Widget, device: Gdk3.Device) {.inline.} =
  gtk_device_grab_remove(widget.getPointer, device.getPointer)
# proc gtk_device_grab_remove*(widget: Widget, device: Gdk3.Device) {.inline.} =

# gtk_disable_setlocale
# flags: {} container: -
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_disable_setlocale*() {.cdecl, dynlib: lib, importc: "gtk_disable_setlocale".}
# gtk_distribute_natural_allocation
# flags: {} container: -
# arg extra_space: INT32 'int32' 'int32' IN
# arg n_requested_sizes: UINT32 'uint32' 'uint32' IN
# arg sizes: INTERFACE (STRUCT) 'ptr TRequestedSize' 'ptr TRequestedSize' IN
# return: INT32 'int32' 'int32'
proc gtk_distribute_natural_allocation*(extra_space: int32, n_requested_sizes: uint32, sizes: ptr TRequestedSize): int32 {.cdecl, dynlib: lib, importc: "gtk_distribute_natural_allocation".}
# gtk_drag_cancel
# flags: {} container: -
# arg context: INTERFACE (OBJECT) 'Gdk3.DragContext' 'ptr Gdk3.TDragContext' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_cancel(context: ptr Gdk3.TDragContext) {.cdecl, dynlib: lib, importc: "gtk_drag_cancel".}
proc gtk_drag_cancel*(context: Gdk3.DragContext) {.inline.} =
  gtk_drag_cancel(context.getPointer)
# proc gtk_drag_cancel*(context: Gdk3.DragContext) {.inline.} =

# gtk_drag_finish
# flags: {} container: -
# arg context: INTERFACE (OBJECT) 'Gdk3.DragContext' 'ptr Gdk3.TDragContext' IN (diff., need sugar)
# arg success: BOOLEAN 'bool' 'bool' IN
# arg del: BOOLEAN 'bool' 'bool' IN
# arg time_: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_finish(context: ptr Gdk3.TDragContext, success: bool, del: bool, time_x: uint32) {.cdecl, dynlib: lib, importc: "gtk_drag_finish".}
proc gtk_drag_finish*(context: Gdk3.DragContext, success: bool, del: bool, time_x: uint32) {.inline.} =
  gtk_drag_finish(context.getPointer, success, del, time_x)
# proc gtk_drag_finish*(context: Gdk3.DragContext, success: bool, del: bool, time_x: uint32) {.inline.} =

# gtk_drag_get_source_widget
# flags: {} container: -
# arg context: INTERFACE (OBJECT) 'Gdk3.DragContext' 'ptr Gdk3.TDragContext' IN (diff., need sugar)
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_drag_get_source_widget(context: ptr Gdk3.TDragContext): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_drag_get_source_widget".}
proc gtk_drag_get_source_widget*(context: Gdk3.DragContext): Widget {.inline.} =
  wrap(gtk_drag_get_source_widget(context.getPointer))
# proc gtk_drag_get_source_widget*(context: Gdk3.DragContext): Widget {.inline.} =

# gtk_drag_set_icon_default
# flags: {} container: -
# arg context: INTERFACE (OBJECT) 'Gdk3.DragContext' 'ptr Gdk3.TDragContext' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_set_icon_default(context: ptr Gdk3.TDragContext) {.cdecl, dynlib: lib, importc: "gtk_drag_set_icon_default".}
proc gtk_drag_set_icon_default*(context: Gdk3.DragContext) {.inline.} =
  gtk_drag_set_icon_default(context.getPointer)
# proc gtk_drag_set_icon_default*(context: Gdk3.DragContext) {.inline.} =

# gtk_drag_set_icon_gicon
# flags: {} container: -
# arg context: INTERFACE (OBJECT) 'Gdk3.DragContext' 'ptr Gdk3.TDragContext' IN (diff., need sugar)
# arg icon: INTERFACE (INTERFACE) 'ptr Gio2.TIcon' 'ptr Gio2.TIcon' IN
# arg hot_x: INT32 'int32' 'int32' IN
# arg hot_y: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_set_icon_gicon(context: ptr Gdk3.TDragContext, icon: ptr Gio2.TIcon, hot_x: int32, hot_y: int32) {.cdecl, dynlib: lib, importc: "gtk_drag_set_icon_gicon".}
proc gtk_drag_set_icon_gicon*(context: Gdk3.DragContext, icon: ptr Gio2.TIcon, hot_x: int32, hot_y: int32) {.inline.} =
  gtk_drag_set_icon_gicon(context.getPointer, icon, hot_x, hot_y)
# proc gtk_drag_set_icon_gicon*(context: Gdk3.DragContext, icon: ptr Gio2.TIcon, hot_x: int32, hot_y: int32) {.inline.} =

# gtk_drag_set_icon_name
# flags: {} container: -
# arg context: INTERFACE (OBJECT) 'Gdk3.DragContext' 'ptr Gdk3.TDragContext' IN (diff., need sugar)
# arg icon_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg hot_x: INT32 'int32' 'int32' IN
# arg hot_y: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_set_icon_name(context: ptr Gdk3.TDragContext, icon_name: ucstring, hot_x: int32, hot_y: int32) {.cdecl, dynlib: lib, importc: "gtk_drag_set_icon_name".}
proc gtk_drag_set_icon_name*(context: Gdk3.DragContext, icon_name: ustring, hot_x: int32, hot_y: int32) {.inline.} =
  gtk_drag_set_icon_name(context.getPointer, ucstring(icon_name), hot_x, hot_y)
# proc gtk_drag_set_icon_name*(context: Gdk3.DragContext, icon_name: ustring, hot_x: int32, hot_y: int32) {.inline.} =

# gtk_drag_set_icon_pixbuf
# flags: {} container: -
# arg context: INTERFACE (OBJECT) 'Gdk3.DragContext' 'ptr Gdk3.TDragContext' IN (diff., need sugar)
# arg pixbuf: INTERFACE (OBJECT) 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# arg hot_x: INT32 'int32' 'int32' IN
# arg hot_y: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_set_icon_pixbuf(context: ptr Gdk3.TDragContext, pixbuf: ptr GdkPixbuf2.TPixbuf, hot_x: int32, hot_y: int32) {.cdecl, dynlib: lib, importc: "gtk_drag_set_icon_pixbuf".}
proc gtk_drag_set_icon_pixbuf*(context: Gdk3.DragContext, pixbuf: GdkPixbuf2.Pixbuf, hot_x: int32, hot_y: int32) {.inline.} =
  gtk_drag_set_icon_pixbuf(context.getPointer, pixbuf.getPointer, hot_x, hot_y)
# proc gtk_drag_set_icon_pixbuf*(context: Gdk3.DragContext, pixbuf: GdkPixbuf2.Pixbuf, hot_x: int32, hot_y: int32) {.inline.} =

# gtk_drag_set_icon_stock
# flags: {} container: - (deprecated)
# gtk_drag_set_icon_surface
# flags: {} container: -
# arg context: INTERFACE (OBJECT) 'Gdk3.DragContext' 'ptr Gdk3.TDragContext' IN (diff., need sugar)
# arg surface: INTERFACE (STRUCT) 'ptr cairo1.TSurface' 'ptr cairo1.TSurface' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_set_icon_surface(context: ptr Gdk3.TDragContext, surface: ptr cairo1.TSurface) {.cdecl, dynlib: lib, importc: "gtk_drag_set_icon_surface".}
proc gtk_drag_set_icon_surface*(context: Gdk3.DragContext, surface: ptr cairo1.TSurface) {.inline.} =
  gtk_drag_set_icon_surface(context.getPointer, surface)
# proc gtk_drag_set_icon_surface*(context: Gdk3.DragContext, surface: ptr cairo1.TSurface) {.inline.} =

# gtk_drag_set_icon_widget
# flags: {} container: -
# arg context: INTERFACE (OBJECT) 'Gdk3.DragContext' 'ptr Gdk3.TDragContext' IN (diff., need sugar)
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg hot_x: INT32 'int32' 'int32' IN
# arg hot_y: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_set_icon_widget(context: ptr Gdk3.TDragContext, widget: ptr TWidget, hot_x: int32, hot_y: int32) {.cdecl, dynlib: lib, importc: "gtk_drag_set_icon_widget".}
proc gtk_drag_set_icon_widget*(context: Gdk3.DragContext, widget: Widget, hot_x: int32, hot_y: int32) {.inline.} =
  gtk_drag_set_icon_widget(context.getPointer, widget.getPointer, hot_x, hot_y)
# proc gtk_drag_set_icon_widget*(context: Gdk3.DragContext, widget: Widget, hot_x: int32, hot_y: int32) {.inline.} =

# gtk_draw_insertion_cursor
# flags: {} container: - (deprecated)
# gtk_events_pending
# flags: {} container: -
# return: BOOLEAN 'bool' 'bool'
proc gtk_events_pending*(): bool {.cdecl, dynlib: lib, importc: "gtk_events_pending".}
# gtk_false
# flags: {} container: -
# return: BOOLEAN 'bool' 'bool'
proc gtk_false*(): bool {.cdecl, dynlib: lib, importc: "gtk_false".}
# gtk_file_chooser_error_quark
# flags: {} container: -
# return: UINT32 'uint32' 'uint32'
proc gtk_file_chooser_error_quark*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_file_chooser_error_quark".}
# gtk_get_binary_age
# flags: {} container: -
# return: UINT32 'uint32' 'uint32'
proc gtk_get_binary_age*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_get_binary_age".}
# gtk_get_current_event
# flags: {} container: -
# return: INTERFACE 'ptr Gdk3.TEvent' 'ptr Gdk3.TEvent'
proc gtk_get_current_event*(): ptr Gdk3.TEvent {.cdecl, dynlib: lib, importc: "gtk_get_current_event".}
# gtk_get_current_event_device
# flags: {} container: -
# return: INTERFACE 'Gdk3.Device' 'TransferNone[Gdk3.TDevice]' (diff., need sugar)
proc gtk_get_current_event_device_import(): TransferNone[Gdk3.TDevice] {.cdecl, dynlib: lib, importc: "gtk_get_current_event_device".}
proc gtk_get_current_event_device*(): Gdk3.Device {.inline.} =
  wrap(gtk_get_current_event_device_import())
# proc gtk_get_current_event_device*(): Gdk3.Device {.inline.} =

# gtk_get_current_event_state
# flags: {} container: -
# arg state: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' OUT
# return: BOOLEAN 'bool' 'bool'
proc gtk_get_current_event_state*(state: Gdk3.SModifierType): bool {.cdecl, dynlib: lib, importc: "gtk_get_current_event_state".}
# gtk_get_current_event_time
# flags: {} container: -
# return: UINT32 'uint32' 'uint32'
proc gtk_get_current_event_time*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_get_current_event_time".}
# gtk_get_debug_flags
# flags: {} container: -
# return: UINT32 'uint32' 'uint32'
proc gtk_get_debug_flags*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_get_debug_flags".}
# gtk_get_default_language
# flags: {} container: -
# return: INTERFACE 'ptr Pango1.TLanguage' 'ptr Pango1.TLanguage'
proc gtk_get_default_language*(): ptr Pango1.TLanguage {.cdecl, dynlib: lib, importc: "gtk_get_default_language".}
# gtk_get_event_widget
# flags: {} container: -
# arg event: INTERFACE (UNION) 'ptr Gdk3.TEvent' 'ptr Gdk3.TEvent' IN
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_get_event_widget_import(event: ptr Gdk3.TEvent): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_get_event_widget".}
proc gtk_get_event_widget*(event: ptr Gdk3.TEvent): Widget {.inline.} =
  wrap(gtk_get_event_widget_import(event))
# proc gtk_get_event_widget*(event: ptr Gdk3.TEvent): Widget {.inline.} =

# gtk_get_interface_age
# flags: {} container: -
# return: UINT32 'uint32' 'uint32'
proc gtk_get_interface_age*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_get_interface_age".}
# gtk_get_locale_direction
# flags: {} container: -
# return: INTERFACE 'TextDirection' 'TextDirection'
proc gtk_get_locale_direction*(): TextDirection {.cdecl, dynlib: lib, importc: "gtk_get_locale_direction".}
# gtk_get_major_version
# flags: {} container: -
# return: UINT32 'uint32' 'uint32'
proc gtk_get_major_version*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_get_major_version".}
# gtk_get_micro_version
# flags: {} container: -
# return: UINT32 'uint32' 'uint32'
proc gtk_get_micro_version*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_get_micro_version".}
# gtk_get_minor_version
# flags: {} container: -
# return: UINT32 'uint32' 'uint32'
proc gtk_get_minor_version*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_get_minor_version".}
# gtk_get_option_group
# flags: {} container: -
# arg open_default_display: BOOLEAN 'bool' 'bool' IN
# return: INTERFACE 'ptr GLib2.TOptionGroup' 'ptr GLib2.TOptionGroup'
proc gtk_get_option_group*(open_default_display: bool): ptr GLib2.TOptionGroup {.cdecl, dynlib: lib, importc: "gtk_get_option_group".}
# gtk_grab_get_current
# flags: {} container: -
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_grab_get_current_import(): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_grab_get_current".}
proc gtk_grab_get_current*(): Widget {.inline.} =
  wrap(gtk_grab_get_current_import())
# proc gtk_grab_get_current*(): Widget {.inline.} =

# gtk_icon_size_from_name
# flags: {} container: - (deprecated)
# gtk_icon_size_get_name
# flags: {} container: - (deprecated)
# gtk_icon_size_lookup
# flags: {} container: -
# arg size: INT32 'int32' 'int32' IN
# arg width: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg height: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: BOOLEAN 'bool' 'bool'
proc gtk_icon_size_lookup(size: int32, width: ptr int32, height: ptr int32): bool {.cdecl, dynlib: lib, importc: "gtk_icon_size_lookup".}
proc gtk_icon_size_lookup*(size: int32, width: var int32, height: var int32): bool {.inline.} =
  gtk_icon_size_lookup(size, addr(width), addr(height))
# tuple-return
# width: var int32
# height: var int32
# proc gtk_icon_size_lookup*(size: int32): bool {.inline.} =

# gtk_icon_size_lookup_for_settings
# flags: {} container: - (deprecated)
# gtk_icon_size_register
# flags: {} container: - (deprecated)
# gtk_icon_size_register_alias
# flags: {} container: - (deprecated)
# gtk_icon_theme_error_quark
# flags: {} container: -
# return: UINT32 'uint32' 'uint32'
proc gtk_icon_theme_error_quark*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_icon_theme_error_quark".}
# gtk_init
# flags: {} container: -
# arg argc: INT32 'var int32' 'ptr int32' INOUT (diff., need sugar)
# arg argv: ARRAY 'var uncheckedArray[ucstring]' 'var uncheckedArray[ucstring]' INOUT array lengthArg: 0 optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_init(argc: ptr int32, argv: var uncheckedArray[ucstring]) {.cdecl, dynlib: lib, importc: "gtk_init".}
proc gtk_init*(argc: var int32, argv: var uncheckedArray[ucstring]) {.inline.} =
  gtk_init(addr(argc), argv)
# proc gtk_init*(argc: var int32, argv: var uncheckedArray[ucstring]) {.inline.} =

# gtk_init_abi_check
# flags: {} container: -
# arg argc: INT32 'ptr int32' 'ptr int32' IN
# arg argv: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg num_checks: INT32 'int32' 'int32' IN
# arg sizeof_GtkWindow: UINT32 'uint32' 'uint32' IN
# arg sizeof_GtkBox: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_init_abi_check(argc: ptr int32, argv: ucstring, num_checks: int32, sizeof_GtkWindow: uint32, sizeof_GtkBox: uint32) {.cdecl, dynlib: lib, importc: "gtk_init_abi_check".}
proc gtk_init_abi_check*(argc: ptr int32, argv: ustring, num_checks: int32, sizeof_GtkWindow: uint32, sizeof_GtkBox: uint32) {.inline.} =
  gtk_init_abi_check(argc, ucstring(argv), num_checks, sizeof_GtkWindow, sizeof_GtkBox)
# proc gtk_init_abi_check*(argc: ptr int32, argv: ustring, num_checks: int32, sizeof_GtkWindow: uint32, sizeof_GtkBox: uint32) {.inline.} =

# gtk_init_check
# flags: {} container: -
# arg argc: INT32 'var int32' 'ptr int32' INOUT (diff., need sugar)
# arg argv: ARRAY 'var uncheckedArray[ucstring]' 'var uncheckedArray[ucstring]' INOUT array lengthArg: 0 optional
# return: BOOLEAN 'bool' 'bool'
proc gtk_init_check(argc: ptr int32, argv: var uncheckedArray[ucstring]): bool {.cdecl, dynlib: lib, importc: "gtk_init_check".}
proc gtk_init_check*(argc: var int32, argv: var uncheckedArray[ucstring]): bool {.inline.} =
  gtk_init_check(addr(argc), argv)
# proc gtk_init_check*(argc: var int32, argv: var uncheckedArray[ucstring]): bool {.inline.} =

# gtk_init_check_abi_check
# flags: {} container: -
# arg argc: INT32 'ptr int32' 'ptr int32' IN
# arg argv: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg num_checks: INT32 'int32' 'int32' IN
# arg sizeof_GtkWindow: UINT32 'uint32' 'uint32' IN
# arg sizeof_GtkBox: UINT32 'uint32' 'uint32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_init_check_abi_check(argc: ptr int32, argv: ucstring, num_checks: int32, sizeof_GtkWindow: uint32, sizeof_GtkBox: uint32): bool {.cdecl, dynlib: lib, importc: "gtk_init_check_abi_check".}
proc gtk_init_check_abi_check*(argc: ptr int32, argv: ustring, num_checks: int32, sizeof_GtkWindow: uint32, sizeof_GtkBox: uint32): bool {.inline.} =
  gtk_init_check_abi_check(argc, ucstring(argv), num_checks, sizeof_GtkWindow, sizeof_GtkBox)
# proc gtk_init_check_abi_check*(argc: ptr int32, argv: ustring, num_checks: int32, sizeof_GtkWindow: uint32, sizeof_GtkBox: uint32): bool {.inline.} =

# gtk_init_with_args
# flags: {throws} container: -
# can throw
# arg argc: INT32 'var int32' 'ptr int32' INOUT (diff., need sugar)
# arg argv: ARRAY 'var uncheckedArray[ucstring]' 'var uncheckedArray[ucstring]' INOUT array lengthArg: 0 optional
# arg parameter_string: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg entries: ARRAY 'uncheckedArray[GLib2.TOptionEntry]' 'uncheckedArray[GLib2.TOptionEntry]' IN array zero-terminated
# arg translation_domain: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_init_with_args(argc: ptr int32, argv: var uncheckedArray[ucstring], parameter_string: ucstring, entries: uncheckedArray[GLib2.TOptionEntry], translation_domain: ucstring, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_init_with_args".}
proc gtk_init_with_args*(argc: var int32, argv: var uncheckedArray[ucstring], parameter_string: ustring, entries: uncheckedArray[GLib2.TOptionEntry], translation_domain: ustring): bool {.inline.} =
  gtk_init_with_args(addr(argc), argv, ucstring(parameter_string), entries, ucstring(translation_domain))
# proc gtk_init_with_args*(argc: var int32, argv: var uncheckedArray[ucstring], parameter_string: ustring, entries: uncheckedArray[GLib2.TOptionEntry], translation_domain: ustring): bool {.inline.} =

# gtk_key_snooper_remove
# flags: {} container: - (deprecated)
# gtk_main
# flags: {} container: -
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_main*() {.cdecl, dynlib: lib, importc: "gtk_main".}
# gtk_main_do_event
# flags: {} container: -
# arg event: INTERFACE (UNION) 'ptr Gdk3.TEvent' 'ptr Gdk3.TEvent' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_main_do_event*(event: ptr Gdk3.TEvent) {.cdecl, dynlib: lib, importc: "gtk_main_do_event".}
# gtk_main_iteration
# flags: {} container: -
# return: BOOLEAN 'bool' 'bool'
proc gtk_main_iteration*(): bool {.cdecl, dynlib: lib, importc: "gtk_main_iteration".}
# gtk_main_iteration_do
# flags: {} container: -
# arg blocking: BOOLEAN 'bool' 'bool' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_main_iteration_do*(blocking: bool): bool {.cdecl, dynlib: lib, importc: "gtk_main_iteration_do".}
# gtk_main_level
# flags: {} container: -
# return: UINT32 'uint32' 'uint32'
proc gtk_main_level*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_main_level".}
# gtk_main_quit
# flags: {} container: -
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_main_quit*() {.cdecl, dynlib: lib, importc: "gtk_main_quit".}
# gtk_paint_arrow
# flags: {} container: - (deprecated)
# gtk_paint_box
# flags: {} container: - (deprecated)
# gtk_paint_box_gap
# flags: {} container: - (deprecated)
# gtk_paint_check
# flags: {} container: - (deprecated)
# gtk_paint_diamond
# flags: {} container: - (deprecated)
# gtk_paint_expander
# flags: {} container: - (deprecated)
# gtk_paint_extension
# flags: {} container: - (deprecated)
# gtk_paint_flat_box
# flags: {} container: - (deprecated)
# gtk_paint_focus
# flags: {} container: - (deprecated)
# gtk_paint_handle
# flags: {} container: - (deprecated)
# gtk_paint_hline
# flags: {} container: - (deprecated)
# gtk_paint_layout
# flags: {} container: - (deprecated)
# gtk_paint_option
# flags: {} container: - (deprecated)
# gtk_paint_resize_grip
# flags: {} container: - (deprecated)
# gtk_paint_shadow
# flags: {} container: - (deprecated)
# gtk_paint_shadow_gap
# flags: {} container: - (deprecated)
# gtk_paint_slider
# flags: {} container: - (deprecated)
# gtk_paint_spinner
# flags: {} container: - (deprecated)
# gtk_paint_tab
# flags: {} container: - (deprecated)
# gtk_paint_vline
# flags: {} container: - (deprecated)
# gtk_paper_size_get_default
# flags: {} container: -
# return: UTF8 'ucstring' 'ucstring'
proc gtk_paper_size_get_default*(): ucstring {.cdecl, dynlib: lib, importc: "gtk_paper_size_get_default".}
# gtk_paper_size_get_paper_sizes
# flags: {} container: -
# arg include_custom: BOOLEAN 'bool' 'bool' IN
# return: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_paper_size_get_paper_sizes*(include_custom: bool): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_paper_size_get_paper_sizes".}
# gtk_parse_args
# flags: {} container: -
# arg argc: INT32 'var int32' 'ptr int32' INOUT (diff., need sugar)
# arg argv: ARRAY 'var uncheckedArray[ucstring]' 'var uncheckedArray[ucstring]' INOUT array lengthArg: 0
# return: BOOLEAN 'bool' 'bool'
proc gtk_parse_args(argc: ptr int32, argv: var uncheckedArray[ucstring]): bool {.cdecl, dynlib: lib, importc: "gtk_parse_args".}
proc gtk_parse_args*(argc: var int32, argv: var uncheckedArray[ucstring]): bool {.inline.} =
  gtk_parse_args(addr(argc), argv)
# proc gtk_parse_args*(argc: var int32, argv: var uncheckedArray[ucstring]): bool {.inline.} =

# gtk_print_error_quark
# flags: {} container: -
# return: UINT32 'uint32' 'uint32'
proc gtk_print_error_quark*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_print_error_quark".}
# gtk_print_run_page_setup_dialog
# flags: {} container: -
# arg parent: INTERFACE (OBJECT) 'Window' 'ptr TWindow' IN (diff., need sugar)
# arg page_setup: INTERFACE (OBJECT) 'PageSetup' 'ptr TPageSetup' IN (diff., need sugar)
# arg settings: INTERFACE (OBJECT) 'PrintSettings' 'ptr TPrintSettings' IN (diff., need sugar)
# return: INTERFACE 'PageSetup' 'TransferFull[TPageSetup]' (diff., need sugar)
proc gtk_print_run_page_setup_dialog(parent: ptr TWindow, page_setup: ptr TPageSetup, settings: ptr TPrintSettings): TransferFull[TPageSetup] {.cdecl, dynlib: lib, importc: "gtk_print_run_page_setup_dialog".}
proc gtk_print_run_page_setup_dialog*(parent: Window, page_setup: PageSetup, settings: PrintSettings): PageSetup {.inline.} =
  wrap(gtk_print_run_page_setup_dialog(parent.getPointer, page_setup.getPointer, settings.getPointer))
# proc gtk_print_run_page_setup_dialog*(parent: Window, page_setup: PageSetup, settings: PrintSettings): PageSetup {.inline.} =

# gtk_print_run_page_setup_dialog_async
# flags: {} container: -
# arg parent: INTERFACE (OBJECT) 'Window' 'ptr TWindow' IN (diff., need sugar)
# arg page_setup: INTERFACE (OBJECT) 'PageSetup' 'ptr TPageSetup' IN (diff., need sugar)
# arg settings: INTERFACE (OBJECT) 'PrintSettings' 'ptr TPrintSettings' IN (diff., need sugar)
# arg done_cb: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg data: VOID 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_run_page_setup_dialog_async(parent: ptr TWindow, page_setup: ptr TPageSetup, settings: ptr TPrintSettings, done_cb: pointer, data: pointer) {.cdecl, dynlib: lib, importc: "gtk_print_run_page_setup_dialog_async".}
proc gtk_print_run_page_setup_dialog_async*(parent: Window, page_setup: PageSetup, settings: PrintSettings, done_cb: pointer, data: pointer) {.inline.} =
  gtk_print_run_page_setup_dialog_async(parent.getPointer, page_setup.getPointer, settings.getPointer, done_cb, data)
# proc gtk_print_run_page_setup_dialog_async*(parent: Window, page_setup: PageSetup, settings: PrintSettings, done_cb: pointer, data: pointer) {.inline.} =

# gtk_propagate_event
# flags: {} container: -
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg event: INTERFACE (UNION) 'ptr Gdk3.TEvent' 'ptr Gdk3.TEvent' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_propagate_event(widget: ptr TWidget, event: ptr Gdk3.TEvent) {.cdecl, dynlib: lib, importc: "gtk_propagate_event".}
proc gtk_propagate_event*(widget: Widget, event: ptr Gdk3.TEvent) {.inline.} =
  gtk_propagate_event(widget.getPointer, event)
# proc gtk_propagate_event*(widget: Widget, event: ptr Gdk3.TEvent) {.inline.} =

# gtk_rc_add_default_file
# flags: {} container: - (deprecated)
# gtk_rc_find_module_in_path
# flags: {} container: - (deprecated)
# gtk_rc_find_pixmap_in_path
# flags: {} container: - (deprecated)
# gtk_rc_get_default_files
# flags: {} container: - (deprecated)
# gtk_rc_get_im_module_file
# flags: {} container: - (deprecated)
# gtk_rc_get_im_module_path
# flags: {} container: - (deprecated)
# gtk_rc_get_module_dir
# flags: {} container: - (deprecated)
# gtk_rc_get_style
# flags: {} container: - (deprecated)
# gtk_rc_get_style_by_paths
# flags: {} container: - (deprecated)
# gtk_rc_get_theme_dir
# flags: {} container: - (deprecated)
# gtk_rc_parse
# flags: {} container: - (deprecated)
# gtk_rc_parse_color
# flags: {} container: - (deprecated)
# gtk_rc_parse_color_full
# flags: {} container: - (deprecated)
# gtk_rc_parse_priority
# flags: {} container: - (deprecated)
# gtk_rc_parse_state
# flags: {} container: - (deprecated)
# gtk_rc_parse_string
# flags: {} container: - (deprecated)
# gtk_rc_property_parse_border
# flags: {} container: -
# arg pspec: INTERFACE (OBJECT) 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# arg gstring: INTERFACE (STRUCT) 'ptr GLib2.TString' 'ptr GLib2.TString' IN
# arg property_value: INTERFACE (STRUCT) 'ptr GObject2.TValue' 'ptr GObject2.TValue' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_rc_property_parse_border(pspec: ptr GObject2.TParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.cdecl, dynlib: lib, importc: "gtk_rc_property_parse_border".}
proc gtk_rc_property_parse_border*(pspec: GObject2.ParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.inline.} =
  gtk_rc_property_parse_border(pspec.getPointer, gstring, property_value)
# proc gtk_rc_property_parse_border*(pspec: GObject2.ParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.inline.} =

# gtk_rc_property_parse_color
# flags: {} container: -
# arg pspec: INTERFACE (OBJECT) 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# arg gstring: INTERFACE (STRUCT) 'ptr GLib2.TString' 'ptr GLib2.TString' IN
# arg property_value: INTERFACE (STRUCT) 'ptr GObject2.TValue' 'ptr GObject2.TValue' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_rc_property_parse_color(pspec: ptr GObject2.TParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.cdecl, dynlib: lib, importc: "gtk_rc_property_parse_color".}
proc gtk_rc_property_parse_color*(pspec: GObject2.ParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.inline.} =
  gtk_rc_property_parse_color(pspec.getPointer, gstring, property_value)
# proc gtk_rc_property_parse_color*(pspec: GObject2.ParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.inline.} =

# gtk_rc_property_parse_enum
# flags: {} container: -
# arg pspec: INTERFACE (OBJECT) 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# arg gstring: INTERFACE (STRUCT) 'ptr GLib2.TString' 'ptr GLib2.TString' IN
# arg property_value: INTERFACE (STRUCT) 'ptr GObject2.TValue' 'ptr GObject2.TValue' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_rc_property_parse_enum(pspec: ptr GObject2.TParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.cdecl, dynlib: lib, importc: "gtk_rc_property_parse_enum".}
proc gtk_rc_property_parse_enum*(pspec: GObject2.ParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.inline.} =
  gtk_rc_property_parse_enum(pspec.getPointer, gstring, property_value)
# proc gtk_rc_property_parse_enum*(pspec: GObject2.ParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.inline.} =

# gtk_rc_property_parse_flags
# flags: {} container: -
# arg pspec: INTERFACE (OBJECT) 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# arg gstring: INTERFACE (STRUCT) 'ptr GLib2.TString' 'ptr GLib2.TString' IN
# arg property_value: INTERFACE (STRUCT) 'ptr GObject2.TValue' 'ptr GObject2.TValue' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_rc_property_parse_flags(pspec: ptr GObject2.TParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.cdecl, dynlib: lib, importc: "gtk_rc_property_parse_flags".}
proc gtk_rc_property_parse_flags*(pspec: GObject2.ParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.inline.} =
  gtk_rc_property_parse_flags(pspec.getPointer, gstring, property_value)
# proc gtk_rc_property_parse_flags*(pspec: GObject2.ParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.inline.} =

# gtk_rc_property_parse_requisition
# flags: {} container: -
# arg pspec: INTERFACE (OBJECT) 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# arg gstring: INTERFACE (STRUCT) 'ptr GLib2.TString' 'ptr GLib2.TString' IN
# arg property_value: INTERFACE (STRUCT) 'ptr GObject2.TValue' 'ptr GObject2.TValue' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_rc_property_parse_requisition(pspec: ptr GObject2.TParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.cdecl, dynlib: lib, importc: "gtk_rc_property_parse_requisition".}
proc gtk_rc_property_parse_requisition*(pspec: GObject2.ParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.inline.} =
  gtk_rc_property_parse_requisition(pspec.getPointer, gstring, property_value)
# proc gtk_rc_property_parse_requisition*(pspec: GObject2.ParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.inline.} =

# gtk_rc_reparse_all
# flags: {} container: - (deprecated)
# gtk_rc_reparse_all_for_settings
# flags: {} container: - (deprecated)
# gtk_rc_reset_styles
# flags: {} container: - (deprecated)
# gtk_rc_set_default_files
# flags: {} container: - (deprecated)
# gtk_recent_chooser_error_quark
# flags: {} container: -
# return: UINT32 'uint32' 'uint32'
proc gtk_recent_chooser_error_quark*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_recent_chooser_error_quark".}
# gtk_recent_manager_error_quark
# flags: {} container: -
# return: UINT32 'uint32' 'uint32'
proc gtk_recent_manager_error_quark*(): uint32 {.cdecl, dynlib: lib, importc: "gtk_recent_manager_error_quark".}
# gtk_render_activity
# flags: {} container: -
# arg context: INTERFACE (OBJECT) 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# arg cr: INTERFACE (STRUCT) 'ptr cairo1.TContext' 'ptr cairo1.TContext' IN
# arg x: DOUBLE 'float64' 'float64' IN
# arg y: DOUBLE 'float64' 'float64' IN
# arg width: DOUBLE 'float64' 'float64' IN
# arg height: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_render_activity(context: ptr TStyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.cdecl, dynlib: lib, importc: "gtk_render_activity".}
proc gtk_render_activity*(context: StyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =
  gtk_render_activity(context.getPointer, cr, x, y, width, height)
# proc gtk_render_activity*(context: StyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =

# gtk_render_arrow
# flags: {} container: -
# arg context: INTERFACE (OBJECT) 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# arg cr: INTERFACE (STRUCT) 'ptr cairo1.TContext' 'ptr cairo1.TContext' IN
# arg angle: DOUBLE 'float64' 'float64' IN
# arg x: DOUBLE 'float64' 'float64' IN
# arg y: DOUBLE 'float64' 'float64' IN
# arg size: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_render_arrow(context: ptr TStyleContext, cr: ptr cairo1.TContext, angle: float64, x: float64, y: float64, size: float64) {.cdecl, dynlib: lib, importc: "gtk_render_arrow".}
proc gtk_render_arrow*(context: StyleContext, cr: ptr cairo1.TContext, angle: float64, x: float64, y: float64, size: float64) {.inline.} =
  gtk_render_arrow(context.getPointer, cr, angle, x, y, size)
# proc gtk_render_arrow*(context: StyleContext, cr: ptr cairo1.TContext, angle: float64, x: float64, y: float64, size: float64) {.inline.} =

# gtk_render_background
# flags: {} container: -
# arg context: INTERFACE (OBJECT) 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# arg cr: INTERFACE (STRUCT) 'ptr cairo1.TContext' 'ptr cairo1.TContext' IN
# arg x: DOUBLE 'float64' 'float64' IN
# arg y: DOUBLE 'float64' 'float64' IN
# arg width: DOUBLE 'float64' 'float64' IN
# arg height: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_render_background(context: ptr TStyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.cdecl, dynlib: lib, importc: "gtk_render_background".}
proc gtk_render_background*(context: StyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =
  gtk_render_background(context.getPointer, cr, x, y, width, height)
# proc gtk_render_background*(context: StyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =

# gtk_render_check
# flags: {} container: -
# arg context: INTERFACE (OBJECT) 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# arg cr: INTERFACE (STRUCT) 'ptr cairo1.TContext' 'ptr cairo1.TContext' IN
# arg x: DOUBLE 'float64' 'float64' IN
# arg y: DOUBLE 'float64' 'float64' IN
# arg width: DOUBLE 'float64' 'float64' IN
# arg height: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_render_check(context: ptr TStyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.cdecl, dynlib: lib, importc: "gtk_render_check".}
proc gtk_render_check*(context: StyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =
  gtk_render_check(context.getPointer, cr, x, y, width, height)
# proc gtk_render_check*(context: StyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =

# gtk_render_expander
# flags: {} container: -
# arg context: INTERFACE (OBJECT) 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# arg cr: INTERFACE (STRUCT) 'ptr cairo1.TContext' 'ptr cairo1.TContext' IN
# arg x: DOUBLE 'float64' 'float64' IN
# arg y: DOUBLE 'float64' 'float64' IN
# arg width: DOUBLE 'float64' 'float64' IN
# arg height: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_render_expander(context: ptr TStyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.cdecl, dynlib: lib, importc: "gtk_render_expander".}
proc gtk_render_expander*(context: StyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =
  gtk_render_expander(context.getPointer, cr, x, y, width, height)
# proc gtk_render_expander*(context: StyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =

# gtk_render_extension
# flags: {} container: -
# arg context: INTERFACE (OBJECT) 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# arg cr: INTERFACE (STRUCT) 'ptr cairo1.TContext' 'ptr cairo1.TContext' IN
# arg x: DOUBLE 'float64' 'float64' IN
# arg y: DOUBLE 'float64' 'float64' IN
# arg width: DOUBLE 'float64' 'float64' IN
# arg height: DOUBLE 'float64' 'float64' IN
# arg gap_side: INTERFACE (ENUM) 'PositionType' 'PositionType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_render_extension(context: ptr TStyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64, gap_side: PositionType) {.cdecl, dynlib: lib, importc: "gtk_render_extension".}
proc gtk_render_extension*(context: StyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64, gap_side: PositionType) {.inline.} =
  gtk_render_extension(context.getPointer, cr, x, y, width, height, gap_side)
# proc gtk_render_extension*(context: StyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64, gap_side: PositionType) {.inline.} =

# gtk_render_focus
# flags: {} container: -
# arg context: INTERFACE (OBJECT) 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# arg cr: INTERFACE (STRUCT) 'ptr cairo1.TContext' 'ptr cairo1.TContext' IN
# arg x: DOUBLE 'float64' 'float64' IN
# arg y: DOUBLE 'float64' 'float64' IN
# arg width: DOUBLE 'float64' 'float64' IN
# arg height: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_render_focus(context: ptr TStyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.cdecl, dynlib: lib, importc: "gtk_render_focus".}
proc gtk_render_focus*(context: StyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =
  gtk_render_focus(context.getPointer, cr, x, y, width, height)
# proc gtk_render_focus*(context: StyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =

# gtk_render_frame
# flags: {} container: -
# arg context: INTERFACE (OBJECT) 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# arg cr: INTERFACE (STRUCT) 'ptr cairo1.TContext' 'ptr cairo1.TContext' IN
# arg x: DOUBLE 'float64' 'float64' IN
# arg y: DOUBLE 'float64' 'float64' IN
# arg width: DOUBLE 'float64' 'float64' IN
# arg height: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_render_frame(context: ptr TStyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.cdecl, dynlib: lib, importc: "gtk_render_frame".}
proc gtk_render_frame*(context: StyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =
  gtk_render_frame(context.getPointer, cr, x, y, width, height)
# proc gtk_render_frame*(context: StyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =

# gtk_render_frame_gap
# flags: {} container: -
# arg context: INTERFACE (OBJECT) 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# arg cr: INTERFACE (STRUCT) 'ptr cairo1.TContext' 'ptr cairo1.TContext' IN
# arg x: DOUBLE 'float64' 'float64' IN
# arg y: DOUBLE 'float64' 'float64' IN
# arg width: DOUBLE 'float64' 'float64' IN
# arg height: DOUBLE 'float64' 'float64' IN
# arg gap_side: INTERFACE (ENUM) 'PositionType' 'PositionType' IN
# arg xy0_gap: DOUBLE 'float64' 'float64' IN
# arg xy1_gap: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_render_frame_gap(context: ptr TStyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64, gap_side: PositionType, xy0_gap: float64, xy1_gap: float64) {.cdecl, dynlib: lib, importc: "gtk_render_frame_gap".}
proc gtk_render_frame_gap*(context: StyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64, gap_side: PositionType, xy0_gap: float64, xy1_gap: float64) {.inline.} =
  gtk_render_frame_gap(context.getPointer, cr, x, y, width, height, gap_side, xy0_gap, xy1_gap)
# proc gtk_render_frame_gap*(context: StyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64, gap_side: PositionType, xy0_gap: float64, xy1_gap: float64) {.inline.} =

# gtk_render_handle
# flags: {} container: -
# arg context: INTERFACE (OBJECT) 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# arg cr: INTERFACE (STRUCT) 'ptr cairo1.TContext' 'ptr cairo1.TContext' IN
# arg x: DOUBLE 'float64' 'float64' IN
# arg y: DOUBLE 'float64' 'float64' IN
# arg width: DOUBLE 'float64' 'float64' IN
# arg height: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_render_handle(context: ptr TStyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.cdecl, dynlib: lib, importc: "gtk_render_handle".}
proc gtk_render_handle*(context: StyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =
  gtk_render_handle(context.getPointer, cr, x, y, width, height)
# proc gtk_render_handle*(context: StyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =

# gtk_render_icon
# flags: {} container: -
# arg context: INTERFACE (OBJECT) 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# arg cr: INTERFACE (STRUCT) 'ptr cairo1.TContext' 'ptr cairo1.TContext' IN
# arg pixbuf: INTERFACE (OBJECT) 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# arg x: DOUBLE 'float64' 'float64' IN
# arg y: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_render_icon(context: ptr TStyleContext, cr: ptr cairo1.TContext, pixbuf: ptr GdkPixbuf2.TPixbuf, x: float64, y: float64) {.cdecl, dynlib: lib, importc: "gtk_render_icon".}
proc gtk_render_icon*(context: StyleContext, cr: ptr cairo1.TContext, pixbuf: GdkPixbuf2.Pixbuf, x: float64, y: float64) {.inline.} =
  gtk_render_icon(context.getPointer, cr, pixbuf.getPointer, x, y)
# proc gtk_render_icon*(context: StyleContext, cr: ptr cairo1.TContext, pixbuf: GdkPixbuf2.Pixbuf, x: float64, y: float64) {.inline.} =

# gtk_render_icon_pixbuf
# flags: {} container: - (deprecated)
# gtk_render_icon_surface
# flags: {} container: -
# arg context: INTERFACE (OBJECT) 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# arg cr: INTERFACE (STRUCT) 'ptr cairo1.TContext' 'ptr cairo1.TContext' IN
# arg surface: INTERFACE (STRUCT) 'ptr cairo1.TSurface' 'ptr cairo1.TSurface' IN
# arg x: DOUBLE 'float64' 'float64' IN
# arg y: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_render_icon_surface(context: ptr TStyleContext, cr: ptr cairo1.TContext, surface: ptr cairo1.TSurface, x: float64, y: float64) {.cdecl, dynlib: lib, importc: "gtk_render_icon_surface".}
proc gtk_render_icon_surface*(context: StyleContext, cr: ptr cairo1.TContext, surface: ptr cairo1.TSurface, x: float64, y: float64) {.inline.} =
  gtk_render_icon_surface(context.getPointer, cr, surface, x, y)
# proc gtk_render_icon_surface*(context: StyleContext, cr: ptr cairo1.TContext, surface: ptr cairo1.TSurface, x: float64, y: float64) {.inline.} =

# gtk_render_insertion_cursor
# flags: {} container: -
# arg context: INTERFACE (OBJECT) 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# arg cr: INTERFACE (STRUCT) 'ptr cairo1.TContext' 'ptr cairo1.TContext' IN
# arg x: DOUBLE 'float64' 'float64' IN
# arg y: DOUBLE 'float64' 'float64' IN
# arg layout: INTERFACE (OBJECT) 'Pango1.Layout' 'ptr Pango1.TLayout' IN (diff., need sugar)
# arg index: INT32 'int32' 'int32' IN
# arg direction: INTERFACE (ENUM) 'Pango1.Direction' 'Pango1.Direction' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_render_insertion_cursor(context: ptr TStyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, layout: ptr Pango1.TLayout, index: int32, direction: Pango1.Direction) {.cdecl, dynlib: lib, importc: "gtk_render_insertion_cursor".}
proc gtk_render_insertion_cursor*(context: StyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, layout: Pango1.Layout, index: int32, direction: Pango1.Direction) {.inline.} =
  gtk_render_insertion_cursor(context.getPointer, cr, x, y, layout.getPointer, index, direction)
# proc gtk_render_insertion_cursor*(context: StyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, layout: Pango1.Layout, index: int32, direction: Pango1.Direction) {.inline.} =

# gtk_render_layout
# flags: {} container: -
# arg context: INTERFACE (OBJECT) 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# arg cr: INTERFACE (STRUCT) 'ptr cairo1.TContext' 'ptr cairo1.TContext' IN
# arg x: DOUBLE 'float64' 'float64' IN
# arg y: DOUBLE 'float64' 'float64' IN
# arg layout: INTERFACE (OBJECT) 'Pango1.Layout' 'ptr Pango1.TLayout' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_render_layout(context: ptr TStyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, layout: ptr Pango1.TLayout) {.cdecl, dynlib: lib, importc: "gtk_render_layout".}
proc gtk_render_layout*(context: StyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, layout: Pango1.Layout) {.inline.} =
  gtk_render_layout(context.getPointer, cr, x, y, layout.getPointer)
# proc gtk_render_layout*(context: StyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, layout: Pango1.Layout) {.inline.} =

# gtk_render_line
# flags: {} container: -
# arg context: INTERFACE (OBJECT) 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# arg cr: INTERFACE (STRUCT) 'ptr cairo1.TContext' 'ptr cairo1.TContext' IN
# arg x0: DOUBLE 'float64' 'float64' IN
# arg y0: DOUBLE 'float64' 'float64' IN
# arg x1: DOUBLE 'float64' 'float64' IN
# arg y1: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_render_line(context: ptr TStyleContext, cr: ptr cairo1.TContext, x0: float64, y0: float64, x1: float64, y1: float64) {.cdecl, dynlib: lib, importc: "gtk_render_line".}
proc gtk_render_line*(context: StyleContext, cr: ptr cairo1.TContext, x0: float64, y0: float64, x1: float64, y1: float64) {.inline.} =
  gtk_render_line(context.getPointer, cr, x0, y0, x1, y1)
# proc gtk_render_line*(context: StyleContext, cr: ptr cairo1.TContext, x0: float64, y0: float64, x1: float64, y1: float64) {.inline.} =

# gtk_render_option
# flags: {} container: -
# arg context: INTERFACE (OBJECT) 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# arg cr: INTERFACE (STRUCT) 'ptr cairo1.TContext' 'ptr cairo1.TContext' IN
# arg x: DOUBLE 'float64' 'float64' IN
# arg y: DOUBLE 'float64' 'float64' IN
# arg width: DOUBLE 'float64' 'float64' IN
# arg height: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_render_option(context: ptr TStyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.cdecl, dynlib: lib, importc: "gtk_render_option".}
proc gtk_render_option*(context: StyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =
  gtk_render_option(context.getPointer, cr, x, y, width, height)
# proc gtk_render_option*(context: StyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64) {.inline.} =

# gtk_render_slider
# flags: {} container: -
# arg context: INTERFACE (OBJECT) 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# arg cr: INTERFACE (STRUCT) 'ptr cairo1.TContext' 'ptr cairo1.TContext' IN
# arg x: DOUBLE 'float64' 'float64' IN
# arg y: DOUBLE 'float64' 'float64' IN
# arg width: DOUBLE 'float64' 'float64' IN
# arg height: DOUBLE 'float64' 'float64' IN
# arg orientation: INTERFACE (ENUM) 'Orientation' 'Orientation' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_render_slider(context: ptr TStyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64, orientation: Orientation) {.cdecl, dynlib: lib, importc: "gtk_render_slider".}
proc gtk_render_slider*(context: StyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64, orientation: Orientation) {.inline.} =
  gtk_render_slider(context.getPointer, cr, x, y, width, height, orientation)
# proc gtk_render_slider*(context: StyleContext, cr: ptr cairo1.TContext, x: float64, y: float64, width: float64, height: float64, orientation: Orientation) {.inline.} =

# gtk_rgb_to_hsv
# flags: {} container: -
# arg r: DOUBLE 'float64' 'float64' IN
# arg g: DOUBLE 'float64' 'float64' IN
# arg b: DOUBLE 'float64' 'float64' IN
# arg h: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar)
# arg s: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar)
# arg v: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_rgb_to_hsv(r: float64, g: float64, b: float64, h: ptr float64, s: ptr float64, v: ptr float64) {.cdecl, dynlib: lib, importc: "gtk_rgb_to_hsv".}
proc gtk_rgb_to_hsv*(r: float64, g: float64, b: float64, h: var float64, s: var float64, v: var float64) {.inline.} =
  gtk_rgb_to_hsv(r, g, b, addr(h), addr(s), addr(v))
# tuple-return
# h: var float64
# s: var float64
# v: var float64
# proc gtk_rgb_to_hsv*(r: float64, g: float64, b: float64) {.inline.} =

# gtk_selection_add_target
# flags: {} container: -
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg selection: INTERFACE (STRUCT) 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom' IN
# arg target: INTERFACE (STRUCT) 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom' IN
# arg info: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_selection_add_target(widget: ptr TWidget, selection: ptr Gdk3.TAtom, target: ptr Gdk3.TAtom, info: uint32) {.cdecl, dynlib: lib, importc: "gtk_selection_add_target".}
proc gtk_selection_add_target*(widget: Widget, selection: ptr Gdk3.TAtom, target: ptr Gdk3.TAtom, info: uint32) {.inline.} =
  gtk_selection_add_target(widget.getPointer, selection, target, info)
# proc gtk_selection_add_target*(widget: Widget, selection: ptr Gdk3.TAtom, target: ptr Gdk3.TAtom, info: uint32) {.inline.} =

# gtk_selection_add_targets
# flags: {} container: -
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg selection: INTERFACE (STRUCT) 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom' IN
# arg targets: ARRAY 'var openarray[TTargetEntry]' 'openarray[TTargetEntry]' IN (diff., need sugar) array lengthArg: 3
# arg ntargets: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_selection_add_targets(widget: ptr TWidget, selection: ptr Gdk3.TAtom, targets: openarray[TTargetEntry], ntargets: uint32) {.cdecl, dynlib: lib, importc: "gtk_selection_add_targets".}
proc gtk_selection_add_targets*(widget: Widget, selection: ptr Gdk3.TAtom, targets: var openarray[TTargetEntry]) {.inline.} =
  gtk_selection_add_targets(widget.getPointer, selection, targets, targets.len.uint32)
# proc gtk_selection_add_targets*(widget: Widget, selection: ptr Gdk3.TAtom, targets: var openarray[TTargetEntry]) {.inline.} =

# gtk_selection_clear_targets
# flags: {} container: -
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg selection: INTERFACE (STRUCT) 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_selection_clear_targets(widget: ptr TWidget, selection: ptr Gdk3.TAtom) {.cdecl, dynlib: lib, importc: "gtk_selection_clear_targets".}
proc gtk_selection_clear_targets*(widget: Widget, selection: ptr Gdk3.TAtom) {.inline.} =
  gtk_selection_clear_targets(widget.getPointer, selection)
# proc gtk_selection_clear_targets*(widget: Widget, selection: ptr Gdk3.TAtom) {.inline.} =

# gtk_selection_convert
# flags: {} container: -
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg selection: INTERFACE (STRUCT) 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom' IN
# arg target: INTERFACE (STRUCT) 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom' IN
# arg time_: UINT32 'uint32' 'uint32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_selection_convert(widget: ptr TWidget, selection: ptr Gdk3.TAtom, target: ptr Gdk3.TAtom, time_x: uint32): bool {.cdecl, dynlib: lib, importc: "gtk_selection_convert".}
proc gtk_selection_convert*(widget: Widget, selection: ptr Gdk3.TAtom, target: ptr Gdk3.TAtom, time_x: uint32): bool {.inline.} =
  gtk_selection_convert(widget.getPointer, selection, target, time_x)
# proc gtk_selection_convert*(widget: Widget, selection: ptr Gdk3.TAtom, target: ptr Gdk3.TAtom, time_x: uint32): bool {.inline.} =

# gtk_selection_owner_set
# flags: {} container: -
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg selection: INTERFACE (STRUCT) 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom' IN
# arg time_: UINT32 'uint32' 'uint32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_selection_owner_set(widget: ptr TWidget, selection: ptr Gdk3.TAtom, time_x: uint32): bool {.cdecl, dynlib: lib, importc: "gtk_selection_owner_set".}
proc gtk_selection_owner_set*(widget: Widget, selection: ptr Gdk3.TAtom, time_x: uint32): bool {.inline.} =
  gtk_selection_owner_set(widget.getPointer, selection, time_x)
# proc gtk_selection_owner_set*(widget: Widget, selection: ptr Gdk3.TAtom, time_x: uint32): bool {.inline.} =

# gtk_selection_owner_set_for_display
# flags: {} container: -
# arg display: INTERFACE (OBJECT) 'Gdk3.Display' 'ptr Gdk3.TDisplay' IN (diff., need sugar)
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg selection: INTERFACE (STRUCT) 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom' IN
# arg time_: UINT32 'uint32' 'uint32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_selection_owner_set_for_display(display: ptr Gdk3.TDisplay, widget: ptr TWidget, selection: ptr Gdk3.TAtom, time_x: uint32): bool {.cdecl, dynlib: lib, importc: "gtk_selection_owner_set_for_display".}
proc gtk_selection_owner_set_for_display*(display: Gdk3.Display, widget: Widget, selection: ptr Gdk3.TAtom, time_x: uint32): bool {.inline.} =
  gtk_selection_owner_set_for_display(display.getPointer, widget.getPointer, selection, time_x)
# proc gtk_selection_owner_set_for_display*(display: Gdk3.Display, widget: Widget, selection: ptr Gdk3.TAtom, time_x: uint32): bool {.inline.} =

# gtk_selection_remove_all
# flags: {} container: -
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_selection_remove_all(widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_selection_remove_all".}
proc gtk_selection_remove_all*(widget: Widget) {.inline.} =
  gtk_selection_remove_all(widget.getPointer)
# proc gtk_selection_remove_all*(widget: Widget) {.inline.} =

# gtk_set_debug_flags
# flags: {} container: -
# arg flags: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_set_debug_flags*(flags: uint32) {.cdecl, dynlib: lib, importc: "gtk_set_debug_flags".}
# gtk_show_uri
# flags: {throws} container: -
# can throw
# arg screen: INTERFACE (OBJECT) 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# arg uri: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg timestamp: UINT32 'uint32' 'uint32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_show_uri(screen: ptr Gdk3.TScreen, uri: ucstring, timestamp: uint32, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_show_uri".}
proc gtk_show_uri*(screen: Gdk3.Screen, uri: ustring, timestamp: uint32): bool {.inline.} =
  gtk_show_uri(screen.getPointer, ucstring(uri), timestamp)
# proc gtk_show_uri*(screen: Gdk3.Screen, uri: ustring, timestamp: uint32): bool {.inline.} =

# gtk_stock_add
# flags: {} container: - (deprecated)
# gtk_stock_add_static
# flags: {} container: - (deprecated)
# gtk_stock_list_ids
# flags: {} container: - (deprecated)
# gtk_stock_lookup
# flags: {} container: - (deprecated)
# gtk_stock_set_translate_func
# flags: {} container: - (deprecated)
# gtk_target_table_free
# flags: {} container: -
# arg targets: ARRAY 'var openarray[TTargetEntry]' 'openarray[TTargetEntry]' IN (diff., need sugar) array lengthArg: 1
# arg n_targets: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_target_table_free(targets: openarray[TTargetEntry], n_targets: int32) {.cdecl, dynlib: lib, importc: "gtk_target_table_free".}
proc gtk_target_table_free*(targets: var openarray[TTargetEntry]) {.inline.} =
  gtk_target_table_free(targets, targets.len.int32)
# proc gtk_target_table_free*(targets: var openarray[TTargetEntry]) {.inline.} =

# gtk_target_table_new_from_list
# flags: {} container: -
# arg list: INTERFACE (STRUCT) 'ptr TTargetList' 'ptr TTargetList' IN
# arg n_targets: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# return: ARRAY 'zeroTerminatedArray[TTargetEntry]' 'zeroTerminatedArray[TTargetEntry]'
proc gtk_target_table_new_from_list(list: ptr TTargetList, n_targets: ptr int32): zeroTerminatedArray[TTargetEntry] {.cdecl, dynlib: lib, importc: "gtk_target_table_new_from_list".}
proc gtk_target_table_new_from_list*(list: ptr TTargetList, n_targets: var int32): zeroTerminatedArray[TTargetEntry] {.inline.} =
  gtk_target_table_new_from_list(list, addr(n_targets))
# tuple-return
# n_targets: var int32
# proc gtk_target_table_new_from_list*(list: ptr TTargetList): zeroTerminatedArray[TTargetEntry] {.inline.} =

# gtk_targets_include_image
# flags: {} container: -
# arg targets: ARRAY 'var openarray[ptr Gdk3.TAtom]' 'openarray[ptr Gdk3.TAtom]' IN (diff., need sugar) array lengthArg: 1
# arg n_targets: INT32 'int32' 'int32' IN
# arg writable: BOOLEAN 'bool' 'bool' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_targets_include_image(targets: openarray[ptr Gdk3.TAtom], n_targets: int32, writable: bool): bool {.cdecl, dynlib: lib, importc: "gtk_targets_include_image".}
proc gtk_targets_include_image*(targets: var openarray[ptr Gdk3.TAtom], writable: bool): bool {.inline.} =
  gtk_targets_include_image(targets, targets.len.int32, writable)
# proc gtk_targets_include_image*(targets: var openarray[ptr Gdk3.TAtom], writable: bool): bool {.inline.} =

# gtk_targets_include_rich_text
# flags: {} container: -
# arg targets: ARRAY 'var openarray[ptr Gdk3.TAtom]' 'openarray[ptr Gdk3.TAtom]' IN (diff., need sugar) array lengthArg: 1
# arg n_targets: INT32 'int32' 'int32' IN
# arg buffer: INTERFACE (OBJECT) 'TextBuffer' 'ptr TTextBuffer' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_targets_include_rich_text(targets: openarray[ptr Gdk3.TAtom], n_targets: int32, buffer: ptr TTextBuffer): bool {.cdecl, dynlib: lib, importc: "gtk_targets_include_rich_text".}
proc gtk_targets_include_rich_text*(targets: var openarray[ptr Gdk3.TAtom], buffer: TextBuffer): bool {.inline.} =
  gtk_targets_include_rich_text(targets, targets.len.int32, buffer.getPointer)
# proc gtk_targets_include_rich_text*(targets: var openarray[ptr Gdk3.TAtom], buffer: TextBuffer): bool {.inline.} =

# gtk_targets_include_text
# flags: {} container: -
# arg targets: ARRAY 'var openarray[ptr Gdk3.TAtom]' 'openarray[ptr Gdk3.TAtom]' IN (diff., need sugar) array lengthArg: 1
# arg n_targets: INT32 'int32' 'int32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_targets_include_text(targets: openarray[ptr Gdk3.TAtom], n_targets: int32): bool {.cdecl, dynlib: lib, importc: "gtk_targets_include_text".}
proc gtk_targets_include_text*(targets: var openarray[ptr Gdk3.TAtom]): bool {.inline.} =
  gtk_targets_include_text(targets, targets.len.int32)
# proc gtk_targets_include_text*(targets: var openarray[ptr Gdk3.TAtom]): bool {.inline.} =

# gtk_targets_include_uri
# flags: {} container: -
# arg targets: ARRAY 'var openarray[ptr Gdk3.TAtom]' 'openarray[ptr Gdk3.TAtom]' IN (diff., need sugar) array lengthArg: 1
# arg n_targets: INT32 'int32' 'int32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_targets_include_uri(targets: openarray[ptr Gdk3.TAtom], n_targets: int32): bool {.cdecl, dynlib: lib, importc: "gtk_targets_include_uri".}
proc gtk_targets_include_uri*(targets: var openarray[ptr Gdk3.TAtom]): bool {.inline.} =
  gtk_targets_include_uri(targets, targets.len.int32)
# proc gtk_targets_include_uri*(targets: var openarray[ptr Gdk3.TAtom]): bool {.inline.} =

# gtk_test_create_simple_window
# flags: {} container: -
# arg window_title: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg dialog_text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_test_create_simple_window(window_title: ucstring, dialog_text: ucstring): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_test_create_simple_window".}
proc gtk_test_create_simple_window*(window_title: ustring, dialog_text: ustring): Widget {.inline.} =
  wrap(gtk_test_create_simple_window(ucstring(window_title), ucstring(dialog_text)))
# proc gtk_test_create_simple_window*(window_title: ustring, dialog_text: ustring): Widget {.inline.} =

# gtk_test_find_label
# flags: {} container: -
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg label_pattern: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_test_find_label(widget: ptr TWidget, label_pattern: ucstring): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_test_find_label".}
proc gtk_test_find_label*(widget: Widget, label_pattern: ustring): Widget {.inline.} =
  wrap(gtk_test_find_label(widget.getPointer, ucstring(label_pattern)))
# proc gtk_test_find_label*(widget: Widget, label_pattern: ustring): Widget {.inline.} =

# gtk_test_find_sibling
# flags: {} container: -
# arg base_widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg widget_type: GTYPE 'GType' 'GType' IN
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_test_find_sibling(base_widget: ptr TWidget, widget_type: GType): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_test_find_sibling".}
proc gtk_test_find_sibling*(base_widget: Widget, widget_type: GType): Widget {.inline.} =
  wrap(gtk_test_find_sibling(base_widget.getPointer, widget_type))
# proc gtk_test_find_sibling*(base_widget: Widget, widget_type: GType): Widget {.inline.} =

# gtk_test_find_widget
# flags: {} container: -
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg label_pattern: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg widget_type: GTYPE 'GType' 'GType' IN
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_test_find_widget(widget: ptr TWidget, label_pattern: ucstring, widget_type: GType): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_test_find_widget".}
proc gtk_test_find_widget*(widget: Widget, label_pattern: ustring, widget_type: GType): Widget {.inline.} =
  wrap(gtk_test_find_widget(widget.getPointer, ucstring(label_pattern), widget_type))
# proc gtk_test_find_widget*(widget: Widget, label_pattern: ustring, widget_type: GType): Widget {.inline.} =

# gtk_test_list_all_types
# flags: {} container: -
# arg n_types: UINT32 'var uint32' 'ptr uint32' OUT (diff., need sugar)
# return: ARRAY 'zeroTerminatedArray[GType]' 'zeroTerminatedArray[GType]'
proc gtk_test_list_all_types(n_types: ptr uint32): zeroTerminatedArray[GType] {.cdecl, dynlib: lib, importc: "gtk_test_list_all_types".}
proc gtk_test_list_all_types*(n_types: var uint32): zeroTerminatedArray[GType] {.inline.} =
  gtk_test_list_all_types(addr(n_types))
# tuple-return
# n_types: var uint32
# proc gtk_test_list_all_types*(): zeroTerminatedArray[GType] {.inline.} =

# gtk_test_register_all_types
# flags: {} container: -
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_test_register_all_types*() {.cdecl, dynlib: lib, importc: "gtk_test_register_all_types".}
# gtk_test_slider_get_value
# flags: {} container: -
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: DOUBLE 'float64' 'float64'
proc gtk_test_slider_get_value(widget: ptr TWidget): float64 {.cdecl, dynlib: lib, importc: "gtk_test_slider_get_value".}
proc gtk_test_slider_get_value*(widget: Widget): float64 {.inline.} =
  gtk_test_slider_get_value(widget.getPointer)
# proc gtk_test_slider_get_value*(widget: Widget): float64 {.inline.} =

# gtk_test_slider_set_perc
# flags: {} container: -
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg percentage: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_test_slider_set_perc(widget: ptr TWidget, percentage: float64) {.cdecl, dynlib: lib, importc: "gtk_test_slider_set_perc".}
proc gtk_test_slider_set_perc*(widget: Widget, percentage: float64) {.inline.} =
  gtk_test_slider_set_perc(widget.getPointer, percentage)
# proc gtk_test_slider_set_perc*(widget: Widget, percentage: float64) {.inline.} =

# gtk_test_spin_button_click
# flags: {} container: -
# arg spinner: INTERFACE (OBJECT) 'SpinButton' 'ptr TSpinButton' IN (diff., need sugar)
# arg button: UINT32 'uint32' 'uint32' IN
# arg upwards: BOOLEAN 'bool' 'bool' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_test_spin_button_click(spinner: ptr TSpinButton, button: uint32, upwards: bool): bool {.cdecl, dynlib: lib, importc: "gtk_test_spin_button_click".}
proc gtk_test_spin_button_click*(spinner: SpinButton, button: uint32, upwards: bool): bool {.inline.} =
  gtk_test_spin_button_click(spinner.getPointer, button, upwards)
# proc gtk_test_spin_button_click*(spinner: SpinButton, button: uint32, upwards: bool): bool {.inline.} =

# gtk_test_text_get
# flags: {} container: -
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: UTF8 'ucstring' 'ucstring'
proc gtk_test_text_get(widget: ptr TWidget): ucstring {.cdecl, dynlib: lib, importc: "gtk_test_text_get".}
proc gtk_test_text_get*(widget: Widget): ucstring {.inline.} =
  gtk_test_text_get(widget.getPointer)
# proc gtk_test_text_get*(widget: Widget): ucstring {.inline.} =

# gtk_test_text_set
# flags: {} container: -
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg string: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_test_text_set(widget: ptr TWidget, string: ucstring) {.cdecl, dynlib: lib, importc: "gtk_test_text_set".}
proc gtk_test_text_set*(widget: Widget, string: ustring) {.inline.} =
  gtk_test_text_set(widget.getPointer, ucstring(string))
# proc gtk_test_text_set*(widget: Widget, string: ustring) {.inline.} =

# gtk_test_widget_click
# flags: {} container: -
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg button: UINT32 'uint32' 'uint32' IN
# arg modifiers: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_test_widget_click(widget: ptr TWidget, button: uint32, modifiers: Gdk3.SModifierType): bool {.cdecl, dynlib: lib, importc: "gtk_test_widget_click".}
proc gtk_test_widget_click*(widget: Widget, button: uint32, modifiers: Gdk3.SModifierType): bool {.inline.} =
  gtk_test_widget_click(widget.getPointer, button, modifiers)
# proc gtk_test_widget_click*(widget: Widget, button: uint32, modifiers: Gdk3.SModifierType): bool {.inline.} =

# gtk_test_widget_send_key
# flags: {} container: -
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg keyval: UINT32 'uint32' 'uint32' IN
# arg modifiers: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_test_widget_send_key(widget: ptr TWidget, keyval: uint32, modifiers: Gdk3.SModifierType): bool {.cdecl, dynlib: lib, importc: "gtk_test_widget_send_key".}
proc gtk_test_widget_send_key*(widget: Widget, keyval: uint32, modifiers: Gdk3.SModifierType): bool {.inline.} =
  gtk_test_widget_send_key(widget.getPointer, keyval, modifiers)
# proc gtk_test_widget_send_key*(widget: Widget, keyval: uint32, modifiers: Gdk3.SModifierType): bool {.inline.} =

# gtk_test_widget_wait_for_draw
# flags: {} container: -
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_test_widget_wait_for_draw(widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_test_widget_wait_for_draw".}
proc gtk_test_widget_wait_for_draw*(widget: Widget) {.inline.} =
  gtk_test_widget_wait_for_draw(widget.getPointer)
# proc gtk_test_widget_wait_for_draw*(widget: Widget) {.inline.} =

# gtk_tree_get_row_drag_data
# flags: {} container: -
# arg selection_data: INTERFACE (STRUCT) 'ptr TSelectionData' 'ptr TSelectionData' IN
# arg tree_model: INTERFACE (INTERFACE) 'ptr TTreeModel' 'ptr TTreeModel' OUT optional
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' OUT optional
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_get_row_drag_data*(selection_data: ptr TSelectionData, tree_model: ptr TTreeModel, path: ptr TTreePath): bool {.cdecl, dynlib: lib, importc: "gtk_tree_get_row_drag_data".}
# gtk_tree_row_reference_deleted
# flags: {} container: -
# arg proxy: INTERFACE (OBJECT) 'GObject2.Object' 'ptr GObject2.TObject' IN (diff., need sugar)
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_row_reference_deleted(proxy: ptr GObject2.TObject, path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_tree_row_reference_deleted".}
proc gtk_tree_row_reference_deleted*(proxy: GObject2.Object, path: ptr TTreePath) {.inline.} =
  gtk_tree_row_reference_deleted(proxy.getPointer, path)
# proc gtk_tree_row_reference_deleted*(proxy: GObject2.Object, path: ptr TTreePath) {.inline.} =

# gtk_tree_row_reference_inserted
# flags: {} container: -
# arg proxy: INTERFACE (OBJECT) 'GObject2.Object' 'ptr GObject2.TObject' IN (diff., need sugar)
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_row_reference_inserted(proxy: ptr GObject2.TObject, path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_tree_row_reference_inserted".}
proc gtk_tree_row_reference_inserted*(proxy: GObject2.Object, path: ptr TTreePath) {.inline.} =
  gtk_tree_row_reference_inserted(proxy.getPointer, path)
# proc gtk_tree_row_reference_inserted*(proxy: GObject2.Object, path: ptr TTreePath) {.inline.} =

# gtk_tree_set_row_drag_data
# flags: {} container: -
# arg selection_data: INTERFACE (STRUCT) 'ptr TSelectionData' 'ptr TSelectionData' IN
# arg tree_model: INTERFACE (INTERFACE) 'ptr TTreeModel' 'ptr TTreeModel' IN
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_set_row_drag_data*(selection_data: ptr TSelectionData, tree_model: ptr TTreeModel, path: ptr TTreePath): bool {.cdecl, dynlib: lib, importc: "gtk_tree_set_row_drag_data".}
# gtk_true
# flags: {} container: -
# return: BOOLEAN 'bool' 'bool'
proc gtk_true*(): bool {.cdecl, dynlib: lib, importc: "gtk_true".}
  # object methods
  #------------------
# initializer for AboutDialog: gtk_about_dialog_get_type
proc gtk_about_dialog_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_type".}
template gtype*(klass_parameter: typedesc[AboutDialog]): GType = gtk_about_dialog_get_type()
# gtk_about_dialog_new
# flags: {isConstructor} container: AboutDialog
# need sugar: is static method
# return: INTERFACE 'AboutDialog' 'TransferNone[TAboutDialog]' (diff., need sugar)
proc gtk_about_dialog_new(): TransferNone[TAboutDialog] {.cdecl, dynlib: lib, importc: "gtk_about_dialog_new".}
proc new_aboutdialog*(): AboutDialog {.inline.} =
  wrap(gtk_about_dialog_new())
# proc new_aboutdialog*(): AboutDialog {.inline.} =

# gtk_about_dialog_add_credit_section
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# arg section_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg people: ARRAY 'uncheckedArray[ucstring]' 'uncheckedArray[ucstring]' IN array zero-terminated
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_add_credit_section(self: ptr TAboutDialog, section_name: ucstring, people: uncheckedArray[ucstring]) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_add_credit_section".}
proc add_credit_section*(self: AboutDialog, section_name: ustring, people: uncheckedArray[ucstring]) {.inline.} =
  gtk_about_dialog_add_credit_section(self, ucstring(section_name), people)
# proc add_credit_section*(self: AboutDialog, section_name: ustring, people: uncheckedArray[ucstring]) {.inline.} =

# gtk_about_dialog_get_artists
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# return: ARRAY 'zeroTerminatedArray[ucstring]' 'zeroTerminatedArray[ucstring]'
proc gtk_about_dialog_get_artists(self: ptr TAboutDialog): zeroTerminatedArray[ucstring] {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_artists".}
proc get_artists*(self: AboutDialog): zeroTerminatedArray[ucstring] {.inline.} =
  gtk_about_dialog_get_artists(self)
# proc get_artists*(self: AboutDialog): zeroTerminatedArray[ucstring] {.inline.} =

# gtk_about_dialog_get_authors
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# return: ARRAY 'zeroTerminatedArray[ucstring]' 'zeroTerminatedArray[ucstring]'
proc gtk_about_dialog_get_authors(self: ptr TAboutDialog): zeroTerminatedArray[ucstring] {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_authors".}
proc get_authors*(self: AboutDialog): zeroTerminatedArray[ucstring] {.inline.} =
  gtk_about_dialog_get_authors(self)
# proc get_authors*(self: AboutDialog): zeroTerminatedArray[ucstring] {.inline.} =

# gtk_about_dialog_get_comments
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_about_dialog_get_comments(self: ptr TAboutDialog): ucstring {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_comments".}
proc get_comments*(self: AboutDialog): ucstring {.inline.} =
  gtk_about_dialog_get_comments(self)
# proc get_comments*(self: AboutDialog): ucstring {.inline.} =

# gtk_about_dialog_get_copyright
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_about_dialog_get_copyright(self: ptr TAboutDialog): ucstring {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_copyright".}
proc get_copyright*(self: AboutDialog): ucstring {.inline.} =
  gtk_about_dialog_get_copyright(self)
# proc get_copyright*(self: AboutDialog): ucstring {.inline.} =

# gtk_about_dialog_get_documenters
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# return: ARRAY 'zeroTerminatedArray[ucstring]' 'zeroTerminatedArray[ucstring]'
proc gtk_about_dialog_get_documenters(self: ptr TAboutDialog): zeroTerminatedArray[ucstring] {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_documenters".}
proc get_documenters*(self: AboutDialog): zeroTerminatedArray[ucstring] {.inline.} =
  gtk_about_dialog_get_documenters(self)
# proc get_documenters*(self: AboutDialog): zeroTerminatedArray[ucstring] {.inline.} =

# gtk_about_dialog_get_license
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_about_dialog_get_license(self: ptr TAboutDialog): ucstring {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_license".}
proc get_license*(self: AboutDialog): ucstring {.inline.} =
  gtk_about_dialog_get_license(self)
# proc get_license*(self: AboutDialog): ucstring {.inline.} =

# gtk_about_dialog_get_license_type
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# return: INTERFACE 'License' 'License'
proc gtk_about_dialog_get_license_type(self: ptr TAboutDialog): License {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_license_type".}
proc get_license_type*(self: AboutDialog): License {.inline.} =
  gtk_about_dialog_get_license_type(self)
# proc get_license_type*(self: AboutDialog): License {.inline.} =

# gtk_about_dialog_get_logo
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# return: INTERFACE 'GdkPixbuf2.Pixbuf' 'TransferNone[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_about_dialog_get_logo(self: ptr TAboutDialog): TransferNone[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_logo".}
proc get_logo*(self: AboutDialog): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_about_dialog_get_logo(self))
# proc get_logo*(self: AboutDialog): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_about_dialog_get_logo_icon_name
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_about_dialog_get_logo_icon_name(self: ptr TAboutDialog): ucstring {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_logo_icon_name".}
proc get_logo_icon_name*(self: AboutDialog): ucstring {.inline.} =
  gtk_about_dialog_get_logo_icon_name(self)
# proc get_logo_icon_name*(self: AboutDialog): ucstring {.inline.} =

# gtk_about_dialog_get_program_name
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_about_dialog_get_program_name(self: ptr TAboutDialog): ucstring {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_program_name".}
proc get_program_name*(self: AboutDialog): ucstring {.inline.} =
  gtk_about_dialog_get_program_name(self)
# proc get_program_name*(self: AboutDialog): ucstring {.inline.} =

# gtk_about_dialog_get_translator_credits
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_about_dialog_get_translator_credits(self: ptr TAboutDialog): ucstring {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_translator_credits".}
proc get_translator_credits*(self: AboutDialog): ucstring {.inline.} =
  gtk_about_dialog_get_translator_credits(self)
# proc get_translator_credits*(self: AboutDialog): ucstring {.inline.} =

# gtk_about_dialog_get_version
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_about_dialog_get_version(self: ptr TAboutDialog): ucstring {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_version".}
proc get_version*(self: AboutDialog): ucstring {.inline.} =
  gtk_about_dialog_get_version(self)
# proc get_version*(self: AboutDialog): ucstring {.inline.} =

# gtk_about_dialog_get_website
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_about_dialog_get_website(self: ptr TAboutDialog): ucstring {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_website".}
proc get_website*(self: AboutDialog): ucstring {.inline.} =
  gtk_about_dialog_get_website(self)
# proc get_website*(self: AboutDialog): ucstring {.inline.} =

# gtk_about_dialog_get_website_label
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_about_dialog_get_website_label(self: ptr TAboutDialog): ucstring {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_website_label".}
proc get_website_label*(self: AboutDialog): ucstring {.inline.} =
  gtk_about_dialog_get_website_label(self)
# proc get_website_label*(self: AboutDialog): ucstring {.inline.} =

# gtk_about_dialog_get_wrap_license
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_about_dialog_get_wrap_license(self: ptr TAboutDialog): bool {.cdecl, dynlib: lib, importc: "gtk_about_dialog_get_wrap_license".}
proc get_wrap_license*(self: AboutDialog): bool {.inline.} =
  gtk_about_dialog_get_wrap_license(self)
# proc get_wrap_license*(self: AboutDialog): bool {.inline.} =

# gtk_about_dialog_set_artists
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# arg artists: ARRAY 'uncheckedArray[ucstring]' 'uncheckedArray[ucstring]' IN array zero-terminated
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_artists(self: ptr TAboutDialog, artists: uncheckedArray[ucstring]) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_artists".}
proc set_artists*(self: AboutDialog, artists: uncheckedArray[ucstring]) {.inline.} =
  gtk_about_dialog_set_artists(self, artists)
# proc set_artists*(self: AboutDialog, artists: uncheckedArray[ucstring]) {.inline.} =

# gtk_about_dialog_set_authors
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# arg authors: ARRAY 'uncheckedArray[ucstring]' 'uncheckedArray[ucstring]' IN array zero-terminated
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_authors(self: ptr TAboutDialog, authors: uncheckedArray[ucstring]) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_authors".}
proc set_authors*(self: AboutDialog, authors: uncheckedArray[ucstring]) {.inline.} =
  gtk_about_dialog_set_authors(self, authors)
# proc set_authors*(self: AboutDialog, authors: uncheckedArray[ucstring]) {.inline.} =

# gtk_about_dialog_set_comments
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# arg comments: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_comments(self: ptr TAboutDialog, comments: ucstring) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_comments".}
proc set_comments*(self: AboutDialog, comments: ustring) {.inline.} =
  gtk_about_dialog_set_comments(self, ucstring(comments))
# proc set_comments*(self: AboutDialog, comments: ustring) {.inline.} =

# gtk_about_dialog_set_copyright
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# arg copyright: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_copyright(self: ptr TAboutDialog, copyright: ucstring) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_copyright".}
proc set_copyright*(self: AboutDialog, copyright: ustring) {.inline.} =
  gtk_about_dialog_set_copyright(self, ucstring(copyright))
# proc set_copyright*(self: AboutDialog, copyright: ustring) {.inline.} =

# gtk_about_dialog_set_documenters
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# arg documenters: ARRAY 'uncheckedArray[ucstring]' 'uncheckedArray[ucstring]' IN array zero-terminated
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_documenters(self: ptr TAboutDialog, documenters: uncheckedArray[ucstring]) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_documenters".}
proc set_documenters*(self: AboutDialog, documenters: uncheckedArray[ucstring]) {.inline.} =
  gtk_about_dialog_set_documenters(self, documenters)
# proc set_documenters*(self: AboutDialog, documenters: uncheckedArray[ucstring]) {.inline.} =

# gtk_about_dialog_set_license
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# arg license: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_license(self: ptr TAboutDialog, license: ucstring) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_license".}
proc set_license*(self: AboutDialog, license: ustring) {.inline.} =
  gtk_about_dialog_set_license(self, ucstring(license))
# proc set_license*(self: AboutDialog, license: ustring) {.inline.} =

# gtk_about_dialog_set_license_type
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# arg license_type: INTERFACE (ENUM) 'License' 'License' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_license_type(self: ptr TAboutDialog, license_type: License) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_license_type".}
proc set_license_type*(self: AboutDialog, license_type: License) {.inline.} =
  gtk_about_dialog_set_license_type(self, license_type)
# proc set_license_type*(self: AboutDialog, license_type: License) {.inline.} =

# gtk_about_dialog_set_logo
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# arg logo: INTERFACE (OBJECT) 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_logo(self: ptr TAboutDialog, logo: ptr GdkPixbuf2.TPixbuf) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_logo".}
proc set_logo*(self: AboutDialog, logo: GdkPixbuf2.Pixbuf) {.inline.} =
  gtk_about_dialog_set_logo(self, logo.getPointer)
# proc set_logo*(self: AboutDialog, logo: GdkPixbuf2.Pixbuf) {.inline.} =

# gtk_about_dialog_set_logo_icon_name
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# arg icon_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_logo_icon_name(self: ptr TAboutDialog, icon_name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_logo_icon_name".}
proc set_logo_icon_name*(self: AboutDialog, icon_name: ustring) {.inline.} =
  gtk_about_dialog_set_logo_icon_name(self, ucstring(icon_name))
# proc set_logo_icon_name*(self: AboutDialog, icon_name: ustring) {.inline.} =

# gtk_about_dialog_set_program_name
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_program_name(self: ptr TAboutDialog, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_program_name".}
proc set_program_name*(self: AboutDialog, name: ustring) {.inline.} =
  gtk_about_dialog_set_program_name(self, ucstring(name))
# proc set_program_name*(self: AboutDialog, name: ustring) {.inline.} =

# gtk_about_dialog_set_translator_credits
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# arg translator_credits: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_translator_credits(self: ptr TAboutDialog, translator_credits: ucstring) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_translator_credits".}
proc set_translator_credits*(self: AboutDialog, translator_credits: ustring) {.inline.} =
  gtk_about_dialog_set_translator_credits(self, ucstring(translator_credits))
# proc set_translator_credits*(self: AboutDialog, translator_credits: ustring) {.inline.} =

# gtk_about_dialog_set_version
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# arg version: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_version(self: ptr TAboutDialog, version: ucstring) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_version".}
proc set_version*(self: AboutDialog, version: ustring) {.inline.} =
  gtk_about_dialog_set_version(self, ucstring(version))
# proc set_version*(self: AboutDialog, version: ustring) {.inline.} =

# gtk_about_dialog_set_website
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# arg website: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_website(self: ptr TAboutDialog, website: ucstring) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_website".}
proc set_website*(self: AboutDialog, website: ustring) {.inline.} =
  gtk_about_dialog_set_website(self, ucstring(website))
# proc set_website*(self: AboutDialog, website: ustring) {.inline.} =

# gtk_about_dialog_set_website_label
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# arg website_label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_website_label(self: ptr TAboutDialog, website_label: ucstring) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_website_label".}
proc set_website_label*(self: AboutDialog, website_label: ustring) {.inline.} =
  gtk_about_dialog_set_website_label(self, ucstring(website_label))
# proc set_website_label*(self: AboutDialog, website_label: ustring) {.inline.} =

# gtk_about_dialog_set_wrap_license
# flags: {isMethod} container: AboutDialog
# need sugar: is method
# arg wrap_license: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_about_dialog_set_wrap_license(self: ptr TAboutDialog, wrap_license: bool) {.cdecl, dynlib: lib, importc: "gtk_about_dialog_set_wrap_license".}
proc set_wrap_license*(self: AboutDialog, wrap_license: bool) {.inline.} =
  gtk_about_dialog_set_wrap_license(self, wrap_license)
# proc set_wrap_license*(self: AboutDialog, wrap_license: bool) {.inline.} =

# initializer for AccelGroup: gtk_accel_group_get_type
proc gtk_accel_group_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_accel_group_get_type".}
template gtype*(klass_parameter: typedesc[AccelGroup]): GType = gtk_accel_group_get_type()
# gtk_accel_group_new
# flags: {isConstructor} container: AccelGroup
# need sugar: is static method
# return: INTERFACE 'AccelGroup' 'TransferFull[TAccelGroup]' (diff., need sugar)
proc gtk_accel_group_new(): TransferFull[TAccelGroup] {.cdecl, dynlib: lib, importc: "gtk_accel_group_new".}
proc new_accelgroup*(): AccelGroup {.inline.} =
  wrap(gtk_accel_group_new())
# proc new_accelgroup*(): AccelGroup {.inline.} =

# gtk_accel_group_from_accel_closure
# flags: {} container: AccelGroup
# need sugar: is static method
# arg closure: INTERFACE (STRUCT) 'ptr GObject2.TClosure' 'ptr GObject2.TClosure' IN
# return: INTERFACE 'AccelGroup' 'TransferNone[TAccelGroup]' (diff., need sugar)
proc gtk_accel_group_from_accel_closure(closure: ptr GObject2.TClosure): TransferNone[TAccelGroup] {.cdecl, dynlib: lib, importc: "gtk_accel_group_from_accel_closure".}
template from_accel_closure*(klass_parameter: typedesc[AccelGroup], closure: ptr GObject2.TClosure): AccelGroup =
  wrap(gtk_accel_group_from_accel_closure(closure))
# template from_accel_closure*(klass_parameter: typedesc[AccelGroup], closure: ptr GObject2.TClosure): AccelGroup =

# gtk_accel_group_activate
# flags: {isMethod} container: AccelGroup
# need sugar: is method
# arg accel_quark: UINT32 'uint32' 'uint32' IN
# arg acceleratable: INTERFACE (OBJECT) 'GObject2.Object' 'ptr GObject2.TObject' IN (diff., need sugar)
# arg accel_key: UINT32 'uint32' 'uint32' IN
# arg accel_mods: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_accel_group_activate(self: ptr TAccelGroup, accel_quark: uint32, acceleratable: ptr GObject2.TObject, accel_key: uint32, accel_mods: Gdk3.SModifierType): bool {.cdecl, dynlib: lib, importc: "gtk_accel_group_activate".}
proc activate*(self: AccelGroup, accel_quark: uint32, acceleratable: GObject2.Object, accel_key: uint32, accel_mods: Gdk3.SModifierType): bool {.inline.} =
  gtk_accel_group_activate(self, accel_quark, acceleratable.getPointer, accel_key, accel_mods)
# proc activate*(self: AccelGroup, accel_quark: uint32, acceleratable: GObject2.Object, accel_key: uint32, accel_mods: Gdk3.SModifierType): bool {.inline.} =

# gtk_accel_group_connect
# flags: {isMethod} container: AccelGroup
# need sugar: is method
# arg accel_key: UINT32 'uint32' 'uint32' IN
# arg accel_mods: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# arg accel_flags: INTERFACE (FLAGS) 'SAccelFlags' 'SAccelFlags' IN
# arg closure: INTERFACE (STRUCT) 'ptr GObject2.TClosure' 'ptr GObject2.TClosure' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_group_connect(self: ptr TAccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType, accel_flags: SAccelFlags, closure: ptr GObject2.TClosure) {.cdecl, dynlib: lib, importc: "gtk_accel_group_connect".}
proc connect*(self: AccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType, accel_flags: SAccelFlags, closure: ptr GObject2.TClosure) {.inline.} =
  gtk_accel_group_connect(self, accel_key, accel_mods, accel_flags, closure)
# proc connect*(self: AccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType, accel_flags: SAccelFlags, closure: ptr GObject2.TClosure) {.inline.} =

# gtk_accel_group_connect_by_path
# flags: {isMethod} container: AccelGroup
# need sugar: is method
# arg accel_path: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg closure: INTERFACE (STRUCT) 'ptr GObject2.TClosure' 'ptr GObject2.TClosure' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_group_connect_by_path(self: ptr TAccelGroup, accel_path: ucstring, closure: ptr GObject2.TClosure) {.cdecl, dynlib: lib, importc: "gtk_accel_group_connect_by_path".}
proc connect_by_path*(self: AccelGroup, accel_path: ustring, closure: ptr GObject2.TClosure) {.inline.} =
  gtk_accel_group_connect_by_path(self, ucstring(accel_path), closure)
# proc connect_by_path*(self: AccelGroup, accel_path: ustring, closure: ptr GObject2.TClosure) {.inline.} =

# gtk_accel_group_disconnect
# flags: {isMethod} container: AccelGroup
# need sugar: is method
# arg closure: INTERFACE (STRUCT) 'ptr GObject2.TClosure' 'ptr GObject2.TClosure' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_accel_group_disconnect(self: ptr TAccelGroup, closure: ptr GObject2.TClosure): bool {.cdecl, dynlib: lib, importc: "gtk_accel_group_disconnect".}
proc disconnect*(self: AccelGroup, closure: ptr GObject2.TClosure): bool {.inline.} =
  gtk_accel_group_disconnect(self, closure)
# proc disconnect*(self: AccelGroup, closure: ptr GObject2.TClosure): bool {.inline.} =

# gtk_accel_group_disconnect_key
# flags: {isMethod} container: AccelGroup
# need sugar: is method
# arg accel_key: UINT32 'uint32' 'uint32' IN
# arg accel_mods: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_accel_group_disconnect_key(self: ptr TAccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType): bool {.cdecl, dynlib: lib, importc: "gtk_accel_group_disconnect_key".}
proc disconnect_key*(self: AccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType): bool {.inline.} =
  gtk_accel_group_disconnect_key(self, accel_key, accel_mods)
# proc disconnect_key*(self: AccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType): bool {.inline.} =

# gtk_accel_group_find
# flags: {isMethod} container: AccelGroup
# need sugar: is method
# arg find_func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg data: VOID 'pointer' 'pointer' IN
# return: INTERFACE 'ptr TAccelKey' 'ptr TAccelKey'
proc gtk_accel_group_find(self: ptr TAccelGroup, find_func: pointer, data: pointer): ptr TAccelKey {.cdecl, dynlib: lib, importc: "gtk_accel_group_find".}
proc find*(self: AccelGroup, find_func: pointer, data: pointer): ptr TAccelKey {.inline.} =
  gtk_accel_group_find(self, find_func, data)
# proc find*(self: AccelGroup, find_func: pointer, data: pointer): ptr TAccelKey {.inline.} =

# gtk_accel_group_get_is_locked
# flags: {isMethod} container: AccelGroup
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_accel_group_get_is_locked(self: ptr TAccelGroup): bool {.cdecl, dynlib: lib, importc: "gtk_accel_group_get_is_locked".}
proc get_is_locked*(self: AccelGroup): bool {.inline.} =
  gtk_accel_group_get_is_locked(self)
# proc get_is_locked*(self: AccelGroup): bool {.inline.} =

# gtk_accel_group_get_modifier_mask
# flags: {isMethod} container: AccelGroup
# need sugar: is method
# return: INTERFACE 'Gdk3.SModifierType' 'Gdk3.SModifierType'
proc gtk_accel_group_get_modifier_mask(self: ptr TAccelGroup): Gdk3.SModifierType {.cdecl, dynlib: lib, importc: "gtk_accel_group_get_modifier_mask".}
proc get_modifier_mask*(self: AccelGroup): Gdk3.SModifierType {.inline.} =
  gtk_accel_group_get_modifier_mask(self)
# proc get_modifier_mask*(self: AccelGroup): Gdk3.SModifierType {.inline.} =

# gtk_accel_group_lock
# flags: {isMethod} container: AccelGroup
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_group_lock(self: ptr TAccelGroup) {.cdecl, dynlib: lib, importc: "gtk_accel_group_lock".}
proc lock*(self: AccelGroup) {.inline.} =
  gtk_accel_group_lock(self)
# proc lock*(self: AccelGroup) {.inline.} =

# gtk_accel_group_query
# flags: {isMethod} container: AccelGroup
# need sugar: is method
# arg accel_key: UINT32 'uint32' 'uint32' IN
# arg accel_mods: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# arg n_entries: UINT32 'var uint32' 'ptr uint32' OUT (diff., need sugar) optional
# return: ARRAY 'zeroTerminatedArray[TAccelGroupEntry]' 'zeroTerminatedArray[TAccelGroupEntry]'
proc gtk_accel_group_query(self: ptr TAccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType, n_entries: ptr uint32): zeroTerminatedArray[TAccelGroupEntry] {.cdecl, dynlib: lib, importc: "gtk_accel_group_query".}
proc query*(self: AccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType, n_entries: var uint32): zeroTerminatedArray[TAccelGroupEntry] {.inline.} =
  gtk_accel_group_query(self, accel_key, accel_mods, addr(n_entries))
# tuple-return
# n_entries: var uint32
# proc query*(self: AccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType): zeroTerminatedArray[TAccelGroupEntry] {.inline.} =

# gtk_accel_group_unlock
# flags: {isMethod} container: AccelGroup
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_group_unlock(self: ptr TAccelGroup) {.cdecl, dynlib: lib, importc: "gtk_accel_group_unlock".}
proc unlock*(self: AccelGroup) {.inline.} =
  gtk_accel_group_unlock(self)
# proc unlock*(self: AccelGroup) {.inline.} =

# initializer for AccelLabel: gtk_accel_label_get_type
proc gtk_accel_label_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_accel_label_get_type".}
template gtype*(klass_parameter: typedesc[AccelLabel]): GType = gtk_accel_label_get_type()
# gtk_accel_label_new
# flags: {isConstructor} container: AccelLabel
# need sugar: is static method
# arg string: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'AccelLabel' 'TransferNone[TAccelLabel]' (diff., need sugar)
proc gtk_accel_label_new(string: ucstring): TransferNone[TAccelLabel] {.cdecl, dynlib: lib, importc: "gtk_accel_label_new".}
proc new_accellabel*(string: ustring): AccelLabel {.inline.} =
  wrap(gtk_accel_label_new(ucstring(string)))
# proc new_accellabel*(string: ustring): AccelLabel {.inline.} =

# gtk_accel_label_get_accel
# flags: {isMethod} container: AccelLabel
# need sugar: is method
# arg accelerator_key: UINT32 'var uint32' 'ptr uint32' OUT (diff., need sugar)
# arg accelerator_mods: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' OUT
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_label_get_accel(self: ptr TAccelLabel, accelerator_key: ptr uint32, accelerator_mods: Gdk3.SModifierType) {.cdecl, dynlib: lib, importc: "gtk_accel_label_get_accel".}
proc get_accel*(self: AccelLabel, accelerator_key: var uint32, accelerator_mods: Gdk3.SModifierType) {.inline.} =
  gtk_accel_label_get_accel(self, addr(accelerator_key), accelerator_mods)
# tuple-return
# accelerator_key: var uint32
# accelerator_mods: Gdk3.SModifierType
# proc get_accel*(self: AccelLabel) {.inline.} =

# gtk_accel_label_get_accel_widget
# flags: {isMethod} container: AccelLabel
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_accel_label_get_accel_widget(self: ptr TAccelLabel): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_accel_label_get_accel_widget".}
proc get_accel_widget*(self: AccelLabel): Widget {.inline.} =
  wrap(gtk_accel_label_get_accel_widget(self))
# proc get_accel_widget*(self: AccelLabel): Widget {.inline.} =

# gtk_accel_label_get_accel_width
# flags: {isMethod} container: AccelLabel
# need sugar: is method
# return: UINT32 'uint32' 'uint32'
proc gtk_accel_label_get_accel_width(self: ptr TAccelLabel): uint32 {.cdecl, dynlib: lib, importc: "gtk_accel_label_get_accel_width".}
proc get_accel_width*(self: AccelLabel): uint32 {.inline.} =
  gtk_accel_label_get_accel_width(self)
# proc get_accel_width*(self: AccelLabel): uint32 {.inline.} =

# gtk_accel_label_refetch
# flags: {isMethod} container: AccelLabel
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_accel_label_refetch(self: ptr TAccelLabel): bool {.cdecl, dynlib: lib, importc: "gtk_accel_label_refetch".}
proc refetch*(self: AccelLabel): bool {.inline.} =
  gtk_accel_label_refetch(self)
# proc refetch*(self: AccelLabel): bool {.inline.} =

# gtk_accel_label_set_accel
# flags: {isMethod} container: AccelLabel
# need sugar: is method
# arg accelerator_key: UINT32 'uint32' 'uint32' IN
# arg accelerator_mods: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_label_set_accel(self: ptr TAccelLabel, accelerator_key: uint32, accelerator_mods: Gdk3.SModifierType) {.cdecl, dynlib: lib, importc: "gtk_accel_label_set_accel".}
proc set_accel*(self: AccelLabel, accelerator_key: uint32, accelerator_mods: Gdk3.SModifierType) {.inline.} =
  gtk_accel_label_set_accel(self, accelerator_key, accelerator_mods)
# proc set_accel*(self: AccelLabel, accelerator_key: uint32, accelerator_mods: Gdk3.SModifierType) {.inline.} =

# gtk_accel_label_set_accel_closure
# flags: {isMethod} container: AccelLabel
# need sugar: is method
# arg accel_closure: INTERFACE (STRUCT) 'ptr GObject2.TClosure' 'ptr GObject2.TClosure' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_label_set_accel_closure(self: ptr TAccelLabel, accel_closure: ptr GObject2.TClosure) {.cdecl, dynlib: lib, importc: "gtk_accel_label_set_accel_closure".}
proc set_accel_closure*(self: AccelLabel, accel_closure: ptr GObject2.TClosure) {.inline.} =
  gtk_accel_label_set_accel_closure(self, accel_closure)
# proc set_accel_closure*(self: AccelLabel, accel_closure: ptr GObject2.TClosure) {.inline.} =

# gtk_accel_label_set_accel_widget
# flags: {isMethod} container: AccelLabel
# need sugar: is method
# arg accel_widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_label_set_accel_widget(self: ptr TAccelLabel, accel_widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_accel_label_set_accel_widget".}
proc set_accel_widget*(self: AccelLabel, accel_widget: Widget) {.inline.} =
  gtk_accel_label_set_accel_widget(self, accel_widget.getPointer)
# proc set_accel_widget*(self: AccelLabel, accel_widget: Widget) {.inline.} =

# initializer for AccelMap: gtk_accel_map_get_type
proc gtk_accel_map_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_accel_map_get_type".}
template gtype*(klass_parameter: typedesc[AccelMap]): GType = gtk_accel_map_get_type()
# gtk_accel_map_add_entry
# flags: {} container: AccelMap
# need sugar: is static method
# arg accel_path: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg accel_key: UINT32 'uint32' 'uint32' IN
# arg accel_mods: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_map_add_entry(accel_path: ucstring, accel_key: uint32, accel_mods: Gdk3.SModifierType) {.cdecl, dynlib: lib, importc: "gtk_accel_map_add_entry".}
template add_entry*(klass_parameter: typedesc[AccelMap], accel_path: ustring, accel_key: uint32, accel_mods: Gdk3.SModifierType) =
  gtk_accel_map_add_entry(ucstring(accel_path), accel_key, accel_mods)
# template add_entry*(klass_parameter: typedesc[AccelMap], accel_path: ustring, accel_key: uint32, accel_mods: Gdk3.SModifierType) =

# gtk_accel_map_add_filter
# flags: {} container: AccelMap
# need sugar: is static method
# arg filter_pattern: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_map_add_filter(filter_pattern: ucstring) {.cdecl, dynlib: lib, importc: "gtk_accel_map_add_filter".}
template add_filter*(klass_parameter: typedesc[AccelMap], filter_pattern: ustring) =
  gtk_accel_map_add_filter(ucstring(filter_pattern))
# template add_filter*(klass_parameter: typedesc[AccelMap], filter_pattern: ustring) =

# gtk_accel_map_change_entry
# flags: {} container: AccelMap
# need sugar: is static method
# arg accel_path: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg accel_key: UINT32 'uint32' 'uint32' IN
# arg accel_mods: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# arg replace: BOOLEAN 'bool' 'bool' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_accel_map_change_entry(accel_path: ucstring, accel_key: uint32, accel_mods: Gdk3.SModifierType, replace: bool): bool {.cdecl, dynlib: lib, importc: "gtk_accel_map_change_entry".}
template change_entry*(klass_parameter: typedesc[AccelMap], accel_path: ustring, accel_key: uint32, accel_mods: Gdk3.SModifierType, replace: bool): bool =
  gtk_accel_map_change_entry(ucstring(accel_path), accel_key, accel_mods, replace)
# template change_entry*(klass_parameter: typedesc[AccelMap], accel_path: ustring, accel_key: uint32, accel_mods: Gdk3.SModifierType, replace: bool): bool =

# gtk_accel_map_foreach
# flags: {} container: AccelMap
# need sugar: is static method
# arg data: VOID 'pointer' 'pointer' IN
# arg foreach_func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_map_foreach(data: pointer, foreach_func: pointer) {.cdecl, dynlib: lib, importc: "gtk_accel_map_foreach".}
template foreach*(klass_parameter: typedesc[AccelMap], data: pointer, foreach_func: pointer) =
  gtk_accel_map_foreach(data, foreach_func)
# template foreach*(klass_parameter: typedesc[AccelMap], data: pointer, foreach_func: pointer) =

# gtk_accel_map_foreach_unfiltered
# flags: {} container: AccelMap
# need sugar: is static method
# arg data: VOID 'pointer' 'pointer' IN
# arg foreach_func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_map_foreach_unfiltered(data: pointer, foreach_func: pointer) {.cdecl, dynlib: lib, importc: "gtk_accel_map_foreach_unfiltered".}
template foreach_unfiltered*(klass_parameter: typedesc[AccelMap], data: pointer, foreach_func: pointer) =
  gtk_accel_map_foreach_unfiltered(data, foreach_func)
# template foreach_unfiltered*(klass_parameter: typedesc[AccelMap], data: pointer, foreach_func: pointer) =

# gtk_accel_map_get
# flags: {} container: AccelMap
# need sugar: is static method
# return: INTERFACE 'AccelMap' 'TransferNone[TAccelMap]' (diff., need sugar)
proc gtk_accel_map_get(): TransferNone[TAccelMap] {.cdecl, dynlib: lib, importc: "gtk_accel_map_get".}
template get*(klass_parameter: typedesc[AccelMap]): AccelMap =
  wrap(gtk_accel_map_get())
# template get*(klass_parameter: typedesc[AccelMap]): AccelMap =

# gtk_accel_map_load
# flags: {} container: AccelMap
# need sugar: is static method
# arg file_name: FILENAME 'string' 'cstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_map_load(file_name: cstring) {.cdecl, dynlib: lib, importc: "gtk_accel_map_load".}
template load*(klass_parameter: typedesc[AccelMap], file_name: string) =
  gtk_accel_map_load(cstring(file_name))
# template load*(klass_parameter: typedesc[AccelMap], file_name: string) =

# gtk_accel_map_load_fd
# flags: {} container: AccelMap
# need sugar: is static method
# arg fd: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_map_load_fd(fd: int32) {.cdecl, dynlib: lib, importc: "gtk_accel_map_load_fd".}
template load_fd*(klass_parameter: typedesc[AccelMap], fd: int32) =
  gtk_accel_map_load_fd(fd)
# template load_fd*(klass_parameter: typedesc[AccelMap], fd: int32) =

# gtk_accel_map_load_scanner
# flags: {} container: AccelMap
# need sugar: is static method
# arg scanner: INTERFACE (STRUCT) 'ptr GLib2.TScanner' 'ptr GLib2.TScanner' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_map_load_scanner(scanner: ptr GLib2.TScanner) {.cdecl, dynlib: lib, importc: "gtk_accel_map_load_scanner".}
template load_scanner*(klass_parameter: typedesc[AccelMap], scanner: ptr GLib2.TScanner) =
  gtk_accel_map_load_scanner(scanner)
# template load_scanner*(klass_parameter: typedesc[AccelMap], scanner: ptr GLib2.TScanner) =

# gtk_accel_map_lock_path
# flags: {} container: AccelMap
# need sugar: is static method
# arg accel_path: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_map_lock_path(accel_path: ucstring) {.cdecl, dynlib: lib, importc: "gtk_accel_map_lock_path".}
template lock_path*(klass_parameter: typedesc[AccelMap], accel_path: ustring) =
  gtk_accel_map_lock_path(ucstring(accel_path))
# template lock_path*(klass_parameter: typedesc[AccelMap], accel_path: ustring) =

# gtk_accel_map_lookup_entry
# flags: {} container: AccelMap
# need sugar: is static method
# arg accel_path: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg key: INTERFACE (STRUCT) 'ptr TAccelKey' 'ptr TAccelKey' OUT caller-allocates optional
# return: BOOLEAN 'bool' 'bool'
proc gtk_accel_map_lookup_entry(accel_path: ucstring, key: ptr TAccelKey): bool {.cdecl, dynlib: lib, importc: "gtk_accel_map_lookup_entry".}
template lookup_entry*(klass_parameter: typedesc[AccelMap], accel_path: ustring, key: ptr TAccelKey): bool =
  gtk_accel_map_lookup_entry(ucstring(accel_path), key)
# tuple-return
# key: ptr TAccelKey
# template lookup_entry*(klass_parameter: typedesc[AccelMap], accel_path: ustring): bool =

# gtk_accel_map_save
# flags: {} container: AccelMap
# need sugar: is static method
# arg file_name: FILENAME 'string' 'cstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_map_save(file_name: cstring) {.cdecl, dynlib: lib, importc: "gtk_accel_map_save".}
template save*(klass_parameter: typedesc[AccelMap], file_name: string) =
  gtk_accel_map_save(cstring(file_name))
# template save*(klass_parameter: typedesc[AccelMap], file_name: string) =

# gtk_accel_map_save_fd
# flags: {} container: AccelMap
# need sugar: is static method
# arg fd: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_map_save_fd(fd: int32) {.cdecl, dynlib: lib, importc: "gtk_accel_map_save_fd".}
template save_fd*(klass_parameter: typedesc[AccelMap], fd: int32) =
  gtk_accel_map_save_fd(fd)
# template save_fd*(klass_parameter: typedesc[AccelMap], fd: int32) =

# gtk_accel_map_unlock_path
# flags: {} container: AccelMap
# need sugar: is static method
# arg accel_path: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_accel_map_unlock_path(accel_path: ucstring) {.cdecl, dynlib: lib, importc: "gtk_accel_map_unlock_path".}
template unlock_path*(klass_parameter: typedesc[AccelMap], accel_path: ustring) =
  gtk_accel_map_unlock_path(ucstring(accel_path))
# template unlock_path*(klass_parameter: typedesc[AccelMap], accel_path: ustring) =

# initializer for Accessible: gtk_accessible_get_type
proc gtk_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_accessible_get_type".}
template gtype*(klass_parameter: typedesc[Accessible]): GType = gtk_accessible_get_type()
# gtk_accessible_connect_widget_destroyed
# flags: {isMethod} container: Accessible (deprecated)
# gtk_accessible_get_widget
# flags: {isMethod} container: Accessible
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_accessible_get_widget(self: ptr TAccessible): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_accessible_get_widget".}
proc get_widget*(self: Accessible): Widget {.inline.} =
  wrap(gtk_accessible_get_widget(self))
# proc get_widget*(self: Accessible): Widget {.inline.} =

# gtk_accessible_set_widget
# flags: {isMethod} container: Accessible
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_accessible_set_widget(self: ptr TAccessible, widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_accessible_set_widget".}
proc set_widget*(self: Accessible, widget: Widget) {.inline.} =
  gtk_accessible_set_widget(self, widget.getPointer)
# proc set_widget*(self: Accessible, widget: Widget) {.inline.} =

# initializer for Action: gtk_action_get_type
proc gtk_action_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_action_get_type".}
template gtype*(klass_parameter: typedesc[Action]): GType = gtk_action_get_type()
# gtk_action_new
# flags: {isConstructor} container: Action (deprecated)
# gtk_action_activate
# flags: {isMethod} container: Action (deprecated)
# gtk_action_block_activate
# flags: {isMethod} container: Action (deprecated)
# gtk_action_connect_accelerator
# flags: {isMethod} container: Action (deprecated)
# gtk_action_create_icon
# flags: {isMethod} container: Action (deprecated)
# gtk_action_create_menu
# flags: {isMethod} container: Action (deprecated)
# gtk_action_create_menu_item
# flags: {isMethod} container: Action (deprecated)
# gtk_action_create_tool_item
# flags: {isMethod} container: Action (deprecated)
# gtk_action_disconnect_accelerator
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_accel_closure
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_accel_path
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_always_show_image
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_gicon
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_icon_name
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_is_important
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_label
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_name
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_proxies
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_sensitive
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_short_label
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_stock_id
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_tooltip
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_visible
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_visible_horizontal
# flags: {isMethod} container: Action (deprecated)
# gtk_action_get_visible_vertical
# flags: {isMethod} container: Action (deprecated)
# gtk_action_is_sensitive
# flags: {isMethod} container: Action (deprecated)
# gtk_action_is_visible
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_accel_group
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_accel_path
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_always_show_image
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_gicon
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_icon_name
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_is_important
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_label
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_sensitive
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_short_label
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_stock_id
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_tooltip
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_visible
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_visible_horizontal
# flags: {isMethod} container: Action (deprecated)
# gtk_action_set_visible_vertical
# flags: {isMethod} container: Action (deprecated)
# gtk_action_unblock_activate
# flags: {isMethod} container: Action (deprecated)
# initializer for ActionBar: gtk_action_bar_get_type
proc gtk_action_bar_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_action_bar_get_type".}
template gtype*(klass_parameter: typedesc[ActionBar]): GType = gtk_action_bar_get_type()
# gtk_action_bar_new
# flags: {isConstructor} container: ActionBar
# need sugar: is static method
# return: INTERFACE 'ActionBar' 'TransferNone[TActionBar]' (diff., need sugar)
proc gtk_action_bar_new(): TransferNone[TActionBar] {.cdecl, dynlib: lib, importc: "gtk_action_bar_new".}
proc new_actionbar*(): ActionBar {.inline.} =
  wrap(gtk_action_bar_new())
# proc new_actionbar*(): ActionBar {.inline.} =

# gtk_action_bar_get_center_widget
# flags: {isMethod} container: ActionBar
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_action_bar_get_center_widget(self: ptr TActionBar): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_action_bar_get_center_widget".}
proc get_center_widget*(self: ActionBar): Widget {.inline.} =
  wrap(gtk_action_bar_get_center_widget(self))
# proc get_center_widget*(self: ActionBar): Widget {.inline.} =

# gtk_action_bar_pack_end
# flags: {isMethod} container: ActionBar
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_action_bar_pack_end(self: ptr TActionBar, child: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_action_bar_pack_end".}
proc pack_end*(self: ActionBar, child: Widget) {.inline.} =
  gtk_action_bar_pack_end(self, child.getPointer)
# proc pack_end*(self: ActionBar, child: Widget) {.inline.} =

# gtk_action_bar_pack_start
# flags: {isMethod} container: ActionBar
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_action_bar_pack_start(self: ptr TActionBar, child: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_action_bar_pack_start".}
proc pack_start*(self: ActionBar, child: Widget) {.inline.} =
  gtk_action_bar_pack_start(self, child.getPointer)
# proc pack_start*(self: ActionBar, child: Widget) {.inline.} =

# gtk_action_bar_set_center_widget
# flags: {isMethod} container: ActionBar
# need sugar: is method
# arg center_widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_action_bar_set_center_widget(self: ptr TActionBar, center_widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_action_bar_set_center_widget".}
proc set_center_widget*(self: ActionBar, center_widget: Widget) {.inline.} =
  gtk_action_bar_set_center_widget(self, center_widget.getPointer)
# proc set_center_widget*(self: ActionBar, center_widget: Widget) {.inline.} =

# initializer for ActionGroup: gtk_action_group_get_type
proc gtk_action_group_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_action_group_get_type".}
template gtype*(klass_parameter: typedesc[ActionGroup]): GType = gtk_action_group_get_type()
# gtk_action_group_new
# flags: {isConstructor} container: ActionGroup (deprecated)
# gtk_action_group_add_action
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_add_action_with_accel
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_get_accel_group
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_get_action
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_get_name
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_get_sensitive
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_get_visible
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_list_actions
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_remove_action
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_set_accel_group
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_set_sensitive
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_set_translate_func
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_set_translation_domain
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_set_visible
# flags: {isMethod} container: ActionGroup (deprecated)
# gtk_action_group_translate_string
# flags: {isMethod} container: ActionGroup (deprecated)
# initializer for Adjustment: gtk_adjustment_get_type
proc gtk_adjustment_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_adjustment_get_type".}
template gtype*(klass_parameter: typedesc[Adjustment]): GType = gtk_adjustment_get_type()
# gtk_adjustment_new
# flags: {isConstructor} container: Adjustment
# need sugar: is static method
# arg value: DOUBLE 'float64' 'float64' IN
# arg lower: DOUBLE 'float64' 'float64' IN
# arg upper: DOUBLE 'float64' 'float64' IN
# arg step_increment: DOUBLE 'float64' 'float64' IN
# arg page_increment: DOUBLE 'float64' 'float64' IN
# arg page_size: DOUBLE 'float64' 'float64' IN
# return: INTERFACE 'Adjustment' 'TransferNone[TAdjustment]' (diff., need sugar)
proc gtk_adjustment_new(value: float64, lower: float64, upper: float64, step_increment: float64, page_increment: float64, page_size: float64): TransferNone[TAdjustment] {.cdecl, dynlib: lib, importc: "gtk_adjustment_new".}
proc new_adjustment*(value: float64, lower: float64, upper: float64, step_increment: float64, page_increment: float64, page_size: float64): Adjustment {.inline.} =
  wrap(gtk_adjustment_new(value, lower, upper, step_increment, page_increment, page_size))
# proc new_adjustment*(value: float64, lower: float64, upper: float64, step_increment: float64, page_increment: float64, page_size: float64): Adjustment {.inline.} =

# gtk_adjustment_changed
# flags: {isMethod} container: Adjustment (deprecated)
# gtk_adjustment_clamp_page
# flags: {isMethod} container: Adjustment
# need sugar: is method
# arg lower: DOUBLE 'float64' 'float64' IN
# arg upper: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_adjustment_clamp_page(self: ptr TAdjustment, lower: float64, upper: float64) {.cdecl, dynlib: lib, importc: "gtk_adjustment_clamp_page".}
proc clamp_page*(self: Adjustment, lower: float64, upper: float64) {.inline.} =
  gtk_adjustment_clamp_page(self, lower, upper)
# proc clamp_page*(self: Adjustment, lower: float64, upper: float64) {.inline.} =

# gtk_adjustment_configure
# flags: {isMethod} container: Adjustment
# need sugar: is method
# arg value: DOUBLE 'float64' 'float64' IN
# arg lower: DOUBLE 'float64' 'float64' IN
# arg upper: DOUBLE 'float64' 'float64' IN
# arg step_increment: DOUBLE 'float64' 'float64' IN
# arg page_increment: DOUBLE 'float64' 'float64' IN
# arg page_size: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_adjustment_configure(self: ptr TAdjustment, value: float64, lower: float64, upper: float64, step_increment: float64, page_increment: float64, page_size: float64) {.cdecl, dynlib: lib, importc: "gtk_adjustment_configure".}
proc configure*(self: Adjustment, value: float64, lower: float64, upper: float64, step_increment: float64, page_increment: float64, page_size: float64) {.inline.} =
  gtk_adjustment_configure(self, value, lower, upper, step_increment, page_increment, page_size)
# proc configure*(self: Adjustment, value: float64, lower: float64, upper: float64, step_increment: float64, page_increment: float64, page_size: float64) {.inline.} =

# gtk_adjustment_get_lower
# flags: {isMethod} container: Adjustment
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_adjustment_get_lower(self: ptr TAdjustment): float64 {.cdecl, dynlib: lib, importc: "gtk_adjustment_get_lower".}
proc get_lower*(self: Adjustment): float64 {.inline.} =
  gtk_adjustment_get_lower(self)
# proc get_lower*(self: Adjustment): float64 {.inline.} =

# gtk_adjustment_get_minimum_increment
# flags: {isMethod} container: Adjustment
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_adjustment_get_minimum_increment(self: ptr TAdjustment): float64 {.cdecl, dynlib: lib, importc: "gtk_adjustment_get_minimum_increment".}
proc get_minimum_increment*(self: Adjustment): float64 {.inline.} =
  gtk_adjustment_get_minimum_increment(self)
# proc get_minimum_increment*(self: Adjustment): float64 {.inline.} =

# gtk_adjustment_get_page_increment
# flags: {isMethod} container: Adjustment
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_adjustment_get_page_increment(self: ptr TAdjustment): float64 {.cdecl, dynlib: lib, importc: "gtk_adjustment_get_page_increment".}
proc get_page_increment*(self: Adjustment): float64 {.inline.} =
  gtk_adjustment_get_page_increment(self)
# proc get_page_increment*(self: Adjustment): float64 {.inline.} =

# gtk_adjustment_get_page_size
# flags: {isMethod} container: Adjustment
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_adjustment_get_page_size(self: ptr TAdjustment): float64 {.cdecl, dynlib: lib, importc: "gtk_adjustment_get_page_size".}
proc get_page_size*(self: Adjustment): float64 {.inline.} =
  gtk_adjustment_get_page_size(self)
# proc get_page_size*(self: Adjustment): float64 {.inline.} =

# gtk_adjustment_get_step_increment
# flags: {isMethod} container: Adjustment
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_adjustment_get_step_increment(self: ptr TAdjustment): float64 {.cdecl, dynlib: lib, importc: "gtk_adjustment_get_step_increment".}
proc get_step_increment*(self: Adjustment): float64 {.inline.} =
  gtk_adjustment_get_step_increment(self)
# proc get_step_increment*(self: Adjustment): float64 {.inline.} =

# gtk_adjustment_get_upper
# flags: {isMethod} container: Adjustment
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_adjustment_get_upper(self: ptr TAdjustment): float64 {.cdecl, dynlib: lib, importc: "gtk_adjustment_get_upper".}
proc get_upper*(self: Adjustment): float64 {.inline.} =
  gtk_adjustment_get_upper(self)
# proc get_upper*(self: Adjustment): float64 {.inline.} =

# gtk_adjustment_get_value
# flags: {isMethod} container: Adjustment
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_adjustment_get_value(self: ptr TAdjustment): float64 {.cdecl, dynlib: lib, importc: "gtk_adjustment_get_value".}
proc get_value*(self: Adjustment): float64 {.inline.} =
  gtk_adjustment_get_value(self)
# proc get_value*(self: Adjustment): float64 {.inline.} =

# gtk_adjustment_set_lower
# flags: {isMethod} container: Adjustment
# need sugar: is method
# arg lower: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_adjustment_set_lower(self: ptr TAdjustment, lower: float64) {.cdecl, dynlib: lib, importc: "gtk_adjustment_set_lower".}
proc set_lower*(self: Adjustment, lower: float64) {.inline.} =
  gtk_adjustment_set_lower(self, lower)
# proc set_lower*(self: Adjustment, lower: float64) {.inline.} =

# gtk_adjustment_set_page_increment
# flags: {isMethod} container: Adjustment
# need sugar: is method
# arg page_increment: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_adjustment_set_page_increment(self: ptr TAdjustment, page_increment: float64) {.cdecl, dynlib: lib, importc: "gtk_adjustment_set_page_increment".}
proc set_page_increment*(self: Adjustment, page_increment: float64) {.inline.} =
  gtk_adjustment_set_page_increment(self, page_increment)
# proc set_page_increment*(self: Adjustment, page_increment: float64) {.inline.} =

# gtk_adjustment_set_page_size
# flags: {isMethod} container: Adjustment
# need sugar: is method
# arg page_size: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_adjustment_set_page_size(self: ptr TAdjustment, page_size: float64) {.cdecl, dynlib: lib, importc: "gtk_adjustment_set_page_size".}
proc set_page_size*(self: Adjustment, page_size: float64) {.inline.} =
  gtk_adjustment_set_page_size(self, page_size)
# proc set_page_size*(self: Adjustment, page_size: float64) {.inline.} =

# gtk_adjustment_set_step_increment
# flags: {isMethod} container: Adjustment
# need sugar: is method
# arg step_increment: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_adjustment_set_step_increment(self: ptr TAdjustment, step_increment: float64) {.cdecl, dynlib: lib, importc: "gtk_adjustment_set_step_increment".}
proc set_step_increment*(self: Adjustment, step_increment: float64) {.inline.} =
  gtk_adjustment_set_step_increment(self, step_increment)
# proc set_step_increment*(self: Adjustment, step_increment: float64) {.inline.} =

# gtk_adjustment_set_upper
# flags: {isMethod} container: Adjustment
# need sugar: is method
# arg upper: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_adjustment_set_upper(self: ptr TAdjustment, upper: float64) {.cdecl, dynlib: lib, importc: "gtk_adjustment_set_upper".}
proc set_upper*(self: Adjustment, upper: float64) {.inline.} =
  gtk_adjustment_set_upper(self, upper)
# proc set_upper*(self: Adjustment, upper: float64) {.inline.} =

# gtk_adjustment_set_value
# flags: {isMethod} container: Adjustment
# need sugar: is method
# arg value: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_adjustment_set_value(self: ptr TAdjustment, value: float64) {.cdecl, dynlib: lib, importc: "gtk_adjustment_set_value".}
proc set_value*(self: Adjustment, value: float64) {.inline.} =
  gtk_adjustment_set_value(self, value)
# proc set_value*(self: Adjustment, value: float64) {.inline.} =

# gtk_adjustment_value_changed
# flags: {isMethod} container: Adjustment (deprecated)
# initializer for Alignment: gtk_alignment_get_type
proc gtk_alignment_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_alignment_get_type".}
template gtype*(klass_parameter: typedesc[Alignment]): GType = gtk_alignment_get_type()
# gtk_alignment_new
# flags: {isConstructor} container: Alignment (deprecated)
# gtk_alignment_get_padding
# flags: {isMethod} container: Alignment (deprecated)
# gtk_alignment_set
# flags: {isMethod} container: Alignment (deprecated)
# gtk_alignment_set_padding
# flags: {isMethod} container: Alignment (deprecated)
# initializer for AppChooserButton: gtk_app_chooser_button_get_type
proc gtk_app_chooser_button_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_app_chooser_button_get_type".}
template gtype*(klass_parameter: typedesc[AppChooserButton]): GType = gtk_app_chooser_button_get_type()
# gtk_app_chooser_button_new
# flags: {isConstructor} container: AppChooserButton
# need sugar: is static method
# arg content_type: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'AppChooserButton' 'TransferNone[TAppChooserButton]' (diff., need sugar)
proc gtk_app_chooser_button_new(content_type: ucstring): TransferNone[TAppChooserButton] {.cdecl, dynlib: lib, importc: "gtk_app_chooser_button_new".}
proc new_appchooserbutton*(content_type: ustring): AppChooserButton {.inline.} =
  wrap(gtk_app_chooser_button_new(ucstring(content_type)))
# proc new_appchooserbutton*(content_type: ustring): AppChooserButton {.inline.} =

# gtk_app_chooser_button_append_custom_item
# flags: {isMethod} container: AppChooserButton
# need sugar: is method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg icon: INTERFACE (INTERFACE) 'ptr Gio2.TIcon' 'ptr Gio2.TIcon' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_app_chooser_button_append_custom_item(self: ptr TAppChooserButton, name: ucstring, label: ucstring, icon: ptr Gio2.TIcon) {.cdecl, dynlib: lib, importc: "gtk_app_chooser_button_append_custom_item".}
proc append_custom_item*(self: AppChooserButton, name: ustring, label: ustring, icon: ptr Gio2.TIcon) {.inline.} =
  gtk_app_chooser_button_append_custom_item(self, ucstring(name), ucstring(label), icon)
# proc append_custom_item*(self: AppChooserButton, name: ustring, label: ustring, icon: ptr Gio2.TIcon) {.inline.} =

# gtk_app_chooser_button_append_separator
# flags: {isMethod} container: AppChooserButton
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_app_chooser_button_append_separator(self: ptr TAppChooserButton) {.cdecl, dynlib: lib, importc: "gtk_app_chooser_button_append_separator".}
proc append_separator*(self: AppChooserButton) {.inline.} =
  gtk_app_chooser_button_append_separator(self)
# proc append_separator*(self: AppChooserButton) {.inline.} =

# gtk_app_chooser_button_get_heading
# flags: {isMethod} container: AppChooserButton
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_app_chooser_button_get_heading(self: ptr TAppChooserButton): ucstring {.cdecl, dynlib: lib, importc: "gtk_app_chooser_button_get_heading".}
proc get_heading*(self: AppChooserButton): ucstring {.inline.} =
  gtk_app_chooser_button_get_heading(self)
# proc get_heading*(self: AppChooserButton): ucstring {.inline.} =

# gtk_app_chooser_button_get_show_default_item
# flags: {isMethod} container: AppChooserButton
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_app_chooser_button_get_show_default_item(self: ptr TAppChooserButton): bool {.cdecl, dynlib: lib, importc: "gtk_app_chooser_button_get_show_default_item".}
proc get_show_default_item*(self: AppChooserButton): bool {.inline.} =
  gtk_app_chooser_button_get_show_default_item(self)
# proc get_show_default_item*(self: AppChooserButton): bool {.inline.} =

# gtk_app_chooser_button_get_show_dialog_item
# flags: {isMethod} container: AppChooserButton
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_app_chooser_button_get_show_dialog_item(self: ptr TAppChooserButton): bool {.cdecl, dynlib: lib, importc: "gtk_app_chooser_button_get_show_dialog_item".}
proc get_show_dialog_item*(self: AppChooserButton): bool {.inline.} =
  gtk_app_chooser_button_get_show_dialog_item(self)
# proc get_show_dialog_item*(self: AppChooserButton): bool {.inline.} =

# gtk_app_chooser_button_set_active_custom_item
# flags: {isMethod} container: AppChooserButton
# need sugar: is method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_app_chooser_button_set_active_custom_item(self: ptr TAppChooserButton, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_app_chooser_button_set_active_custom_item".}
proc set_active_custom_item*(self: AppChooserButton, name: ustring) {.inline.} =
  gtk_app_chooser_button_set_active_custom_item(self, ucstring(name))
# proc set_active_custom_item*(self: AppChooserButton, name: ustring) {.inline.} =

# gtk_app_chooser_button_set_heading
# flags: {isMethod} container: AppChooserButton
# need sugar: is method
# arg heading: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_app_chooser_button_set_heading(self: ptr TAppChooserButton, heading: ucstring) {.cdecl, dynlib: lib, importc: "gtk_app_chooser_button_set_heading".}
proc set_heading*(self: AppChooserButton, heading: ustring) {.inline.} =
  gtk_app_chooser_button_set_heading(self, ucstring(heading))
# proc set_heading*(self: AppChooserButton, heading: ustring) {.inline.} =

# gtk_app_chooser_button_set_show_default_item
# flags: {isMethod} container: AppChooserButton
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_app_chooser_button_set_show_default_item(self: ptr TAppChooserButton, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_app_chooser_button_set_show_default_item".}
proc set_show_default_item*(self: AppChooserButton, setting: bool) {.inline.} =
  gtk_app_chooser_button_set_show_default_item(self, setting)
# proc set_show_default_item*(self: AppChooserButton, setting: bool) {.inline.} =

# gtk_app_chooser_button_set_show_dialog_item
# flags: {isMethod} container: AppChooserButton
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_app_chooser_button_set_show_dialog_item(self: ptr TAppChooserButton, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_app_chooser_button_set_show_dialog_item".}
proc set_show_dialog_item*(self: AppChooserButton, setting: bool) {.inline.} =
  gtk_app_chooser_button_set_show_dialog_item(self, setting)
# proc set_show_dialog_item*(self: AppChooserButton, setting: bool) {.inline.} =

# initializer for AppChooserDialog: gtk_app_chooser_dialog_get_type
proc gtk_app_chooser_dialog_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_app_chooser_dialog_get_type".}
template gtype*(klass_parameter: typedesc[AppChooserDialog]): GType = gtk_app_chooser_dialog_get_type()
# gtk_app_chooser_dialog_new
# flags: {isConstructor} container: AppChooserDialog
# need sugar: is static method
# arg parent: INTERFACE (OBJECT) 'Window' 'ptr TWindow' IN (diff., need sugar)
# arg flags: INTERFACE (FLAGS) 'SDialogFlags' 'SDialogFlags' IN
# arg file: INTERFACE (INTERFACE) 'ptr Gio2.TFile' 'ptr Gio2.TFile' IN
# return: INTERFACE 'AppChooserDialog' 'TransferNone[TAppChooserDialog]' (diff., need sugar)
proc gtk_app_chooser_dialog_new(parent: ptr TWindow, flags: SDialogFlags, file: ptr Gio2.TFile): TransferNone[TAppChooserDialog] {.cdecl, dynlib: lib, importc: "gtk_app_chooser_dialog_new".}
proc new_appchooserdialog*(parent: Window, flags: SDialogFlags, file: ptr Gio2.TFile): AppChooserDialog {.inline.} =
  wrap(gtk_app_chooser_dialog_new(parent.getPointer, flags, file))
# proc new_appchooserdialog*(parent: Window, flags: SDialogFlags, file: ptr Gio2.TFile): AppChooserDialog {.inline.} =

# gtk_app_chooser_dialog_new_for_content_type
# flags: {isConstructor} container: AppChooserDialog
# need sugar: is static method
# arg parent: INTERFACE (OBJECT) 'Window' 'ptr TWindow' IN (diff., need sugar)
# arg flags: INTERFACE (FLAGS) 'SDialogFlags' 'SDialogFlags' IN
# arg content_type: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'AppChooserDialog' 'TransferNone[TAppChooserDialog]' (diff., need sugar)
proc gtk_app_chooser_dialog_new_for_content_type(parent: ptr TWindow, flags: SDialogFlags, content_type: ucstring): TransferNone[TAppChooserDialog] {.cdecl, dynlib: lib, importc: "gtk_app_chooser_dialog_new_for_content_type".}
proc new_appchooserdialog_for_content_type*(parent: Window, flags: SDialogFlags, content_type: ustring): AppChooserDialog {.inline.} =
  wrap(gtk_app_chooser_dialog_new_for_content_type(parent.getPointer, flags, ucstring(content_type)))
# proc new_appchooserdialog_for_content_type*(parent: Window, flags: SDialogFlags, content_type: ustring): AppChooserDialog {.inline.} =

# gtk_app_chooser_dialog_get_heading
# flags: {isMethod} container: AppChooserDialog
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_app_chooser_dialog_get_heading(self: ptr TAppChooserDialog): ucstring {.cdecl, dynlib: lib, importc: "gtk_app_chooser_dialog_get_heading".}
proc get_heading*(self: AppChooserDialog): ucstring {.inline.} =
  gtk_app_chooser_dialog_get_heading(self)
# proc get_heading*(self: AppChooserDialog): ucstring {.inline.} =

# gtk_app_chooser_dialog_get_widget
# flags: {isMethod} container: AppChooserDialog
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_app_chooser_dialog_get_widget(self: ptr TAppChooserDialog): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_app_chooser_dialog_get_widget".}
proc get_widget*(self: AppChooserDialog): Widget {.inline.} =
  wrap(gtk_app_chooser_dialog_get_widget(self))
# proc get_widget*(self: AppChooserDialog): Widget {.inline.} =

# gtk_app_chooser_dialog_set_heading
# flags: {isMethod} container: AppChooserDialog
# need sugar: is method
# arg heading: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_app_chooser_dialog_set_heading(self: ptr TAppChooserDialog, heading: ucstring) {.cdecl, dynlib: lib, importc: "gtk_app_chooser_dialog_set_heading".}
proc set_heading*(self: AppChooserDialog, heading: ustring) {.inline.} =
  gtk_app_chooser_dialog_set_heading(self, ucstring(heading))
# proc set_heading*(self: AppChooserDialog, heading: ustring) {.inline.} =

# initializer for AppChooserWidget: gtk_app_chooser_widget_get_type
proc gtk_app_chooser_widget_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_get_type".}
template gtype*(klass_parameter: typedesc[AppChooserWidget]): GType = gtk_app_chooser_widget_get_type()
# gtk_app_chooser_widget_new
# flags: {isConstructor} container: AppChooserWidget
# need sugar: is static method
# arg content_type: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'AppChooserWidget' 'TransferNone[TAppChooserWidget]' (diff., need sugar)
proc gtk_app_chooser_widget_new(content_type: ucstring): TransferNone[TAppChooserWidget] {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_new".}
proc new_appchooserwidget*(content_type: ustring): AppChooserWidget {.inline.} =
  wrap(gtk_app_chooser_widget_new(ucstring(content_type)))
# proc new_appchooserwidget*(content_type: ustring): AppChooserWidget {.inline.} =

# gtk_app_chooser_widget_get_default_text
# flags: {isMethod} container: AppChooserWidget
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_app_chooser_widget_get_default_text(self: ptr TAppChooserWidget): ucstring {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_get_default_text".}
proc get_default_text*(self: AppChooserWidget): ucstring {.inline.} =
  gtk_app_chooser_widget_get_default_text(self)
# proc get_default_text*(self: AppChooserWidget): ucstring {.inline.} =

# gtk_app_chooser_widget_get_show_all
# flags: {isMethod} container: AppChooserWidget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_app_chooser_widget_get_show_all(self: ptr TAppChooserWidget): bool {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_get_show_all".}
proc get_show_all*(self: AppChooserWidget): bool {.inline.} =
  gtk_app_chooser_widget_get_show_all(self)
# proc get_show_all*(self: AppChooserWidget): bool {.inline.} =

# gtk_app_chooser_widget_get_show_default
# flags: {isMethod} container: AppChooserWidget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_app_chooser_widget_get_show_default(self: ptr TAppChooserWidget): bool {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_get_show_default".}
proc get_show_default*(self: AppChooserWidget): bool {.inline.} =
  gtk_app_chooser_widget_get_show_default(self)
# proc get_show_default*(self: AppChooserWidget): bool {.inline.} =

# gtk_app_chooser_widget_get_show_fallback
# flags: {isMethod} container: AppChooserWidget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_app_chooser_widget_get_show_fallback(self: ptr TAppChooserWidget): bool {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_get_show_fallback".}
proc get_show_fallback*(self: AppChooserWidget): bool {.inline.} =
  gtk_app_chooser_widget_get_show_fallback(self)
# proc get_show_fallback*(self: AppChooserWidget): bool {.inline.} =

# gtk_app_chooser_widget_get_show_other
# flags: {isMethod} container: AppChooserWidget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_app_chooser_widget_get_show_other(self: ptr TAppChooserWidget): bool {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_get_show_other".}
proc get_show_other*(self: AppChooserWidget): bool {.inline.} =
  gtk_app_chooser_widget_get_show_other(self)
# proc get_show_other*(self: AppChooserWidget): bool {.inline.} =

# gtk_app_chooser_widget_get_show_recommended
# flags: {isMethod} container: AppChooserWidget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_app_chooser_widget_get_show_recommended(self: ptr TAppChooserWidget): bool {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_get_show_recommended".}
proc get_show_recommended*(self: AppChooserWidget): bool {.inline.} =
  gtk_app_chooser_widget_get_show_recommended(self)
# proc get_show_recommended*(self: AppChooserWidget): bool {.inline.} =

# gtk_app_chooser_widget_set_default_text
# flags: {isMethod} container: AppChooserWidget
# need sugar: is method
# arg text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_app_chooser_widget_set_default_text(self: ptr TAppChooserWidget, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_set_default_text".}
proc set_default_text*(self: AppChooserWidget, text: ustring) {.inline.} =
  gtk_app_chooser_widget_set_default_text(self, ucstring(text))
# proc set_default_text*(self: AppChooserWidget, text: ustring) {.inline.} =

# gtk_app_chooser_widget_set_show_all
# flags: {isMethod} container: AppChooserWidget
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_app_chooser_widget_set_show_all(self: ptr TAppChooserWidget, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_set_show_all".}
proc set_show_all*(self: AppChooserWidget, setting: bool) {.inline.} =
  gtk_app_chooser_widget_set_show_all(self, setting)
# proc set_show_all*(self: AppChooserWidget, setting: bool) {.inline.} =

# gtk_app_chooser_widget_set_show_default
# flags: {isMethod} container: AppChooserWidget
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_app_chooser_widget_set_show_default(self: ptr TAppChooserWidget, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_set_show_default".}
proc set_show_default*(self: AppChooserWidget, setting: bool) {.inline.} =
  gtk_app_chooser_widget_set_show_default(self, setting)
# proc set_show_default*(self: AppChooserWidget, setting: bool) {.inline.} =

# gtk_app_chooser_widget_set_show_fallback
# flags: {isMethod} container: AppChooserWidget
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_app_chooser_widget_set_show_fallback(self: ptr TAppChooserWidget, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_set_show_fallback".}
proc set_show_fallback*(self: AppChooserWidget, setting: bool) {.inline.} =
  gtk_app_chooser_widget_set_show_fallback(self, setting)
# proc set_show_fallback*(self: AppChooserWidget, setting: bool) {.inline.} =

# gtk_app_chooser_widget_set_show_other
# flags: {isMethod} container: AppChooserWidget
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_app_chooser_widget_set_show_other(self: ptr TAppChooserWidget, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_set_show_other".}
proc set_show_other*(self: AppChooserWidget, setting: bool) {.inline.} =
  gtk_app_chooser_widget_set_show_other(self, setting)
# proc set_show_other*(self: AppChooserWidget, setting: bool) {.inline.} =

# gtk_app_chooser_widget_set_show_recommended
# flags: {isMethod} container: AppChooserWidget
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_app_chooser_widget_set_show_recommended(self: ptr TAppChooserWidget, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_app_chooser_widget_set_show_recommended".}
proc set_show_recommended*(self: AppChooserWidget, setting: bool) {.inline.} =
  gtk_app_chooser_widget_set_show_recommended(self, setting)
# proc set_show_recommended*(self: AppChooserWidget, setting: bool) {.inline.} =

# initializer for Application: gtk_application_get_type
proc gtk_application_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_application_get_type".}
template gtype*(klass_parameter: typedesc[Application]): GType = gtk_application_get_type()
# gtk_application_new
# flags: {isConstructor} container: Application
# need sugar: is static method
# arg application_id: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg flags: INTERFACE (FLAGS) 'Gio2.SApplicationFlags' 'Gio2.SApplicationFlags' IN
# return: INTERFACE 'Application' 'TransferFull[TApplication]' (diff., need sugar)
proc gtk_application_new(application_id: ucstring, flags: Gio2.SApplicationFlags): TransferFull[TApplication] {.cdecl, dynlib: lib, importc: "gtk_application_new".}
proc new_application*(application_id: ustring, flags: Gio2.SApplicationFlags): Application {.inline.} =
  wrap(gtk_application_new(ucstring(application_id), flags))
# proc new_application*(application_id: ustring, flags: Gio2.SApplicationFlags): Application {.inline.} =

# gtk_application_add_accelerator
# flags: {isMethod} container: Application (deprecated)
# gtk_application_add_window
# flags: {isMethod} container: Application
# need sugar: is method
# arg window: INTERFACE (OBJECT) 'Window' 'ptr TWindow' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_application_add_window(self: ptr TApplication, window: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_application_add_window".}
proc add_window*(self: Application, window: Window) {.inline.} =
  gtk_application_add_window(self, window.getPointer)
# proc add_window*(self: Application, window: Window) {.inline.} =

# gtk_application_get_accels_for_action
# flags: {isMethod} container: Application
# need sugar: is method
# arg detailed_action_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: ARRAY 'zeroTerminatedArray[ucstring]' 'zeroTerminatedArray[ucstring]'
proc gtk_application_get_accels_for_action(self: ptr TApplication, detailed_action_name: ucstring): zeroTerminatedArray[ucstring] {.cdecl, dynlib: lib, importc: "gtk_application_get_accels_for_action".}
proc get_accels_for_action*(self: Application, detailed_action_name: ustring): zeroTerminatedArray[ucstring] {.inline.} =
  gtk_application_get_accels_for_action(self, ucstring(detailed_action_name))
# proc get_accels_for_action*(self: Application, detailed_action_name: ustring): zeroTerminatedArray[ucstring] {.inline.} =

# gtk_application_get_actions_for_accel
# flags: {isMethod} container: Application
# need sugar: is method
# arg accel: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: ARRAY 'zeroTerminatedArray[ucstring]' 'zeroTerminatedArray[ucstring]'
proc gtk_application_get_actions_for_accel(self: ptr TApplication, accel: ucstring): zeroTerminatedArray[ucstring] {.cdecl, dynlib: lib, importc: "gtk_application_get_actions_for_accel".}
proc get_actions_for_accel*(self: Application, accel: ustring): zeroTerminatedArray[ucstring] {.inline.} =
  gtk_application_get_actions_for_accel(self, ucstring(accel))
# proc get_actions_for_accel*(self: Application, accel: ustring): zeroTerminatedArray[ucstring] {.inline.} =

# gtk_application_get_active_window
# flags: {isMethod} container: Application
# need sugar: is method
# return: INTERFACE 'Window' 'TransferNone[TWindow]' (diff., need sugar)
proc gtk_application_get_active_window(self: ptr TApplication): TransferNone[TWindow] {.cdecl, dynlib: lib, importc: "gtk_application_get_active_window".}
proc get_active_window*(self: Application): Window {.inline.} =
  wrap(gtk_application_get_active_window(self))
# proc get_active_window*(self: Application): Window {.inline.} =

# gtk_application_get_app_menu
# flags: {isMethod} container: Application
# need sugar: is method
# return: INTERFACE 'Gio2.MenuModel' 'TransferNone[Gio2.TMenuModel]' (diff., need sugar)
proc gtk_application_get_app_menu(self: ptr TApplication): TransferNone[Gio2.TMenuModel] {.cdecl, dynlib: lib, importc: "gtk_application_get_app_menu".}
proc get_app_menu*(self: Application): Gio2.MenuModel {.inline.} =
  wrap(gtk_application_get_app_menu(self))
# proc get_app_menu*(self: Application): Gio2.MenuModel {.inline.} =

# gtk_application_get_menu_by_id
# flags: {isMethod} container: Application
# need sugar: is method
# arg id: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'Gio2.Menu' 'TransferNone[Gio2.TMenu]' (diff., need sugar)
proc gtk_application_get_menu_by_id(self: ptr TApplication, id: ucstring): TransferNone[Gio2.TMenu] {.cdecl, dynlib: lib, importc: "gtk_application_get_menu_by_id".}
proc get_menu_by_id*(self: Application, id: ustring): Gio2.Menu {.inline.} =
  wrap(gtk_application_get_menu_by_id(self, ucstring(id)))
# proc get_menu_by_id*(self: Application, id: ustring): Gio2.Menu {.inline.} =

# gtk_application_get_menubar
# flags: {isMethod} container: Application
# need sugar: is method
# return: INTERFACE 'Gio2.MenuModel' 'TransferNone[Gio2.TMenuModel]' (diff., need sugar)
proc gtk_application_get_menubar(self: ptr TApplication): TransferNone[Gio2.TMenuModel] {.cdecl, dynlib: lib, importc: "gtk_application_get_menubar".}
proc get_menubar*(self: Application): Gio2.MenuModel {.inline.} =
  wrap(gtk_application_get_menubar(self))
# proc get_menubar*(self: Application): Gio2.MenuModel {.inline.} =

# gtk_application_get_window_by_id
# flags: {isMethod} container: Application
# need sugar: is method
# arg id: UINT32 'uint32' 'uint32' IN
# return: INTERFACE 'Window' 'TransferNone[TWindow]' (diff., need sugar)
proc gtk_application_get_window_by_id(self: ptr TApplication, id: uint32): TransferNone[TWindow] {.cdecl, dynlib: lib, importc: "gtk_application_get_window_by_id".}
proc get_window_by_id*(self: Application, id: uint32): Window {.inline.} =
  wrap(gtk_application_get_window_by_id(self, id))
# proc get_window_by_id*(self: Application, id: uint32): Window {.inline.} =

# gtk_application_get_windows
# flags: {isMethod} container: Application
# need sugar: is method
# return: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_application_get_windows(self: ptr TApplication): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_application_get_windows".}
proc get_windows*(self: Application): ptr GLIST_TODO {.inline.} =
  gtk_application_get_windows(self)
# proc get_windows*(self: Application): ptr GLIST_TODO {.inline.} =

# gtk_application_inhibit
# flags: {isMethod} container: Application
# need sugar: is method
# arg window: INTERFACE (OBJECT) 'Window' 'ptr TWindow' IN (diff., need sugar)
# arg flags: INTERFACE (FLAGS) 'SApplicationInhibitFlags' 'SApplicationInhibitFlags' IN
# arg reason: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: UINT32 'uint32' 'uint32'
proc gtk_application_inhibit(self: ptr TApplication, window: ptr TWindow, flags: SApplicationInhibitFlags, reason: ucstring): uint32 {.cdecl, dynlib: lib, importc: "gtk_application_inhibit".}
proc inhibit*(self: Application, window: Window, flags: SApplicationInhibitFlags, reason: ustring): uint32 {.inline.} =
  gtk_application_inhibit(self, window.getPointer, flags, ucstring(reason))
# proc inhibit*(self: Application, window: Window, flags: SApplicationInhibitFlags, reason: ustring): uint32 {.inline.} =

# gtk_application_is_inhibited
# flags: {isMethod} container: Application
# need sugar: is method
# arg flags: INTERFACE (FLAGS) 'SApplicationInhibitFlags' 'SApplicationInhibitFlags' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_application_is_inhibited(self: ptr TApplication, flags: SApplicationInhibitFlags): bool {.cdecl, dynlib: lib, importc: "gtk_application_is_inhibited".}
proc is_inhibited*(self: Application, flags: SApplicationInhibitFlags): bool {.inline.} =
  gtk_application_is_inhibited(self, flags)
# proc is_inhibited*(self: Application, flags: SApplicationInhibitFlags): bool {.inline.} =

# gtk_application_list_action_descriptions
# flags: {isMethod} container: Application
# need sugar: is method
# return: ARRAY 'zeroTerminatedArray[ucstring]' 'zeroTerminatedArray[ucstring]'
proc gtk_application_list_action_descriptions(self: ptr TApplication): zeroTerminatedArray[ucstring] {.cdecl, dynlib: lib, importc: "gtk_application_list_action_descriptions".}
proc list_action_descriptions*(self: Application): zeroTerminatedArray[ucstring] {.inline.} =
  gtk_application_list_action_descriptions(self)
# proc list_action_descriptions*(self: Application): zeroTerminatedArray[ucstring] {.inline.} =

# gtk_application_prefers_app_menu
# flags: {isMethod} container: Application
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_application_prefers_app_menu(self: ptr TApplication): bool {.cdecl, dynlib: lib, importc: "gtk_application_prefers_app_menu".}
proc prefers_app_menu*(self: Application): bool {.inline.} =
  gtk_application_prefers_app_menu(self)
# proc prefers_app_menu*(self: Application): bool {.inline.} =

# gtk_application_remove_accelerator
# flags: {isMethod} container: Application (deprecated)
# gtk_application_remove_window
# flags: {isMethod} container: Application
# need sugar: is method
# arg window: INTERFACE (OBJECT) 'Window' 'ptr TWindow' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_application_remove_window(self: ptr TApplication, window: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_application_remove_window".}
proc remove_window*(self: Application, window: Window) {.inline.} =
  gtk_application_remove_window(self, window.getPointer)
# proc remove_window*(self: Application, window: Window) {.inline.} =

# gtk_application_set_accels_for_action
# flags: {isMethod} container: Application
# need sugar: is method
# arg detailed_action_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg accels: ARRAY 'uncheckedArray[ucstring]' 'uncheckedArray[ucstring]' IN array zero-terminated
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_application_set_accels_for_action(self: ptr TApplication, detailed_action_name: ucstring, accels: uncheckedArray[ucstring]) {.cdecl, dynlib: lib, importc: "gtk_application_set_accels_for_action".}
proc set_accels_for_action*(self: Application, detailed_action_name: ustring, accels: uncheckedArray[ucstring]) {.inline.} =
  gtk_application_set_accels_for_action(self, ucstring(detailed_action_name), accels)
# proc set_accels_for_action*(self: Application, detailed_action_name: ustring, accels: uncheckedArray[ucstring]) {.inline.} =

# gtk_application_set_app_menu
# flags: {isMethod} container: Application
# need sugar: is method
# arg app_menu: INTERFACE (OBJECT) 'Gio2.MenuModel' 'ptr Gio2.TMenuModel' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_application_set_app_menu(self: ptr TApplication, app_menu: ptr Gio2.TMenuModel) {.cdecl, dynlib: lib, importc: "gtk_application_set_app_menu".}
proc set_app_menu*(self: Application, app_menu: Gio2.MenuModel) {.inline.} =
  gtk_application_set_app_menu(self, app_menu.getPointer)
# proc set_app_menu*(self: Application, app_menu: Gio2.MenuModel) {.inline.} =

# gtk_application_set_menubar
# flags: {isMethod} container: Application
# need sugar: is method
# arg menubar: INTERFACE (OBJECT) 'Gio2.MenuModel' 'ptr Gio2.TMenuModel' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_application_set_menubar(self: ptr TApplication, menubar: ptr Gio2.TMenuModel) {.cdecl, dynlib: lib, importc: "gtk_application_set_menubar".}
proc set_menubar*(self: Application, menubar: Gio2.MenuModel) {.inline.} =
  gtk_application_set_menubar(self, menubar.getPointer)
# proc set_menubar*(self: Application, menubar: Gio2.MenuModel) {.inline.} =

# gtk_application_uninhibit
# flags: {isMethod} container: Application
# need sugar: is method
# arg cookie: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_application_uninhibit(self: ptr TApplication, cookie: uint32) {.cdecl, dynlib: lib, importc: "gtk_application_uninhibit".}
proc uninhibit*(self: Application, cookie: uint32) {.inline.} =
  gtk_application_uninhibit(self, cookie)
# proc uninhibit*(self: Application, cookie: uint32) {.inline.} =

# initializer for ApplicationWindow: gtk_application_window_get_type
proc gtk_application_window_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_application_window_get_type".}
template gtype*(klass_parameter: typedesc[ApplicationWindow]): GType = gtk_application_window_get_type()
# gtk_application_window_new
# flags: {isConstructor} container: ApplicationWindow
# need sugar: is static method
# arg application: INTERFACE (OBJECT) 'Application' 'ptr TApplication' IN (diff., need sugar)
# return: INTERFACE 'ApplicationWindow' 'TransferNone[TApplicationWindow]' (diff., need sugar)
proc gtk_application_window_new(application: ptr TApplication): TransferNone[TApplicationWindow] {.cdecl, dynlib: lib, importc: "gtk_application_window_new".}
proc new_applicationwindow*(application: Application): ApplicationWindow {.inline.} =
  wrap(gtk_application_window_new(application.getPointer))
# proc new_applicationwindow*(application: Application): ApplicationWindow {.inline.} =

# gtk_application_window_get_id
# flags: {isMethod} container: ApplicationWindow
# need sugar: is method
# return: UINT32 'uint32' 'uint32'
proc gtk_application_window_get_id(self: ptr TApplicationWindow): uint32 {.cdecl, dynlib: lib, importc: "gtk_application_window_get_id".}
proc get_id*(self: ApplicationWindow): uint32 {.inline.} =
  gtk_application_window_get_id(self)
# proc get_id*(self: ApplicationWindow): uint32 {.inline.} =

# gtk_application_window_get_show_menubar
# flags: {isMethod} container: ApplicationWindow
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_application_window_get_show_menubar(self: ptr TApplicationWindow): bool {.cdecl, dynlib: lib, importc: "gtk_application_window_get_show_menubar".}
proc get_show_menubar*(self: ApplicationWindow): bool {.inline.} =
  gtk_application_window_get_show_menubar(self)
# proc get_show_menubar*(self: ApplicationWindow): bool {.inline.} =

# gtk_application_window_set_show_menubar
# flags: {isMethod} container: ApplicationWindow
# need sugar: is method
# arg show_menubar: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_application_window_set_show_menubar(self: ptr TApplicationWindow, show_menubar: bool) {.cdecl, dynlib: lib, importc: "gtk_application_window_set_show_menubar".}
proc set_show_menubar*(self: ApplicationWindow, show_menubar: bool) {.inline.} =
  gtk_application_window_set_show_menubar(self, show_menubar)
# proc set_show_menubar*(self: ApplicationWindow, show_menubar: bool) {.inline.} =

# initializer for Arrow: gtk_arrow_get_type
proc gtk_arrow_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_arrow_get_type".}
template gtype*(klass_parameter: typedesc[Arrow]): GType = gtk_arrow_get_type()
# gtk_arrow_new
# flags: {isConstructor} container: Arrow (deprecated)
# gtk_arrow_set
# flags: {isMethod} container: Arrow (deprecated)
# initializer for ArrowAccessible: gtk_arrow_accessible_get_type
proc gtk_arrow_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_arrow_accessible_get_type".}
template gtype*(klass_parameter: typedesc[ArrowAccessible]): GType = gtk_arrow_accessible_get_type()
# initializer for AspectFrame: gtk_aspect_frame_get_type
proc gtk_aspect_frame_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_aspect_frame_get_type".}
template gtype*(klass_parameter: typedesc[AspectFrame]): GType = gtk_aspect_frame_get_type()
# gtk_aspect_frame_new
# flags: {isConstructor} container: AspectFrame
# need sugar: is static method
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg xalign: FLOAT 'float32' 'float32' IN
# arg yalign: FLOAT 'float32' 'float32' IN
# arg ratio: FLOAT 'float32' 'float32' IN
# arg obey_child: BOOLEAN 'bool' 'bool' IN
# return: INTERFACE 'AspectFrame' 'TransferNone[TAspectFrame]' (diff., need sugar)
proc gtk_aspect_frame_new(label: ucstring, xalign: float32, yalign: float32, ratio: float32, obey_child: bool): TransferNone[TAspectFrame] {.cdecl, dynlib: lib, importc: "gtk_aspect_frame_new".}
proc new_aspectframe*(label: ustring, xalign: float32, yalign: float32, ratio: float32, obey_child: bool): AspectFrame {.inline.} =
  wrap(gtk_aspect_frame_new(ucstring(label), xalign, yalign, ratio, obey_child))
# proc new_aspectframe*(label: ustring, xalign: float32, yalign: float32, ratio: float32, obey_child: bool): AspectFrame {.inline.} =

# gtk_aspect_frame_set
# flags: {isMethod} container: AspectFrame
# need sugar: is method
# arg xalign: FLOAT 'float32' 'float32' IN
# arg yalign: FLOAT 'float32' 'float32' IN
# arg ratio: FLOAT 'float32' 'float32' IN
# arg obey_child: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_aspect_frame_set(self: ptr TAspectFrame, xalign: float32, yalign: float32, ratio: float32, obey_child: bool) {.cdecl, dynlib: lib, importc: "gtk_aspect_frame_set".}
proc set*(self: AspectFrame, xalign: float32, yalign: float32, ratio: float32, obey_child: bool) {.inline.} =
  gtk_aspect_frame_set(self, xalign, yalign, ratio, obey_child)
# proc set*(self: AspectFrame, xalign: float32, yalign: float32, ratio: float32, obey_child: bool) {.inline.} =

# initializer for Assistant: gtk_assistant_get_type
proc gtk_assistant_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_assistant_get_type".}
template gtype*(klass_parameter: typedesc[Assistant]): GType = gtk_assistant_get_type()
# gtk_assistant_new
# flags: {isConstructor} container: Assistant
# need sugar: is static method
# return: INTERFACE 'Assistant' 'TransferNone[TAssistant]' (diff., need sugar)
proc gtk_assistant_new(): TransferNone[TAssistant] {.cdecl, dynlib: lib, importc: "gtk_assistant_new".}
proc new_assistant*(): Assistant {.inline.} =
  wrap(gtk_assistant_new())
# proc new_assistant*(): Assistant {.inline.} =

# gtk_assistant_add_action_widget
# flags: {isMethod} container: Assistant
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_assistant_add_action_widget(self: ptr TAssistant, child: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_assistant_add_action_widget".}
proc add_action_widget*(self: Assistant, child: Widget) {.inline.} =
  gtk_assistant_add_action_widget(self, child.getPointer)
# proc add_action_widget*(self: Assistant, child: Widget) {.inline.} =

# gtk_assistant_append_page
# flags: {isMethod} container: Assistant
# need sugar: is method
# arg page: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: INT32 'int32' 'int32'
proc gtk_assistant_append_page(self: ptr TAssistant, page: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_assistant_append_page".}
proc append_page*(self: Assistant, page: Widget): int32 {.inline.} =
  gtk_assistant_append_page(self, page.getPointer)
# proc append_page*(self: Assistant, page: Widget): int32 {.inline.} =

# gtk_assistant_commit
# flags: {isMethod} container: Assistant
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_assistant_commit(self: ptr TAssistant) {.cdecl, dynlib: lib, importc: "gtk_assistant_commit".}
proc commit*(self: Assistant) {.inline.} =
  gtk_assistant_commit(self)
# proc commit*(self: Assistant) {.inline.} =

# gtk_assistant_get_current_page
# flags: {isMethod} container: Assistant
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_assistant_get_current_page(self: ptr TAssistant): int32 {.cdecl, dynlib: lib, importc: "gtk_assistant_get_current_page".}
proc get_current_page*(self: Assistant): int32 {.inline.} =
  gtk_assistant_get_current_page(self)
# proc get_current_page*(self: Assistant): int32 {.inline.} =

# gtk_assistant_get_n_pages
# flags: {isMethod} container: Assistant
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_assistant_get_n_pages(self: ptr TAssistant): int32 {.cdecl, dynlib: lib, importc: "gtk_assistant_get_n_pages".}
proc get_n_pages*(self: Assistant): int32 {.inline.} =
  gtk_assistant_get_n_pages(self)
# proc get_n_pages*(self: Assistant): int32 {.inline.} =

# gtk_assistant_get_nth_page
# flags: {isMethod} container: Assistant
# need sugar: is method
# arg page_num: INT32 'int32' 'int32' IN
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_assistant_get_nth_page(self: ptr TAssistant, page_num: int32): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_assistant_get_nth_page".}
proc get_nth_page*(self: Assistant, page_num: int32): Widget {.inline.} =
  wrap(gtk_assistant_get_nth_page(self, page_num))
# proc get_nth_page*(self: Assistant, page_num: int32): Widget {.inline.} =

# gtk_assistant_get_page_complete
# flags: {isMethod} container: Assistant
# need sugar: is method
# arg page: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_assistant_get_page_complete(self: ptr TAssistant, page: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_assistant_get_page_complete".}
proc get_page_complete*(self: Assistant, page: Widget): bool {.inline.} =
  gtk_assistant_get_page_complete(self, page.getPointer)
# proc get_page_complete*(self: Assistant, page: Widget): bool {.inline.} =

# gtk_assistant_get_page_has_padding
# flags: {isMethod} container: Assistant
# need sugar: is method
# arg page: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_assistant_get_page_has_padding(self: ptr TAssistant, page: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_assistant_get_page_has_padding".}
proc get_page_has_padding*(self: Assistant, page: Widget): bool {.inline.} =
  gtk_assistant_get_page_has_padding(self, page.getPointer)
# proc get_page_has_padding*(self: Assistant, page: Widget): bool {.inline.} =

# gtk_assistant_get_page_header_image
# flags: {isMethod} container: Assistant (deprecated)
# gtk_assistant_get_page_side_image
# flags: {isMethod} container: Assistant (deprecated)
# gtk_assistant_get_page_title
# flags: {isMethod} container: Assistant
# need sugar: is method
# arg page: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: UTF8 'ucstring' 'ucstring'
proc gtk_assistant_get_page_title(self: ptr TAssistant, page: ptr TWidget): ucstring {.cdecl, dynlib: lib, importc: "gtk_assistant_get_page_title".}
proc get_page_title*(self: Assistant, page: Widget): ucstring {.inline.} =
  gtk_assistant_get_page_title(self, page.getPointer)
# proc get_page_title*(self: Assistant, page: Widget): ucstring {.inline.} =

# gtk_assistant_get_page_type
# flags: {isMethod} container: Assistant
# need sugar: is method
# arg page: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: INTERFACE 'AssistantPageType' 'AssistantPageType'
proc gtk_assistant_get_page_type(self: ptr TAssistant, page: ptr TWidget): AssistantPageType {.cdecl, dynlib: lib, importc: "gtk_assistant_get_page_type".}
proc get_page_type*(self: Assistant, page: Widget): AssistantPageType {.inline.} =
  gtk_assistant_get_page_type(self, page.getPointer)
# proc get_page_type*(self: Assistant, page: Widget): AssistantPageType {.inline.} =

# gtk_assistant_insert_page
# flags: {isMethod} container: Assistant
# need sugar: is method
# arg page: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg position: INT32 'int32' 'int32' IN
# return: INT32 'int32' 'int32'
proc gtk_assistant_insert_page(self: ptr TAssistant, page: ptr TWidget, position: int32): int32 {.cdecl, dynlib: lib, importc: "gtk_assistant_insert_page".}
proc insert_page*(self: Assistant, page: Widget, position: int32): int32 {.inline.} =
  gtk_assistant_insert_page(self, page.getPointer, position)
# proc insert_page*(self: Assistant, page: Widget, position: int32): int32 {.inline.} =

# gtk_assistant_next_page
# flags: {isMethod} container: Assistant
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_assistant_next_page(self: ptr TAssistant) {.cdecl, dynlib: lib, importc: "gtk_assistant_next_page".}
proc next_page*(self: Assistant) {.inline.} =
  gtk_assistant_next_page(self)
# proc next_page*(self: Assistant) {.inline.} =

# gtk_assistant_prepend_page
# flags: {isMethod} container: Assistant
# need sugar: is method
# arg page: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: INT32 'int32' 'int32'
proc gtk_assistant_prepend_page(self: ptr TAssistant, page: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_assistant_prepend_page".}
proc prepend_page*(self: Assistant, page: Widget): int32 {.inline.} =
  gtk_assistant_prepend_page(self, page.getPointer)
# proc prepend_page*(self: Assistant, page: Widget): int32 {.inline.} =

# gtk_assistant_previous_page
# flags: {isMethod} container: Assistant
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_assistant_previous_page(self: ptr TAssistant) {.cdecl, dynlib: lib, importc: "gtk_assistant_previous_page".}
proc previous_page*(self: Assistant) {.inline.} =
  gtk_assistant_previous_page(self)
# proc previous_page*(self: Assistant) {.inline.} =

# gtk_assistant_remove_action_widget
# flags: {isMethod} container: Assistant
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_assistant_remove_action_widget(self: ptr TAssistant, child: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_assistant_remove_action_widget".}
proc remove_action_widget*(self: Assistant, child: Widget) {.inline.} =
  gtk_assistant_remove_action_widget(self, child.getPointer)
# proc remove_action_widget*(self: Assistant, child: Widget) {.inline.} =

# gtk_assistant_remove_page
# flags: {isMethod} container: Assistant
# need sugar: is method
# arg page_num: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_assistant_remove_page(self: ptr TAssistant, page_num: int32) {.cdecl, dynlib: lib, importc: "gtk_assistant_remove_page".}
proc remove_page*(self: Assistant, page_num: int32) {.inline.} =
  gtk_assistant_remove_page(self, page_num)
# proc remove_page*(self: Assistant, page_num: int32) {.inline.} =

# gtk_assistant_set_current_page
# flags: {isMethod} container: Assistant
# need sugar: is method
# arg page_num: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_assistant_set_current_page(self: ptr TAssistant, page_num: int32) {.cdecl, dynlib: lib, importc: "gtk_assistant_set_current_page".}
proc set_current_page*(self: Assistant, page_num: int32) {.inline.} =
  gtk_assistant_set_current_page(self, page_num)
# proc set_current_page*(self: Assistant, page_num: int32) {.inline.} =

# gtk_assistant_set_forward_page_func
# flags: {isMethod} container: Assistant
# need sugar: is method
# arg page_func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg data: VOID 'pointer' 'pointer' IN
# arg destroy: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_assistant_set_forward_page_func(self: ptr TAssistant, page_func: pointer, data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_assistant_set_forward_page_func".}
proc set_forward_page_func*(self: Assistant, page_func: pointer, data: pointer, destroy: pointer) {.inline.} =
  gtk_assistant_set_forward_page_func(self, page_func, data, destroy)
# proc set_forward_page_func*(self: Assistant, page_func: pointer, data: pointer, destroy: pointer) {.inline.} =

# gtk_assistant_set_page_complete
# flags: {isMethod} container: Assistant
# need sugar: is method
# arg page: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg complete: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_assistant_set_page_complete(self: ptr TAssistant, page: ptr TWidget, complete: bool) {.cdecl, dynlib: lib, importc: "gtk_assistant_set_page_complete".}
proc set_page_complete*(self: Assistant, page: Widget, complete: bool) {.inline.} =
  gtk_assistant_set_page_complete(self, page.getPointer, complete)
# proc set_page_complete*(self: Assistant, page: Widget, complete: bool) {.inline.} =

# gtk_assistant_set_page_has_padding
# flags: {isMethod} container: Assistant
# need sugar: is method
# arg page: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg has_padding: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_assistant_set_page_has_padding(self: ptr TAssistant, page: ptr TWidget, has_padding: bool) {.cdecl, dynlib: lib, importc: "gtk_assistant_set_page_has_padding".}
proc set_page_has_padding*(self: Assistant, page: Widget, has_padding: bool) {.inline.} =
  gtk_assistant_set_page_has_padding(self, page.getPointer, has_padding)
# proc set_page_has_padding*(self: Assistant, page: Widget, has_padding: bool) {.inline.} =

# gtk_assistant_set_page_header_image
# flags: {isMethod} container: Assistant (deprecated)
# gtk_assistant_set_page_side_image
# flags: {isMethod} container: Assistant (deprecated)
# gtk_assistant_set_page_title
# flags: {isMethod} container: Assistant
# need sugar: is method
# arg page: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg title: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_assistant_set_page_title(self: ptr TAssistant, page: ptr TWidget, title: ucstring) {.cdecl, dynlib: lib, importc: "gtk_assistant_set_page_title".}
proc set_page_title*(self: Assistant, page: Widget, title: ustring) {.inline.} =
  gtk_assistant_set_page_title(self, page.getPointer, ucstring(title))
# proc set_page_title*(self: Assistant, page: Widget, title: ustring) {.inline.} =

# gtk_assistant_set_page_type
# flags: {isMethod} container: Assistant
# need sugar: is method
# arg page: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg type: INTERFACE (ENUM) 'AssistantPageType' 'AssistantPageType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_assistant_set_page_type(self: ptr TAssistant, page: ptr TWidget, type_x: AssistantPageType) {.cdecl, dynlib: lib, importc: "gtk_assistant_set_page_type".}
proc set_page_type*(self: Assistant, page: Widget, type_x: AssistantPageType) {.inline.} =
  gtk_assistant_set_page_type(self, page.getPointer, type_x)
# proc set_page_type*(self: Assistant, page: Widget, type_x: AssistantPageType) {.inline.} =

# gtk_assistant_update_buttons_state
# flags: {isMethod} container: Assistant
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_assistant_update_buttons_state(self: ptr TAssistant) {.cdecl, dynlib: lib, importc: "gtk_assistant_update_buttons_state".}
proc update_buttons_state*(self: Assistant) {.inline.} =
  gtk_assistant_update_buttons_state(self)
# proc update_buttons_state*(self: Assistant) {.inline.} =

# initializer for Bin: gtk_bin_get_type
proc gtk_bin_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_bin_get_type".}
template gtype*(klass_parameter: typedesc[Bin]): GType = gtk_bin_get_type()
# gtk_bin_get_child
# flags: {isMethod} container: Bin
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_bin_get_child(self: ptr TBin): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_bin_get_child".}
proc get_child*(self: Bin): Widget {.inline.} =
  wrap(gtk_bin_get_child(self))
# proc get_child*(self: Bin): Widget {.inline.} =

# initializer for BooleanCellAccessible: gtk_boolean_cell_accessible_get_type
proc gtk_boolean_cell_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_boolean_cell_accessible_get_type".}
template gtype*(klass_parameter: typedesc[BooleanCellAccessible]): GType = gtk_boolean_cell_accessible_get_type()
# initializer for Box: gtk_box_get_type
proc gtk_box_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_box_get_type".}
template gtype*(klass_parameter: typedesc[Box]): GType = gtk_box_get_type()
# gtk_box_new
# flags: {isConstructor} container: Box
# need sugar: is static method
# arg orientation: INTERFACE (ENUM) 'Orientation' 'Orientation' IN
# arg spacing: INT32 'int32' 'int32' IN
# return: INTERFACE 'Box' 'TransferNone[TBox]' (diff., need sugar)
proc gtk_box_new(orientation: Orientation, spacing: int32): TransferNone[TBox] {.cdecl, dynlib: lib, importc: "gtk_box_new".}
proc new_box*(orientation: Orientation, spacing: int32): Box {.inline.} =
  wrap(gtk_box_new(orientation, spacing))
# proc new_box*(orientation: Orientation, spacing: int32): Box {.inline.} =

# gtk_box_get_baseline_position
# flags: {isMethod} container: Box
# need sugar: is method
# return: INTERFACE 'BaselinePosition' 'BaselinePosition'
proc gtk_box_get_baseline_position(self: ptr TBox): BaselinePosition {.cdecl, dynlib: lib, importc: "gtk_box_get_baseline_position".}
proc get_baseline_position*(self: Box): BaselinePosition {.inline.} =
  gtk_box_get_baseline_position(self)
# proc get_baseline_position*(self: Box): BaselinePosition {.inline.} =

# gtk_box_get_center_widget
# flags: {isMethod} container: Box
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_box_get_center_widget(self: ptr TBox): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_box_get_center_widget".}
proc get_center_widget*(self: Box): Widget {.inline.} =
  wrap(gtk_box_get_center_widget(self))
# proc get_center_widget*(self: Box): Widget {.inline.} =

# gtk_box_get_homogeneous
# flags: {isMethod} container: Box
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_box_get_homogeneous(self: ptr TBox): bool {.cdecl, dynlib: lib, importc: "gtk_box_get_homogeneous".}
proc get_homogeneous*(self: Box): bool {.inline.} =
  gtk_box_get_homogeneous(self)
# proc get_homogeneous*(self: Box): bool {.inline.} =

# gtk_box_get_spacing
# flags: {isMethod} container: Box
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_box_get_spacing(self: ptr TBox): int32 {.cdecl, dynlib: lib, importc: "gtk_box_get_spacing".}
proc get_spacing*(self: Box): int32 {.inline.} =
  gtk_box_get_spacing(self)
# proc get_spacing*(self: Box): int32 {.inline.} =

# gtk_box_pack_end
# flags: {isMethod} container: Box
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg expand: BOOLEAN 'bool' 'bool' IN
# arg fill: BOOLEAN 'bool' 'bool' IN
# arg padding: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_box_pack_end(self: ptr TBox, child: ptr TWidget, expand: bool, fill: bool, padding: uint32) {.cdecl, dynlib: lib, importc: "gtk_box_pack_end".}
proc pack_end*(self: Box, child: Widget, expand: bool, fill: bool, padding: uint32) {.inline.} =
  gtk_box_pack_end(self, child.getPointer, expand, fill, padding)
# proc pack_end*(self: Box, child: Widget, expand: bool, fill: bool, padding: uint32) {.inline.} =

# gtk_box_pack_start
# flags: {isMethod} container: Box
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg expand: BOOLEAN 'bool' 'bool' IN
# arg fill: BOOLEAN 'bool' 'bool' IN
# arg padding: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_box_pack_start(self: ptr TBox, child: ptr TWidget, expand: bool, fill: bool, padding: uint32) {.cdecl, dynlib: lib, importc: "gtk_box_pack_start".}
proc pack_start*(self: Box, child: Widget, expand: bool, fill: bool, padding: uint32) {.inline.} =
  gtk_box_pack_start(self, child.getPointer, expand, fill, padding)
# proc pack_start*(self: Box, child: Widget, expand: bool, fill: bool, padding: uint32) {.inline.} =

# gtk_box_query_child_packing
# flags: {isMethod} container: Box
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg expand: BOOLEAN 'var bool' 'ptr bool' OUT (diff., need sugar)
# arg fill: BOOLEAN 'var bool' 'ptr bool' OUT (diff., need sugar)
# arg padding: UINT32 'var uint32' 'ptr uint32' OUT (diff., need sugar)
# arg pack_type: INTERFACE (ENUM) 'PackType' 'PackType' OUT
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_box_query_child_packing(self: ptr TBox, child: ptr TWidget, expand: ptr bool, fill: ptr bool, padding: ptr uint32, pack_type: PackType) {.cdecl, dynlib: lib, importc: "gtk_box_query_child_packing".}
proc query_child_packing*(self: Box, child: Widget, expand: var bool, fill: var bool, padding: var uint32, pack_type: PackType) {.inline.} =
  gtk_box_query_child_packing(self, child.getPointer, addr(expand), addr(fill), addr(padding), pack_type)
# tuple-return
# expand: var bool
# fill: var bool
# padding: var uint32
# pack_type: PackType
# proc query_child_packing*(self: Box, child: Widget) {.inline.} =

# gtk_box_reorder_child
# flags: {isMethod} container: Box
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg position: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_box_reorder_child(self: ptr TBox, child: ptr TWidget, position: int32) {.cdecl, dynlib: lib, importc: "gtk_box_reorder_child".}
proc reorder_child*(self: Box, child: Widget, position: int32) {.inline.} =
  gtk_box_reorder_child(self, child.getPointer, position)
# proc reorder_child*(self: Box, child: Widget, position: int32) {.inline.} =

# gtk_box_set_baseline_position
# flags: {isMethod} container: Box
# need sugar: is method
# arg position: INTERFACE (ENUM) 'BaselinePosition' 'BaselinePosition' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_box_set_baseline_position(self: ptr TBox, position: BaselinePosition) {.cdecl, dynlib: lib, importc: "gtk_box_set_baseline_position".}
proc set_baseline_position*(self: Box, position: BaselinePosition) {.inline.} =
  gtk_box_set_baseline_position(self, position)
# proc set_baseline_position*(self: Box, position: BaselinePosition) {.inline.} =

# gtk_box_set_center_widget
# flags: {isMethod} container: Box
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_box_set_center_widget(self: ptr TBox, widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_box_set_center_widget".}
proc set_center_widget*(self: Box, widget: Widget) {.inline.} =
  gtk_box_set_center_widget(self, widget.getPointer)
# proc set_center_widget*(self: Box, widget: Widget) {.inline.} =

# gtk_box_set_child_packing
# flags: {isMethod} container: Box
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg expand: BOOLEAN 'bool' 'bool' IN
# arg fill: BOOLEAN 'bool' 'bool' IN
# arg padding: UINT32 'uint32' 'uint32' IN
# arg pack_type: INTERFACE (ENUM) 'PackType' 'PackType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_box_set_child_packing(self: ptr TBox, child: ptr TWidget, expand: bool, fill: bool, padding: uint32, pack_type: PackType) {.cdecl, dynlib: lib, importc: "gtk_box_set_child_packing".}
proc set_child_packing*(self: Box, child: Widget, expand: bool, fill: bool, padding: uint32, pack_type: PackType) {.inline.} =
  gtk_box_set_child_packing(self, child.getPointer, expand, fill, padding, pack_type)
# proc set_child_packing*(self: Box, child: Widget, expand: bool, fill: bool, padding: uint32, pack_type: PackType) {.inline.} =

# gtk_box_set_homogeneous
# flags: {isMethod} container: Box
# need sugar: is method
# arg homogeneous: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_box_set_homogeneous(self: ptr TBox, homogeneous: bool) {.cdecl, dynlib: lib, importc: "gtk_box_set_homogeneous".}
proc set_homogeneous*(self: Box, homogeneous: bool) {.inline.} =
  gtk_box_set_homogeneous(self, homogeneous)
# proc set_homogeneous*(self: Box, homogeneous: bool) {.inline.} =

# gtk_box_set_spacing
# flags: {isMethod} container: Box
# need sugar: is method
# arg spacing: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_box_set_spacing(self: ptr TBox, spacing: int32) {.cdecl, dynlib: lib, importc: "gtk_box_set_spacing".}
proc set_spacing*(self: Box, spacing: int32) {.inline.} =
  gtk_box_set_spacing(self, spacing)
# proc set_spacing*(self: Box, spacing: int32) {.inline.} =

# initializer for Builder: gtk_builder_get_type
proc gtk_builder_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_builder_get_type".}
template gtype*(klass_parameter: typedesc[Builder]): GType = gtk_builder_get_type()
# gtk_builder_new
# flags: {isConstructor} container: Builder
# need sugar: is static method
# return: INTERFACE 'Builder' 'TransferFull[TBuilder]' (diff., need sugar)
proc gtk_builder_new(): TransferFull[TBuilder] {.cdecl, dynlib: lib, importc: "gtk_builder_new".}
proc new_builder*(): Builder {.inline.} =
  wrap(gtk_builder_new())
# proc new_builder*(): Builder {.inline.} =

# gtk_builder_new_from_file
# flags: {isConstructor} container: Builder
# need sugar: is static method
# arg filename: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'Builder' 'TransferFull[TBuilder]' (diff., need sugar)
proc gtk_builder_new_from_file(filename: ucstring): TransferFull[TBuilder] {.cdecl, dynlib: lib, importc: "gtk_builder_new_from_file".}
proc new_builder_from_file*(filename: ustring): Builder {.inline.} =
  wrap(gtk_builder_new_from_file(ucstring(filename)))
# proc new_builder_from_file*(filename: ustring): Builder {.inline.} =

# gtk_builder_new_from_resource
# flags: {isConstructor} container: Builder
# need sugar: is static method
# arg resource_path: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'Builder' 'TransferFull[TBuilder]' (diff., need sugar)
proc gtk_builder_new_from_resource(resource_path: ucstring): TransferFull[TBuilder] {.cdecl, dynlib: lib, importc: "gtk_builder_new_from_resource".}
proc new_builder_from_resource*(resource_path: ustring): Builder {.inline.} =
  wrap(gtk_builder_new_from_resource(ucstring(resource_path)))
# proc new_builder_from_resource*(resource_path: ustring): Builder {.inline.} =

# gtk_builder_new_from_string
# flags: {isConstructor} container: Builder
# need sugar: is static method
# arg string: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg length: INT32 'int32' 'int32' IN
# return: INTERFACE 'Builder' 'TransferFull[TBuilder]' (diff., need sugar)
proc gtk_builder_new_from_string(string: ucstring, length: int32): TransferFull[TBuilder] {.cdecl, dynlib: lib, importc: "gtk_builder_new_from_string".}
proc new_builder_from_string*(string: ustring, length: int32): Builder {.inline.} =
  wrap(gtk_builder_new_from_string(ucstring(string), length))
# proc new_builder_from_string*(string: ustring, length: int32): Builder {.inline.} =

# gtk_builder_add_callback_symbol
# flags: {isMethod} container: Builder
# need sugar: is method
# arg callback_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg callback_symbol: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_builder_add_callback_symbol(self: ptr TBuilder, callback_name: ucstring, callback_symbol: pointer) {.cdecl, dynlib: lib, importc: "gtk_builder_add_callback_symbol".}
proc add_callback_symbol*(self: Builder, callback_name: ustring, callback_symbol: pointer) {.inline.} =
  gtk_builder_add_callback_symbol(self, ucstring(callback_name), callback_symbol)
# proc add_callback_symbol*(self: Builder, callback_name: ustring, callback_symbol: pointer) {.inline.} =

# gtk_builder_add_from_file
# flags: {isMethod, throws} container: Builder
# can throw
# need sugar: is method
# arg filename: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: UINT32 'uint32' 'uint32'
proc gtk_builder_add_from_file(self: ptr TBuilder, filename: ucstring, error: ptr PGError=nil): uint32 {.cdecl, dynlib: lib, importc: "gtk_builder_add_from_file".}
proc add_from_file*(self: Builder, filename: ustring): uint32 {.inline.} =
  gtk_builder_add_from_file(self, ucstring(filename))
# proc add_from_file*(self: Builder, filename: ustring): uint32 {.inline.} =

# gtk_builder_add_from_resource
# flags: {isMethod, throws} container: Builder
# can throw
# need sugar: is method
# arg resource_path: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: UINT32 'uint32' 'uint32'
proc gtk_builder_add_from_resource(self: ptr TBuilder, resource_path: ucstring, error: ptr PGError=nil): uint32 {.cdecl, dynlib: lib, importc: "gtk_builder_add_from_resource".}
proc add_from_resource*(self: Builder, resource_path: ustring): uint32 {.inline.} =
  gtk_builder_add_from_resource(self, ucstring(resource_path))
# proc add_from_resource*(self: Builder, resource_path: ustring): uint32 {.inline.} =

# gtk_builder_add_from_string
# flags: {isMethod, throws} container: Builder
# can throw
# need sugar: is method
# arg buffer: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg length: UINT32 'uint32' 'uint32' IN
# return: UINT32 'uint32' 'uint32'
proc gtk_builder_add_from_string(self: ptr TBuilder, buffer: ucstring, length: uint32, error: ptr PGError=nil): uint32 {.cdecl, dynlib: lib, importc: "gtk_builder_add_from_string".}
proc add_from_string*(self: Builder, buffer: ustring, length: uint32): uint32 {.inline.} =
  gtk_builder_add_from_string(self, ucstring(buffer), length)
# proc add_from_string*(self: Builder, buffer: ustring, length: uint32): uint32 {.inline.} =

# gtk_builder_add_objects_from_file
# flags: {isMethod, throws} container: Builder
# can throw
# need sugar: is method
# arg filename: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg object_ids: ARRAY 'uncheckedArray[ucstring]' 'uncheckedArray[ucstring]' IN array zero-terminated
# return: UINT32 'uint32' 'uint32'
proc gtk_builder_add_objects_from_file(self: ptr TBuilder, filename: ucstring, object_ids: uncheckedArray[ucstring], error: ptr PGError=nil): uint32 {.cdecl, dynlib: lib, importc: "gtk_builder_add_objects_from_file".}
proc add_objects_from_file*(self: Builder, filename: ustring, object_ids: uncheckedArray[ucstring]): uint32 {.inline.} =
  gtk_builder_add_objects_from_file(self, ucstring(filename), object_ids)
# proc add_objects_from_file*(self: Builder, filename: ustring, object_ids: uncheckedArray[ucstring]): uint32 {.inline.} =

# gtk_builder_add_objects_from_resource
# flags: {isMethod, throws} container: Builder
# can throw
# need sugar: is method
# arg resource_path: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg object_ids: ARRAY 'uncheckedArray[ucstring]' 'uncheckedArray[ucstring]' IN array zero-terminated
# return: UINT32 'uint32' 'uint32'
proc gtk_builder_add_objects_from_resource(self: ptr TBuilder, resource_path: ucstring, object_ids: uncheckedArray[ucstring], error: ptr PGError=nil): uint32 {.cdecl, dynlib: lib, importc: "gtk_builder_add_objects_from_resource".}
proc add_objects_from_resource*(self: Builder, resource_path: ustring, object_ids: uncheckedArray[ucstring]): uint32 {.inline.} =
  gtk_builder_add_objects_from_resource(self, ucstring(resource_path), object_ids)
# proc add_objects_from_resource*(self: Builder, resource_path: ustring, object_ids: uncheckedArray[ucstring]): uint32 {.inline.} =

# gtk_builder_add_objects_from_string
# flags: {isMethod, throws} container: Builder
# can throw
# need sugar: is method
# arg buffer: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg length: UINT32 'uint32' 'uint32' IN
# arg object_ids: ARRAY 'uncheckedArray[ucstring]' 'uncheckedArray[ucstring]' IN array zero-terminated
# return: UINT32 'uint32' 'uint32'
proc gtk_builder_add_objects_from_string(self: ptr TBuilder, buffer: ucstring, length: uint32, object_ids: uncheckedArray[ucstring], error: ptr PGError=nil): uint32 {.cdecl, dynlib: lib, importc: "gtk_builder_add_objects_from_string".}
proc add_objects_from_string*(self: Builder, buffer: ustring, length: uint32, object_ids: uncheckedArray[ucstring]): uint32 {.inline.} =
  gtk_builder_add_objects_from_string(self, ucstring(buffer), length, object_ids)
# proc add_objects_from_string*(self: Builder, buffer: ustring, length: uint32, object_ids: uncheckedArray[ucstring]): uint32 {.inline.} =

# gtk_builder_connect_signals
# flags: {isMethod} container: Builder
# need sugar: is method
# arg user_data: VOID 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_builder_connect_signals(self: ptr TBuilder, user_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_builder_connect_signals".}
proc connect_signals*(self: Builder, user_data: pointer) {.inline.} =
  gtk_builder_connect_signals(self, user_data)
# proc connect_signals*(self: Builder, user_data: pointer) {.inline.} =

# gtk_builder_connect_signals_full
# flags: {isMethod} container: Builder
# need sugar: is method
# arg func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg user_data: VOID 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_builder_connect_signals_full(self: ptr TBuilder, func_x: pointer, user_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_builder_connect_signals_full".}
proc connect_signals_full*(self: Builder, func_x: pointer, user_data: pointer) {.inline.} =
  gtk_builder_connect_signals_full(self, func_x, user_data)
# proc connect_signals_full*(self: Builder, func_x: pointer, user_data: pointer) {.inline.} =

# gtk_builder_expose_object
# flags: {isMethod} container: Builder
# need sugar: is method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg object: INTERFACE (OBJECT) 'GObject2.Object' 'ptr GObject2.TObject' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_builder_expose_object(self: ptr TBuilder, name: ucstring, object_x: ptr GObject2.TObject) {.cdecl, dynlib: lib, importc: "gtk_builder_expose_object".}
proc expose_object*(self: Builder, name: ustring, object_x: GObject2.Object) {.inline.} =
  gtk_builder_expose_object(self, ucstring(name), object_x.getPointer)
# proc expose_object*(self: Builder, name: ustring, object_x: GObject2.Object) {.inline.} =

# gtk_builder_get_application
# flags: {isMethod} container: Builder
# need sugar: is method
# return: INTERFACE 'Application' 'TransferNone[TApplication]' (diff., need sugar)
proc gtk_builder_get_application(self: ptr TBuilder): TransferNone[TApplication] {.cdecl, dynlib: lib, importc: "gtk_builder_get_application".}
proc get_application*(self: Builder): Application {.inline.} =
  wrap(gtk_builder_get_application(self))
# proc get_application*(self: Builder): Application {.inline.} =

# gtk_builder_get_object
# flags: {isMethod} container: Builder
# need sugar: is method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'GObject2.Object' 'TransferNone[GObject2.TObject]' (diff., need sugar)
proc gtk_builder_get_object(self: ptr TBuilder, name: ucstring): TransferNone[GObject2.TObject] {.cdecl, dynlib: lib, importc: "gtk_builder_get_object".}
proc get_object*(self: Builder, name: ustring): GObject2.Object {.inline.} =
  wrap(gtk_builder_get_object(self, ucstring(name)))
# proc get_object*(self: Builder, name: ustring): GObject2.Object {.inline.} =

# gtk_builder_get_objects
# flags: {isMethod} container: Builder
# need sugar: is method
# return: GSLIST 'ptr GSLIST_TODO' 'ptr GSLIST_TODO'
proc gtk_builder_get_objects(self: ptr TBuilder): ptr GSLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_builder_get_objects".}
proc get_objects*(self: Builder): ptr GSLIST_TODO {.inline.} =
  gtk_builder_get_objects(self)
# proc get_objects*(self: Builder): ptr GSLIST_TODO {.inline.} =

# gtk_builder_get_translation_domain
# flags: {isMethod} container: Builder
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_builder_get_translation_domain(self: ptr TBuilder): ucstring {.cdecl, dynlib: lib, importc: "gtk_builder_get_translation_domain".}
proc get_translation_domain*(self: Builder): ucstring {.inline.} =
  gtk_builder_get_translation_domain(self)
# proc get_translation_domain*(self: Builder): ucstring {.inline.} =

# gtk_builder_get_type_from_name
# flags: {isMethod} container: Builder
# need sugar: is method
# arg type_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: GTYPE 'GType' 'GType'
proc gtk_builder_get_type_from_name(self: ptr TBuilder, type_name: ucstring): GType {.cdecl, dynlib: lib, importc: "gtk_builder_get_type_from_name".}
proc get_type_from_name*(self: Builder, type_name: ustring): GType {.inline.} =
  gtk_builder_get_type_from_name(self, ucstring(type_name))
# proc get_type_from_name*(self: Builder, type_name: ustring): GType {.inline.} =

# gtk_builder_set_application
# flags: {isMethod} container: Builder
# need sugar: is method
# arg application: INTERFACE (OBJECT) 'Application' 'ptr TApplication' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_builder_set_application(self: ptr TBuilder, application: ptr TApplication) {.cdecl, dynlib: lib, importc: "gtk_builder_set_application".}
proc set_application*(self: Builder, application: Application) {.inline.} =
  gtk_builder_set_application(self, application.getPointer)
# proc set_application*(self: Builder, application: Application) {.inline.} =

# gtk_builder_set_translation_domain
# flags: {isMethod} container: Builder
# need sugar: is method
# arg domain: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_builder_set_translation_domain(self: ptr TBuilder, domain: ucstring) {.cdecl, dynlib: lib, importc: "gtk_builder_set_translation_domain".}
proc set_translation_domain*(self: Builder, domain: ustring) {.inline.} =
  gtk_builder_set_translation_domain(self, ucstring(domain))
# proc set_translation_domain*(self: Builder, domain: ustring) {.inline.} =

# gtk_builder_value_from_string
# flags: {isMethod, throws} container: Builder
# can throw
# need sugar: is method
# arg pspec: INTERFACE (OBJECT) 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# arg string: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg value: INTERFACE (STRUCT) 'ptr GObject2.TValue' 'ptr GObject2.TValue' OUT caller-allocates
# return: BOOLEAN 'bool' 'bool'
proc gtk_builder_value_from_string(self: ptr TBuilder, pspec: ptr GObject2.TParamSpec, string: ucstring, value: ptr GObject2.TValue, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_builder_value_from_string".}
proc value_from_string*(self: Builder, pspec: GObject2.ParamSpec, string: ustring, value: ptr GObject2.TValue): bool {.inline.} =
  gtk_builder_value_from_string(self, pspec.getPointer, ucstring(string), value)
# tuple-return
# value: ptr GObject2.TValue
# proc value_from_string*(self: Builder, pspec: GObject2.ParamSpec, string: ustring): bool {.inline.} =

# gtk_builder_value_from_string_type
# flags: {isMethod, throws} container: Builder
# can throw
# need sugar: is method
# arg type: GTYPE 'GType' 'GType' IN
# arg string: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg value: INTERFACE (STRUCT) 'ptr GObject2.TValue' 'ptr GObject2.TValue' OUT caller-allocates
# return: BOOLEAN 'bool' 'bool'
proc gtk_builder_value_from_string_type(self: ptr TBuilder, type_x: GType, string: ucstring, value: ptr GObject2.TValue, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_builder_value_from_string_type".}
proc value_from_string_type*(self: Builder, type_x: GType, string: ustring, value: ptr GObject2.TValue): bool {.inline.} =
  gtk_builder_value_from_string_type(self, type_x, ucstring(string), value)
# tuple-return
# value: ptr GObject2.TValue
# proc value_from_string_type*(self: Builder, type_x: GType, string: ustring): bool {.inline.} =

# initializer for Button: gtk_button_get_type
proc gtk_button_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_button_get_type".}
template gtype*(klass_parameter: typedesc[Button]): GType = gtk_button_get_type()
# gtk_button_new
# flags: {isConstructor} container: Button
# need sugar: is static method
# return: INTERFACE 'Button' 'TransferNone[TButton]' (diff., need sugar)
proc gtk_button_new(): TransferNone[TButton] {.cdecl, dynlib: lib, importc: "gtk_button_new".}
proc new_button*(): Button {.inline.} =
  wrap(gtk_button_new())
# proc new_button*(): Button {.inline.} =

# gtk_button_new_from_icon_name
# flags: {isConstructor} container: Button
# need sugar: is static method
# arg icon_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg size: INT32 'int32' 'int32' IN
# return: INTERFACE 'Button' 'TransferNone[TButton]' (diff., need sugar)
proc gtk_button_new_from_icon_name(icon_name: ucstring, size: int32): TransferNone[TButton] {.cdecl, dynlib: lib, importc: "gtk_button_new_from_icon_name".}
proc new_button_from_icon_name*(icon_name: ustring, size: int32): Button {.inline.} =
  wrap(gtk_button_new_from_icon_name(ucstring(icon_name), size))
# proc new_button_from_icon_name*(icon_name: ustring, size: int32): Button {.inline.} =

# gtk_button_new_from_stock
# flags: {isConstructor} container: Button (deprecated)
# gtk_button_new_with_label
# flags: {isConstructor} container: Button
# need sugar: is static method
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'Button' 'TransferNone[TButton]' (diff., need sugar)
proc gtk_button_new_with_label(label: ucstring): TransferNone[TButton] {.cdecl, dynlib: lib, importc: "gtk_button_new_with_label".}
proc new_button_with_label*(label: ustring): Button {.inline.} =
  wrap(gtk_button_new_with_label(ucstring(label)))
# proc new_button_with_label*(label: ustring): Button {.inline.} =

# gtk_button_new_with_mnemonic
# flags: {isConstructor} container: Button
# need sugar: is static method
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'Button' 'TransferNone[TButton]' (diff., need sugar)
proc gtk_button_new_with_mnemonic(label: ucstring): TransferNone[TButton] {.cdecl, dynlib: lib, importc: "gtk_button_new_with_mnemonic".}
proc new_button_with_mnemonic*(label: ustring): Button {.inline.} =
  wrap(gtk_button_new_with_mnemonic(ucstring(label)))
# proc new_button_with_mnemonic*(label: ustring): Button {.inline.} =

# gtk_button_clicked
# flags: {isMethod} container: Button
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_button_clicked(self: ptr TButton) {.cdecl, dynlib: lib, importc: "gtk_button_clicked".}
proc clicked*(self: Button) {.inline.} =
  gtk_button_clicked(self)
# proc clicked*(self: Button) {.inline.} =

# gtk_button_enter
# flags: {isMethod} container: Button (deprecated)
# gtk_button_get_alignment
# flags: {isMethod} container: Button (deprecated)
# gtk_button_get_always_show_image
# flags: {isMethod} container: Button
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_button_get_always_show_image(self: ptr TButton): bool {.cdecl, dynlib: lib, importc: "gtk_button_get_always_show_image".}
proc get_always_show_image*(self: Button): bool {.inline.} =
  gtk_button_get_always_show_image(self)
# proc get_always_show_image*(self: Button): bool {.inline.} =

# gtk_button_get_event_window
# flags: {isMethod} container: Button
# need sugar: is method
# return: INTERFACE 'Gdk3.Window' 'TransferNone[Gdk3.TWindow]' (diff., need sugar)
proc gtk_button_get_event_window(self: ptr TButton): TransferNone[Gdk3.TWindow] {.cdecl, dynlib: lib, importc: "gtk_button_get_event_window".}
proc get_event_window*(self: Button): Gdk3.Window {.inline.} =
  wrap(gtk_button_get_event_window(self))
# proc get_event_window*(self: Button): Gdk3.Window {.inline.} =

# gtk_button_get_focus_on_click
# flags: {isMethod} container: Button
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_button_get_focus_on_click(self: ptr TButton): bool {.cdecl, dynlib: lib, importc: "gtk_button_get_focus_on_click".}
proc get_focus_on_click*(self: Button): bool {.inline.} =
  gtk_button_get_focus_on_click(self)
# proc get_focus_on_click*(self: Button): bool {.inline.} =

# gtk_button_get_image
# flags: {isMethod} container: Button
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_button_get_image(self: ptr TButton): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_button_get_image".}
proc get_image*(self: Button): Widget {.inline.} =
  wrap(gtk_button_get_image(self))
# proc get_image*(self: Button): Widget {.inline.} =

# gtk_button_get_image_position
# flags: {isMethod} container: Button
# need sugar: is method
# return: INTERFACE 'PositionType' 'PositionType'
proc gtk_button_get_image_position(self: ptr TButton): PositionType {.cdecl, dynlib: lib, importc: "gtk_button_get_image_position".}
proc get_image_position*(self: Button): PositionType {.inline.} =
  gtk_button_get_image_position(self)
# proc get_image_position*(self: Button): PositionType {.inline.} =

# gtk_button_get_label
# flags: {isMethod} container: Button
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_button_get_label(self: ptr TButton): ucstring {.cdecl, dynlib: lib, importc: "gtk_button_get_label".}
proc get_label*(self: Button): ucstring {.inline.} =
  gtk_button_get_label(self)
# proc get_label*(self: Button): ucstring {.inline.} =

# gtk_button_get_relief
# flags: {isMethod} container: Button
# need sugar: is method
# return: INTERFACE 'ReliefStyle' 'ReliefStyle'
proc gtk_button_get_relief(self: ptr TButton): ReliefStyle {.cdecl, dynlib: lib, importc: "gtk_button_get_relief".}
proc get_relief*(self: Button): ReliefStyle {.inline.} =
  gtk_button_get_relief(self)
# proc get_relief*(self: Button): ReliefStyle {.inline.} =

# gtk_button_get_use_stock
# flags: {isMethod} container: Button (deprecated)
# gtk_button_get_use_underline
# flags: {isMethod} container: Button
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_button_get_use_underline(self: ptr TButton): bool {.cdecl, dynlib: lib, importc: "gtk_button_get_use_underline".}
proc get_use_underline*(self: Button): bool {.inline.} =
  gtk_button_get_use_underline(self)
# proc get_use_underline*(self: Button): bool {.inline.} =

# gtk_button_leave
# flags: {isMethod} container: Button (deprecated)
# gtk_button_pressed
# flags: {isMethod} container: Button (deprecated)
# gtk_button_released
# flags: {isMethod} container: Button (deprecated)
# gtk_button_set_alignment
# flags: {isMethod} container: Button (deprecated)
# gtk_button_set_always_show_image
# flags: {isMethod} container: Button
# need sugar: is method
# arg always_show: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_button_set_always_show_image(self: ptr TButton, always_show: bool) {.cdecl, dynlib: lib, importc: "gtk_button_set_always_show_image".}
proc set_always_show_image*(self: Button, always_show: bool) {.inline.} =
  gtk_button_set_always_show_image(self, always_show)
# proc set_always_show_image*(self: Button, always_show: bool) {.inline.} =

# gtk_button_set_focus_on_click
# flags: {isMethod} container: Button
# need sugar: is method
# arg focus_on_click: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_button_set_focus_on_click(self: ptr TButton, focus_on_click: bool) {.cdecl, dynlib: lib, importc: "gtk_button_set_focus_on_click".}
proc set_focus_on_click*(self: Button, focus_on_click: bool) {.inline.} =
  gtk_button_set_focus_on_click(self, focus_on_click)
# proc set_focus_on_click*(self: Button, focus_on_click: bool) {.inline.} =

# gtk_button_set_image
# flags: {isMethod} container: Button
# need sugar: is method
# arg image: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_button_set_image(self: ptr TButton, image: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_button_set_image".}
proc set_image*(self: Button, image: Widget) {.inline.} =
  gtk_button_set_image(self, image.getPointer)
# proc set_image*(self: Button, image: Widget) {.inline.} =

# gtk_button_set_image_position
# flags: {isMethod} container: Button
# need sugar: is method
# arg position: INTERFACE (ENUM) 'PositionType' 'PositionType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_button_set_image_position(self: ptr TButton, position: PositionType) {.cdecl, dynlib: lib, importc: "gtk_button_set_image_position".}
proc set_image_position*(self: Button, position: PositionType) {.inline.} =
  gtk_button_set_image_position(self, position)
# proc set_image_position*(self: Button, position: PositionType) {.inline.} =

# gtk_button_set_label
# flags: {isMethod} container: Button
# need sugar: is method
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_button_set_label(self: ptr TButton, label: ucstring) {.cdecl, dynlib: lib, importc: "gtk_button_set_label".}
proc set_label*(self: Button, label: ustring) {.inline.} =
  gtk_button_set_label(self, ucstring(label))
# proc set_label*(self: Button, label: ustring) {.inline.} =

# gtk_button_set_relief
# flags: {isMethod} container: Button
# need sugar: is method
# arg relief: INTERFACE (ENUM) 'ReliefStyle' 'ReliefStyle' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_button_set_relief(self: ptr TButton, relief: ReliefStyle) {.cdecl, dynlib: lib, importc: "gtk_button_set_relief".}
proc set_relief*(self: Button, relief: ReliefStyle) {.inline.} =
  gtk_button_set_relief(self, relief)
# proc set_relief*(self: Button, relief: ReliefStyle) {.inline.} =

# gtk_button_set_use_stock
# flags: {isMethod} container: Button (deprecated)
# gtk_button_set_use_underline
# flags: {isMethod} container: Button
# need sugar: is method
# arg use_underline: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_button_set_use_underline(self: ptr TButton, use_underline: bool) {.cdecl, dynlib: lib, importc: "gtk_button_set_use_underline".}
proc set_use_underline*(self: Button, use_underline: bool) {.inline.} =
  gtk_button_set_use_underline(self, use_underline)
# proc set_use_underline*(self: Button, use_underline: bool) {.inline.} =

# initializer for ButtonAccessible: gtk_button_accessible_get_type
proc gtk_button_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_button_accessible_get_type".}
template gtype*(klass_parameter: typedesc[ButtonAccessible]): GType = gtk_button_accessible_get_type()
# initializer for ButtonBox: gtk_button_box_get_type
proc gtk_button_box_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_button_box_get_type".}
template gtype*(klass_parameter: typedesc[ButtonBox]): GType = gtk_button_box_get_type()
# gtk_button_box_new
# flags: {isConstructor} container: ButtonBox
# need sugar: is static method
# arg orientation: INTERFACE (ENUM) 'Orientation' 'Orientation' IN
# return: INTERFACE 'ButtonBox' 'TransferNone[TButtonBox]' (diff., need sugar)
proc gtk_button_box_new(orientation: Orientation): TransferNone[TButtonBox] {.cdecl, dynlib: lib, importc: "gtk_button_box_new".}
proc new_buttonbox*(orientation: Orientation): ButtonBox {.inline.} =
  wrap(gtk_button_box_new(orientation))
# proc new_buttonbox*(orientation: Orientation): ButtonBox {.inline.} =

# gtk_button_box_get_child_non_homogeneous
# flags: {isMethod} container: ButtonBox
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_button_box_get_child_non_homogeneous(self: ptr TButtonBox, child: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_button_box_get_child_non_homogeneous".}
proc get_child_non_homogeneous*(self: ButtonBox, child: Widget): bool {.inline.} =
  gtk_button_box_get_child_non_homogeneous(self, child.getPointer)
# proc get_child_non_homogeneous*(self: ButtonBox, child: Widget): bool {.inline.} =

# gtk_button_box_get_child_secondary
# flags: {isMethod} container: ButtonBox
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_button_box_get_child_secondary(self: ptr TButtonBox, child: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_button_box_get_child_secondary".}
proc get_child_secondary*(self: ButtonBox, child: Widget): bool {.inline.} =
  gtk_button_box_get_child_secondary(self, child.getPointer)
# proc get_child_secondary*(self: ButtonBox, child: Widget): bool {.inline.} =

# gtk_button_box_get_layout
# flags: {isMethod} container: ButtonBox
# need sugar: is method
# return: INTERFACE 'ButtonBoxStyle' 'ButtonBoxStyle'
proc gtk_button_box_get_layout(self: ptr TButtonBox): ButtonBoxStyle {.cdecl, dynlib: lib, importc: "gtk_button_box_get_layout".}
proc get_layout*(self: ButtonBox): ButtonBoxStyle {.inline.} =
  gtk_button_box_get_layout(self)
# proc get_layout*(self: ButtonBox): ButtonBoxStyle {.inline.} =

# gtk_button_box_set_child_non_homogeneous
# flags: {isMethod} container: ButtonBox
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg non_homogeneous: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_button_box_set_child_non_homogeneous(self: ptr TButtonBox, child: ptr TWidget, non_homogeneous: bool) {.cdecl, dynlib: lib, importc: "gtk_button_box_set_child_non_homogeneous".}
proc set_child_non_homogeneous*(self: ButtonBox, child: Widget, non_homogeneous: bool) {.inline.} =
  gtk_button_box_set_child_non_homogeneous(self, child.getPointer, non_homogeneous)
# proc set_child_non_homogeneous*(self: ButtonBox, child: Widget, non_homogeneous: bool) {.inline.} =

# gtk_button_box_set_child_secondary
# flags: {isMethod} container: ButtonBox
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg is_secondary: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_button_box_set_child_secondary(self: ptr TButtonBox, child: ptr TWidget, is_secondary: bool) {.cdecl, dynlib: lib, importc: "gtk_button_box_set_child_secondary".}
proc set_child_secondary*(self: ButtonBox, child: Widget, is_secondary: bool) {.inline.} =
  gtk_button_box_set_child_secondary(self, child.getPointer, is_secondary)
# proc set_child_secondary*(self: ButtonBox, child: Widget, is_secondary: bool) {.inline.} =

# gtk_button_box_set_layout
# flags: {isMethod} container: ButtonBox
# need sugar: is method
# arg layout_style: INTERFACE (ENUM) 'ButtonBoxStyle' 'ButtonBoxStyle' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_button_box_set_layout(self: ptr TButtonBox, layout_style: ButtonBoxStyle) {.cdecl, dynlib: lib, importc: "gtk_button_box_set_layout".}
proc set_layout*(self: ButtonBox, layout_style: ButtonBoxStyle) {.inline.} =
  gtk_button_box_set_layout(self, layout_style)
# proc set_layout*(self: ButtonBox, layout_style: ButtonBoxStyle) {.inline.} =

# initializer for Calendar: gtk_calendar_get_type
proc gtk_calendar_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_calendar_get_type".}
template gtype*(klass_parameter: typedesc[Calendar]): GType = gtk_calendar_get_type()
# gtk_calendar_new
# flags: {isConstructor} container: Calendar
# need sugar: is static method
# return: INTERFACE 'Calendar' 'TransferNone[TCalendar]' (diff., need sugar)
proc gtk_calendar_new(): TransferNone[TCalendar] {.cdecl, dynlib: lib, importc: "gtk_calendar_new".}
proc new_calendar*(): Calendar {.inline.} =
  wrap(gtk_calendar_new())
# proc new_calendar*(): Calendar {.inline.} =

# gtk_calendar_clear_marks
# flags: {isMethod} container: Calendar
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_calendar_clear_marks(self: ptr TCalendar) {.cdecl, dynlib: lib, importc: "gtk_calendar_clear_marks".}
proc clear_marks*(self: Calendar) {.inline.} =
  gtk_calendar_clear_marks(self)
# proc clear_marks*(self: Calendar) {.inline.} =

# gtk_calendar_get_date
# flags: {isMethod} container: Calendar
# need sugar: is method
# arg year: UINT32 'var uint32' 'ptr uint32' OUT (diff., need sugar) optional
# arg month: UINT32 'var uint32' 'ptr uint32' OUT (diff., need sugar) optional
# arg day: UINT32 'var uint32' 'ptr uint32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_calendar_get_date(self: ptr TCalendar, year: ptr uint32, month: ptr uint32, day: ptr uint32) {.cdecl, dynlib: lib, importc: "gtk_calendar_get_date".}
proc get_date*(self: Calendar, year: var uint32, month: var uint32, day: var uint32) {.inline.} =
  gtk_calendar_get_date(self, addr(year), addr(month), addr(day))
# tuple-return
# year: var uint32
# month: var uint32
# day: var uint32
# proc get_date*(self: Calendar) {.inline.} =

# gtk_calendar_get_day_is_marked
# flags: {isMethod} container: Calendar
# need sugar: is method
# arg day: UINT32 'uint32' 'uint32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_calendar_get_day_is_marked(self: ptr TCalendar, day: uint32): bool {.cdecl, dynlib: lib, importc: "gtk_calendar_get_day_is_marked".}
proc get_day_is_marked*(self: Calendar, day: uint32): bool {.inline.} =
  gtk_calendar_get_day_is_marked(self, day)
# proc get_day_is_marked*(self: Calendar, day: uint32): bool {.inline.} =

# gtk_calendar_get_detail_height_rows
# flags: {isMethod} container: Calendar
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_calendar_get_detail_height_rows(self: ptr TCalendar): int32 {.cdecl, dynlib: lib, importc: "gtk_calendar_get_detail_height_rows".}
proc get_detail_height_rows*(self: Calendar): int32 {.inline.} =
  gtk_calendar_get_detail_height_rows(self)
# proc get_detail_height_rows*(self: Calendar): int32 {.inline.} =

# gtk_calendar_get_detail_width_chars
# flags: {isMethod} container: Calendar
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_calendar_get_detail_width_chars(self: ptr TCalendar): int32 {.cdecl, dynlib: lib, importc: "gtk_calendar_get_detail_width_chars".}
proc get_detail_width_chars*(self: Calendar): int32 {.inline.} =
  gtk_calendar_get_detail_width_chars(self)
# proc get_detail_width_chars*(self: Calendar): int32 {.inline.} =

# gtk_calendar_get_display_options
# flags: {isMethod} container: Calendar
# need sugar: is method
# return: INTERFACE 'SCalendarDisplayOptions' 'SCalendarDisplayOptions'
proc gtk_calendar_get_display_options(self: ptr TCalendar): SCalendarDisplayOptions {.cdecl, dynlib: lib, importc: "gtk_calendar_get_display_options".}
proc get_display_options*(self: Calendar): SCalendarDisplayOptions {.inline.} =
  gtk_calendar_get_display_options(self)
# proc get_display_options*(self: Calendar): SCalendarDisplayOptions {.inline.} =

# gtk_calendar_mark_day
# flags: {isMethod} container: Calendar
# need sugar: is method
# arg day: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_calendar_mark_day(self: ptr TCalendar, day: uint32) {.cdecl, dynlib: lib, importc: "gtk_calendar_mark_day".}
proc mark_day*(self: Calendar, day: uint32) {.inline.} =
  gtk_calendar_mark_day(self, day)
# proc mark_day*(self: Calendar, day: uint32) {.inline.} =

# gtk_calendar_select_day
# flags: {isMethod} container: Calendar
# need sugar: is method
# arg day: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_calendar_select_day(self: ptr TCalendar, day: uint32) {.cdecl, dynlib: lib, importc: "gtk_calendar_select_day".}
proc select_day*(self: Calendar, day: uint32) {.inline.} =
  gtk_calendar_select_day(self, day)
# proc select_day*(self: Calendar, day: uint32) {.inline.} =

# gtk_calendar_select_month
# flags: {isMethod} container: Calendar
# need sugar: is method
# arg month: UINT32 'uint32' 'uint32' IN
# arg year: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_calendar_select_month(self: ptr TCalendar, month: uint32, year: uint32) {.cdecl, dynlib: lib, importc: "gtk_calendar_select_month".}
proc select_month*(self: Calendar, month: uint32, year: uint32) {.inline.} =
  gtk_calendar_select_month(self, month, year)
# proc select_month*(self: Calendar, month: uint32, year: uint32) {.inline.} =

# gtk_calendar_set_detail_func
# flags: {isMethod} container: Calendar
# need sugar: is method
# arg func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg data: VOID 'pointer' 'pointer' IN
# arg destroy: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_calendar_set_detail_func(self: ptr TCalendar, func_x: pointer, data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_calendar_set_detail_func".}
proc set_detail_func*(self: Calendar, func_x: pointer, data: pointer, destroy: pointer) {.inline.} =
  gtk_calendar_set_detail_func(self, func_x, data, destroy)
# proc set_detail_func*(self: Calendar, func_x: pointer, data: pointer, destroy: pointer) {.inline.} =

# gtk_calendar_set_detail_height_rows
# flags: {isMethod} container: Calendar
# need sugar: is method
# arg rows: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_calendar_set_detail_height_rows(self: ptr TCalendar, rows: int32) {.cdecl, dynlib: lib, importc: "gtk_calendar_set_detail_height_rows".}
proc set_detail_height_rows*(self: Calendar, rows: int32) {.inline.} =
  gtk_calendar_set_detail_height_rows(self, rows)
# proc set_detail_height_rows*(self: Calendar, rows: int32) {.inline.} =

# gtk_calendar_set_detail_width_chars
# flags: {isMethod} container: Calendar
# need sugar: is method
# arg chars: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_calendar_set_detail_width_chars(self: ptr TCalendar, chars: int32) {.cdecl, dynlib: lib, importc: "gtk_calendar_set_detail_width_chars".}
proc set_detail_width_chars*(self: Calendar, chars: int32) {.inline.} =
  gtk_calendar_set_detail_width_chars(self, chars)
# proc set_detail_width_chars*(self: Calendar, chars: int32) {.inline.} =

# gtk_calendar_set_display_options
# flags: {isMethod} container: Calendar
# need sugar: is method
# arg flags: INTERFACE (FLAGS) 'SCalendarDisplayOptions' 'SCalendarDisplayOptions' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_calendar_set_display_options(self: ptr TCalendar, flags: SCalendarDisplayOptions) {.cdecl, dynlib: lib, importc: "gtk_calendar_set_display_options".}
proc set_display_options*(self: Calendar, flags: SCalendarDisplayOptions) {.inline.} =
  gtk_calendar_set_display_options(self, flags)
# proc set_display_options*(self: Calendar, flags: SCalendarDisplayOptions) {.inline.} =

# gtk_calendar_unmark_day
# flags: {isMethod} container: Calendar
# need sugar: is method
# arg day: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_calendar_unmark_day(self: ptr TCalendar, day: uint32) {.cdecl, dynlib: lib, importc: "gtk_calendar_unmark_day".}
proc unmark_day*(self: Calendar, day: uint32) {.inline.} =
  gtk_calendar_unmark_day(self, day)
# proc unmark_day*(self: Calendar, day: uint32) {.inline.} =

# initializer for CellAccessible: gtk_cell_accessible_get_type
proc gtk_cell_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_cell_accessible_get_type".}
template gtype*(klass_parameter: typedesc[CellAccessible]): GType = gtk_cell_accessible_get_type()
# initializer for CellArea: gtk_cell_area_get_type
proc gtk_cell_area_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_type".}
template gtype*(klass_parameter: typedesc[CellArea]): GType = gtk_cell_area_get_type()
# gtk_cell_area_activate
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg context: INTERFACE (OBJECT) 'CellAreaContext' 'ptr TCellAreaContext' IN (diff., need sugar)
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg cell_area: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# arg flags: INTERFACE (FLAGS) 'SCellRendererState' 'SCellRendererState' IN
# arg edit_only: BOOLEAN 'bool' 'bool' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_cell_area_activate(self: ptr TCellArea, context: ptr TCellAreaContext, widget: ptr TWidget, cell_area: ptr Gdk3.TRectangle, flags: SCellRendererState, edit_only: bool): bool {.cdecl, dynlib: lib, importc: "gtk_cell_area_activate".}
proc activate*(self: CellArea, context: CellAreaContext, widget: Widget, cell_area: ptr Gdk3.TRectangle, flags: SCellRendererState, edit_only: bool): bool {.inline.} =
  gtk_cell_area_activate(self, context.getPointer, widget.getPointer, cell_area, flags, edit_only)
# proc activate*(self: CellArea, context: CellAreaContext, widget: Widget, cell_area: ptr Gdk3.TRectangle, flags: SCellRendererState, edit_only: bool): bool {.inline.} =

# gtk_cell_area_activate_cell
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg renderer: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# arg event: INTERFACE (UNION) 'ptr Gdk3.TEvent' 'ptr Gdk3.TEvent' IN
# arg cell_area: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# arg flags: INTERFACE (FLAGS) 'SCellRendererState' 'SCellRendererState' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_cell_area_activate_cell(self: ptr TCellArea, widget: ptr TWidget, renderer: ptr TCellRenderer, event: ptr Gdk3.TEvent, cell_area: ptr Gdk3.TRectangle, flags: SCellRendererState): bool {.cdecl, dynlib: lib, importc: "gtk_cell_area_activate_cell".}
proc activate_cell*(self: CellArea, widget: Widget, renderer: CellRenderer, event: ptr Gdk3.TEvent, cell_area: ptr Gdk3.TRectangle, flags: SCellRendererState): bool {.inline.} =
  gtk_cell_area_activate_cell(self, widget.getPointer, renderer.getPointer, event, cell_area, flags)
# proc activate_cell*(self: CellArea, widget: Widget, renderer: CellRenderer, event: ptr Gdk3.TEvent, cell_area: ptr Gdk3.TRectangle, flags: SCellRendererState): bool {.inline.} =

# gtk_cell_area_add
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg renderer: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_add(self: ptr TCellArea, renderer: ptr TCellRenderer) {.cdecl, dynlib: lib, importc: "gtk_cell_area_add".}
proc add*(self: CellArea, renderer: CellRenderer) {.inline.} =
  gtk_cell_area_add(self, renderer.getPointer)
# proc add*(self: CellArea, renderer: CellRenderer) {.inline.} =

# gtk_cell_area_add_focus_sibling
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg renderer: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# arg sibling: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_add_focus_sibling(self: ptr TCellArea, renderer: ptr TCellRenderer, sibling: ptr TCellRenderer) {.cdecl, dynlib: lib, importc: "gtk_cell_area_add_focus_sibling".}
proc add_focus_sibling*(self: CellArea, renderer: CellRenderer, sibling: CellRenderer) {.inline.} =
  gtk_cell_area_add_focus_sibling(self, renderer.getPointer, sibling.getPointer)
# proc add_focus_sibling*(self: CellArea, renderer: CellRenderer, sibling: CellRenderer) {.inline.} =

# gtk_cell_area_apply_attributes
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg tree_model: INTERFACE (INTERFACE) 'ptr TTreeModel' 'ptr TTreeModel' IN
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# arg is_expander: BOOLEAN 'bool' 'bool' IN
# arg is_expanded: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_apply_attributes(self: ptr TCellArea, tree_model: ptr TTreeModel, iter: ptr TTreeIter, is_expander: bool, is_expanded: bool) {.cdecl, dynlib: lib, importc: "gtk_cell_area_apply_attributes".}
proc apply_attributes*(self: CellArea, tree_model: ptr TTreeModel, iter: ptr TTreeIter, is_expander: bool, is_expanded: bool) {.inline.} =
  gtk_cell_area_apply_attributes(self, tree_model, iter, is_expander, is_expanded)
# proc apply_attributes*(self: CellArea, tree_model: ptr TTreeModel, iter: ptr TTreeIter, is_expander: bool, is_expanded: bool) {.inline.} =

# gtk_cell_area_attribute_connect
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg renderer: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# arg attribute: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg column: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_attribute_connect(self: ptr TCellArea, renderer: ptr TCellRenderer, attribute: ucstring, column: int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_attribute_connect".}
proc attribute_connect*(self: CellArea, renderer: CellRenderer, attribute: ustring, column: int32) {.inline.} =
  gtk_cell_area_attribute_connect(self, renderer.getPointer, ucstring(attribute), column)
# proc attribute_connect*(self: CellArea, renderer: CellRenderer, attribute: ustring, column: int32) {.inline.} =

# gtk_cell_area_attribute_disconnect
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg renderer: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# arg attribute: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_attribute_disconnect(self: ptr TCellArea, renderer: ptr TCellRenderer, attribute: ucstring) {.cdecl, dynlib: lib, importc: "gtk_cell_area_attribute_disconnect".}
proc attribute_disconnect*(self: CellArea, renderer: CellRenderer, attribute: ustring) {.inline.} =
  gtk_cell_area_attribute_disconnect(self, renderer.getPointer, ucstring(attribute))
# proc attribute_disconnect*(self: CellArea, renderer: CellRenderer, attribute: ustring) {.inline.} =

# gtk_cell_area_attribute_get_column
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg renderer: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# arg attribute: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INT32 'int32' 'int32'
proc gtk_cell_area_attribute_get_column(self: ptr TCellArea, renderer: ptr TCellRenderer, attribute: ucstring): int32 {.cdecl, dynlib: lib, importc: "gtk_cell_area_attribute_get_column".}
proc attribute_get_column*(self: CellArea, renderer: CellRenderer, attribute: ustring): int32 {.inline.} =
  gtk_cell_area_attribute_get_column(self, renderer.getPointer, ucstring(attribute))
# proc attribute_get_column*(self: CellArea, renderer: CellRenderer, attribute: ustring): int32 {.inline.} =

# gtk_cell_area_cell_get_property
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg renderer: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# arg property_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg value: INTERFACE (STRUCT) 'ptr GObject2.TValue' 'ptr GObject2.TValue' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_cell_get_property(self: ptr TCellArea, renderer: ptr TCellRenderer, property_name: ucstring, value: ptr GObject2.TValue) {.cdecl, dynlib: lib, importc: "gtk_cell_area_cell_get_property".}
proc cell_get_property*(self: CellArea, renderer: CellRenderer, property_name: ustring, value: ptr GObject2.TValue) {.inline.} =
  gtk_cell_area_cell_get_property(self, renderer.getPointer, ucstring(property_name), value)
# proc cell_get_property*(self: CellArea, renderer: CellRenderer, property_name: ustring, value: ptr GObject2.TValue) {.inline.} =

# gtk_cell_area_cell_set_property
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg renderer: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# arg property_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg value: INTERFACE (STRUCT) 'ptr GObject2.TValue' 'ptr GObject2.TValue' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_cell_set_property(self: ptr TCellArea, renderer: ptr TCellRenderer, property_name: ucstring, value: ptr GObject2.TValue) {.cdecl, dynlib: lib, importc: "gtk_cell_area_cell_set_property".}
proc cell_set_property*(self: CellArea, renderer: CellRenderer, property_name: ustring, value: ptr GObject2.TValue) {.inline.} =
  gtk_cell_area_cell_set_property(self, renderer.getPointer, ucstring(property_name), value)
# proc cell_set_property*(self: CellArea, renderer: CellRenderer, property_name: ustring, value: ptr GObject2.TValue) {.inline.} =

# gtk_cell_area_copy_context
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg context: INTERFACE (OBJECT) 'CellAreaContext' 'ptr TCellAreaContext' IN (diff., need sugar)
# return: INTERFACE 'CellAreaContext' 'TransferFull[TCellAreaContext]' (diff., need sugar)
proc gtk_cell_area_copy_context(self: ptr TCellArea, context: ptr TCellAreaContext): TransferFull[TCellAreaContext] {.cdecl, dynlib: lib, importc: "gtk_cell_area_copy_context".}
proc copy_context*(self: CellArea, context: CellAreaContext): CellAreaContext {.inline.} =
  wrap(gtk_cell_area_copy_context(self, context.getPointer))
# proc copy_context*(self: CellArea, context: CellAreaContext): CellAreaContext {.inline.} =

# gtk_cell_area_create_context
# flags: {isMethod} container: CellArea
# need sugar: is method
# return: INTERFACE 'CellAreaContext' 'TransferFull[TCellAreaContext]' (diff., need sugar)
proc gtk_cell_area_create_context(self: ptr TCellArea): TransferFull[TCellAreaContext] {.cdecl, dynlib: lib, importc: "gtk_cell_area_create_context".}
proc create_context*(self: CellArea): CellAreaContext {.inline.} =
  wrap(gtk_cell_area_create_context(self))
# proc create_context*(self: CellArea): CellAreaContext {.inline.} =

# gtk_cell_area_event
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg context: INTERFACE (OBJECT) 'CellAreaContext' 'ptr TCellAreaContext' IN (diff., need sugar)
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg event: INTERFACE (UNION) 'ptr Gdk3.TEvent' 'ptr Gdk3.TEvent' IN
# arg cell_area: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# arg flags: INTERFACE (FLAGS) 'SCellRendererState' 'SCellRendererState' IN
# return: INT32 'int32' 'int32'
proc gtk_cell_area_event(self: ptr TCellArea, context: ptr TCellAreaContext, widget: ptr TWidget, event: ptr Gdk3.TEvent, cell_area: ptr Gdk3.TRectangle, flags: SCellRendererState): int32 {.cdecl, dynlib: lib, importc: "gtk_cell_area_event".}
proc event*(self: CellArea, context: CellAreaContext, widget: Widget, event: ptr Gdk3.TEvent, cell_area: ptr Gdk3.TRectangle, flags: SCellRendererState): int32 {.inline.} =
  gtk_cell_area_event(self, context.getPointer, widget.getPointer, event, cell_area, flags)
# proc event*(self: CellArea, context: CellAreaContext, widget: Widget, event: ptr Gdk3.TEvent, cell_area: ptr Gdk3.TRectangle, flags: SCellRendererState): int32 {.inline.} =

# gtk_cell_area_focus
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg direction: INTERFACE (ENUM) 'DirectionType' 'DirectionType' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_cell_area_focus(self: ptr TCellArea, direction: DirectionType): bool {.cdecl, dynlib: lib, importc: "gtk_cell_area_focus".}
proc focus*(self: CellArea, direction: DirectionType): bool {.inline.} =
  gtk_cell_area_focus(self, direction)
# proc focus*(self: CellArea, direction: DirectionType): bool {.inline.} =

# gtk_cell_area_foreach
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg callback: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg callback_data: VOID 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_foreach(self: ptr TCellArea, callback: pointer, callback_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_cell_area_foreach".}
proc foreach*(self: CellArea, callback: pointer, callback_data: pointer) {.inline.} =
  gtk_cell_area_foreach(self, callback, callback_data)
# proc foreach*(self: CellArea, callback: pointer, callback_data: pointer) {.inline.} =

# gtk_cell_area_foreach_alloc
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg context: INTERFACE (OBJECT) 'CellAreaContext' 'ptr TCellAreaContext' IN (diff., need sugar)
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg cell_area: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# arg background_area: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# arg callback: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg callback_data: VOID 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_foreach_alloc(self: ptr TCellArea, context: ptr TCellAreaContext, widget: ptr TWidget, cell_area: ptr Gdk3.TRectangle, background_area: ptr Gdk3.TRectangle, callback: pointer, callback_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_cell_area_foreach_alloc".}
proc foreach_alloc*(self: CellArea, context: CellAreaContext, widget: Widget, cell_area: ptr Gdk3.TRectangle, background_area: ptr Gdk3.TRectangle, callback: pointer, callback_data: pointer) {.inline.} =
  gtk_cell_area_foreach_alloc(self, context.getPointer, widget.getPointer, cell_area, background_area, callback, callback_data)
# proc foreach_alloc*(self: CellArea, context: CellAreaContext, widget: Widget, cell_area: ptr Gdk3.TRectangle, background_area: ptr Gdk3.TRectangle, callback: pointer, callback_data: pointer) {.inline.} =

# gtk_cell_area_get_cell_allocation
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg context: INTERFACE (OBJECT) 'CellAreaContext' 'ptr TCellAreaContext' IN (diff., need sugar)
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg renderer: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# arg cell_area: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# arg allocation: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' OUT caller-allocates
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_get_cell_allocation(self: ptr TCellArea, context: ptr TCellAreaContext, widget: ptr TWidget, renderer: ptr TCellRenderer, cell_area: ptr Gdk3.TRectangle, allocation: ptr Gdk3.TRectangle) {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_cell_allocation".}
proc get_cell_allocation*(self: CellArea, context: CellAreaContext, widget: Widget, renderer: CellRenderer, cell_area: ptr Gdk3.TRectangle, allocation: ptr Gdk3.TRectangle) {.inline.} =
  gtk_cell_area_get_cell_allocation(self, context.getPointer, widget.getPointer, renderer.getPointer, cell_area, allocation)
# tuple-return
# allocation: ptr Gdk3.TRectangle
# proc get_cell_allocation*(self: CellArea, context: CellAreaContext, widget: Widget, renderer: CellRenderer, cell_area: ptr Gdk3.TRectangle) {.inline.} =

# gtk_cell_area_get_cell_at_position
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg context: INTERFACE (OBJECT) 'CellAreaContext' 'ptr TCellAreaContext' IN (diff., need sugar)
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg cell_area: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# arg x: INT32 'int32' 'int32' IN
# arg y: INT32 'int32' 'int32' IN
# arg alloc_area: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' OUT caller-allocates optional
# return: INTERFACE 'CellRenderer' 'TransferNone[TCellRenderer]' (diff., need sugar)
proc gtk_cell_area_get_cell_at_position(self: ptr TCellArea, context: ptr TCellAreaContext, widget: ptr TWidget, cell_area: ptr Gdk3.TRectangle, x: int32, y: int32, alloc_area: ptr Gdk3.TRectangle): TransferNone[TCellRenderer] {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_cell_at_position".}
proc get_cell_at_position*(self: CellArea, context: CellAreaContext, widget: Widget, cell_area: ptr Gdk3.TRectangle, x: int32, y: int32, alloc_area: ptr Gdk3.TRectangle): CellRenderer {.inline.} =
  wrap(gtk_cell_area_get_cell_at_position(self, context.getPointer, widget.getPointer, cell_area, x, y, alloc_area))
# tuple-return
# alloc_area: ptr Gdk3.TRectangle
# proc get_cell_at_position*(self: CellArea, context: CellAreaContext, widget: Widget, cell_area: ptr Gdk3.TRectangle, x: int32, y: int32): CellRenderer {.inline.} =

# gtk_cell_area_get_current_path_string
# flags: {isMethod} container: CellArea
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_cell_area_get_current_path_string(self: ptr TCellArea): ucstring {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_current_path_string".}
proc get_current_path_string*(self: CellArea): ucstring {.inline.} =
  gtk_cell_area_get_current_path_string(self)
# proc get_current_path_string*(self: CellArea): ucstring {.inline.} =

# gtk_cell_area_get_edit_widget
# flags: {isMethod} container: CellArea
# need sugar: is method
# return: INTERFACE 'ptr TCellEditable' 'TransferNone[TCellEditable]' (diff., need sugar)
proc gtk_cell_area_get_edit_widget(self: ptr TCellArea): TransferNone[TCellEditable] {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_edit_widget".}
proc get_edit_widget*(self: CellArea): ptr TCellEditable {.inline.} =
  wrap(gtk_cell_area_get_edit_widget(self))
# proc get_edit_widget*(self: CellArea): ptr TCellEditable {.inline.} =

# gtk_cell_area_get_edited_cell
# flags: {isMethod} container: CellArea
# need sugar: is method
# return: INTERFACE 'CellRenderer' 'TransferNone[TCellRenderer]' (diff., need sugar)
proc gtk_cell_area_get_edited_cell(self: ptr TCellArea): TransferNone[TCellRenderer] {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_edited_cell".}
proc get_edited_cell*(self: CellArea): CellRenderer {.inline.} =
  wrap(gtk_cell_area_get_edited_cell(self))
# proc get_edited_cell*(self: CellArea): CellRenderer {.inline.} =

# gtk_cell_area_get_focus_cell
# flags: {isMethod} container: CellArea
# need sugar: is method
# return: INTERFACE 'CellRenderer' 'TransferNone[TCellRenderer]' (diff., need sugar)
proc gtk_cell_area_get_focus_cell(self: ptr TCellArea): TransferNone[TCellRenderer] {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_focus_cell".}
proc get_focus_cell*(self: CellArea): CellRenderer {.inline.} =
  wrap(gtk_cell_area_get_focus_cell(self))
# proc get_focus_cell*(self: CellArea): CellRenderer {.inline.} =

# gtk_cell_area_get_focus_from_sibling
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg renderer: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# return: INTERFACE 'CellRenderer' 'TransferNone[TCellRenderer]' (diff., need sugar)
proc gtk_cell_area_get_focus_from_sibling(self: ptr TCellArea, renderer: ptr TCellRenderer): TransferNone[TCellRenderer] {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_focus_from_sibling".}
proc get_focus_from_sibling*(self: CellArea, renderer: CellRenderer): CellRenderer {.inline.} =
  wrap(gtk_cell_area_get_focus_from_sibling(self, renderer.getPointer))
# proc get_focus_from_sibling*(self: CellArea, renderer: CellRenderer): CellRenderer {.inline.} =

# gtk_cell_area_get_focus_siblings
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg renderer: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# return: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_cell_area_get_focus_siblings(self: ptr TCellArea, renderer: ptr TCellRenderer): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_focus_siblings".}
proc get_focus_siblings*(self: CellArea, renderer: CellRenderer): ptr GLIST_TODO {.inline.} =
  gtk_cell_area_get_focus_siblings(self, renderer.getPointer)
# proc get_focus_siblings*(self: CellArea, renderer: CellRenderer): ptr GLIST_TODO {.inline.} =

# gtk_cell_area_get_preferred_height
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg context: INTERFACE (OBJECT) 'CellAreaContext' 'ptr TCellAreaContext' IN (diff., need sugar)
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg minimum_height: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg natural_height: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_get_preferred_height(self: ptr TCellArea, context: ptr TCellAreaContext, widget: ptr TWidget, minimum_height: ptr int32, natural_height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_preferred_height".}
proc get_preferred_height*(self: CellArea, context: CellAreaContext, widget: Widget, minimum_height: var int32, natural_height: var int32) {.inline.} =
  gtk_cell_area_get_preferred_height(self, context.getPointer, widget.getPointer, addr(minimum_height), addr(natural_height))
# tuple-return
# minimum_height: var int32
# natural_height: var int32
# proc get_preferred_height*(self: CellArea, context: CellAreaContext, widget: Widget) {.inline.} =

# gtk_cell_area_get_preferred_height_for_width
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg context: INTERFACE (OBJECT) 'CellAreaContext' 'ptr TCellAreaContext' IN (diff., need sugar)
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg width: INT32 'int32' 'int32' IN
# arg minimum_height: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg natural_height: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_get_preferred_height_for_width(self: ptr TCellArea, context: ptr TCellAreaContext, widget: ptr TWidget, width: int32, minimum_height: ptr int32, natural_height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_preferred_height_for_width".}
proc get_preferred_height_for_width*(self: CellArea, context: CellAreaContext, widget: Widget, width: int32, minimum_height: var int32, natural_height: var int32) {.inline.} =
  gtk_cell_area_get_preferred_height_for_width(self, context.getPointer, widget.getPointer, width, addr(minimum_height), addr(natural_height))
# tuple-return
# minimum_height: var int32
# natural_height: var int32
# proc get_preferred_height_for_width*(self: CellArea, context: CellAreaContext, widget: Widget, width: int32) {.inline.} =

# gtk_cell_area_get_preferred_width
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg context: INTERFACE (OBJECT) 'CellAreaContext' 'ptr TCellAreaContext' IN (diff., need sugar)
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg minimum_width: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg natural_width: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_get_preferred_width(self: ptr TCellArea, context: ptr TCellAreaContext, widget: ptr TWidget, minimum_width: ptr int32, natural_width: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_preferred_width".}
proc get_preferred_width*(self: CellArea, context: CellAreaContext, widget: Widget, minimum_width: var int32, natural_width: var int32) {.inline.} =
  gtk_cell_area_get_preferred_width(self, context.getPointer, widget.getPointer, addr(minimum_width), addr(natural_width))
# tuple-return
# minimum_width: var int32
# natural_width: var int32
# proc get_preferred_width*(self: CellArea, context: CellAreaContext, widget: Widget) {.inline.} =

# gtk_cell_area_get_preferred_width_for_height
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg context: INTERFACE (OBJECT) 'CellAreaContext' 'ptr TCellAreaContext' IN (diff., need sugar)
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg height: INT32 'int32' 'int32' IN
# arg minimum_width: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg natural_width: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_get_preferred_width_for_height(self: ptr TCellArea, context: ptr TCellAreaContext, widget: ptr TWidget, height: int32, minimum_width: ptr int32, natural_width: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_preferred_width_for_height".}
proc get_preferred_width_for_height*(self: CellArea, context: CellAreaContext, widget: Widget, height: int32, minimum_width: var int32, natural_width: var int32) {.inline.} =
  gtk_cell_area_get_preferred_width_for_height(self, context.getPointer, widget.getPointer, height, addr(minimum_width), addr(natural_width))
# tuple-return
# minimum_width: var int32
# natural_width: var int32
# proc get_preferred_width_for_height*(self: CellArea, context: CellAreaContext, widget: Widget, height: int32) {.inline.} =

# gtk_cell_area_get_request_mode
# flags: {isMethod} container: CellArea
# need sugar: is method
# return: INTERFACE 'SizeRequestMode' 'SizeRequestMode'
proc gtk_cell_area_get_request_mode(self: ptr TCellArea): SizeRequestMode {.cdecl, dynlib: lib, importc: "gtk_cell_area_get_request_mode".}
proc get_request_mode*(self: CellArea): SizeRequestMode {.inline.} =
  gtk_cell_area_get_request_mode(self)
# proc get_request_mode*(self: CellArea): SizeRequestMode {.inline.} =

# gtk_cell_area_has_renderer
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg renderer: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_cell_area_has_renderer(self: ptr TCellArea, renderer: ptr TCellRenderer): bool {.cdecl, dynlib: lib, importc: "gtk_cell_area_has_renderer".}
proc has_renderer*(self: CellArea, renderer: CellRenderer): bool {.inline.} =
  gtk_cell_area_has_renderer(self, renderer.getPointer)
# proc has_renderer*(self: CellArea, renderer: CellRenderer): bool {.inline.} =

# gtk_cell_area_inner_cell_area
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg cell_area: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# arg inner_area: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' OUT caller-allocates
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_inner_cell_area(self: ptr TCellArea, widget: ptr TWidget, cell_area: ptr Gdk3.TRectangle, inner_area: ptr Gdk3.TRectangle) {.cdecl, dynlib: lib, importc: "gtk_cell_area_inner_cell_area".}
proc inner_cell_area*(self: CellArea, widget: Widget, cell_area: ptr Gdk3.TRectangle, inner_area: ptr Gdk3.TRectangle) {.inline.} =
  gtk_cell_area_inner_cell_area(self, widget.getPointer, cell_area, inner_area)
# tuple-return
# inner_area: ptr Gdk3.TRectangle
# proc inner_cell_area*(self: CellArea, widget: Widget, cell_area: ptr Gdk3.TRectangle) {.inline.} =

# gtk_cell_area_is_activatable
# flags: {isMethod} container: CellArea
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_cell_area_is_activatable(self: ptr TCellArea): bool {.cdecl, dynlib: lib, importc: "gtk_cell_area_is_activatable".}
proc is_activatable*(self: CellArea): bool {.inline.} =
  gtk_cell_area_is_activatable(self)
# proc is_activatable*(self: CellArea): bool {.inline.} =

# gtk_cell_area_is_focus_sibling
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg renderer: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# arg sibling: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_cell_area_is_focus_sibling(self: ptr TCellArea, renderer: ptr TCellRenderer, sibling: ptr TCellRenderer): bool {.cdecl, dynlib: lib, importc: "gtk_cell_area_is_focus_sibling".}
proc is_focus_sibling*(self: CellArea, renderer: CellRenderer, sibling: CellRenderer): bool {.inline.} =
  gtk_cell_area_is_focus_sibling(self, renderer.getPointer, sibling.getPointer)
# proc is_focus_sibling*(self: CellArea, renderer: CellRenderer, sibling: CellRenderer): bool {.inline.} =

# gtk_cell_area_remove
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg renderer: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_remove(self: ptr TCellArea, renderer: ptr TCellRenderer) {.cdecl, dynlib: lib, importc: "gtk_cell_area_remove".}
proc remove*(self: CellArea, renderer: CellRenderer) {.inline.} =
  gtk_cell_area_remove(self, renderer.getPointer)
# proc remove*(self: CellArea, renderer: CellRenderer) {.inline.} =

# gtk_cell_area_remove_focus_sibling
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg renderer: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# arg sibling: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_remove_focus_sibling(self: ptr TCellArea, renderer: ptr TCellRenderer, sibling: ptr TCellRenderer) {.cdecl, dynlib: lib, importc: "gtk_cell_area_remove_focus_sibling".}
proc remove_focus_sibling*(self: CellArea, renderer: CellRenderer, sibling: CellRenderer) {.inline.} =
  gtk_cell_area_remove_focus_sibling(self, renderer.getPointer, sibling.getPointer)
# proc remove_focus_sibling*(self: CellArea, renderer: CellRenderer, sibling: CellRenderer) {.inline.} =

# gtk_cell_area_render
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg context: INTERFACE (OBJECT) 'CellAreaContext' 'ptr TCellAreaContext' IN (diff., need sugar)
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg cr: INTERFACE (STRUCT) 'ptr cairo1.TContext' 'ptr cairo1.TContext' IN
# arg background_area: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# arg cell_area: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# arg flags: INTERFACE (FLAGS) 'SCellRendererState' 'SCellRendererState' IN
# arg paint_focus: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_render(self: ptr TCellArea, context: ptr TCellAreaContext, widget: ptr TWidget, cr: ptr cairo1.TContext, background_area: ptr Gdk3.TRectangle, cell_area: ptr Gdk3.TRectangle, flags: SCellRendererState, paint_focus: bool) {.cdecl, dynlib: lib, importc: "gtk_cell_area_render".}
proc render*(self: CellArea, context: CellAreaContext, widget: Widget, cr: ptr cairo1.TContext, background_area: ptr Gdk3.TRectangle, cell_area: ptr Gdk3.TRectangle, flags: SCellRendererState, paint_focus: bool) {.inline.} =
  gtk_cell_area_render(self, context.getPointer, widget.getPointer, cr, background_area, cell_area, flags, paint_focus)
# proc render*(self: CellArea, context: CellAreaContext, widget: Widget, cr: ptr cairo1.TContext, background_area: ptr Gdk3.TRectangle, cell_area: ptr Gdk3.TRectangle, flags: SCellRendererState, paint_focus: bool) {.inline.} =

# gtk_cell_area_request_renderer
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg renderer: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# arg orientation: INTERFACE (ENUM) 'Orientation' 'Orientation' IN
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg for_size: INT32 'int32' 'int32' IN
# arg minimum_size: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg natural_size: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_request_renderer(self: ptr TCellArea, renderer: ptr TCellRenderer, orientation: Orientation, widget: ptr TWidget, for_size: int32, minimum_size: ptr int32, natural_size: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_request_renderer".}
proc request_renderer*(self: CellArea, renderer: CellRenderer, orientation: Orientation, widget: Widget, for_size: int32, minimum_size: var int32, natural_size: var int32) {.inline.} =
  gtk_cell_area_request_renderer(self, renderer.getPointer, orientation, widget.getPointer, for_size, addr(minimum_size), addr(natural_size))
# tuple-return
# minimum_size: var int32
# natural_size: var int32
# proc request_renderer*(self: CellArea, renderer: CellRenderer, orientation: Orientation, widget: Widget, for_size: int32) {.inline.} =

# gtk_cell_area_set_focus_cell
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg renderer: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_set_focus_cell(self: ptr TCellArea, renderer: ptr TCellRenderer) {.cdecl, dynlib: lib, importc: "gtk_cell_area_set_focus_cell".}
proc set_focus_cell*(self: CellArea, renderer: CellRenderer) {.inline.} =
  gtk_cell_area_set_focus_cell(self, renderer.getPointer)
# proc set_focus_cell*(self: CellArea, renderer: CellRenderer) {.inline.} =

# gtk_cell_area_stop_editing
# flags: {isMethod} container: CellArea
# need sugar: is method
# arg canceled: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_stop_editing(self: ptr TCellArea, canceled: bool) {.cdecl, dynlib: lib, importc: "gtk_cell_area_stop_editing".}
proc stop_editing*(self: CellArea, canceled: bool) {.inline.} =
  gtk_cell_area_stop_editing(self, canceled)
# proc stop_editing*(self: CellArea, canceled: bool) {.inline.} =

# initializer for CellAreaBox: gtk_cell_area_box_get_type
proc gtk_cell_area_box_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_cell_area_box_get_type".}
template gtype*(klass_parameter: typedesc[CellAreaBox]): GType = gtk_cell_area_box_get_type()
# gtk_cell_area_box_new
# flags: {isConstructor} container: CellAreaBox
# need sugar: is static method
# return: INTERFACE 'CellAreaBox' 'TransferNone[TCellAreaBox]' (diff., need sugar)
proc gtk_cell_area_box_new(): TransferNone[TCellAreaBox] {.cdecl, dynlib: lib, importc: "gtk_cell_area_box_new".}
proc new_cellareabox*(): CellAreaBox {.inline.} =
  wrap(gtk_cell_area_box_new())
# proc new_cellareabox*(): CellAreaBox {.inline.} =

# gtk_cell_area_box_get_spacing
# flags: {isMethod} container: CellAreaBox
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_cell_area_box_get_spacing(self: ptr TCellAreaBox): int32 {.cdecl, dynlib: lib, importc: "gtk_cell_area_box_get_spacing".}
proc get_spacing*(self: CellAreaBox): int32 {.inline.} =
  gtk_cell_area_box_get_spacing(self)
# proc get_spacing*(self: CellAreaBox): int32 {.inline.} =

# gtk_cell_area_box_pack_end
# flags: {isMethod} container: CellAreaBox
# need sugar: is method
# arg renderer: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# arg expand: BOOLEAN 'bool' 'bool' IN
# arg align: BOOLEAN 'bool' 'bool' IN
# arg fixed: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_box_pack_end(self: ptr TCellAreaBox, renderer: ptr TCellRenderer, expand: bool, align: bool, fixed: bool) {.cdecl, dynlib: lib, importc: "gtk_cell_area_box_pack_end".}
proc pack_end*(self: CellAreaBox, renderer: CellRenderer, expand: bool, align: bool, fixed: bool) {.inline.} =
  gtk_cell_area_box_pack_end(self, renderer.getPointer, expand, align, fixed)
# proc pack_end*(self: CellAreaBox, renderer: CellRenderer, expand: bool, align: bool, fixed: bool) {.inline.} =

# gtk_cell_area_box_pack_start
# flags: {isMethod} container: CellAreaBox
# need sugar: is method
# arg renderer: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# arg expand: BOOLEAN 'bool' 'bool' IN
# arg align: BOOLEAN 'bool' 'bool' IN
# arg fixed: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_box_pack_start(self: ptr TCellAreaBox, renderer: ptr TCellRenderer, expand: bool, align: bool, fixed: bool) {.cdecl, dynlib: lib, importc: "gtk_cell_area_box_pack_start".}
proc pack_start*(self: CellAreaBox, renderer: CellRenderer, expand: bool, align: bool, fixed: bool) {.inline.} =
  gtk_cell_area_box_pack_start(self, renderer.getPointer, expand, align, fixed)
# proc pack_start*(self: CellAreaBox, renderer: CellRenderer, expand: bool, align: bool, fixed: bool) {.inline.} =

# gtk_cell_area_box_set_spacing
# flags: {isMethod} container: CellAreaBox
# need sugar: is method
# arg spacing: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_box_set_spacing(self: ptr TCellAreaBox, spacing: int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_box_set_spacing".}
proc set_spacing*(self: CellAreaBox, spacing: int32) {.inline.} =
  gtk_cell_area_box_set_spacing(self, spacing)
# proc set_spacing*(self: CellAreaBox, spacing: int32) {.inline.} =

# initializer for CellAreaContext: gtk_cell_area_context_get_type
proc gtk_cell_area_context_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_cell_area_context_get_type".}
template gtype*(klass_parameter: typedesc[CellAreaContext]): GType = gtk_cell_area_context_get_type()
# gtk_cell_area_context_allocate
# flags: {isMethod} container: CellAreaContext
# need sugar: is method
# arg width: INT32 'int32' 'int32' IN
# arg height: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_context_allocate(self: ptr TCellAreaContext, width: int32, height: int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_context_allocate".}
proc allocate*(self: CellAreaContext, width: int32, height: int32) {.inline.} =
  gtk_cell_area_context_allocate(self, width, height)
# proc allocate*(self: CellAreaContext, width: int32, height: int32) {.inline.} =

# gtk_cell_area_context_get_allocation
# flags: {isMethod} container: CellAreaContext
# need sugar: is method
# arg width: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg height: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_context_get_allocation(self: ptr TCellAreaContext, width: ptr int32, height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_context_get_allocation".}
proc get_allocation*(self: CellAreaContext, width: var int32, height: var int32) {.inline.} =
  gtk_cell_area_context_get_allocation(self, addr(width), addr(height))
# tuple-return
# width: var int32
# height: var int32
# proc get_allocation*(self: CellAreaContext) {.inline.} =

# gtk_cell_area_context_get_area
# flags: {isMethod} container: CellAreaContext
# need sugar: is method
# return: INTERFACE 'CellArea' 'TransferNone[TCellArea]' (diff., need sugar)
proc gtk_cell_area_context_get_area(self: ptr TCellAreaContext): TransferNone[TCellArea] {.cdecl, dynlib: lib, importc: "gtk_cell_area_context_get_area".}
proc get_area*(self: CellAreaContext): CellArea {.inline.} =
  wrap(gtk_cell_area_context_get_area(self))
# proc get_area*(self: CellAreaContext): CellArea {.inline.} =

# gtk_cell_area_context_get_preferred_height
# flags: {isMethod} container: CellAreaContext
# need sugar: is method
# arg minimum_height: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg natural_height: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_context_get_preferred_height(self: ptr TCellAreaContext, minimum_height: ptr int32, natural_height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_context_get_preferred_height".}
proc get_preferred_height*(self: CellAreaContext, minimum_height: var int32, natural_height: var int32) {.inline.} =
  gtk_cell_area_context_get_preferred_height(self, addr(minimum_height), addr(natural_height))
# tuple-return
# minimum_height: var int32
# natural_height: var int32
# proc get_preferred_height*(self: CellAreaContext) {.inline.} =

# gtk_cell_area_context_get_preferred_height_for_width
# flags: {isMethod} container: CellAreaContext
# need sugar: is method
# arg width: INT32 'int32' 'int32' IN
# arg minimum_height: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg natural_height: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_context_get_preferred_height_for_width(self: ptr TCellAreaContext, width: int32, minimum_height: ptr int32, natural_height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_context_get_preferred_height_for_width".}
proc get_preferred_height_for_width*(self: CellAreaContext, width: int32, minimum_height: var int32, natural_height: var int32) {.inline.} =
  gtk_cell_area_context_get_preferred_height_for_width(self, width, addr(minimum_height), addr(natural_height))
# tuple-return
# minimum_height: var int32
# natural_height: var int32
# proc get_preferred_height_for_width*(self: CellAreaContext, width: int32) {.inline.} =

# gtk_cell_area_context_get_preferred_width
# flags: {isMethod} container: CellAreaContext
# need sugar: is method
# arg minimum_width: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg natural_width: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_context_get_preferred_width(self: ptr TCellAreaContext, minimum_width: ptr int32, natural_width: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_context_get_preferred_width".}
proc get_preferred_width*(self: CellAreaContext, minimum_width: var int32, natural_width: var int32) {.inline.} =
  gtk_cell_area_context_get_preferred_width(self, addr(minimum_width), addr(natural_width))
# tuple-return
# minimum_width: var int32
# natural_width: var int32
# proc get_preferred_width*(self: CellAreaContext) {.inline.} =

# gtk_cell_area_context_get_preferred_width_for_height
# flags: {isMethod} container: CellAreaContext
# need sugar: is method
# arg height: INT32 'int32' 'int32' IN
# arg minimum_width: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg natural_width: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_context_get_preferred_width_for_height(self: ptr TCellAreaContext, height: int32, minimum_width: ptr int32, natural_width: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_context_get_preferred_width_for_height".}
proc get_preferred_width_for_height*(self: CellAreaContext, height: int32, minimum_width: var int32, natural_width: var int32) {.inline.} =
  gtk_cell_area_context_get_preferred_width_for_height(self, height, addr(minimum_width), addr(natural_width))
# tuple-return
# minimum_width: var int32
# natural_width: var int32
# proc get_preferred_width_for_height*(self: CellAreaContext, height: int32) {.inline.} =

# gtk_cell_area_context_push_preferred_height
# flags: {isMethod} container: CellAreaContext
# need sugar: is method
# arg minimum_height: INT32 'int32' 'int32' IN
# arg natural_height: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_context_push_preferred_height(self: ptr TCellAreaContext, minimum_height: int32, natural_height: int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_context_push_preferred_height".}
proc push_preferred_height*(self: CellAreaContext, minimum_height: int32, natural_height: int32) {.inline.} =
  gtk_cell_area_context_push_preferred_height(self, minimum_height, natural_height)
# proc push_preferred_height*(self: CellAreaContext, minimum_height: int32, natural_height: int32) {.inline.} =

# gtk_cell_area_context_push_preferred_width
# flags: {isMethod} container: CellAreaContext
# need sugar: is method
# arg minimum_width: INT32 'int32' 'int32' IN
# arg natural_width: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_context_push_preferred_width(self: ptr TCellAreaContext, minimum_width: int32, natural_width: int32) {.cdecl, dynlib: lib, importc: "gtk_cell_area_context_push_preferred_width".}
proc push_preferred_width*(self: CellAreaContext, minimum_width: int32, natural_width: int32) {.inline.} =
  gtk_cell_area_context_push_preferred_width(self, minimum_width, natural_width)
# proc push_preferred_width*(self: CellAreaContext, minimum_width: int32, natural_width: int32) {.inline.} =

# gtk_cell_area_context_reset
# flags: {isMethod} container: CellAreaContext
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_context_reset(self: ptr TCellAreaContext) {.cdecl, dynlib: lib, importc: "gtk_cell_area_context_reset".}
proc reset*(self: CellAreaContext) {.inline.} =
  gtk_cell_area_context_reset(self)
# proc reset*(self: CellAreaContext) {.inline.} =

# initializer for CellRenderer: gtk_cell_renderer_get_type
proc gtk_cell_renderer_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_type".}
template gtype*(klass_parameter: typedesc[CellRenderer]): GType = gtk_cell_renderer_get_type()
# gtk_cell_renderer_activate
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# arg event: INTERFACE (UNION) 'ptr Gdk3.TEvent' 'ptr Gdk3.TEvent' IN
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg path: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg background_area: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# arg cell_area: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# arg flags: INTERFACE (FLAGS) 'SCellRendererState' 'SCellRendererState' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_cell_renderer_activate(self: ptr TCellRenderer, event: ptr Gdk3.TEvent, widget: ptr TWidget, path: ucstring, background_area: ptr Gdk3.TRectangle, cell_area: ptr Gdk3.TRectangle, flags: SCellRendererState): bool {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_activate".}
proc activate*(self: CellRenderer, event: ptr Gdk3.TEvent, widget: Widget, path: ustring, background_area: ptr Gdk3.TRectangle, cell_area: ptr Gdk3.TRectangle, flags: SCellRendererState): bool {.inline.} =
  gtk_cell_renderer_activate(self, event, widget.getPointer, ucstring(path), background_area, cell_area, flags)
# proc activate*(self: CellRenderer, event: ptr Gdk3.TEvent, widget: Widget, path: ustring, background_area: ptr Gdk3.TRectangle, cell_area: ptr Gdk3.TRectangle, flags: SCellRendererState): bool {.inline.} =

# gtk_cell_renderer_get_aligned_area
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg flags: INTERFACE (FLAGS) 'SCellRendererState' 'SCellRendererState' IN
# arg cell_area: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# arg aligned_area: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' OUT caller-allocates
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_get_aligned_area(self: ptr TCellRenderer, widget: ptr TWidget, flags: SCellRendererState, cell_area: ptr Gdk3.TRectangle, aligned_area: ptr Gdk3.TRectangle) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_aligned_area".}
proc get_aligned_area*(self: CellRenderer, widget: Widget, flags: SCellRendererState, cell_area: ptr Gdk3.TRectangle, aligned_area: ptr Gdk3.TRectangle) {.inline.} =
  gtk_cell_renderer_get_aligned_area(self, widget.getPointer, flags, cell_area, aligned_area)
# tuple-return
# aligned_area: ptr Gdk3.TRectangle
# proc get_aligned_area*(self: CellRenderer, widget: Widget, flags: SCellRendererState, cell_area: ptr Gdk3.TRectangle) {.inline.} =

# gtk_cell_renderer_get_alignment
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# arg xalign: FLOAT 'var float32' 'ptr float32' OUT (diff., need sugar) optional
# arg yalign: FLOAT 'var float32' 'ptr float32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_get_alignment(self: ptr TCellRenderer, xalign: ptr float32, yalign: ptr float32) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_alignment".}
proc get_alignment*(self: CellRenderer, xalign: var float32, yalign: var float32) {.inline.} =
  gtk_cell_renderer_get_alignment(self, addr(xalign), addr(yalign))
# tuple-return
# xalign: var float32
# yalign: var float32
# proc get_alignment*(self: CellRenderer) {.inline.} =

# gtk_cell_renderer_get_fixed_size
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# arg width: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg height: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_get_fixed_size(self: ptr TCellRenderer, width: ptr int32, height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_fixed_size".}
proc get_fixed_size*(self: CellRenderer, width: var int32, height: var int32) {.inline.} =
  gtk_cell_renderer_get_fixed_size(self, addr(width), addr(height))
# tuple-return
# width: var int32
# height: var int32
# proc get_fixed_size*(self: CellRenderer) {.inline.} =

# gtk_cell_renderer_get_padding
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# arg xpad: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg ypad: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_get_padding(self: ptr TCellRenderer, xpad: ptr int32, ypad: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_padding".}
proc get_padding*(self: CellRenderer, xpad: var int32, ypad: var int32) {.inline.} =
  gtk_cell_renderer_get_padding(self, addr(xpad), addr(ypad))
# tuple-return
# xpad: var int32
# ypad: var int32
# proc get_padding*(self: CellRenderer) {.inline.} =

# gtk_cell_renderer_get_preferred_height
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg minimum_size: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg natural_size: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_get_preferred_height(self: ptr TCellRenderer, widget: ptr TWidget, minimum_size: ptr int32, natural_size: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_preferred_height".}
proc get_preferred_height*(self: CellRenderer, widget: Widget, minimum_size: var int32, natural_size: var int32) {.inline.} =
  gtk_cell_renderer_get_preferred_height(self, widget.getPointer, addr(minimum_size), addr(natural_size))
# tuple-return
# minimum_size: var int32
# natural_size: var int32
# proc get_preferred_height*(self: CellRenderer, widget: Widget) {.inline.} =

# gtk_cell_renderer_get_preferred_height_for_width
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg width: INT32 'int32' 'int32' IN
# arg minimum_height: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg natural_height: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_get_preferred_height_for_width(self: ptr TCellRenderer, widget: ptr TWidget, width: int32, minimum_height: ptr int32, natural_height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_preferred_height_for_width".}
proc get_preferred_height_for_width*(self: CellRenderer, widget: Widget, width: int32, minimum_height: var int32, natural_height: var int32) {.inline.} =
  gtk_cell_renderer_get_preferred_height_for_width(self, widget.getPointer, width, addr(minimum_height), addr(natural_height))
# tuple-return
# minimum_height: var int32
# natural_height: var int32
# proc get_preferred_height_for_width*(self: CellRenderer, widget: Widget, width: int32) {.inline.} =

# gtk_cell_renderer_get_preferred_size
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg minimum_size: INTERFACE (STRUCT) 'ptr TRequisition' 'ptr TRequisition' OUT caller-allocates optional
# arg natural_size: INTERFACE (STRUCT) 'ptr TRequisition' 'ptr TRequisition' OUT caller-allocates optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_get_preferred_size(self: ptr TCellRenderer, widget: ptr TWidget, minimum_size: ptr TRequisition, natural_size: ptr TRequisition) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_preferred_size".}
proc get_preferred_size*(self: CellRenderer, widget: Widget, minimum_size: ptr TRequisition, natural_size: ptr TRequisition) {.inline.} =
  gtk_cell_renderer_get_preferred_size(self, widget.getPointer, minimum_size, natural_size)
# tuple-return
# minimum_size: ptr TRequisition
# natural_size: ptr TRequisition
# proc get_preferred_size*(self: CellRenderer, widget: Widget) {.inline.} =

# gtk_cell_renderer_get_preferred_width
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg minimum_size: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg natural_size: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_get_preferred_width(self: ptr TCellRenderer, widget: ptr TWidget, minimum_size: ptr int32, natural_size: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_preferred_width".}
proc get_preferred_width*(self: CellRenderer, widget: Widget, minimum_size: var int32, natural_size: var int32) {.inline.} =
  gtk_cell_renderer_get_preferred_width(self, widget.getPointer, addr(minimum_size), addr(natural_size))
# tuple-return
# minimum_size: var int32
# natural_size: var int32
# proc get_preferred_width*(self: CellRenderer, widget: Widget) {.inline.} =

# gtk_cell_renderer_get_preferred_width_for_height
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg height: INT32 'int32' 'int32' IN
# arg minimum_width: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg natural_width: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_get_preferred_width_for_height(self: ptr TCellRenderer, widget: ptr TWidget, height: int32, minimum_width: ptr int32, natural_width: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_preferred_width_for_height".}
proc get_preferred_width_for_height*(self: CellRenderer, widget: Widget, height: int32, minimum_width: var int32, natural_width: var int32) {.inline.} =
  gtk_cell_renderer_get_preferred_width_for_height(self, widget.getPointer, height, addr(minimum_width), addr(natural_width))
# tuple-return
# minimum_width: var int32
# natural_width: var int32
# proc get_preferred_width_for_height*(self: CellRenderer, widget: Widget, height: int32) {.inline.} =

# gtk_cell_renderer_get_request_mode
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# return: INTERFACE 'SizeRequestMode' 'SizeRequestMode'
proc gtk_cell_renderer_get_request_mode(self: ptr TCellRenderer): SizeRequestMode {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_request_mode".}
proc get_request_mode*(self: CellRenderer): SizeRequestMode {.inline.} =
  gtk_cell_renderer_get_request_mode(self)
# proc get_request_mode*(self: CellRenderer): SizeRequestMode {.inline.} =

# gtk_cell_renderer_get_sensitive
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_cell_renderer_get_sensitive(self: ptr TCellRenderer): bool {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_sensitive".}
proc get_sensitive*(self: CellRenderer): bool {.inline.} =
  gtk_cell_renderer_get_sensitive(self)
# proc get_sensitive*(self: CellRenderer): bool {.inline.} =

# gtk_cell_renderer_get_size
# flags: {isMethod} container: CellRenderer (deprecated)
# gtk_cell_renderer_get_state
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg cell_state: INTERFACE (FLAGS) 'SCellRendererState' 'SCellRendererState' IN
# return: INTERFACE 'SStateFlags' 'SStateFlags'
proc gtk_cell_renderer_get_state(self: ptr TCellRenderer, widget: ptr TWidget, cell_state: SCellRendererState): SStateFlags {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_state".}
proc get_state*(self: CellRenderer, widget: Widget, cell_state: SCellRendererState): SStateFlags {.inline.} =
  gtk_cell_renderer_get_state(self, widget.getPointer, cell_state)
# proc get_state*(self: CellRenderer, widget: Widget, cell_state: SCellRendererState): SStateFlags {.inline.} =

# gtk_cell_renderer_get_visible
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_cell_renderer_get_visible(self: ptr TCellRenderer): bool {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_get_visible".}
proc get_visible*(self: CellRenderer): bool {.inline.} =
  gtk_cell_renderer_get_visible(self)
# proc get_visible*(self: CellRenderer): bool {.inline.} =

# gtk_cell_renderer_is_activatable
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_cell_renderer_is_activatable(self: ptr TCellRenderer): bool {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_is_activatable".}
proc is_activatable*(self: CellRenderer): bool {.inline.} =
  gtk_cell_renderer_is_activatable(self)
# proc is_activatable*(self: CellRenderer): bool {.inline.} =

# gtk_cell_renderer_render
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# arg cr: INTERFACE (STRUCT) 'ptr cairo1.TContext' 'ptr cairo1.TContext' IN
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg background_area: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# arg cell_area: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# arg flags: INTERFACE (FLAGS) 'SCellRendererState' 'SCellRendererState' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_render(self: ptr TCellRenderer, cr: ptr cairo1.TContext, widget: ptr TWidget, background_area: ptr Gdk3.TRectangle, cell_area: ptr Gdk3.TRectangle, flags: SCellRendererState) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_render".}
proc render*(self: CellRenderer, cr: ptr cairo1.TContext, widget: Widget, background_area: ptr Gdk3.TRectangle, cell_area: ptr Gdk3.TRectangle, flags: SCellRendererState) {.inline.} =
  gtk_cell_renderer_render(self, cr, widget.getPointer, background_area, cell_area, flags)
# proc render*(self: CellRenderer, cr: ptr cairo1.TContext, widget: Widget, background_area: ptr Gdk3.TRectangle, cell_area: ptr Gdk3.TRectangle, flags: SCellRendererState) {.inline.} =

# gtk_cell_renderer_set_alignment
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# arg xalign: FLOAT 'float32' 'float32' IN
# arg yalign: FLOAT 'float32' 'float32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_set_alignment(self: ptr TCellRenderer, xalign: float32, yalign: float32) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_set_alignment".}
proc set_alignment*(self: CellRenderer, xalign: float32, yalign: float32) {.inline.} =
  gtk_cell_renderer_set_alignment(self, xalign, yalign)
# proc set_alignment*(self: CellRenderer, xalign: float32, yalign: float32) {.inline.} =

# gtk_cell_renderer_set_fixed_size
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# arg width: INT32 'int32' 'int32' IN
# arg height: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_set_fixed_size(self: ptr TCellRenderer, width: int32, height: int32) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_set_fixed_size".}
proc set_fixed_size*(self: CellRenderer, width: int32, height: int32) {.inline.} =
  gtk_cell_renderer_set_fixed_size(self, width, height)
# proc set_fixed_size*(self: CellRenderer, width: int32, height: int32) {.inline.} =

# gtk_cell_renderer_set_padding
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# arg xpad: INT32 'int32' 'int32' IN
# arg ypad: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_set_padding(self: ptr TCellRenderer, xpad: int32, ypad: int32) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_set_padding".}
proc set_padding*(self: CellRenderer, xpad: int32, ypad: int32) {.inline.} =
  gtk_cell_renderer_set_padding(self, xpad, ypad)
# proc set_padding*(self: CellRenderer, xpad: int32, ypad: int32) {.inline.} =

# gtk_cell_renderer_set_sensitive
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# arg sensitive: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_set_sensitive(self: ptr TCellRenderer, sensitive: bool) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_set_sensitive".}
proc set_sensitive*(self: CellRenderer, sensitive: bool) {.inline.} =
  gtk_cell_renderer_set_sensitive(self, sensitive)
# proc set_sensitive*(self: CellRenderer, sensitive: bool) {.inline.} =

# gtk_cell_renderer_set_visible
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# arg visible: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_set_visible(self: ptr TCellRenderer, visible: bool) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_set_visible".}
proc set_visible*(self: CellRenderer, visible: bool) {.inline.} =
  gtk_cell_renderer_set_visible(self, visible)
# proc set_visible*(self: CellRenderer, visible: bool) {.inline.} =

# gtk_cell_renderer_start_editing
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# arg event: INTERFACE (UNION) 'ptr Gdk3.TEvent' 'ptr Gdk3.TEvent' IN
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg path: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg background_area: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# arg cell_area: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# arg flags: INTERFACE (FLAGS) 'SCellRendererState' 'SCellRendererState' IN
# return: INTERFACE 'ptr TCellEditable' 'TransferNone[TCellEditable]' (diff., need sugar)
proc gtk_cell_renderer_start_editing(self: ptr TCellRenderer, event: ptr Gdk3.TEvent, widget: ptr TWidget, path: ucstring, background_area: ptr Gdk3.TRectangle, cell_area: ptr Gdk3.TRectangle, flags: SCellRendererState): TransferNone[TCellEditable] {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_start_editing".}
proc start_editing*(self: CellRenderer, event: ptr Gdk3.TEvent, widget: Widget, path: ustring, background_area: ptr Gdk3.TRectangle, cell_area: ptr Gdk3.TRectangle, flags: SCellRendererState): ptr TCellEditable {.inline.} =
  wrap(gtk_cell_renderer_start_editing(self, event, widget.getPointer, ucstring(path), background_area, cell_area, flags))
# proc start_editing*(self: CellRenderer, event: ptr Gdk3.TEvent, widget: Widget, path: ustring, background_area: ptr Gdk3.TRectangle, cell_area: ptr Gdk3.TRectangle, flags: SCellRendererState): ptr TCellEditable {.inline.} =

# gtk_cell_renderer_stop_editing
# flags: {isMethod} container: CellRenderer
# need sugar: is method
# arg canceled: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_stop_editing(self: ptr TCellRenderer, canceled: bool) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_stop_editing".}
proc stop_editing*(self: CellRenderer, canceled: bool) {.inline.} =
  gtk_cell_renderer_stop_editing(self, canceled)
# proc stop_editing*(self: CellRenderer, canceled: bool) {.inline.} =

# initializer for CellRendererAccel: gtk_cell_renderer_accel_get_type
proc gtk_cell_renderer_accel_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_accel_get_type".}
template gtype*(klass_parameter: typedesc[CellRendererAccel]): GType = gtk_cell_renderer_accel_get_type()
# gtk_cell_renderer_accel_new
# flags: {isConstructor} container: CellRendererAccel
# need sugar: is static method
# return: INTERFACE 'CellRendererAccel' 'TransferNone[TCellRendererAccel]' (diff., need sugar)
proc gtk_cell_renderer_accel_new(): TransferNone[TCellRendererAccel] {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_accel_new".}
proc new_cellrendereraccel*(): CellRendererAccel {.inline.} =
  wrap(gtk_cell_renderer_accel_new())
# proc new_cellrendereraccel*(): CellRendererAccel {.inline.} =

# initializer for CellRendererCombo: gtk_cell_renderer_combo_get_type
proc gtk_cell_renderer_combo_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_combo_get_type".}
template gtype*(klass_parameter: typedesc[CellRendererCombo]): GType = gtk_cell_renderer_combo_get_type()
# gtk_cell_renderer_combo_new
# flags: {isConstructor} container: CellRendererCombo
# need sugar: is static method
# return: INTERFACE 'CellRendererCombo' 'TransferNone[TCellRendererCombo]' (diff., need sugar)
proc gtk_cell_renderer_combo_new(): TransferNone[TCellRendererCombo] {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_combo_new".}
proc new_cellrenderercombo*(): CellRendererCombo {.inline.} =
  wrap(gtk_cell_renderer_combo_new())
# proc new_cellrenderercombo*(): CellRendererCombo {.inline.} =

# initializer for CellRendererPixbuf: gtk_cell_renderer_pixbuf_get_type
proc gtk_cell_renderer_pixbuf_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_pixbuf_get_type".}
template gtype*(klass_parameter: typedesc[CellRendererPixbuf]): GType = gtk_cell_renderer_pixbuf_get_type()
# gtk_cell_renderer_pixbuf_new
# flags: {isConstructor} container: CellRendererPixbuf
# need sugar: is static method
# return: INTERFACE 'CellRendererPixbuf' 'TransferNone[TCellRendererPixbuf]' (diff., need sugar)
proc gtk_cell_renderer_pixbuf_new(): TransferNone[TCellRendererPixbuf] {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_pixbuf_new".}
proc new_cellrendererpixbuf*(): CellRendererPixbuf {.inline.} =
  wrap(gtk_cell_renderer_pixbuf_new())
# proc new_cellrendererpixbuf*(): CellRendererPixbuf {.inline.} =

# initializer for CellRendererProgress: gtk_cell_renderer_progress_get_type
proc gtk_cell_renderer_progress_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_progress_get_type".}
template gtype*(klass_parameter: typedesc[CellRendererProgress]): GType = gtk_cell_renderer_progress_get_type()
# gtk_cell_renderer_progress_new
# flags: {isConstructor} container: CellRendererProgress
# need sugar: is static method
# return: INTERFACE 'CellRendererProgress' 'TransferNone[TCellRendererProgress]' (diff., need sugar)
proc gtk_cell_renderer_progress_new(): TransferNone[TCellRendererProgress] {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_progress_new".}
proc new_cellrendererprogress*(): CellRendererProgress {.inline.} =
  wrap(gtk_cell_renderer_progress_new())
# proc new_cellrendererprogress*(): CellRendererProgress {.inline.} =

# initializer for CellRendererSpin: gtk_cell_renderer_spin_get_type
proc gtk_cell_renderer_spin_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_spin_get_type".}
template gtype*(klass_parameter: typedesc[CellRendererSpin]): GType = gtk_cell_renderer_spin_get_type()
# gtk_cell_renderer_spin_new
# flags: {isConstructor} container: CellRendererSpin
# need sugar: is static method
# return: INTERFACE 'CellRendererSpin' 'TransferNone[TCellRendererSpin]' (diff., need sugar)
proc gtk_cell_renderer_spin_new(): TransferNone[TCellRendererSpin] {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_spin_new".}
proc new_cellrendererspin*(): CellRendererSpin {.inline.} =
  wrap(gtk_cell_renderer_spin_new())
# proc new_cellrendererspin*(): CellRendererSpin {.inline.} =

# initializer for CellRendererSpinner: gtk_cell_renderer_spinner_get_type
proc gtk_cell_renderer_spinner_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_spinner_get_type".}
template gtype*(klass_parameter: typedesc[CellRendererSpinner]): GType = gtk_cell_renderer_spinner_get_type()
# gtk_cell_renderer_spinner_new
# flags: {isConstructor} container: CellRendererSpinner
# need sugar: is static method
# return: INTERFACE 'CellRendererSpinner' 'TransferNone[TCellRendererSpinner]' (diff., need sugar)
proc gtk_cell_renderer_spinner_new(): TransferNone[TCellRendererSpinner] {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_spinner_new".}
proc new_cellrendererspinner*(): CellRendererSpinner {.inline.} =
  wrap(gtk_cell_renderer_spinner_new())
# proc new_cellrendererspinner*(): CellRendererSpinner {.inline.} =

# initializer for CellRendererText: gtk_cell_renderer_text_get_type
proc gtk_cell_renderer_text_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_text_get_type".}
template gtype*(klass_parameter: typedesc[CellRendererText]): GType = gtk_cell_renderer_text_get_type()
# gtk_cell_renderer_text_new
# flags: {isConstructor} container: CellRendererText
# need sugar: is static method
# return: INTERFACE 'CellRendererText' 'TransferNone[TCellRendererText]' (diff., need sugar)
proc gtk_cell_renderer_text_new(): TransferNone[TCellRendererText] {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_text_new".}
proc new_cellrenderertext*(): CellRendererText {.inline.} =
  wrap(gtk_cell_renderer_text_new())
# proc new_cellrenderertext*(): CellRendererText {.inline.} =

# gtk_cell_renderer_text_set_fixed_height_from_font
# flags: {isMethod} container: CellRendererText
# need sugar: is method
# arg number_of_rows: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_text_set_fixed_height_from_font(self: ptr TCellRendererText, number_of_rows: int32) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_text_set_fixed_height_from_font".}
proc set_fixed_height_from_font*(self: CellRendererText, number_of_rows: int32) {.inline.} =
  gtk_cell_renderer_text_set_fixed_height_from_font(self, number_of_rows)
# proc set_fixed_height_from_font*(self: CellRendererText, number_of_rows: int32) {.inline.} =

# initializer for CellRendererToggle: gtk_cell_renderer_toggle_get_type
proc gtk_cell_renderer_toggle_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_toggle_get_type".}
template gtype*(klass_parameter: typedesc[CellRendererToggle]): GType = gtk_cell_renderer_toggle_get_type()
# gtk_cell_renderer_toggle_new
# flags: {isConstructor} container: CellRendererToggle
# need sugar: is static method
# return: INTERFACE 'CellRendererToggle' 'TransferNone[TCellRendererToggle]' (diff., need sugar)
proc gtk_cell_renderer_toggle_new(): TransferNone[TCellRendererToggle] {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_toggle_new".}
proc new_cellrenderertoggle*(): CellRendererToggle {.inline.} =
  wrap(gtk_cell_renderer_toggle_new())
# proc new_cellrenderertoggle*(): CellRendererToggle {.inline.} =

# gtk_cell_renderer_toggle_get_activatable
# flags: {isMethod} container: CellRendererToggle
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_cell_renderer_toggle_get_activatable(self: ptr TCellRendererToggle): bool {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_toggle_get_activatable".}
proc get_activatable*(self: CellRendererToggle): bool {.inline.} =
  gtk_cell_renderer_toggle_get_activatable(self)
# proc get_activatable*(self: CellRendererToggle): bool {.inline.} =

# gtk_cell_renderer_toggle_get_active
# flags: {isMethod} container: CellRendererToggle
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_cell_renderer_toggle_get_active(self: ptr TCellRendererToggle): bool {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_toggle_get_active".}
proc get_active*(self: CellRendererToggle): bool {.inline.} =
  gtk_cell_renderer_toggle_get_active(self)
# proc get_active*(self: CellRendererToggle): bool {.inline.} =

# gtk_cell_renderer_toggle_get_radio
# flags: {isMethod} container: CellRendererToggle
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_cell_renderer_toggle_get_radio(self: ptr TCellRendererToggle): bool {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_toggle_get_radio".}
proc get_radio*(self: CellRendererToggle): bool {.inline.} =
  gtk_cell_renderer_toggle_get_radio(self)
# proc get_radio*(self: CellRendererToggle): bool {.inline.} =

# gtk_cell_renderer_toggle_set_activatable
# flags: {isMethod} container: CellRendererToggle
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_toggle_set_activatable(self: ptr TCellRendererToggle, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_toggle_set_activatable".}
proc set_activatable*(self: CellRendererToggle, setting: bool) {.inline.} =
  gtk_cell_renderer_toggle_set_activatable(self, setting)
# proc set_activatable*(self: CellRendererToggle, setting: bool) {.inline.} =

# gtk_cell_renderer_toggle_set_active
# flags: {isMethod} container: CellRendererToggle
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_toggle_set_active(self: ptr TCellRendererToggle, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_toggle_set_active".}
proc set_active*(self: CellRendererToggle, setting: bool) {.inline.} =
  gtk_cell_renderer_toggle_set_active(self, setting)
# proc set_active*(self: CellRendererToggle, setting: bool) {.inline.} =

# gtk_cell_renderer_toggle_set_radio
# flags: {isMethod} container: CellRendererToggle
# need sugar: is method
# arg radio: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_toggle_set_radio(self: ptr TCellRendererToggle, radio: bool) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_toggle_set_radio".}
proc set_radio*(self: CellRendererToggle, radio: bool) {.inline.} =
  gtk_cell_renderer_toggle_set_radio(self, radio)
# proc set_radio*(self: CellRendererToggle, radio: bool) {.inline.} =

# initializer for CellView: gtk_cell_view_get_type
proc gtk_cell_view_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_cell_view_get_type".}
template gtype*(klass_parameter: typedesc[CellView]): GType = gtk_cell_view_get_type()
# gtk_cell_view_new
# flags: {isConstructor} container: CellView
# need sugar: is static method
# return: INTERFACE 'CellView' 'TransferNone[TCellView]' (diff., need sugar)
proc gtk_cell_view_new(): TransferNone[TCellView] {.cdecl, dynlib: lib, importc: "gtk_cell_view_new".}
proc new_cellview*(): CellView {.inline.} =
  wrap(gtk_cell_view_new())
# proc new_cellview*(): CellView {.inline.} =

# gtk_cell_view_new_with_context
# flags: {isConstructor} container: CellView
# need sugar: is static method
# arg area: INTERFACE (OBJECT) 'CellArea' 'ptr TCellArea' IN (diff., need sugar)
# arg context: INTERFACE (OBJECT) 'CellAreaContext' 'ptr TCellAreaContext' IN (diff., need sugar)
# return: INTERFACE 'CellView' 'TransferNone[TCellView]' (diff., need sugar)
proc gtk_cell_view_new_with_context(area: ptr TCellArea, context: ptr TCellAreaContext): TransferNone[TCellView] {.cdecl, dynlib: lib, importc: "gtk_cell_view_new_with_context".}
proc new_cellview_with_context*(area: CellArea, context: CellAreaContext): CellView {.inline.} =
  wrap(gtk_cell_view_new_with_context(area.getPointer, context.getPointer))
# proc new_cellview_with_context*(area: CellArea, context: CellAreaContext): CellView {.inline.} =

# gtk_cell_view_new_with_markup
# flags: {isConstructor} container: CellView
# need sugar: is static method
# arg markup: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'CellView' 'TransferNone[TCellView]' (diff., need sugar)
proc gtk_cell_view_new_with_markup(markup: ucstring): TransferNone[TCellView] {.cdecl, dynlib: lib, importc: "gtk_cell_view_new_with_markup".}
proc new_cellview_with_markup*(markup: ustring): CellView {.inline.} =
  wrap(gtk_cell_view_new_with_markup(ucstring(markup)))
# proc new_cellview_with_markup*(markup: ustring): CellView {.inline.} =

# gtk_cell_view_new_with_pixbuf
# flags: {isConstructor} container: CellView
# need sugar: is static method
# arg pixbuf: INTERFACE (OBJECT) 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# return: INTERFACE 'CellView' 'TransferNone[TCellView]' (diff., need sugar)
proc gtk_cell_view_new_with_pixbuf(pixbuf: ptr GdkPixbuf2.TPixbuf): TransferNone[TCellView] {.cdecl, dynlib: lib, importc: "gtk_cell_view_new_with_pixbuf".}
proc new_cellview_with_pixbuf*(pixbuf: GdkPixbuf2.Pixbuf): CellView {.inline.} =
  wrap(gtk_cell_view_new_with_pixbuf(pixbuf.getPointer))
# proc new_cellview_with_pixbuf*(pixbuf: GdkPixbuf2.Pixbuf): CellView {.inline.} =

# gtk_cell_view_new_with_text
# flags: {isConstructor} container: CellView
# need sugar: is static method
# arg text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'CellView' 'TransferNone[TCellView]' (diff., need sugar)
proc gtk_cell_view_new_with_text(text: ucstring): TransferNone[TCellView] {.cdecl, dynlib: lib, importc: "gtk_cell_view_new_with_text".}
proc new_cellview_with_text*(text: ustring): CellView {.inline.} =
  wrap(gtk_cell_view_new_with_text(ucstring(text)))
# proc new_cellview_with_text*(text: ustring): CellView {.inline.} =

# gtk_cell_view_get_displayed_row
# flags: {isMethod} container: CellView
# need sugar: is method
# return: INTERFACE 'ptr TTreePath' 'ptr TTreePath'
proc gtk_cell_view_get_displayed_row(self: ptr TCellView): ptr TTreePath {.cdecl, dynlib: lib, importc: "gtk_cell_view_get_displayed_row".}
proc get_displayed_row*(self: CellView): ptr TTreePath {.inline.} =
  gtk_cell_view_get_displayed_row(self)
# proc get_displayed_row*(self: CellView): ptr TTreePath {.inline.} =

# gtk_cell_view_get_draw_sensitive
# flags: {isMethod} container: CellView
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_cell_view_get_draw_sensitive(self: ptr TCellView): bool {.cdecl, dynlib: lib, importc: "gtk_cell_view_get_draw_sensitive".}
proc get_draw_sensitive*(self: CellView): bool {.inline.} =
  gtk_cell_view_get_draw_sensitive(self)
# proc get_draw_sensitive*(self: CellView): bool {.inline.} =

# gtk_cell_view_get_fit_model
# flags: {isMethod} container: CellView
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_cell_view_get_fit_model(self: ptr TCellView): bool {.cdecl, dynlib: lib, importc: "gtk_cell_view_get_fit_model".}
proc get_fit_model*(self: CellView): bool {.inline.} =
  gtk_cell_view_get_fit_model(self)
# proc get_fit_model*(self: CellView): bool {.inline.} =

# gtk_cell_view_get_model
# flags: {isMethod} container: CellView
# need sugar: is method
# return: INTERFACE 'ptr TTreeModel' 'TransferNone[TTreeModel]' (diff., need sugar)
proc gtk_cell_view_get_model(self: ptr TCellView): TransferNone[TTreeModel] {.cdecl, dynlib: lib, importc: "gtk_cell_view_get_model".}
proc get_model*(self: CellView): ptr TTreeModel {.inline.} =
  wrap(gtk_cell_view_get_model(self))
# proc get_model*(self: CellView): ptr TTreeModel {.inline.} =

# gtk_cell_view_get_size_of_row
# flags: {isMethod} container: CellView (deprecated)
# gtk_cell_view_set_background_color
# flags: {isMethod} container: CellView (deprecated)
# gtk_cell_view_set_background_rgba
# flags: {isMethod} container: CellView
# need sugar: is method
# arg rgba: INTERFACE (STRUCT) 'ptr Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_view_set_background_rgba(self: ptr TCellView, rgba: ptr Gdk3.TRGBA) {.cdecl, dynlib: lib, importc: "gtk_cell_view_set_background_rgba".}
proc set_background_rgba*(self: CellView, rgba: ptr Gdk3.TRGBA) {.inline.} =
  gtk_cell_view_set_background_rgba(self, rgba)
# proc set_background_rgba*(self: CellView, rgba: ptr Gdk3.TRGBA) {.inline.} =

# gtk_cell_view_set_displayed_row
# flags: {isMethod} container: CellView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_view_set_displayed_row(self: ptr TCellView, path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_cell_view_set_displayed_row".}
proc set_displayed_row*(self: CellView, path: ptr TTreePath) {.inline.} =
  gtk_cell_view_set_displayed_row(self, path)
# proc set_displayed_row*(self: CellView, path: ptr TTreePath) {.inline.} =

# gtk_cell_view_set_draw_sensitive
# flags: {isMethod} container: CellView
# need sugar: is method
# arg draw_sensitive: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_view_set_draw_sensitive(self: ptr TCellView, draw_sensitive: bool) {.cdecl, dynlib: lib, importc: "gtk_cell_view_set_draw_sensitive".}
proc set_draw_sensitive*(self: CellView, draw_sensitive: bool) {.inline.} =
  gtk_cell_view_set_draw_sensitive(self, draw_sensitive)
# proc set_draw_sensitive*(self: CellView, draw_sensitive: bool) {.inline.} =

# gtk_cell_view_set_fit_model
# flags: {isMethod} container: CellView
# need sugar: is method
# arg fit_model: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_view_set_fit_model(self: ptr TCellView, fit_model: bool) {.cdecl, dynlib: lib, importc: "gtk_cell_view_set_fit_model".}
proc set_fit_model*(self: CellView, fit_model: bool) {.inline.} =
  gtk_cell_view_set_fit_model(self, fit_model)
# proc set_fit_model*(self: CellView, fit_model: bool) {.inline.} =

# gtk_cell_view_set_model
# flags: {isMethod} container: CellView
# need sugar: is method
# arg model: INTERFACE (INTERFACE) 'ptr TTreeModel' 'ptr TTreeModel' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_view_set_model(self: ptr TCellView, model: ptr TTreeModel) {.cdecl, dynlib: lib, importc: "gtk_cell_view_set_model".}
proc set_model*(self: CellView, model: ptr TTreeModel) {.inline.} =
  gtk_cell_view_set_model(self, model)
# proc set_model*(self: CellView, model: ptr TTreeModel) {.inline.} =

# initializer for CheckButton: gtk_check_button_get_type
proc gtk_check_button_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_check_button_get_type".}
template gtype*(klass_parameter: typedesc[CheckButton]): GType = gtk_check_button_get_type()
# gtk_check_button_new
# flags: {isConstructor} container: CheckButton
# need sugar: is static method
# return: INTERFACE 'CheckButton' 'TransferNone[TCheckButton]' (diff., need sugar)
proc gtk_check_button_new(): TransferNone[TCheckButton] {.cdecl, dynlib: lib, importc: "gtk_check_button_new".}
proc new_checkbutton*(): CheckButton {.inline.} =
  wrap(gtk_check_button_new())
# proc new_checkbutton*(): CheckButton {.inline.} =

# gtk_check_button_new_with_label
# flags: {isConstructor} container: CheckButton
# need sugar: is static method
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'CheckButton' 'TransferNone[TCheckButton]' (diff., need sugar)
proc gtk_check_button_new_with_label(label: ucstring): TransferNone[TCheckButton] {.cdecl, dynlib: lib, importc: "gtk_check_button_new_with_label".}
proc new_checkbutton_with_label*(label: ustring): CheckButton {.inline.} =
  wrap(gtk_check_button_new_with_label(ucstring(label)))
# proc new_checkbutton_with_label*(label: ustring): CheckButton {.inline.} =

# gtk_check_button_new_with_mnemonic
# flags: {isConstructor} container: CheckButton
# need sugar: is static method
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'CheckButton' 'TransferNone[TCheckButton]' (diff., need sugar)
proc gtk_check_button_new_with_mnemonic(label: ucstring): TransferNone[TCheckButton] {.cdecl, dynlib: lib, importc: "gtk_check_button_new_with_mnemonic".}
proc new_checkbutton_with_mnemonic*(label: ustring): CheckButton {.inline.} =
  wrap(gtk_check_button_new_with_mnemonic(ucstring(label)))
# proc new_checkbutton_with_mnemonic*(label: ustring): CheckButton {.inline.} =

# initializer for CheckMenuItem: gtk_check_menu_item_get_type
proc gtk_check_menu_item_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_check_menu_item_get_type".}
template gtype*(klass_parameter: typedesc[CheckMenuItem]): GType = gtk_check_menu_item_get_type()
# gtk_check_menu_item_new
# flags: {isConstructor} container: CheckMenuItem
# need sugar: is static method
# return: INTERFACE 'CheckMenuItem' 'TransferNone[TCheckMenuItem]' (diff., need sugar)
proc gtk_check_menu_item_new(): TransferNone[TCheckMenuItem] {.cdecl, dynlib: lib, importc: "gtk_check_menu_item_new".}
proc new_checkmenuitem*(): CheckMenuItem {.inline.} =
  wrap(gtk_check_menu_item_new())
# proc new_checkmenuitem*(): CheckMenuItem {.inline.} =

# gtk_check_menu_item_new_with_label
# flags: {isConstructor} container: CheckMenuItem
# need sugar: is static method
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'CheckMenuItem' 'TransferNone[TCheckMenuItem]' (diff., need sugar)
proc gtk_check_menu_item_new_with_label(label: ucstring): TransferNone[TCheckMenuItem] {.cdecl, dynlib: lib, importc: "gtk_check_menu_item_new_with_label".}
proc new_checkmenuitem_with_label*(label: ustring): CheckMenuItem {.inline.} =
  wrap(gtk_check_menu_item_new_with_label(ucstring(label)))
# proc new_checkmenuitem_with_label*(label: ustring): CheckMenuItem {.inline.} =

# gtk_check_menu_item_new_with_mnemonic
# flags: {isConstructor} container: CheckMenuItem
# need sugar: is static method
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'CheckMenuItem' 'TransferNone[TCheckMenuItem]' (diff., need sugar)
proc gtk_check_menu_item_new_with_mnemonic(label: ucstring): TransferNone[TCheckMenuItem] {.cdecl, dynlib: lib, importc: "gtk_check_menu_item_new_with_mnemonic".}
proc new_checkmenuitem_with_mnemonic*(label: ustring): CheckMenuItem {.inline.} =
  wrap(gtk_check_menu_item_new_with_mnemonic(ucstring(label)))
# proc new_checkmenuitem_with_mnemonic*(label: ustring): CheckMenuItem {.inline.} =

# gtk_check_menu_item_get_active
# flags: {isMethod} container: CheckMenuItem
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_check_menu_item_get_active(self: ptr TCheckMenuItem): bool {.cdecl, dynlib: lib, importc: "gtk_check_menu_item_get_active".}
proc get_active*(self: CheckMenuItem): bool {.inline.} =
  gtk_check_menu_item_get_active(self)
# proc get_active*(self: CheckMenuItem): bool {.inline.} =

# gtk_check_menu_item_get_draw_as_radio
# flags: {isMethod} container: CheckMenuItem
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_check_menu_item_get_draw_as_radio(self: ptr TCheckMenuItem): bool {.cdecl, dynlib: lib, importc: "gtk_check_menu_item_get_draw_as_radio".}
proc get_draw_as_radio*(self: CheckMenuItem): bool {.inline.} =
  gtk_check_menu_item_get_draw_as_radio(self)
# proc get_draw_as_radio*(self: CheckMenuItem): bool {.inline.} =

# gtk_check_menu_item_get_inconsistent
# flags: {isMethod} container: CheckMenuItem
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_check_menu_item_get_inconsistent(self: ptr TCheckMenuItem): bool {.cdecl, dynlib: lib, importc: "gtk_check_menu_item_get_inconsistent".}
proc get_inconsistent*(self: CheckMenuItem): bool {.inline.} =
  gtk_check_menu_item_get_inconsistent(self)
# proc get_inconsistent*(self: CheckMenuItem): bool {.inline.} =

# gtk_check_menu_item_set_active
# flags: {isMethod} container: CheckMenuItem
# need sugar: is method
# arg is_active: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_check_menu_item_set_active(self: ptr TCheckMenuItem, is_active: bool) {.cdecl, dynlib: lib, importc: "gtk_check_menu_item_set_active".}
proc set_active*(self: CheckMenuItem, is_active: bool) {.inline.} =
  gtk_check_menu_item_set_active(self, is_active)
# proc set_active*(self: CheckMenuItem, is_active: bool) {.inline.} =

# gtk_check_menu_item_set_draw_as_radio
# flags: {isMethod} container: CheckMenuItem
# need sugar: is method
# arg draw_as_radio: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_check_menu_item_set_draw_as_radio(self: ptr TCheckMenuItem, draw_as_radio: bool) {.cdecl, dynlib: lib, importc: "gtk_check_menu_item_set_draw_as_radio".}
proc set_draw_as_radio*(self: CheckMenuItem, draw_as_radio: bool) {.inline.} =
  gtk_check_menu_item_set_draw_as_radio(self, draw_as_radio)
# proc set_draw_as_radio*(self: CheckMenuItem, draw_as_radio: bool) {.inline.} =

# gtk_check_menu_item_set_inconsistent
# flags: {isMethod} container: CheckMenuItem
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_check_menu_item_set_inconsistent(self: ptr TCheckMenuItem, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_check_menu_item_set_inconsistent".}
proc set_inconsistent*(self: CheckMenuItem, setting: bool) {.inline.} =
  gtk_check_menu_item_set_inconsistent(self, setting)
# proc set_inconsistent*(self: CheckMenuItem, setting: bool) {.inline.} =

# gtk_check_menu_item_toggled
# flags: {isMethod} container: CheckMenuItem
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_check_menu_item_toggled(self: ptr TCheckMenuItem) {.cdecl, dynlib: lib, importc: "gtk_check_menu_item_toggled".}
proc toggled*(self: CheckMenuItem) {.inline.} =
  gtk_check_menu_item_toggled(self)
# proc toggled*(self: CheckMenuItem) {.inline.} =

# initializer for CheckMenuItemAccessible: gtk_check_menu_item_accessible_get_type
proc gtk_check_menu_item_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_check_menu_item_accessible_get_type".}
template gtype*(klass_parameter: typedesc[CheckMenuItemAccessible]): GType = gtk_check_menu_item_accessible_get_type()
# initializer for Clipboard: gtk_clipboard_get_type
proc gtk_clipboard_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_clipboard_get_type".}
template gtype*(klass_parameter: typedesc[Clipboard]): GType = gtk_clipboard_get_type()
# gtk_clipboard_get
# flags: {} container: Clipboard
# need sugar: is static method
# arg selection: INTERFACE (STRUCT) 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom' IN
# return: INTERFACE 'Clipboard' 'TransferNone[TClipboard]' (diff., need sugar)
proc gtk_clipboard_get(selection: ptr Gdk3.TAtom): TransferNone[TClipboard] {.cdecl, dynlib: lib, importc: "gtk_clipboard_get".}
template get*(klass_parameter: typedesc[Clipboard], selection: ptr Gdk3.TAtom): Clipboard =
  wrap(gtk_clipboard_get(selection))
# template get*(klass_parameter: typedesc[Clipboard], selection: ptr Gdk3.TAtom): Clipboard =

# gtk_clipboard_get_default
# flags: {} container: Clipboard
# need sugar: is static method
# arg display: INTERFACE (OBJECT) 'Gdk3.Display' 'ptr Gdk3.TDisplay' IN (diff., need sugar)
# return: INTERFACE 'Clipboard' 'TransferNone[TClipboard]' (diff., need sugar)
proc gtk_clipboard_get_default(display: ptr Gdk3.TDisplay): TransferNone[TClipboard] {.cdecl, dynlib: lib, importc: "gtk_clipboard_get_default".}
template get_default*(klass_parameter: typedesc[Clipboard], display: Gdk3.Display): Clipboard =
  wrap(gtk_clipboard_get_default(display.getPointer))
# template get_default*(klass_parameter: typedesc[Clipboard], display: Gdk3.Display): Clipboard =

# gtk_clipboard_get_for_display
# flags: {} container: Clipboard
# need sugar: is static method
# arg display: INTERFACE (OBJECT) 'Gdk3.Display' 'ptr Gdk3.TDisplay' IN (diff., need sugar)
# arg selection: INTERFACE (STRUCT) 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom' IN
# return: INTERFACE 'Clipboard' 'TransferNone[TClipboard]' (diff., need sugar)
proc gtk_clipboard_get_for_display(display: ptr Gdk3.TDisplay, selection: ptr Gdk3.TAtom): TransferNone[TClipboard] {.cdecl, dynlib: lib, importc: "gtk_clipboard_get_for_display".}
template get_for_display*(klass_parameter: typedesc[Clipboard], display: Gdk3.Display, selection: ptr Gdk3.TAtom): Clipboard =
  wrap(gtk_clipboard_get_for_display(display.getPointer, selection))
# template get_for_display*(klass_parameter: typedesc[Clipboard], display: Gdk3.Display, selection: ptr Gdk3.TAtom): Clipboard =

# gtk_clipboard_clear
# flags: {isMethod} container: Clipboard
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_clipboard_clear(self: ptr TClipboard) {.cdecl, dynlib: lib, importc: "gtk_clipboard_clear".}
proc clear*(self: Clipboard) {.inline.} =
  gtk_clipboard_clear(self)
# proc clear*(self: Clipboard) {.inline.} =

# gtk_clipboard_get_display
# flags: {isMethod} container: Clipboard
# need sugar: is method
# return: INTERFACE 'Gdk3.Display' 'TransferNone[Gdk3.TDisplay]' (diff., need sugar)
proc gtk_clipboard_get_display(self: ptr TClipboard): TransferNone[Gdk3.TDisplay] {.cdecl, dynlib: lib, importc: "gtk_clipboard_get_display".}
proc get_display*(self: Clipboard): Gdk3.Display {.inline.} =
  wrap(gtk_clipboard_get_display(self))
# proc get_display*(self: Clipboard): Gdk3.Display {.inline.} =

# gtk_clipboard_get_owner
# flags: {isMethod} container: Clipboard
# need sugar: is method
# return: INTERFACE 'GObject2.Object' 'TransferNone[GObject2.TObject]' (diff., need sugar)
proc gtk_clipboard_get_owner(self: ptr TClipboard): TransferNone[GObject2.TObject] {.cdecl, dynlib: lib, importc: "gtk_clipboard_get_owner".}
proc get_owner*(self: Clipboard): GObject2.Object {.inline.} =
  wrap(gtk_clipboard_get_owner(self))
# proc get_owner*(self: Clipboard): GObject2.Object {.inline.} =

# gtk_clipboard_request_contents
# flags: {isMethod} container: Clipboard
# need sugar: is method
# arg target: INTERFACE (STRUCT) 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom' IN
# arg callback: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg user_data: VOID 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_clipboard_request_contents(self: ptr TClipboard, target: ptr Gdk3.TAtom, callback: pointer, user_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_clipboard_request_contents".}
proc request_contents*(self: Clipboard, target: ptr Gdk3.TAtom, callback: pointer, user_data: pointer) {.inline.} =
  gtk_clipboard_request_contents(self, target, callback, user_data)
# proc request_contents*(self: Clipboard, target: ptr Gdk3.TAtom, callback: pointer, user_data: pointer) {.inline.} =

# gtk_clipboard_request_image
# flags: {isMethod} container: Clipboard
# need sugar: is method
# arg callback: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg user_data: VOID 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_clipboard_request_image(self: ptr TClipboard, callback: pointer, user_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_clipboard_request_image".}
proc request_image*(self: Clipboard, callback: pointer, user_data: pointer) {.inline.} =
  gtk_clipboard_request_image(self, callback, user_data)
# proc request_image*(self: Clipboard, callback: pointer, user_data: pointer) {.inline.} =

# gtk_clipboard_request_rich_text
# flags: {isMethod} container: Clipboard
# need sugar: is method
# arg buffer: INTERFACE (OBJECT) 'TextBuffer' 'ptr TTextBuffer' IN (diff., need sugar)
# arg callback: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg user_data: VOID 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_clipboard_request_rich_text(self: ptr TClipboard, buffer: ptr TTextBuffer, callback: pointer, user_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_clipboard_request_rich_text".}
proc request_rich_text*(self: Clipboard, buffer: TextBuffer, callback: pointer, user_data: pointer) {.inline.} =
  gtk_clipboard_request_rich_text(self, buffer.getPointer, callback, user_data)
# proc request_rich_text*(self: Clipboard, buffer: TextBuffer, callback: pointer, user_data: pointer) {.inline.} =

# gtk_clipboard_request_targets
# flags: {isMethod} container: Clipboard
# need sugar: is method
# arg callback: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg user_data: VOID 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_clipboard_request_targets(self: ptr TClipboard, callback: pointer, user_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_clipboard_request_targets".}
proc request_targets*(self: Clipboard, callback: pointer, user_data: pointer) {.inline.} =
  gtk_clipboard_request_targets(self, callback, user_data)
# proc request_targets*(self: Clipboard, callback: pointer, user_data: pointer) {.inline.} =

# gtk_clipboard_request_text
# flags: {isMethod} container: Clipboard
# need sugar: is method
# arg callback: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg user_data: VOID 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_clipboard_request_text(self: ptr TClipboard, callback: pointer, user_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_clipboard_request_text".}
proc request_text*(self: Clipboard, callback: pointer, user_data: pointer) {.inline.} =
  gtk_clipboard_request_text(self, callback, user_data)
# proc request_text*(self: Clipboard, callback: pointer, user_data: pointer) {.inline.} =

# gtk_clipboard_request_uris
# flags: {isMethod} container: Clipboard
# need sugar: is method
# arg callback: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg user_data: VOID 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_clipboard_request_uris(self: ptr TClipboard, callback: pointer, user_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_clipboard_request_uris".}
proc request_uris*(self: Clipboard, callback: pointer, user_data: pointer) {.inline.} =
  gtk_clipboard_request_uris(self, callback, user_data)
# proc request_uris*(self: Clipboard, callback: pointer, user_data: pointer) {.inline.} =

# gtk_clipboard_set_can_store
# flags: {isMethod} container: Clipboard
# need sugar: is method
# arg targets: ARRAY 'var openarray[TTargetEntry]' 'openarray[TTargetEntry]' IN (diff., need sugar) array lengthArg: 1
# arg n_targets: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_clipboard_set_can_store(self: ptr TClipboard, targets: openarray[TTargetEntry], n_targets: int32) {.cdecl, dynlib: lib, importc: "gtk_clipboard_set_can_store".}
proc set_can_store*(self: Clipboard, targets: var openarray[TTargetEntry]) {.inline.} =
  gtk_clipboard_set_can_store(self, targets, targets.len.int32)
# proc set_can_store*(self: Clipboard, targets: var openarray[TTargetEntry]) {.inline.} =

# gtk_clipboard_set_image
# flags: {isMethod} container: Clipboard
# need sugar: is method
# arg pixbuf: INTERFACE (OBJECT) 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_clipboard_set_image(self: ptr TClipboard, pixbuf: ptr GdkPixbuf2.TPixbuf) {.cdecl, dynlib: lib, importc: "gtk_clipboard_set_image".}
proc set_image*(self: Clipboard, pixbuf: GdkPixbuf2.Pixbuf) {.inline.} =
  gtk_clipboard_set_image(self, pixbuf.getPointer)
# proc set_image*(self: Clipboard, pixbuf: GdkPixbuf2.Pixbuf) {.inline.} =

# gtk_clipboard_set_text
# flags: {isMethod} container: Clipboard
# need sugar: is method
# arg text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg len: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_clipboard_set_text(self: ptr TClipboard, text: ucstring, len: int32) {.cdecl, dynlib: lib, importc: "gtk_clipboard_set_text".}
proc set_text*(self: Clipboard, text: ustring, len: int32) {.inline.} =
  gtk_clipboard_set_text(self, ucstring(text), len)
# proc set_text*(self: Clipboard, text: ustring, len: int32) {.inline.} =

# gtk_clipboard_store
# flags: {isMethod} container: Clipboard
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_clipboard_store(self: ptr TClipboard) {.cdecl, dynlib: lib, importc: "gtk_clipboard_store".}
proc store*(self: Clipboard) {.inline.} =
  gtk_clipboard_store(self)
# proc store*(self: Clipboard) {.inline.} =

# gtk_clipboard_wait_for_contents
# flags: {isMethod} container: Clipboard
# need sugar: is method
# arg target: INTERFACE (STRUCT) 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom' IN
# return: INTERFACE 'ptr TSelectionData' 'ptr TSelectionData'
proc gtk_clipboard_wait_for_contents(self: ptr TClipboard, target: ptr Gdk3.TAtom): ptr TSelectionData {.cdecl, dynlib: lib, importc: "gtk_clipboard_wait_for_contents".}
proc wait_for_contents*(self: Clipboard, target: ptr Gdk3.TAtom): ptr TSelectionData {.inline.} =
  gtk_clipboard_wait_for_contents(self, target)
# proc wait_for_contents*(self: Clipboard, target: ptr Gdk3.TAtom): ptr TSelectionData {.inline.} =

# gtk_clipboard_wait_for_image
# flags: {isMethod} container: Clipboard
# need sugar: is method
# return: INTERFACE 'GdkPixbuf2.Pixbuf' 'TransferFull[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_clipboard_wait_for_image(self: ptr TClipboard): TransferFull[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_clipboard_wait_for_image".}
proc wait_for_image*(self: Clipboard): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_clipboard_wait_for_image(self))
# proc wait_for_image*(self: Clipboard): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_clipboard_wait_for_rich_text
# flags: {isMethod} container: Clipboard
# need sugar: is method
# arg buffer: INTERFACE (OBJECT) 'TextBuffer' 'ptr TTextBuffer' IN (diff., need sugar)
# arg format: INTERFACE (STRUCT) 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom' OUT caller-allocates
# arg length: UINT32 'var uint32' 'ptr uint32' OUT (diff., need sugar)
# return: ARRAY 'string' 'cstring' (diff., need sugar)
proc gtk_clipboard_wait_for_rich_text(self: ptr TClipboard, buffer: ptr TTextBuffer, format: ptr Gdk3.TAtom, length: ptr uint32): cstring {.cdecl, dynlib: lib, importc: "gtk_clipboard_wait_for_rich_text".}
proc wait_for_rich_text*(self: Clipboard, buffer: TextBuffer, format: ptr Gdk3.TAtom, length: var uint32): string {.inline.} =
  $(gtk_clipboard_wait_for_rich_text(self, buffer.getPointer, format, addr(length)))
# tuple-return
# format: ptr Gdk3.TAtom
# length: var uint32
# proc wait_for_rich_text*(self: Clipboard, buffer: TextBuffer): string {.inline.} =

# gtk_clipboard_wait_for_targets
# flags: {isMethod} container: Clipboard
# need sugar: is method
# arg targets: ARRAY 'var openarray[ptr Gdk3.TAtom]' 'openarray[ptr Gdk3.TAtom]' OUT (diff., need sugar) array lengthArg: 1
# arg n_targets: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_clipboard_wait_for_targets(self: ptr TClipboard, targets: openarray[ptr Gdk3.TAtom], n_targets: ptr int32): bool {.cdecl, dynlib: lib, importc: "gtk_clipboard_wait_for_targets".}
proc wait_for_targets*(self: Clipboard, targets: var openarray[ptr Gdk3.TAtom], n_targets: var int32): bool {.inline.} =
  gtk_clipboard_wait_for_targets(self, targets, addr(n_targets))
# tuple-return
# targets: var openarray[ptr Gdk3.TAtom]
# n_targets: var int32
# proc wait_for_targets*(self: Clipboard): bool {.inline.} =

# gtk_clipboard_wait_for_text
# flags: {isMethod} container: Clipboard
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_clipboard_wait_for_text(self: ptr TClipboard): ucstring {.cdecl, dynlib: lib, importc: "gtk_clipboard_wait_for_text".}
proc wait_for_text*(self: Clipboard): ucstring {.inline.} =
  gtk_clipboard_wait_for_text(self)
# proc wait_for_text*(self: Clipboard): ucstring {.inline.} =

# gtk_clipboard_wait_for_uris
# flags: {isMethod} container: Clipboard
# need sugar: is method
# return: ARRAY 'zeroTerminatedArray[ucstring]' 'zeroTerminatedArray[ucstring]'
proc gtk_clipboard_wait_for_uris(self: ptr TClipboard): zeroTerminatedArray[ucstring] {.cdecl, dynlib: lib, importc: "gtk_clipboard_wait_for_uris".}
proc wait_for_uris*(self: Clipboard): zeroTerminatedArray[ucstring] {.inline.} =
  gtk_clipboard_wait_for_uris(self)
# proc wait_for_uris*(self: Clipboard): zeroTerminatedArray[ucstring] {.inline.} =

# gtk_clipboard_wait_is_image_available
# flags: {isMethod} container: Clipboard
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_clipboard_wait_is_image_available(self: ptr TClipboard): bool {.cdecl, dynlib: lib, importc: "gtk_clipboard_wait_is_image_available".}
proc wait_is_image_available*(self: Clipboard): bool {.inline.} =
  gtk_clipboard_wait_is_image_available(self)
# proc wait_is_image_available*(self: Clipboard): bool {.inline.} =

# gtk_clipboard_wait_is_rich_text_available
# flags: {isMethod} container: Clipboard
# need sugar: is method
# arg buffer: INTERFACE (OBJECT) 'TextBuffer' 'ptr TTextBuffer' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_clipboard_wait_is_rich_text_available(self: ptr TClipboard, buffer: ptr TTextBuffer): bool {.cdecl, dynlib: lib, importc: "gtk_clipboard_wait_is_rich_text_available".}
proc wait_is_rich_text_available*(self: Clipboard, buffer: TextBuffer): bool {.inline.} =
  gtk_clipboard_wait_is_rich_text_available(self, buffer.getPointer)
# proc wait_is_rich_text_available*(self: Clipboard, buffer: TextBuffer): bool {.inline.} =

# gtk_clipboard_wait_is_target_available
# flags: {isMethod} container: Clipboard
# need sugar: is method
# arg target: INTERFACE (STRUCT) 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_clipboard_wait_is_target_available(self: ptr TClipboard, target: ptr Gdk3.TAtom): bool {.cdecl, dynlib: lib, importc: "gtk_clipboard_wait_is_target_available".}
proc wait_is_target_available*(self: Clipboard, target: ptr Gdk3.TAtom): bool {.inline.} =
  gtk_clipboard_wait_is_target_available(self, target)
# proc wait_is_target_available*(self: Clipboard, target: ptr Gdk3.TAtom): bool {.inline.} =

# gtk_clipboard_wait_is_text_available
# flags: {isMethod} container: Clipboard
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_clipboard_wait_is_text_available(self: ptr TClipboard): bool {.cdecl, dynlib: lib, importc: "gtk_clipboard_wait_is_text_available".}
proc wait_is_text_available*(self: Clipboard): bool {.inline.} =
  gtk_clipboard_wait_is_text_available(self)
# proc wait_is_text_available*(self: Clipboard): bool {.inline.} =

# gtk_clipboard_wait_is_uris_available
# flags: {isMethod} container: Clipboard
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_clipboard_wait_is_uris_available(self: ptr TClipboard): bool {.cdecl, dynlib: lib, importc: "gtk_clipboard_wait_is_uris_available".}
proc wait_is_uris_available*(self: Clipboard): bool {.inline.} =
  gtk_clipboard_wait_is_uris_available(self)
# proc wait_is_uris_available*(self: Clipboard): bool {.inline.} =

# initializer for ColorButton: gtk_color_button_get_type
proc gtk_color_button_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_color_button_get_type".}
template gtype*(klass_parameter: typedesc[ColorButton]): GType = gtk_color_button_get_type()
# gtk_color_button_new
# flags: {isConstructor} container: ColorButton
# need sugar: is static method
# return: INTERFACE 'ColorButton' 'TransferNone[TColorButton]' (diff., need sugar)
proc gtk_color_button_new(): TransferNone[TColorButton] {.cdecl, dynlib: lib, importc: "gtk_color_button_new".}
proc new_colorbutton*(): ColorButton {.inline.} =
  wrap(gtk_color_button_new())
# proc new_colorbutton*(): ColorButton {.inline.} =

# gtk_color_button_new_with_color
# flags: {isConstructor} container: ColorButton (deprecated)
# gtk_color_button_new_with_rgba
# flags: {isConstructor} container: ColorButton
# need sugar: is static method
# arg rgba: INTERFACE (STRUCT) 'ptr Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN
# return: INTERFACE 'ColorButton' 'TransferNone[TColorButton]' (diff., need sugar)
proc gtk_color_button_new_with_rgba(rgba: ptr Gdk3.TRGBA): TransferNone[TColorButton] {.cdecl, dynlib: lib, importc: "gtk_color_button_new_with_rgba".}
proc new_colorbutton_with_rgba*(rgba: ptr Gdk3.TRGBA): ColorButton {.inline.} =
  wrap(gtk_color_button_new_with_rgba(rgba))
# proc new_colorbutton_with_rgba*(rgba: ptr Gdk3.TRGBA): ColorButton {.inline.} =

# gtk_color_button_get_alpha
# flags: {isMethod} container: ColorButton (deprecated)
# gtk_color_button_get_color
# flags: {isMethod} container: ColorButton (deprecated)
# gtk_color_button_get_title
# flags: {isMethod} container: ColorButton
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_color_button_get_title(self: ptr TColorButton): ucstring {.cdecl, dynlib: lib, importc: "gtk_color_button_get_title".}
proc get_title*(self: ColorButton): ucstring {.inline.} =
  gtk_color_button_get_title(self)
# proc get_title*(self: ColorButton): ucstring {.inline.} =

# gtk_color_button_get_use_alpha
# flags: {isMethod} container: ColorButton (deprecated)
# gtk_color_button_set_alpha
# flags: {isMethod} container: ColorButton (deprecated)
# gtk_color_button_set_color
# flags: {isMethod} container: ColorButton (deprecated)
# gtk_color_button_set_title
# flags: {isMethod} container: ColorButton
# need sugar: is method
# arg title: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_color_button_set_title(self: ptr TColorButton, title: ucstring) {.cdecl, dynlib: lib, importc: "gtk_color_button_set_title".}
proc set_title*(self: ColorButton, title: ustring) {.inline.} =
  gtk_color_button_set_title(self, ucstring(title))
# proc set_title*(self: ColorButton, title: ustring) {.inline.} =

# gtk_color_button_set_use_alpha
# flags: {isMethod} container: ColorButton (deprecated)
# initializer for ColorChooserDialog: gtk_color_chooser_dialog_get_type
proc gtk_color_chooser_dialog_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_color_chooser_dialog_get_type".}
template gtype*(klass_parameter: typedesc[ColorChooserDialog]): GType = gtk_color_chooser_dialog_get_type()
# gtk_color_chooser_dialog_new
# flags: {isConstructor} container: ColorChooserDialog
# need sugar: is static method
# arg title: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg parent: INTERFACE (OBJECT) 'Window' 'ptr TWindow' IN (diff., need sugar)
# return: INTERFACE 'ColorChooserDialog' 'TransferNone[TColorChooserDialog]' (diff., need sugar)
proc gtk_color_chooser_dialog_new(title: ucstring, parent: ptr TWindow): TransferNone[TColorChooserDialog] {.cdecl, dynlib: lib, importc: "gtk_color_chooser_dialog_new".}
proc new_colorchooserdialog*(title: ustring, parent: Window): ColorChooserDialog {.inline.} =
  wrap(gtk_color_chooser_dialog_new(ucstring(title), parent.getPointer))
# proc new_colorchooserdialog*(title: ustring, parent: Window): ColorChooserDialog {.inline.} =

# initializer for ColorChooserWidget: gtk_color_chooser_widget_get_type
proc gtk_color_chooser_widget_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_color_chooser_widget_get_type".}
template gtype*(klass_parameter: typedesc[ColorChooserWidget]): GType = gtk_color_chooser_widget_get_type()
# gtk_color_chooser_widget_new
# flags: {isConstructor} container: ColorChooserWidget
# need sugar: is static method
# return: INTERFACE 'ColorChooserWidget' 'TransferNone[TColorChooserWidget]' (diff., need sugar)
proc gtk_color_chooser_widget_new(): TransferNone[TColorChooserWidget] {.cdecl, dynlib: lib, importc: "gtk_color_chooser_widget_new".}
proc new_colorchooserwidget*(): ColorChooserWidget {.inline.} =
  wrap(gtk_color_chooser_widget_new())
# proc new_colorchooserwidget*(): ColorChooserWidget {.inline.} =

# initializer for ColorSelection: gtk_color_selection_get_type
proc gtk_color_selection_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_color_selection_get_type".}
template gtype*(klass_parameter: typedesc[ColorSelection]): GType = gtk_color_selection_get_type()
# gtk_color_selection_new
# flags: {isConstructor} container: ColorSelection
# need sugar: is static method
# return: INTERFACE 'ColorSelection' 'TransferNone[TColorSelection]' (diff., need sugar)
proc gtk_color_selection_new(): TransferNone[TColorSelection] {.cdecl, dynlib: lib, importc: "gtk_color_selection_new".}
proc new_colorselection*(): ColorSelection {.inline.} =
  wrap(gtk_color_selection_new())
# proc new_colorselection*(): ColorSelection {.inline.} =

# gtk_color_selection_palette_from_string
# flags: {} container: ColorSelection
# need sugar: is static method
# arg str: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg colors: ARRAY 'var openarray[Gdk3.TColor]' 'openarray[Gdk3.TColor]' OUT (diff., need sugar) array lengthArg: 2
# arg n_colors: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_color_selection_palette_from_string(str: ucstring, colors: openarray[Gdk3.TColor], n_colors: ptr int32): bool {.cdecl, dynlib: lib, importc: "gtk_color_selection_palette_from_string".}
template palette_from_string*(klass_parameter: typedesc[ColorSelection], str: ustring, colors: var openarray[Gdk3.TColor], n_colors: var int32): bool =
  gtk_color_selection_palette_from_string(ucstring(str), colors, addr(n_colors))
# tuple-return
# colors: var openarray[Gdk3.TColor]
# n_colors: var int32
# template palette_from_string*(klass_parameter: typedesc[ColorSelection], str: ustring): bool =

# gtk_color_selection_palette_to_string
# flags: {} container: ColorSelection
# need sugar: is static method
# arg colors: ARRAY 'var openarray[Gdk3.TColor]' 'openarray[Gdk3.TColor]' IN (diff., need sugar) array lengthArg: 1
# arg n_colors: INT32 'int32' 'int32' IN
# return: UTF8 'ucstring' 'ucstring'
proc gtk_color_selection_palette_to_string(colors: openarray[Gdk3.TColor], n_colors: int32): ucstring {.cdecl, dynlib: lib, importc: "gtk_color_selection_palette_to_string".}
template palette_to_string*(klass_parameter: typedesc[ColorSelection], colors: var openarray[Gdk3.TColor]): ucstring =
  gtk_color_selection_palette_to_string(colors, colors.len.int32)
# template palette_to_string*(klass_parameter: typedesc[ColorSelection], colors: var openarray[Gdk3.TColor]): ucstring =

# gtk_color_selection_get_current_alpha
# flags: {isMethod} container: ColorSelection
# need sugar: is method
# return: UINT16 'uint16' 'uint16'
proc gtk_color_selection_get_current_alpha(self: ptr TColorSelection): uint16 {.cdecl, dynlib: lib, importc: "gtk_color_selection_get_current_alpha".}
proc get_current_alpha*(self: ColorSelection): uint16 {.inline.} =
  gtk_color_selection_get_current_alpha(self)
# proc get_current_alpha*(self: ColorSelection): uint16 {.inline.} =

# gtk_color_selection_get_current_color
# flags: {isMethod} container: ColorSelection (deprecated)
# gtk_color_selection_get_current_rgba
# flags: {isMethod} container: ColorSelection
# need sugar: is method
# arg rgba: INTERFACE (STRUCT) 'ptr Gdk3.TRGBA' 'ptr Gdk3.TRGBA' OUT caller-allocates
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_color_selection_get_current_rgba(self: ptr TColorSelection, rgba: ptr Gdk3.TRGBA) {.cdecl, dynlib: lib, importc: "gtk_color_selection_get_current_rgba".}
proc get_current_rgba*(self: ColorSelection, rgba: ptr Gdk3.TRGBA) {.inline.} =
  gtk_color_selection_get_current_rgba(self, rgba)
# tuple-return
# rgba: ptr Gdk3.TRGBA
# proc get_current_rgba*(self: ColorSelection) {.inline.} =

# gtk_color_selection_get_has_opacity_control
# flags: {isMethod} container: ColorSelection
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_color_selection_get_has_opacity_control(self: ptr TColorSelection): bool {.cdecl, dynlib: lib, importc: "gtk_color_selection_get_has_opacity_control".}
proc get_has_opacity_control*(self: ColorSelection): bool {.inline.} =
  gtk_color_selection_get_has_opacity_control(self)
# proc get_has_opacity_control*(self: ColorSelection): bool {.inline.} =

# gtk_color_selection_get_has_palette
# flags: {isMethod} container: ColorSelection
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_color_selection_get_has_palette(self: ptr TColorSelection): bool {.cdecl, dynlib: lib, importc: "gtk_color_selection_get_has_palette".}
proc get_has_palette*(self: ColorSelection): bool {.inline.} =
  gtk_color_selection_get_has_palette(self)
# proc get_has_palette*(self: ColorSelection): bool {.inline.} =

# gtk_color_selection_get_previous_alpha
# flags: {isMethod} container: ColorSelection
# need sugar: is method
# return: UINT16 'uint16' 'uint16'
proc gtk_color_selection_get_previous_alpha(self: ptr TColorSelection): uint16 {.cdecl, dynlib: lib, importc: "gtk_color_selection_get_previous_alpha".}
proc get_previous_alpha*(self: ColorSelection): uint16 {.inline.} =
  gtk_color_selection_get_previous_alpha(self)
# proc get_previous_alpha*(self: ColorSelection): uint16 {.inline.} =

# gtk_color_selection_get_previous_color
# flags: {isMethod} container: ColorSelection (deprecated)
# gtk_color_selection_get_previous_rgba
# flags: {isMethod} container: ColorSelection
# need sugar: is method
# arg rgba: INTERFACE (STRUCT) 'ptr Gdk3.TRGBA' 'ptr Gdk3.TRGBA' OUT caller-allocates
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_color_selection_get_previous_rgba(self: ptr TColorSelection, rgba: ptr Gdk3.TRGBA) {.cdecl, dynlib: lib, importc: "gtk_color_selection_get_previous_rgba".}
proc get_previous_rgba*(self: ColorSelection, rgba: ptr Gdk3.TRGBA) {.inline.} =
  gtk_color_selection_get_previous_rgba(self, rgba)
# tuple-return
# rgba: ptr Gdk3.TRGBA
# proc get_previous_rgba*(self: ColorSelection) {.inline.} =

# gtk_color_selection_is_adjusting
# flags: {isMethod} container: ColorSelection
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_color_selection_is_adjusting(self: ptr TColorSelection): bool {.cdecl, dynlib: lib, importc: "gtk_color_selection_is_adjusting".}
proc is_adjusting*(self: ColorSelection): bool {.inline.} =
  gtk_color_selection_is_adjusting(self)
# proc is_adjusting*(self: ColorSelection): bool {.inline.} =

# gtk_color_selection_set_current_alpha
# flags: {isMethod} container: ColorSelection
# need sugar: is method
# arg alpha: UINT16 'uint16' 'uint16' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_color_selection_set_current_alpha(self: ptr TColorSelection, alpha: uint16) {.cdecl, dynlib: lib, importc: "gtk_color_selection_set_current_alpha".}
proc set_current_alpha*(self: ColorSelection, alpha: uint16) {.inline.} =
  gtk_color_selection_set_current_alpha(self, alpha)
# proc set_current_alpha*(self: ColorSelection, alpha: uint16) {.inline.} =

# gtk_color_selection_set_current_color
# flags: {isMethod} container: ColorSelection (deprecated)
# gtk_color_selection_set_current_rgba
# flags: {isMethod} container: ColorSelection
# need sugar: is method
# arg rgba: INTERFACE (STRUCT) 'ptr Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_color_selection_set_current_rgba(self: ptr TColorSelection, rgba: ptr Gdk3.TRGBA) {.cdecl, dynlib: lib, importc: "gtk_color_selection_set_current_rgba".}
proc set_current_rgba*(self: ColorSelection, rgba: ptr Gdk3.TRGBA) {.inline.} =
  gtk_color_selection_set_current_rgba(self, rgba)
# proc set_current_rgba*(self: ColorSelection, rgba: ptr Gdk3.TRGBA) {.inline.} =

# gtk_color_selection_set_has_opacity_control
# flags: {isMethod} container: ColorSelection
# need sugar: is method
# arg has_opacity: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_color_selection_set_has_opacity_control(self: ptr TColorSelection, has_opacity: bool) {.cdecl, dynlib: lib, importc: "gtk_color_selection_set_has_opacity_control".}
proc set_has_opacity_control*(self: ColorSelection, has_opacity: bool) {.inline.} =
  gtk_color_selection_set_has_opacity_control(self, has_opacity)
# proc set_has_opacity_control*(self: ColorSelection, has_opacity: bool) {.inline.} =

# gtk_color_selection_set_has_palette
# flags: {isMethod} container: ColorSelection
# need sugar: is method
# arg has_palette: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_color_selection_set_has_palette(self: ptr TColorSelection, has_palette: bool) {.cdecl, dynlib: lib, importc: "gtk_color_selection_set_has_palette".}
proc set_has_palette*(self: ColorSelection, has_palette: bool) {.inline.} =
  gtk_color_selection_set_has_palette(self, has_palette)
# proc set_has_palette*(self: ColorSelection, has_palette: bool) {.inline.} =

# gtk_color_selection_set_previous_alpha
# flags: {isMethod} container: ColorSelection
# need sugar: is method
# arg alpha: UINT16 'uint16' 'uint16' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_color_selection_set_previous_alpha(self: ptr TColorSelection, alpha: uint16) {.cdecl, dynlib: lib, importc: "gtk_color_selection_set_previous_alpha".}
proc set_previous_alpha*(self: ColorSelection, alpha: uint16) {.inline.} =
  gtk_color_selection_set_previous_alpha(self, alpha)
# proc set_previous_alpha*(self: ColorSelection, alpha: uint16) {.inline.} =

# gtk_color_selection_set_previous_color
# flags: {isMethod} container: ColorSelection (deprecated)
# gtk_color_selection_set_previous_rgba
# flags: {isMethod} container: ColorSelection
# need sugar: is method
# arg rgba: INTERFACE (STRUCT) 'ptr Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_color_selection_set_previous_rgba(self: ptr TColorSelection, rgba: ptr Gdk3.TRGBA) {.cdecl, dynlib: lib, importc: "gtk_color_selection_set_previous_rgba".}
proc set_previous_rgba*(self: ColorSelection, rgba: ptr Gdk3.TRGBA) {.inline.} =
  gtk_color_selection_set_previous_rgba(self, rgba)
# proc set_previous_rgba*(self: ColorSelection, rgba: ptr Gdk3.TRGBA) {.inline.} =

# initializer for ColorSelectionDialog: gtk_color_selection_dialog_get_type
proc gtk_color_selection_dialog_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_color_selection_dialog_get_type".}
template gtype*(klass_parameter: typedesc[ColorSelectionDialog]): GType = gtk_color_selection_dialog_get_type()
# gtk_color_selection_dialog_new
# flags: {isConstructor} container: ColorSelectionDialog
# need sugar: is static method
# arg title: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'ColorSelectionDialog' 'TransferNone[TColorSelectionDialog]' (diff., need sugar)
proc gtk_color_selection_dialog_new(title: ucstring): TransferNone[TColorSelectionDialog] {.cdecl, dynlib: lib, importc: "gtk_color_selection_dialog_new".}
proc new_colorselectiondialog*(title: ustring): ColorSelectionDialog {.inline.} =
  wrap(gtk_color_selection_dialog_new(ucstring(title)))
# proc new_colorselectiondialog*(title: ustring): ColorSelectionDialog {.inline.} =

# gtk_color_selection_dialog_get_color_selection
# flags: {isMethod} container: ColorSelectionDialog
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_color_selection_dialog_get_color_selection(self: ptr TColorSelectionDialog): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_color_selection_dialog_get_color_selection".}
proc get_color_selection*(self: ColorSelectionDialog): Widget {.inline.} =
  wrap(gtk_color_selection_dialog_get_color_selection(self))
# proc get_color_selection*(self: ColorSelectionDialog): Widget {.inline.} =

# initializer for ComboBox: gtk_combo_box_get_type
proc gtk_combo_box_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_type".}
template gtype*(klass_parameter: typedesc[ComboBox]): GType = gtk_combo_box_get_type()
# gtk_combo_box_new
# flags: {isConstructor} container: ComboBox
# need sugar: is static method
# return: INTERFACE 'ComboBox' 'TransferNone[TComboBox]' (diff., need sugar)
proc gtk_combo_box_new(): TransferNone[TComboBox] {.cdecl, dynlib: lib, importc: "gtk_combo_box_new".}
proc new_combobox*(): ComboBox {.inline.} =
  wrap(gtk_combo_box_new())
# proc new_combobox*(): ComboBox {.inline.} =

# gtk_combo_box_new_with_area
# flags: {isConstructor} container: ComboBox
# need sugar: is static method
# arg area: INTERFACE (OBJECT) 'CellArea' 'ptr TCellArea' IN (diff., need sugar)
# return: INTERFACE 'ComboBox' 'TransferNone[TComboBox]' (diff., need sugar)
proc gtk_combo_box_new_with_area(area: ptr TCellArea): TransferNone[TComboBox] {.cdecl, dynlib: lib, importc: "gtk_combo_box_new_with_area".}
proc new_combobox_with_area*(area: CellArea): ComboBox {.inline.} =
  wrap(gtk_combo_box_new_with_area(area.getPointer))
# proc new_combobox_with_area*(area: CellArea): ComboBox {.inline.} =

# gtk_combo_box_new_with_area_and_entry
# flags: {isConstructor} container: ComboBox
# need sugar: is static method
# arg area: INTERFACE (OBJECT) 'CellArea' 'ptr TCellArea' IN (diff., need sugar)
# return: INTERFACE 'ComboBox' 'TransferNone[TComboBox]' (diff., need sugar)
proc gtk_combo_box_new_with_area_and_entry(area: ptr TCellArea): TransferNone[TComboBox] {.cdecl, dynlib: lib, importc: "gtk_combo_box_new_with_area_and_entry".}
proc new_combobox_with_area_and_entry*(area: CellArea): ComboBox {.inline.} =
  wrap(gtk_combo_box_new_with_area_and_entry(area.getPointer))
# proc new_combobox_with_area_and_entry*(area: CellArea): ComboBox {.inline.} =

# gtk_combo_box_new_with_entry
# flags: {isConstructor} container: ComboBox
# need sugar: is static method
# return: INTERFACE 'ComboBox' 'TransferNone[TComboBox]' (diff., need sugar)
proc gtk_combo_box_new_with_entry(): TransferNone[TComboBox] {.cdecl, dynlib: lib, importc: "gtk_combo_box_new_with_entry".}
proc new_combobox_with_entry*(): ComboBox {.inline.} =
  wrap(gtk_combo_box_new_with_entry())
# proc new_combobox_with_entry*(): ComboBox {.inline.} =

# gtk_combo_box_new_with_model
# flags: {isConstructor} container: ComboBox
# need sugar: is static method
# arg model: INTERFACE (INTERFACE) 'ptr TTreeModel' 'ptr TTreeModel' IN
# return: INTERFACE 'ComboBox' 'TransferNone[TComboBox]' (diff., need sugar)
proc gtk_combo_box_new_with_model(model: ptr TTreeModel): TransferNone[TComboBox] {.cdecl, dynlib: lib, importc: "gtk_combo_box_new_with_model".}
proc new_combobox_with_model*(model: ptr TTreeModel): ComboBox {.inline.} =
  wrap(gtk_combo_box_new_with_model(model))
# proc new_combobox_with_model*(model: ptr TTreeModel): ComboBox {.inline.} =

# gtk_combo_box_new_with_model_and_entry
# flags: {isConstructor} container: ComboBox
# need sugar: is static method
# arg model: INTERFACE (INTERFACE) 'ptr TTreeModel' 'ptr TTreeModel' IN
# return: INTERFACE 'ComboBox' 'TransferNone[TComboBox]' (diff., need sugar)
proc gtk_combo_box_new_with_model_and_entry(model: ptr TTreeModel): TransferNone[TComboBox] {.cdecl, dynlib: lib, importc: "gtk_combo_box_new_with_model_and_entry".}
proc new_combobox_with_model_and_entry*(model: ptr TTreeModel): ComboBox {.inline.} =
  wrap(gtk_combo_box_new_with_model_and_entry(model))
# proc new_combobox_with_model_and_entry*(model: ptr TTreeModel): ComboBox {.inline.} =

# gtk_combo_box_get_active
# flags: {isMethod} container: ComboBox
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_combo_box_get_active(self: ptr TComboBox): int32 {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_active".}
proc get_active*(self: ComboBox): int32 {.inline.} =
  gtk_combo_box_get_active(self)
# proc get_active*(self: ComboBox): int32 {.inline.} =

# gtk_combo_box_get_active_id
# flags: {isMethod} container: ComboBox
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_combo_box_get_active_id(self: ptr TComboBox): ucstring {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_active_id".}
proc get_active_id*(self: ComboBox): ucstring {.inline.} =
  gtk_combo_box_get_active_id(self)
# proc get_active_id*(self: ComboBox): ucstring {.inline.} =

# gtk_combo_box_get_active_iter
# flags: {isMethod} container: ComboBox
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' OUT caller-allocates
# return: BOOLEAN 'bool' 'bool'
proc gtk_combo_box_get_active_iter(self: ptr TComboBox, iter: ptr TTreeIter): bool {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_active_iter".}
proc get_active_iter*(self: ComboBox, iter: ptr TTreeIter): bool {.inline.} =
  gtk_combo_box_get_active_iter(self, iter)
# tuple-return
# iter: ptr TTreeIter
# proc get_active_iter*(self: ComboBox): bool {.inline.} =

# gtk_combo_box_get_add_tearoffs
# flags: {isMethod} container: ComboBox (deprecated)
# gtk_combo_box_get_button_sensitivity
# flags: {isMethod} container: ComboBox
# need sugar: is method
# return: INTERFACE 'SensitivityType' 'SensitivityType'
proc gtk_combo_box_get_button_sensitivity(self: ptr TComboBox): SensitivityType {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_button_sensitivity".}
proc get_button_sensitivity*(self: ComboBox): SensitivityType {.inline.} =
  gtk_combo_box_get_button_sensitivity(self)
# proc get_button_sensitivity*(self: ComboBox): SensitivityType {.inline.} =

# gtk_combo_box_get_column_span_column
# flags: {isMethod} container: ComboBox
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_combo_box_get_column_span_column(self: ptr TComboBox): int32 {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_column_span_column".}
proc get_column_span_column*(self: ComboBox): int32 {.inline.} =
  gtk_combo_box_get_column_span_column(self)
# proc get_column_span_column*(self: ComboBox): int32 {.inline.} =

# gtk_combo_box_get_entry_text_column
# flags: {isMethod} container: ComboBox
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_combo_box_get_entry_text_column(self: ptr TComboBox): int32 {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_entry_text_column".}
proc get_entry_text_column*(self: ComboBox): int32 {.inline.} =
  gtk_combo_box_get_entry_text_column(self)
# proc get_entry_text_column*(self: ComboBox): int32 {.inline.} =

# gtk_combo_box_get_focus_on_click
# flags: {isMethod} container: ComboBox
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_combo_box_get_focus_on_click(self: ptr TComboBox): bool {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_focus_on_click".}
proc get_focus_on_click*(self: ComboBox): bool {.inline.} =
  gtk_combo_box_get_focus_on_click(self)
# proc get_focus_on_click*(self: ComboBox): bool {.inline.} =

# gtk_combo_box_get_has_entry
# flags: {isMethod} container: ComboBox
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_combo_box_get_has_entry(self: ptr TComboBox): bool {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_has_entry".}
proc get_has_entry*(self: ComboBox): bool {.inline.} =
  gtk_combo_box_get_has_entry(self)
# proc get_has_entry*(self: ComboBox): bool {.inline.} =

# gtk_combo_box_get_id_column
# flags: {isMethod} container: ComboBox
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_combo_box_get_id_column(self: ptr TComboBox): int32 {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_id_column".}
proc get_id_column*(self: ComboBox): int32 {.inline.} =
  gtk_combo_box_get_id_column(self)
# proc get_id_column*(self: ComboBox): int32 {.inline.} =

# gtk_combo_box_get_model
# flags: {isMethod} container: ComboBox
# need sugar: is method
# return: INTERFACE 'ptr TTreeModel' 'TransferNone[TTreeModel]' (diff., need sugar)
proc gtk_combo_box_get_model(self: ptr TComboBox): TransferNone[TTreeModel] {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_model".}
proc get_model*(self: ComboBox): ptr TTreeModel {.inline.} =
  wrap(gtk_combo_box_get_model(self))
# proc get_model*(self: ComboBox): ptr TTreeModel {.inline.} =

# gtk_combo_box_get_popup_accessible
# flags: {isMethod} container: ComboBox
# need sugar: is method
# return: INTERFACE 'Atk1.Object' 'TransferNone[Atk1.TObject]' (diff., need sugar)
proc gtk_combo_box_get_popup_accessible(self: ptr TComboBox): TransferNone[Atk1.TObject] {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_popup_accessible".}
proc get_popup_accessible*(self: ComboBox): Atk1.Object {.inline.} =
  wrap(gtk_combo_box_get_popup_accessible(self))
# proc get_popup_accessible*(self: ComboBox): Atk1.Object {.inline.} =

# gtk_combo_box_get_popup_fixed_width
# flags: {isMethod} container: ComboBox
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_combo_box_get_popup_fixed_width(self: ptr TComboBox): bool {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_popup_fixed_width".}
proc get_popup_fixed_width*(self: ComboBox): bool {.inline.} =
  gtk_combo_box_get_popup_fixed_width(self)
# proc get_popup_fixed_width*(self: ComboBox): bool {.inline.} =

# gtk_combo_box_get_row_span_column
# flags: {isMethod} container: ComboBox
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_combo_box_get_row_span_column(self: ptr TComboBox): int32 {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_row_span_column".}
proc get_row_span_column*(self: ComboBox): int32 {.inline.} =
  gtk_combo_box_get_row_span_column(self)
# proc get_row_span_column*(self: ComboBox): int32 {.inline.} =

# gtk_combo_box_get_title
# flags: {isMethod} container: ComboBox (deprecated)
# gtk_combo_box_get_wrap_width
# flags: {isMethod} container: ComboBox
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_combo_box_get_wrap_width(self: ptr TComboBox): int32 {.cdecl, dynlib: lib, importc: "gtk_combo_box_get_wrap_width".}
proc get_wrap_width*(self: ComboBox): int32 {.inline.} =
  gtk_combo_box_get_wrap_width(self)
# proc get_wrap_width*(self: ComboBox): int32 {.inline.} =

# gtk_combo_box_popdown
# flags: {isMethod} container: ComboBox
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_popdown(self: ptr TComboBox) {.cdecl, dynlib: lib, importc: "gtk_combo_box_popdown".}
proc popdown*(self: ComboBox) {.inline.} =
  gtk_combo_box_popdown(self)
# proc popdown*(self: ComboBox) {.inline.} =

# gtk_combo_box_popup
# flags: {isMethod} container: ComboBox
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_popup(self: ptr TComboBox) {.cdecl, dynlib: lib, importc: "gtk_combo_box_popup".}
proc popup*(self: ComboBox) {.inline.} =
  gtk_combo_box_popup(self)
# proc popup*(self: ComboBox) {.inline.} =

# gtk_combo_box_popup_for_device
# flags: {isMethod} container: ComboBox
# need sugar: is method
# arg device: INTERFACE (OBJECT) 'Gdk3.Device' 'ptr Gdk3.TDevice' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_popup_for_device(self: ptr TComboBox, device: ptr Gdk3.TDevice) {.cdecl, dynlib: lib, importc: "gtk_combo_box_popup_for_device".}
proc popup_for_device*(self: ComboBox, device: Gdk3.Device) {.inline.} =
  gtk_combo_box_popup_for_device(self, device.getPointer)
# proc popup_for_device*(self: ComboBox, device: Gdk3.Device) {.inline.} =

# gtk_combo_box_set_active
# flags: {isMethod} container: ComboBox
# need sugar: is method
# arg index_: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_set_active(self: ptr TComboBox, index_x: int32) {.cdecl, dynlib: lib, importc: "gtk_combo_box_set_active".}
proc set_active*(self: ComboBox, index_x: int32) {.inline.} =
  gtk_combo_box_set_active(self, index_x)
# proc set_active*(self: ComboBox, index_x: int32) {.inline.} =

# gtk_combo_box_set_active_id
# flags: {isMethod} container: ComboBox
# need sugar: is method
# arg active_id: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_combo_box_set_active_id(self: ptr TComboBox, active_id: ucstring): bool {.cdecl, dynlib: lib, importc: "gtk_combo_box_set_active_id".}
proc set_active_id*(self: ComboBox, active_id: ustring): bool {.inline.} =
  gtk_combo_box_set_active_id(self, ucstring(active_id))
# proc set_active_id*(self: ComboBox, active_id: ustring): bool {.inline.} =

# gtk_combo_box_set_active_iter
# flags: {isMethod} container: ComboBox
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_set_active_iter(self: ptr TComboBox, iter: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_combo_box_set_active_iter".}
proc set_active_iter*(self: ComboBox, iter: ptr TTreeIter) {.inline.} =
  gtk_combo_box_set_active_iter(self, iter)
# proc set_active_iter*(self: ComboBox, iter: ptr TTreeIter) {.inline.} =

# gtk_combo_box_set_add_tearoffs
# flags: {isMethod} container: ComboBox (deprecated)
# gtk_combo_box_set_button_sensitivity
# flags: {isMethod} container: ComboBox
# need sugar: is method
# arg sensitivity: INTERFACE (ENUM) 'SensitivityType' 'SensitivityType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_set_button_sensitivity(self: ptr TComboBox, sensitivity: SensitivityType) {.cdecl, dynlib: lib, importc: "gtk_combo_box_set_button_sensitivity".}
proc set_button_sensitivity*(self: ComboBox, sensitivity: SensitivityType) {.inline.} =
  gtk_combo_box_set_button_sensitivity(self, sensitivity)
# proc set_button_sensitivity*(self: ComboBox, sensitivity: SensitivityType) {.inline.} =

# gtk_combo_box_set_column_span_column
# flags: {isMethod} container: ComboBox
# need sugar: is method
# arg column_span: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_set_column_span_column(self: ptr TComboBox, column_span: int32) {.cdecl, dynlib: lib, importc: "gtk_combo_box_set_column_span_column".}
proc set_column_span_column*(self: ComboBox, column_span: int32) {.inline.} =
  gtk_combo_box_set_column_span_column(self, column_span)
# proc set_column_span_column*(self: ComboBox, column_span: int32) {.inline.} =

# gtk_combo_box_set_entry_text_column
# flags: {isMethod} container: ComboBox
# need sugar: is method
# arg text_column: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_set_entry_text_column(self: ptr TComboBox, text_column: int32) {.cdecl, dynlib: lib, importc: "gtk_combo_box_set_entry_text_column".}
proc set_entry_text_column*(self: ComboBox, text_column: int32) {.inline.} =
  gtk_combo_box_set_entry_text_column(self, text_column)
# proc set_entry_text_column*(self: ComboBox, text_column: int32) {.inline.} =

# gtk_combo_box_set_focus_on_click
# flags: {isMethod} container: ComboBox
# need sugar: is method
# arg focus_on_click: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_set_focus_on_click(self: ptr TComboBox, focus_on_click: bool) {.cdecl, dynlib: lib, importc: "gtk_combo_box_set_focus_on_click".}
proc set_focus_on_click*(self: ComboBox, focus_on_click: bool) {.inline.} =
  gtk_combo_box_set_focus_on_click(self, focus_on_click)
# proc set_focus_on_click*(self: ComboBox, focus_on_click: bool) {.inline.} =

# gtk_combo_box_set_id_column
# flags: {isMethod} container: ComboBox
# need sugar: is method
# arg id_column: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_set_id_column(self: ptr TComboBox, id_column: int32) {.cdecl, dynlib: lib, importc: "gtk_combo_box_set_id_column".}
proc set_id_column*(self: ComboBox, id_column: int32) {.inline.} =
  gtk_combo_box_set_id_column(self, id_column)
# proc set_id_column*(self: ComboBox, id_column: int32) {.inline.} =

# gtk_combo_box_set_model
# flags: {isMethod} container: ComboBox
# need sugar: is method
# arg model: INTERFACE (INTERFACE) 'ptr TTreeModel' 'ptr TTreeModel' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_set_model(self: ptr TComboBox, model: ptr TTreeModel) {.cdecl, dynlib: lib, importc: "gtk_combo_box_set_model".}
proc set_model*(self: ComboBox, model: ptr TTreeModel) {.inline.} =
  gtk_combo_box_set_model(self, model)
# proc set_model*(self: ComboBox, model: ptr TTreeModel) {.inline.} =

# gtk_combo_box_set_popup_fixed_width
# flags: {isMethod} container: ComboBox
# need sugar: is method
# arg fixed: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_set_popup_fixed_width(self: ptr TComboBox, fixed: bool) {.cdecl, dynlib: lib, importc: "gtk_combo_box_set_popup_fixed_width".}
proc set_popup_fixed_width*(self: ComboBox, fixed: bool) {.inline.} =
  gtk_combo_box_set_popup_fixed_width(self, fixed)
# proc set_popup_fixed_width*(self: ComboBox, fixed: bool) {.inline.} =

# gtk_combo_box_set_row_separator_func
# flags: {isMethod} container: ComboBox
# need sugar: is method
# arg func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg data: VOID 'pointer' 'pointer' IN
# arg destroy: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_set_row_separator_func(self: ptr TComboBox, func_x: pointer, data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_combo_box_set_row_separator_func".}
proc set_row_separator_func*(self: ComboBox, func_x: pointer, data: pointer, destroy: pointer) {.inline.} =
  gtk_combo_box_set_row_separator_func(self, func_x, data, destroy)
# proc set_row_separator_func*(self: ComboBox, func_x: pointer, data: pointer, destroy: pointer) {.inline.} =

# gtk_combo_box_set_row_span_column
# flags: {isMethod} container: ComboBox
# need sugar: is method
# arg row_span: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_set_row_span_column(self: ptr TComboBox, row_span: int32) {.cdecl, dynlib: lib, importc: "gtk_combo_box_set_row_span_column".}
proc set_row_span_column*(self: ComboBox, row_span: int32) {.inline.} =
  gtk_combo_box_set_row_span_column(self, row_span)
# proc set_row_span_column*(self: ComboBox, row_span: int32) {.inline.} =

# gtk_combo_box_set_title
# flags: {isMethod} container: ComboBox (deprecated)
# gtk_combo_box_set_wrap_width
# flags: {isMethod} container: ComboBox
# need sugar: is method
# arg width: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_set_wrap_width(self: ptr TComboBox, width: int32) {.cdecl, dynlib: lib, importc: "gtk_combo_box_set_wrap_width".}
proc set_wrap_width*(self: ComboBox, width: int32) {.inline.} =
  gtk_combo_box_set_wrap_width(self, width)
# proc set_wrap_width*(self: ComboBox, width: int32) {.inline.} =

# initializer for ComboBoxAccessible: gtk_combo_box_accessible_get_type
proc gtk_combo_box_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_combo_box_accessible_get_type".}
template gtype*(klass_parameter: typedesc[ComboBoxAccessible]): GType = gtk_combo_box_accessible_get_type()
# initializer for ComboBoxText: gtk_combo_box_text_get_type
proc gtk_combo_box_text_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_combo_box_text_get_type".}
template gtype*(klass_parameter: typedesc[ComboBoxText]): GType = gtk_combo_box_text_get_type()
# gtk_combo_box_text_new
# flags: {isConstructor} container: ComboBoxText
# need sugar: is static method
# return: INTERFACE 'ComboBoxText' 'TransferNone[TComboBoxText]' (diff., need sugar)
proc gtk_combo_box_text_new(): TransferNone[TComboBoxText] {.cdecl, dynlib: lib, importc: "gtk_combo_box_text_new".}
proc new_comboboxtext*(): ComboBoxText {.inline.} =
  wrap(gtk_combo_box_text_new())
# proc new_comboboxtext*(): ComboBoxText {.inline.} =

# gtk_combo_box_text_new_with_entry
# flags: {isConstructor} container: ComboBoxText
# need sugar: is static method
# return: INTERFACE 'ComboBoxText' 'TransferNone[TComboBoxText]' (diff., need sugar)
proc gtk_combo_box_text_new_with_entry(): TransferNone[TComboBoxText] {.cdecl, dynlib: lib, importc: "gtk_combo_box_text_new_with_entry".}
proc new_comboboxtext_with_entry*(): ComboBoxText {.inline.} =
  wrap(gtk_combo_box_text_new_with_entry())
# proc new_comboboxtext_with_entry*(): ComboBoxText {.inline.} =

# gtk_combo_box_text_append
# flags: {isMethod} container: ComboBoxText
# need sugar: is method
# arg id: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_text_append(self: ptr TComboBoxText, id: ucstring, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_combo_box_text_append".}
proc append*(self: ComboBoxText, id: ustring, text: ustring) {.inline.} =
  gtk_combo_box_text_append(self, ucstring(id), ucstring(text))
# proc append*(self: ComboBoxText, id: ustring, text: ustring) {.inline.} =

# gtk_combo_box_text_append_text
# flags: {isMethod} container: ComboBoxText
# need sugar: is method
# arg text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_text_append_text(self: ptr TComboBoxText, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_combo_box_text_append_text".}
proc append_text*(self: ComboBoxText, text: ustring) {.inline.} =
  gtk_combo_box_text_append_text(self, ucstring(text))
# proc append_text*(self: ComboBoxText, text: ustring) {.inline.} =

# gtk_combo_box_text_get_active_text
# flags: {isMethod} container: ComboBoxText
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_combo_box_text_get_active_text(self: ptr TComboBoxText): ucstring {.cdecl, dynlib: lib, importc: "gtk_combo_box_text_get_active_text".}
proc get_active_text*(self: ComboBoxText): ucstring {.inline.} =
  gtk_combo_box_text_get_active_text(self)
# proc get_active_text*(self: ComboBoxText): ucstring {.inline.} =

# gtk_combo_box_text_insert
# flags: {isMethod} container: ComboBoxText
# need sugar: is method
# arg position: INT32 'int32' 'int32' IN
# arg id: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_text_insert(self: ptr TComboBoxText, position: int32, id: ucstring, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_combo_box_text_insert".}
proc insert*(self: ComboBoxText, position: int32, id: ustring, text: ustring) {.inline.} =
  gtk_combo_box_text_insert(self, position, ucstring(id), ucstring(text))
# proc insert*(self: ComboBoxText, position: int32, id: ustring, text: ustring) {.inline.} =

# gtk_combo_box_text_insert_text
# flags: {isMethod} container: ComboBoxText
# need sugar: is method
# arg position: INT32 'int32' 'int32' IN
# arg text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_text_insert_text(self: ptr TComboBoxText, position: int32, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_combo_box_text_insert_text".}
proc insert_text*(self: ComboBoxText, position: int32, text: ustring) {.inline.} =
  gtk_combo_box_text_insert_text(self, position, ucstring(text))
# proc insert_text*(self: ComboBoxText, position: int32, text: ustring) {.inline.} =

# gtk_combo_box_text_prepend
# flags: {isMethod} container: ComboBoxText
# need sugar: is method
# arg id: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_text_prepend(self: ptr TComboBoxText, id: ucstring, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_combo_box_text_prepend".}
proc prepend*(self: ComboBoxText, id: ustring, text: ustring) {.inline.} =
  gtk_combo_box_text_prepend(self, ucstring(id), ucstring(text))
# proc prepend*(self: ComboBoxText, id: ustring, text: ustring) {.inline.} =

# gtk_combo_box_text_prepend_text
# flags: {isMethod} container: ComboBoxText
# need sugar: is method
# arg text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_text_prepend_text(self: ptr TComboBoxText, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_combo_box_text_prepend_text".}
proc prepend_text*(self: ComboBoxText, text: ustring) {.inline.} =
  gtk_combo_box_text_prepend_text(self, ucstring(text))
# proc prepend_text*(self: ComboBoxText, text: ustring) {.inline.} =

# gtk_combo_box_text_remove
# flags: {isMethod} container: ComboBoxText
# need sugar: is method
# arg position: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_text_remove(self: ptr TComboBoxText, position: int32) {.cdecl, dynlib: lib, importc: "gtk_combo_box_text_remove".}
proc remove*(self: ComboBoxText, position: int32) {.inline.} =
  gtk_combo_box_text_remove(self, position)
# proc remove*(self: ComboBoxText, position: int32) {.inline.} =

# gtk_combo_box_text_remove_all
# flags: {isMethod} container: ComboBoxText
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_combo_box_text_remove_all(self: ptr TComboBoxText) {.cdecl, dynlib: lib, importc: "gtk_combo_box_text_remove_all".}
proc remove_all*(self: ComboBoxText) {.inline.} =
  gtk_combo_box_text_remove_all(self)
# proc remove_all*(self: ComboBoxText) {.inline.} =

# initializer for Container: gtk_container_get_type
proc gtk_container_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_container_get_type".}
template gtype*(klass_parameter: typedesc[Container]): GType = gtk_container_get_type()
# gtk_container_add
# flags: {isMethod} container: Container
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_container_add(self: ptr TContainer, widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_container_add".}
proc add*(self: Container, widget: Widget) {.inline.} =
  gtk_container_add(self, widget.getPointer)
# proc add*(self: Container, widget: Widget) {.inline.} =

# gtk_container_check_resize
# flags: {isMethod} container: Container
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_container_check_resize(self: ptr TContainer) {.cdecl, dynlib: lib, importc: "gtk_container_check_resize".}
proc check_resize*(self: Container) {.inline.} =
  gtk_container_check_resize(self)
# proc check_resize*(self: Container) {.inline.} =

# gtk_container_child_get_property
# flags: {isMethod} container: Container
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg property_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg value: INTERFACE (STRUCT) 'ptr GObject2.TValue' 'ptr GObject2.TValue' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_container_child_get_property(self: ptr TContainer, child: ptr TWidget, property_name: ucstring, value: ptr GObject2.TValue) {.cdecl, dynlib: lib, importc: "gtk_container_child_get_property".}
proc child_get_property*(self: Container, child: Widget, property_name: ustring, value: ptr GObject2.TValue) {.inline.} =
  gtk_container_child_get_property(self, child.getPointer, ucstring(property_name), value)
# proc child_get_property*(self: Container, child: Widget, property_name: ustring, value: ptr GObject2.TValue) {.inline.} =

# gtk_container_child_notify
# flags: {isMethod} container: Container
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg child_property: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_container_child_notify(self: ptr TContainer, child: ptr TWidget, child_property: ucstring) {.cdecl, dynlib: lib, importc: "gtk_container_child_notify".}
proc child_notify*(self: Container, child: Widget, child_property: ustring) {.inline.} =
  gtk_container_child_notify(self, child.getPointer, ucstring(child_property))
# proc child_notify*(self: Container, child: Widget, child_property: ustring) {.inline.} =

# gtk_container_child_notify_by_pspec
# flags: {isMethod} container: Container
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg pspec: INTERFACE (OBJECT) 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_container_child_notify_by_pspec(self: ptr TContainer, child: ptr TWidget, pspec: ptr GObject2.TParamSpec) {.cdecl, dynlib: lib, importc: "gtk_container_child_notify_by_pspec".}
proc child_notify_by_pspec*(self: Container, child: Widget, pspec: GObject2.ParamSpec) {.inline.} =
  gtk_container_child_notify_by_pspec(self, child.getPointer, pspec.getPointer)
# proc child_notify_by_pspec*(self: Container, child: Widget, pspec: GObject2.ParamSpec) {.inline.} =

# gtk_container_child_set_property
# flags: {isMethod} container: Container
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg property_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg value: INTERFACE (STRUCT) 'ptr GObject2.TValue' 'ptr GObject2.TValue' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_container_child_set_property(self: ptr TContainer, child: ptr TWidget, property_name: ucstring, value: ptr GObject2.TValue) {.cdecl, dynlib: lib, importc: "gtk_container_child_set_property".}
proc child_set_property*(self: Container, child: Widget, property_name: ustring, value: ptr GObject2.TValue) {.inline.} =
  gtk_container_child_set_property(self, child.getPointer, ucstring(property_name), value)
# proc child_set_property*(self: Container, child: Widget, property_name: ustring, value: ptr GObject2.TValue) {.inline.} =

# gtk_container_child_type
# flags: {isMethod} container: Container
# need sugar: is method
# return: GTYPE 'GType' 'GType'
proc gtk_container_child_type(self: ptr TContainer): GType {.cdecl, dynlib: lib, importc: "gtk_container_child_type".}
proc child_type*(self: Container): GType {.inline.} =
  gtk_container_child_type(self)
# proc child_type*(self: Container): GType {.inline.} =

# gtk_container_forall
# flags: {isMethod} container: Container
# need sugar: is method
# arg callback: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg callback_data: VOID 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_container_forall(self: ptr TContainer, callback: pointer, callback_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_container_forall".}
proc forall*(self: Container, callback: pointer, callback_data: pointer) {.inline.} =
  gtk_container_forall(self, callback, callback_data)
# proc forall*(self: Container, callback: pointer, callback_data: pointer) {.inline.} =

# gtk_container_foreach
# flags: {isMethod} container: Container
# need sugar: is method
# arg callback: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg callback_data: VOID 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_container_foreach(self: ptr TContainer, callback: pointer, callback_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_container_foreach".}
proc foreach*(self: Container, callback: pointer, callback_data: pointer) {.inline.} =
  gtk_container_foreach(self, callback, callback_data)
# proc foreach*(self: Container, callback: pointer, callback_data: pointer) {.inline.} =

# gtk_container_get_border_width
# flags: {isMethod} container: Container
# need sugar: is method
# return: UINT32 'uint32' 'uint32'
proc gtk_container_get_border_width(self: ptr TContainer): uint32 {.cdecl, dynlib: lib, importc: "gtk_container_get_border_width".}
proc get_border_width*(self: Container): uint32 {.inline.} =
  gtk_container_get_border_width(self)
# proc get_border_width*(self: Container): uint32 {.inline.} =

# gtk_container_get_children
# flags: {isMethod} container: Container
# need sugar: is method
# return: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_container_get_children(self: ptr TContainer): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_container_get_children".}
proc get_children*(self: Container): ptr GLIST_TODO {.inline.} =
  gtk_container_get_children(self)
# proc get_children*(self: Container): ptr GLIST_TODO {.inline.} =

# gtk_container_get_focus_chain
# flags: {isMethod} container: Container
# need sugar: is method
# arg focusable_widgets: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO' OUT
# return: BOOLEAN 'bool' 'bool'
proc gtk_container_get_focus_chain(self: ptr TContainer, focusable_widgets: ptr GLIST_TODO): bool {.cdecl, dynlib: lib, importc: "gtk_container_get_focus_chain".}
proc get_focus_chain*(self: Container, focusable_widgets: ptr GLIST_TODO): bool {.inline.} =
  gtk_container_get_focus_chain(self, focusable_widgets)
# tuple-return
# focusable_widgets: ptr GLIST_TODO
# proc get_focus_chain*(self: Container): bool {.inline.} =

# gtk_container_get_focus_child
# flags: {isMethod} container: Container
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_container_get_focus_child(self: ptr TContainer): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_container_get_focus_child".}
proc get_focus_child*(self: Container): Widget {.inline.} =
  wrap(gtk_container_get_focus_child(self))
# proc get_focus_child*(self: Container): Widget {.inline.} =

# gtk_container_get_focus_hadjustment
# flags: {isMethod} container: Container
# need sugar: is method
# return: INTERFACE 'Adjustment' 'TransferNone[TAdjustment]' (diff., need sugar)
proc gtk_container_get_focus_hadjustment(self: ptr TContainer): TransferNone[TAdjustment] {.cdecl, dynlib: lib, importc: "gtk_container_get_focus_hadjustment".}
proc get_focus_hadjustment*(self: Container): Adjustment {.inline.} =
  wrap(gtk_container_get_focus_hadjustment(self))
# proc get_focus_hadjustment*(self: Container): Adjustment {.inline.} =

# gtk_container_get_focus_vadjustment
# flags: {isMethod} container: Container
# need sugar: is method
# return: INTERFACE 'Adjustment' 'TransferNone[TAdjustment]' (diff., need sugar)
proc gtk_container_get_focus_vadjustment(self: ptr TContainer): TransferNone[TAdjustment] {.cdecl, dynlib: lib, importc: "gtk_container_get_focus_vadjustment".}
proc get_focus_vadjustment*(self: Container): Adjustment {.inline.} =
  wrap(gtk_container_get_focus_vadjustment(self))
# proc get_focus_vadjustment*(self: Container): Adjustment {.inline.} =

# gtk_container_get_path_for_child
# flags: {isMethod} container: Container
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: INTERFACE 'ptr TWidgetPath' 'ptr TWidgetPath'
proc gtk_container_get_path_for_child(self: ptr TContainer, child: ptr TWidget): ptr TWidgetPath {.cdecl, dynlib: lib, importc: "gtk_container_get_path_for_child".}
proc get_path_for_child*(self: Container, child: Widget): ptr TWidgetPath {.inline.} =
  gtk_container_get_path_for_child(self, child.getPointer)
# proc get_path_for_child*(self: Container, child: Widget): ptr TWidgetPath {.inline.} =

# gtk_container_get_resize_mode
# flags: {isMethod} container: Container (deprecated)
# gtk_container_propagate_draw
# flags: {isMethod} container: Container
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg cr: INTERFACE (STRUCT) 'ptr cairo1.TContext' 'ptr cairo1.TContext' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_container_propagate_draw(self: ptr TContainer, child: ptr TWidget, cr: ptr cairo1.TContext) {.cdecl, dynlib: lib, importc: "gtk_container_propagate_draw".}
proc propagate_draw*(self: Container, child: Widget, cr: ptr cairo1.TContext) {.inline.} =
  gtk_container_propagate_draw(self, child.getPointer, cr)
# proc propagate_draw*(self: Container, child: Widget, cr: ptr cairo1.TContext) {.inline.} =

# gtk_container_remove
# flags: {isMethod} container: Container
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_container_remove(self: ptr TContainer, widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_container_remove".}
proc remove*(self: Container, widget: Widget) {.inline.} =
  gtk_container_remove(self, widget.getPointer)
# proc remove*(self: Container, widget: Widget) {.inline.} =

# gtk_container_resize_children
# flags: {isMethod} container: Container (deprecated)
# gtk_container_set_border_width
# flags: {isMethod} container: Container
# need sugar: is method
# arg border_width: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_container_set_border_width(self: ptr TContainer, border_width: uint32) {.cdecl, dynlib: lib, importc: "gtk_container_set_border_width".}
proc set_border_width*(self: Container, border_width: uint32) {.inline.} =
  gtk_container_set_border_width(self, border_width)
# proc set_border_width*(self: Container, border_width: uint32) {.inline.} =

# gtk_container_set_focus_chain
# flags: {isMethod} container: Container
# need sugar: is method
# arg focusable_widgets: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_container_set_focus_chain(self: ptr TContainer, focusable_widgets: ptr GLIST_TODO) {.cdecl, dynlib: lib, importc: "gtk_container_set_focus_chain".}
proc set_focus_chain*(self: Container, focusable_widgets: ptr GLIST_TODO) {.inline.} =
  gtk_container_set_focus_chain(self, focusable_widgets)
# proc set_focus_chain*(self: Container, focusable_widgets: ptr GLIST_TODO) {.inline.} =

# gtk_container_set_focus_child
# flags: {isMethod} container: Container
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_container_set_focus_child(self: ptr TContainer, child: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_container_set_focus_child".}
proc set_focus_child*(self: Container, child: Widget) {.inline.} =
  gtk_container_set_focus_child(self, child.getPointer)
# proc set_focus_child*(self: Container, child: Widget) {.inline.} =

# gtk_container_set_focus_hadjustment
# flags: {isMethod} container: Container
# need sugar: is method
# arg adjustment: INTERFACE (OBJECT) 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_container_set_focus_hadjustment(self: ptr TContainer, adjustment: ptr TAdjustment) {.cdecl, dynlib: lib, importc: "gtk_container_set_focus_hadjustment".}
proc set_focus_hadjustment*(self: Container, adjustment: Adjustment) {.inline.} =
  gtk_container_set_focus_hadjustment(self, adjustment.getPointer)
# proc set_focus_hadjustment*(self: Container, adjustment: Adjustment) {.inline.} =

# gtk_container_set_focus_vadjustment
# flags: {isMethod} container: Container
# need sugar: is method
# arg adjustment: INTERFACE (OBJECT) 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_container_set_focus_vadjustment(self: ptr TContainer, adjustment: ptr TAdjustment) {.cdecl, dynlib: lib, importc: "gtk_container_set_focus_vadjustment".}
proc set_focus_vadjustment*(self: Container, adjustment: Adjustment) {.inline.} =
  gtk_container_set_focus_vadjustment(self, adjustment.getPointer)
# proc set_focus_vadjustment*(self: Container, adjustment: Adjustment) {.inline.} =

# gtk_container_set_reallocate_redraws
# flags: {isMethod} container: Container (deprecated)
# gtk_container_set_resize_mode
# flags: {isMethod} container: Container (deprecated)
# gtk_container_unset_focus_chain
# flags: {isMethod} container: Container
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_container_unset_focus_chain(self: ptr TContainer) {.cdecl, dynlib: lib, importc: "gtk_container_unset_focus_chain".}
proc unset_focus_chain*(self: Container) {.inline.} =
  gtk_container_unset_focus_chain(self)
# proc unset_focus_chain*(self: Container) {.inline.} =

# initializer for ContainerAccessible: gtk_container_accessible_get_type
proc gtk_container_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_container_accessible_get_type".}
template gtype*(klass_parameter: typedesc[ContainerAccessible]): GType = gtk_container_accessible_get_type()
# initializer for ContainerCellAccessible: gtk_container_cell_accessible_get_type
proc gtk_container_cell_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_container_cell_accessible_get_type".}
template gtype*(klass_parameter: typedesc[ContainerCellAccessible]): GType = gtk_container_cell_accessible_get_type()
# gtk_container_cell_accessible_new
# flags: {isConstructor} container: ContainerCellAccessible
# need sugar: is static method
# return: INTERFACE 'ContainerCellAccessible' 'TransferFull[TContainerCellAccessible]' (diff., need sugar)
proc gtk_container_cell_accessible_new(): TransferFull[TContainerCellAccessible] {.cdecl, dynlib: lib, importc: "gtk_container_cell_accessible_new".}
proc new_containercellaccessible*(): ContainerCellAccessible {.inline.} =
  wrap(gtk_container_cell_accessible_new())
# proc new_containercellaccessible*(): ContainerCellAccessible {.inline.} =

# gtk_container_cell_accessible_add_child
# flags: {isMethod} container: ContainerCellAccessible
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'CellAccessible' 'ptr TCellAccessible' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_container_cell_accessible_add_child(self: ptr TContainerCellAccessible, child: ptr TCellAccessible) {.cdecl, dynlib: lib, importc: "gtk_container_cell_accessible_add_child".}
proc add_child*(self: ContainerCellAccessible, child: CellAccessible) {.inline.} =
  gtk_container_cell_accessible_add_child(self, child.getPointer)
# proc add_child*(self: ContainerCellAccessible, child: CellAccessible) {.inline.} =

# gtk_container_cell_accessible_get_children
# flags: {isMethod} container: ContainerCellAccessible
# need sugar: is method
# return: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_container_cell_accessible_get_children(self: ptr TContainerCellAccessible): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_container_cell_accessible_get_children".}
proc get_children*(self: ContainerCellAccessible): ptr GLIST_TODO {.inline.} =
  gtk_container_cell_accessible_get_children(self)
# proc get_children*(self: ContainerCellAccessible): ptr GLIST_TODO {.inline.} =

# gtk_container_cell_accessible_remove_child
# flags: {isMethod} container: ContainerCellAccessible
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'CellAccessible' 'ptr TCellAccessible' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_container_cell_accessible_remove_child(self: ptr TContainerCellAccessible, child: ptr TCellAccessible) {.cdecl, dynlib: lib, importc: "gtk_container_cell_accessible_remove_child".}
proc remove_child*(self: ContainerCellAccessible, child: CellAccessible) {.inline.} =
  gtk_container_cell_accessible_remove_child(self, child.getPointer)
# proc remove_child*(self: ContainerCellAccessible, child: CellAccessible) {.inline.} =

# initializer for CssProvider: gtk_css_provider_get_type
proc gtk_css_provider_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_css_provider_get_type".}
template gtype*(klass_parameter: typedesc[CssProvider]): GType = gtk_css_provider_get_type()
# gtk_css_provider_new
# flags: {isConstructor} container: CssProvider
# need sugar: is static method
# return: INTERFACE 'CssProvider' 'TransferFull[TCssProvider]' (diff., need sugar)
proc gtk_css_provider_new(): TransferFull[TCssProvider] {.cdecl, dynlib: lib, importc: "gtk_css_provider_new".}
proc new_cssprovider*(): CssProvider {.inline.} =
  wrap(gtk_css_provider_new())
# proc new_cssprovider*(): CssProvider {.inline.} =

# gtk_css_provider_get_default
# flags: {} container: CssProvider
# need sugar: is static method
# return: INTERFACE 'CssProvider' 'TransferNone[TCssProvider]' (diff., need sugar)
proc gtk_css_provider_get_default(): TransferNone[TCssProvider] {.cdecl, dynlib: lib, importc: "gtk_css_provider_get_default".}
template get_default*(klass_parameter: typedesc[CssProvider]): CssProvider =
  wrap(gtk_css_provider_get_default())
# template get_default*(klass_parameter: typedesc[CssProvider]): CssProvider =

# gtk_css_provider_get_named
# flags: {} container: CssProvider
# need sugar: is static method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg variant: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'CssProvider' 'TransferNone[TCssProvider]' (diff., need sugar)
proc gtk_css_provider_get_named(name: ucstring, variant: ucstring): TransferNone[TCssProvider] {.cdecl, dynlib: lib, importc: "gtk_css_provider_get_named".}
template get_named*(klass_parameter: typedesc[CssProvider], name: ustring, variant: ustring): CssProvider =
  wrap(gtk_css_provider_get_named(ucstring(name), ucstring(variant)))
# template get_named*(klass_parameter: typedesc[CssProvider], name: ustring, variant: ustring): CssProvider =

# gtk_css_provider_load_from_data
# flags: {isMethod, throws} container: CssProvider
# can throw
# need sugar: is method
# arg data: ARRAY 'string' 'cstring' IN (diff., need sugar) array lengthArg: 1
# arg length: INT32 'int32' 'int32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_css_provider_load_from_data(self: ptr TCssProvider, data: cstring, length: int32, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_css_provider_load_from_data".}
proc load_from_data*(self: CssProvider, data: string): bool {.inline.} =
  gtk_css_provider_load_from_data(self, cstring(data), data.len.int32)
# proc load_from_data*(self: CssProvider, data: string): bool {.inline.} =

# gtk_css_provider_load_from_file
# flags: {isMethod, throws} container: CssProvider
# can throw
# need sugar: is method
# arg file: INTERFACE (INTERFACE) 'ptr Gio2.TFile' 'ptr Gio2.TFile' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_css_provider_load_from_file(self: ptr TCssProvider, file: ptr Gio2.TFile, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_css_provider_load_from_file".}
proc load_from_file*(self: CssProvider, file: ptr Gio2.TFile): bool {.inline.} =
  gtk_css_provider_load_from_file(self, file)
# proc load_from_file*(self: CssProvider, file: ptr Gio2.TFile): bool {.inline.} =

# gtk_css_provider_load_from_path
# flags: {isMethod, throws} container: CssProvider
# can throw
# need sugar: is method
# arg path: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_css_provider_load_from_path(self: ptr TCssProvider, path: ucstring, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_css_provider_load_from_path".}
proc load_from_path*(self: CssProvider, path: ustring): bool {.inline.} =
  gtk_css_provider_load_from_path(self, ucstring(path))
# proc load_from_path*(self: CssProvider, path: ustring): bool {.inline.} =

# gtk_css_provider_load_from_resource
# flags: {isMethod} container: CssProvider
# need sugar: is method
# arg resource_path: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_css_provider_load_from_resource(self: ptr TCssProvider, resource_path: ucstring) {.cdecl, dynlib: lib, importc: "gtk_css_provider_load_from_resource".}
proc load_from_resource*(self: CssProvider, resource_path: ustring) {.inline.} =
  gtk_css_provider_load_from_resource(self, ucstring(resource_path))
# proc load_from_resource*(self: CssProvider, resource_path: ustring) {.inline.} =

# gtk_css_provider_to_string
# flags: {isMethod} container: CssProvider
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_css_provider_to_string(self: ptr TCssProvider): ucstring {.cdecl, dynlib: lib, importc: "gtk_css_provider_to_string".}
proc to_string*(self: CssProvider): ucstring {.inline.} =
  gtk_css_provider_to_string(self)
# proc to_string*(self: CssProvider): ucstring {.inline.} =

# initializer for Dialog: gtk_dialog_get_type
proc gtk_dialog_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_dialog_get_type".}
template gtype*(klass_parameter: typedesc[Dialog]): GType = gtk_dialog_get_type()
# gtk_dialog_new
# flags: {isConstructor} container: Dialog
# need sugar: is static method
# return: INTERFACE 'Dialog' 'TransferNone[TDialog]' (diff., need sugar)
proc gtk_dialog_new(): TransferNone[TDialog] {.cdecl, dynlib: lib, importc: "gtk_dialog_new".}
proc new_dialog*(): Dialog {.inline.} =
  wrap(gtk_dialog_new())
# proc new_dialog*(): Dialog {.inline.} =

# gtk_dialog_add_action_widget
# flags: {isMethod} container: Dialog
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg response_id: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_dialog_add_action_widget(self: ptr TDialog, child: ptr TWidget, response_id: int32) {.cdecl, dynlib: lib, importc: "gtk_dialog_add_action_widget".}
proc add_action_widget*(self: Dialog, child: Widget, response_id: int32) {.inline.} =
  gtk_dialog_add_action_widget(self, child.getPointer, response_id)
# proc add_action_widget*(self: Dialog, child: Widget, response_id: int32) {.inline.} =

# gtk_dialog_add_button
# flags: {isMethod} container: Dialog
# need sugar: is method
# arg button_text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg response_id: INT32 'int32' 'int32' IN
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_dialog_add_button(self: ptr TDialog, button_text: ucstring, response_id: int32): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_dialog_add_button".}
proc add_button*(self: Dialog, button_text: ustring, response_id: int32): Widget {.inline.} =
  wrap(gtk_dialog_add_button(self, ucstring(button_text), response_id))
# proc add_button*(self: Dialog, button_text: ustring, response_id: int32): Widget {.inline.} =

# gtk_dialog_get_action_area
# flags: {isMethod} container: Dialog (deprecated)
# gtk_dialog_get_content_area
# flags: {isMethod} container: Dialog
# need sugar: is method
# return: INTERFACE 'Box' 'TransferNone[TBox]' (diff., need sugar)
proc gtk_dialog_get_content_area(self: ptr TDialog): TransferNone[TBox] {.cdecl, dynlib: lib, importc: "gtk_dialog_get_content_area".}
proc get_content_area*(self: Dialog): Box {.inline.} =
  wrap(gtk_dialog_get_content_area(self))
# proc get_content_area*(self: Dialog): Box {.inline.} =

# gtk_dialog_get_header_bar
# flags: {isMethod} container: Dialog
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_dialog_get_header_bar(self: ptr TDialog): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_dialog_get_header_bar".}
proc get_header_bar*(self: Dialog): Widget {.inline.} =
  wrap(gtk_dialog_get_header_bar(self))
# proc get_header_bar*(self: Dialog): Widget {.inline.} =

# gtk_dialog_get_response_for_widget
# flags: {isMethod} container: Dialog
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: INT32 'int32' 'int32'
proc gtk_dialog_get_response_for_widget(self: ptr TDialog, widget: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_dialog_get_response_for_widget".}
proc get_response_for_widget*(self: Dialog, widget: Widget): int32 {.inline.} =
  gtk_dialog_get_response_for_widget(self, widget.getPointer)
# proc get_response_for_widget*(self: Dialog, widget: Widget): int32 {.inline.} =

# gtk_dialog_get_widget_for_response
# flags: {isMethod} container: Dialog
# need sugar: is method
# arg response_id: INT32 'int32' 'int32' IN
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_dialog_get_widget_for_response(self: ptr TDialog, response_id: int32): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_dialog_get_widget_for_response".}
proc get_widget_for_response*(self: Dialog, response_id: int32): Widget {.inline.} =
  wrap(gtk_dialog_get_widget_for_response(self, response_id))
# proc get_widget_for_response*(self: Dialog, response_id: int32): Widget {.inline.} =

# gtk_dialog_response
# flags: {isMethod} container: Dialog
# need sugar: is method
# arg response_id: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_dialog_response(self: ptr TDialog, response_id: int32) {.cdecl, dynlib: lib, importc: "gtk_dialog_response".}
proc response*(self: Dialog, response_id: int32) {.inline.} =
  gtk_dialog_response(self, response_id)
# proc response*(self: Dialog, response_id: int32) {.inline.} =

# gtk_dialog_run
# flags: {isMethod} container: Dialog
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_dialog_run(self: ptr TDialog): int32 {.cdecl, dynlib: lib, importc: "gtk_dialog_run".}
proc run*(self: Dialog): int32 {.inline.} =
  gtk_dialog_run(self)
# proc run*(self: Dialog): int32 {.inline.} =

# gtk_dialog_set_alternative_button_order_from_array
# flags: {isMethod} container: Dialog (deprecated)
# gtk_dialog_set_default_response
# flags: {isMethod} container: Dialog
# need sugar: is method
# arg response_id: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_dialog_set_default_response(self: ptr TDialog, response_id: int32) {.cdecl, dynlib: lib, importc: "gtk_dialog_set_default_response".}
proc set_default_response*(self: Dialog, response_id: int32) {.inline.} =
  gtk_dialog_set_default_response(self, response_id)
# proc set_default_response*(self: Dialog, response_id: int32) {.inline.} =

# gtk_dialog_set_response_sensitive
# flags: {isMethod} container: Dialog
# need sugar: is method
# arg response_id: INT32 'int32' 'int32' IN
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_dialog_set_response_sensitive(self: ptr TDialog, response_id: int32, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_dialog_set_response_sensitive".}
proc set_response_sensitive*(self: Dialog, response_id: int32, setting: bool) {.inline.} =
  gtk_dialog_set_response_sensitive(self, response_id, setting)
# proc set_response_sensitive*(self: Dialog, response_id: int32, setting: bool) {.inline.} =

# initializer for DrawingArea: gtk_drawing_area_get_type
proc gtk_drawing_area_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_drawing_area_get_type".}
template gtype*(klass_parameter: typedesc[DrawingArea]): GType = gtk_drawing_area_get_type()
# gtk_drawing_area_new
# flags: {isConstructor} container: DrawingArea
# need sugar: is static method
# return: INTERFACE 'DrawingArea' 'TransferNone[TDrawingArea]' (diff., need sugar)
proc gtk_drawing_area_new(): TransferNone[TDrawingArea] {.cdecl, dynlib: lib, importc: "gtk_drawing_area_new".}
proc new_drawingarea*(): DrawingArea {.inline.} =
  wrap(gtk_drawing_area_new())
# proc new_drawingarea*(): DrawingArea {.inline.} =

# initializer for Entry: gtk_entry_get_type
proc gtk_entry_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_entry_get_type".}
template gtype*(klass_parameter: typedesc[Entry]): GType = gtk_entry_get_type()
# gtk_entry_new
# flags: {isConstructor} container: Entry
# need sugar: is static method
# return: INTERFACE 'Entry' 'TransferNone[TEntry]' (diff., need sugar)
proc gtk_entry_new(): TransferNone[TEntry] {.cdecl, dynlib: lib, importc: "gtk_entry_new".}
proc new_entry*(): Entry {.inline.} =
  wrap(gtk_entry_new())
# proc new_entry*(): Entry {.inline.} =

# gtk_entry_new_with_buffer
# flags: {isConstructor} container: Entry
# need sugar: is static method
# arg buffer: INTERFACE (OBJECT) 'EntryBuffer' 'ptr TEntryBuffer' IN (diff., need sugar)
# return: INTERFACE 'Entry' 'TransferNone[TEntry]' (diff., need sugar)
proc gtk_entry_new_with_buffer(buffer: ptr TEntryBuffer): TransferNone[TEntry] {.cdecl, dynlib: lib, importc: "gtk_entry_new_with_buffer".}
proc new_entry_with_buffer*(buffer: EntryBuffer): Entry {.inline.} =
  wrap(gtk_entry_new_with_buffer(buffer.getPointer))
# proc new_entry_with_buffer*(buffer: EntryBuffer): Entry {.inline.} =

# gtk_entry_get_activates_default
# flags: {isMethod} container: Entry
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_entry_get_activates_default(self: ptr TEntry): bool {.cdecl, dynlib: lib, importc: "gtk_entry_get_activates_default".}
proc get_activates_default*(self: Entry): bool {.inline.} =
  gtk_entry_get_activates_default(self)
# proc get_activates_default*(self: Entry): bool {.inline.} =

# gtk_entry_get_alignment
# flags: {isMethod} container: Entry
# need sugar: is method
# return: FLOAT 'float32' 'float32'
proc gtk_entry_get_alignment(self: ptr TEntry): float32 {.cdecl, dynlib: lib, importc: "gtk_entry_get_alignment".}
proc get_alignment*(self: Entry): float32 {.inline.} =
  gtk_entry_get_alignment(self)
# proc get_alignment*(self: Entry): float32 {.inline.} =

# gtk_entry_get_attributes
# flags: {isMethod} container: Entry
# need sugar: is method
# return: INTERFACE 'ptr Pango1.TAttrList' 'ptr Pango1.TAttrList'
proc gtk_entry_get_attributes(self: ptr TEntry): ptr Pango1.TAttrList {.cdecl, dynlib: lib, importc: "gtk_entry_get_attributes".}
proc get_attributes*(self: Entry): ptr Pango1.TAttrList {.inline.} =
  gtk_entry_get_attributes(self)
# proc get_attributes*(self: Entry): ptr Pango1.TAttrList {.inline.} =

# gtk_entry_get_buffer
# flags: {isMethod} container: Entry
# need sugar: is method
# return: INTERFACE 'EntryBuffer' 'TransferNone[TEntryBuffer]' (diff., need sugar)
proc gtk_entry_get_buffer(self: ptr TEntry): TransferNone[TEntryBuffer] {.cdecl, dynlib: lib, importc: "gtk_entry_get_buffer".}
proc get_buffer*(self: Entry): EntryBuffer {.inline.} =
  wrap(gtk_entry_get_buffer(self))
# proc get_buffer*(self: Entry): EntryBuffer {.inline.} =

# gtk_entry_get_completion
# flags: {isMethod} container: Entry
# need sugar: is method
# return: INTERFACE 'EntryCompletion' 'TransferNone[TEntryCompletion]' (diff., need sugar)
proc gtk_entry_get_completion(self: ptr TEntry): TransferNone[TEntryCompletion] {.cdecl, dynlib: lib, importc: "gtk_entry_get_completion".}
proc get_completion*(self: Entry): EntryCompletion {.inline.} =
  wrap(gtk_entry_get_completion(self))
# proc get_completion*(self: Entry): EntryCompletion {.inline.} =

# gtk_entry_get_current_icon_drag_source
# flags: {isMethod} container: Entry
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_entry_get_current_icon_drag_source(self: ptr TEntry): int32 {.cdecl, dynlib: lib, importc: "gtk_entry_get_current_icon_drag_source".}
proc get_current_icon_drag_source*(self: Entry): int32 {.inline.} =
  gtk_entry_get_current_icon_drag_source(self)
# proc get_current_icon_drag_source*(self: Entry): int32 {.inline.} =

# gtk_entry_get_cursor_hadjustment
# flags: {isMethod} container: Entry
# need sugar: is method
# return: INTERFACE 'Adjustment' 'TransferNone[TAdjustment]' (diff., need sugar)
proc gtk_entry_get_cursor_hadjustment(self: ptr TEntry): TransferNone[TAdjustment] {.cdecl, dynlib: lib, importc: "gtk_entry_get_cursor_hadjustment".}
proc get_cursor_hadjustment*(self: Entry): Adjustment {.inline.} =
  wrap(gtk_entry_get_cursor_hadjustment(self))
# proc get_cursor_hadjustment*(self: Entry): Adjustment {.inline.} =

# gtk_entry_get_has_frame
# flags: {isMethod} container: Entry
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_entry_get_has_frame(self: ptr TEntry): bool {.cdecl, dynlib: lib, importc: "gtk_entry_get_has_frame".}
proc get_has_frame*(self: Entry): bool {.inline.} =
  gtk_entry_get_has_frame(self)
# proc get_has_frame*(self: Entry): bool {.inline.} =

# gtk_entry_get_icon_activatable
# flags: {isMethod} container: Entry
# need sugar: is method
# arg icon_pos: INTERFACE (ENUM) 'EntryIconPosition' 'EntryIconPosition' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_entry_get_icon_activatable(self: ptr TEntry, icon_pos: EntryIconPosition): bool {.cdecl, dynlib: lib, importc: "gtk_entry_get_icon_activatable".}
proc get_icon_activatable*(self: Entry, icon_pos: EntryIconPosition): bool {.inline.} =
  gtk_entry_get_icon_activatable(self, icon_pos)
# proc get_icon_activatable*(self: Entry, icon_pos: EntryIconPosition): bool {.inline.} =

# gtk_entry_get_icon_area
# flags: {isMethod} container: Entry
# need sugar: is method
# arg icon_pos: INTERFACE (ENUM) 'EntryIconPosition' 'EntryIconPosition' IN
# arg icon_area: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' OUT caller-allocates
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_get_icon_area(self: ptr TEntry, icon_pos: EntryIconPosition, icon_area: ptr Gdk3.TRectangle) {.cdecl, dynlib: lib, importc: "gtk_entry_get_icon_area".}
proc get_icon_area*(self: Entry, icon_pos: EntryIconPosition, icon_area: ptr Gdk3.TRectangle) {.inline.} =
  gtk_entry_get_icon_area(self, icon_pos, icon_area)
# tuple-return
# icon_area: ptr Gdk3.TRectangle
# proc get_icon_area*(self: Entry, icon_pos: EntryIconPosition) {.inline.} =

# gtk_entry_get_icon_at_pos
# flags: {isMethod} container: Entry
# need sugar: is method
# arg x: INT32 'int32' 'int32' IN
# arg y: INT32 'int32' 'int32' IN
# return: INT32 'int32' 'int32'
proc gtk_entry_get_icon_at_pos(self: ptr TEntry, x: int32, y: int32): int32 {.cdecl, dynlib: lib, importc: "gtk_entry_get_icon_at_pos".}
proc get_icon_at_pos*(self: Entry, x: int32, y: int32): int32 {.inline.} =
  gtk_entry_get_icon_at_pos(self, x, y)
# proc get_icon_at_pos*(self: Entry, x: int32, y: int32): int32 {.inline.} =

# gtk_entry_get_icon_gicon
# flags: {isMethod} container: Entry
# need sugar: is method
# arg icon_pos: INTERFACE (ENUM) 'EntryIconPosition' 'EntryIconPosition' IN
# return: INTERFACE 'ptr Gio2.TIcon' 'TransferNone[Gio2.TIcon]' (diff., need sugar)
proc gtk_entry_get_icon_gicon(self: ptr TEntry, icon_pos: EntryIconPosition): TransferNone[Gio2.TIcon] {.cdecl, dynlib: lib, importc: "gtk_entry_get_icon_gicon".}
proc get_icon_gicon*(self: Entry, icon_pos: EntryIconPosition): ptr Gio2.TIcon {.inline.} =
  wrap(gtk_entry_get_icon_gicon(self, icon_pos))
# proc get_icon_gicon*(self: Entry, icon_pos: EntryIconPosition): ptr Gio2.TIcon {.inline.} =

# gtk_entry_get_icon_name
# flags: {isMethod} container: Entry
# need sugar: is method
# arg icon_pos: INTERFACE (ENUM) 'EntryIconPosition' 'EntryIconPosition' IN
# return: UTF8 'ucstring' 'ucstring'
proc gtk_entry_get_icon_name(self: ptr TEntry, icon_pos: EntryIconPosition): ucstring {.cdecl, dynlib: lib, importc: "gtk_entry_get_icon_name".}
proc get_icon_name*(self: Entry, icon_pos: EntryIconPosition): ucstring {.inline.} =
  gtk_entry_get_icon_name(self, icon_pos)
# proc get_icon_name*(self: Entry, icon_pos: EntryIconPosition): ucstring {.inline.} =

# gtk_entry_get_icon_pixbuf
# flags: {isMethod} container: Entry
# need sugar: is method
# arg icon_pos: INTERFACE (ENUM) 'EntryIconPosition' 'EntryIconPosition' IN
# return: INTERFACE 'GdkPixbuf2.Pixbuf' 'TransferNone[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_entry_get_icon_pixbuf(self: ptr TEntry, icon_pos: EntryIconPosition): TransferNone[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_entry_get_icon_pixbuf".}
proc get_icon_pixbuf*(self: Entry, icon_pos: EntryIconPosition): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_entry_get_icon_pixbuf(self, icon_pos))
# proc get_icon_pixbuf*(self: Entry, icon_pos: EntryIconPosition): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_entry_get_icon_sensitive
# flags: {isMethod} container: Entry
# need sugar: is method
# arg icon_pos: INTERFACE (ENUM) 'EntryIconPosition' 'EntryIconPosition' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_entry_get_icon_sensitive(self: ptr TEntry, icon_pos: EntryIconPosition): bool {.cdecl, dynlib: lib, importc: "gtk_entry_get_icon_sensitive".}
proc get_icon_sensitive*(self: Entry, icon_pos: EntryIconPosition): bool {.inline.} =
  gtk_entry_get_icon_sensitive(self, icon_pos)
# proc get_icon_sensitive*(self: Entry, icon_pos: EntryIconPosition): bool {.inline.} =

# gtk_entry_get_icon_stock
# flags: {isMethod} container: Entry (deprecated)
# gtk_entry_get_icon_storage_type
# flags: {isMethod} container: Entry
# need sugar: is method
# arg icon_pos: INTERFACE (ENUM) 'EntryIconPosition' 'EntryIconPosition' IN
# return: INTERFACE 'ImageType' 'ImageType'
proc gtk_entry_get_icon_storage_type(self: ptr TEntry, icon_pos: EntryIconPosition): ImageType {.cdecl, dynlib: lib, importc: "gtk_entry_get_icon_storage_type".}
proc get_icon_storage_type*(self: Entry, icon_pos: EntryIconPosition): ImageType {.inline.} =
  gtk_entry_get_icon_storage_type(self, icon_pos)
# proc get_icon_storage_type*(self: Entry, icon_pos: EntryIconPosition): ImageType {.inline.} =

# gtk_entry_get_icon_tooltip_markup
# flags: {isMethod} container: Entry
# need sugar: is method
# arg icon_pos: INTERFACE (ENUM) 'EntryIconPosition' 'EntryIconPosition' IN
# return: UTF8 'ucstring' 'ucstring'
proc gtk_entry_get_icon_tooltip_markup(self: ptr TEntry, icon_pos: EntryIconPosition): ucstring {.cdecl, dynlib: lib, importc: "gtk_entry_get_icon_tooltip_markup".}
proc get_icon_tooltip_markup*(self: Entry, icon_pos: EntryIconPosition): ucstring {.inline.} =
  gtk_entry_get_icon_tooltip_markup(self, icon_pos)
# proc get_icon_tooltip_markup*(self: Entry, icon_pos: EntryIconPosition): ucstring {.inline.} =

# gtk_entry_get_icon_tooltip_text
# flags: {isMethod} container: Entry
# need sugar: is method
# arg icon_pos: INTERFACE (ENUM) 'EntryIconPosition' 'EntryIconPosition' IN
# return: UTF8 'ucstring' 'ucstring'
proc gtk_entry_get_icon_tooltip_text(self: ptr TEntry, icon_pos: EntryIconPosition): ucstring {.cdecl, dynlib: lib, importc: "gtk_entry_get_icon_tooltip_text".}
proc get_icon_tooltip_text*(self: Entry, icon_pos: EntryIconPosition): ucstring {.inline.} =
  gtk_entry_get_icon_tooltip_text(self, icon_pos)
# proc get_icon_tooltip_text*(self: Entry, icon_pos: EntryIconPosition): ucstring {.inline.} =

# gtk_entry_get_inner_border
# flags: {isMethod} container: Entry (deprecated)
# gtk_entry_get_input_hints
# flags: {isMethod} container: Entry
# need sugar: is method
# return: INTERFACE 'SInputHints' 'SInputHints'
proc gtk_entry_get_input_hints(self: ptr TEntry): SInputHints {.cdecl, dynlib: lib, importc: "gtk_entry_get_input_hints".}
proc get_input_hints*(self: Entry): SInputHints {.inline.} =
  gtk_entry_get_input_hints(self)
# proc get_input_hints*(self: Entry): SInputHints {.inline.} =

# gtk_entry_get_input_purpose
# flags: {isMethod} container: Entry
# need sugar: is method
# return: INTERFACE 'InputPurpose' 'InputPurpose'
proc gtk_entry_get_input_purpose(self: ptr TEntry): InputPurpose {.cdecl, dynlib: lib, importc: "gtk_entry_get_input_purpose".}
proc get_input_purpose*(self: Entry): InputPurpose {.inline.} =
  gtk_entry_get_input_purpose(self)
# proc get_input_purpose*(self: Entry): InputPurpose {.inline.} =

# gtk_entry_get_invisible_char
# flags: {isMethod} container: Entry
# need sugar: is method
# return: UNICHAR 'unichar' 'unichar'
proc gtk_entry_get_invisible_char(self: ptr TEntry): unichar {.cdecl, dynlib: lib, importc: "gtk_entry_get_invisible_char".}
proc get_invisible_char*(self: Entry): unichar {.inline.} =
  gtk_entry_get_invisible_char(self)
# proc get_invisible_char*(self: Entry): unichar {.inline.} =

# gtk_entry_get_layout
# flags: {isMethod} container: Entry
# need sugar: is method
# return: INTERFACE 'Pango1.Layout' 'TransferNone[Pango1.TLayout]' (diff., need sugar)
proc gtk_entry_get_layout(self: ptr TEntry): TransferNone[Pango1.TLayout] {.cdecl, dynlib: lib, importc: "gtk_entry_get_layout".}
proc get_layout*(self: Entry): Pango1.Layout {.inline.} =
  wrap(gtk_entry_get_layout(self))
# proc get_layout*(self: Entry): Pango1.Layout {.inline.} =

# gtk_entry_get_layout_offsets
# flags: {isMethod} container: Entry
# need sugar: is method
# arg x: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg y: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_get_layout_offsets(self: ptr TEntry, x: ptr int32, y: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_entry_get_layout_offsets".}
proc get_layout_offsets*(self: Entry, x: var int32, y: var int32) {.inline.} =
  gtk_entry_get_layout_offsets(self, addr(x), addr(y))
# tuple-return
# x: var int32
# y: var int32
# proc get_layout_offsets*(self: Entry) {.inline.} =

# gtk_entry_get_max_length
# flags: {isMethod} container: Entry
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_entry_get_max_length(self: ptr TEntry): int32 {.cdecl, dynlib: lib, importc: "gtk_entry_get_max_length".}
proc get_max_length*(self: Entry): int32 {.inline.} =
  gtk_entry_get_max_length(self)
# proc get_max_length*(self: Entry): int32 {.inline.} =

# gtk_entry_get_max_width_chars
# flags: {isMethod} container: Entry
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_entry_get_max_width_chars(self: ptr TEntry): int32 {.cdecl, dynlib: lib, importc: "gtk_entry_get_max_width_chars".}
proc get_max_width_chars*(self: Entry): int32 {.inline.} =
  gtk_entry_get_max_width_chars(self)
# proc get_max_width_chars*(self: Entry): int32 {.inline.} =

# gtk_entry_get_overwrite_mode
# flags: {isMethod} container: Entry
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_entry_get_overwrite_mode(self: ptr TEntry): bool {.cdecl, dynlib: lib, importc: "gtk_entry_get_overwrite_mode".}
proc get_overwrite_mode*(self: Entry): bool {.inline.} =
  gtk_entry_get_overwrite_mode(self)
# proc get_overwrite_mode*(self: Entry): bool {.inline.} =

# gtk_entry_get_placeholder_text
# flags: {isMethod} container: Entry
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_entry_get_placeholder_text(self: ptr TEntry): ucstring {.cdecl, dynlib: lib, importc: "gtk_entry_get_placeholder_text".}
proc get_placeholder_text*(self: Entry): ucstring {.inline.} =
  gtk_entry_get_placeholder_text(self)
# proc get_placeholder_text*(self: Entry): ucstring {.inline.} =

# gtk_entry_get_progress_fraction
# flags: {isMethod} container: Entry
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_entry_get_progress_fraction(self: ptr TEntry): float64 {.cdecl, dynlib: lib, importc: "gtk_entry_get_progress_fraction".}
proc get_progress_fraction*(self: Entry): float64 {.inline.} =
  gtk_entry_get_progress_fraction(self)
# proc get_progress_fraction*(self: Entry): float64 {.inline.} =

# gtk_entry_get_progress_pulse_step
# flags: {isMethod} container: Entry
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_entry_get_progress_pulse_step(self: ptr TEntry): float64 {.cdecl, dynlib: lib, importc: "gtk_entry_get_progress_pulse_step".}
proc get_progress_pulse_step*(self: Entry): float64 {.inline.} =
  gtk_entry_get_progress_pulse_step(self)
# proc get_progress_pulse_step*(self: Entry): float64 {.inline.} =

# gtk_entry_get_tabs
# flags: {isMethod} container: Entry
# need sugar: is method
# return: INTERFACE 'ptr Pango1.TTabArray' 'ptr Pango1.TTabArray'
proc gtk_entry_get_tabs(self: ptr TEntry): ptr Pango1.TTabArray {.cdecl, dynlib: lib, importc: "gtk_entry_get_tabs".}
proc get_tabs*(self: Entry): ptr Pango1.TTabArray {.inline.} =
  gtk_entry_get_tabs(self)
# proc get_tabs*(self: Entry): ptr Pango1.TTabArray {.inline.} =

# gtk_entry_get_text
# flags: {isMethod} container: Entry
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_entry_get_text(self: ptr TEntry): ucstring {.cdecl, dynlib: lib, importc: "gtk_entry_get_text".}
proc get_text*(self: Entry): ucstring {.inline.} =
  gtk_entry_get_text(self)
# proc get_text*(self: Entry): ucstring {.inline.} =

# gtk_entry_get_text_area
# flags: {isMethod} container: Entry
# need sugar: is method
# arg text_area: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' OUT caller-allocates
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_get_text_area(self: ptr TEntry, text_area: ptr Gdk3.TRectangle) {.cdecl, dynlib: lib, importc: "gtk_entry_get_text_area".}
proc get_text_area*(self: Entry, text_area: ptr Gdk3.TRectangle) {.inline.} =
  gtk_entry_get_text_area(self, text_area)
# tuple-return
# text_area: ptr Gdk3.TRectangle
# proc get_text_area*(self: Entry) {.inline.} =

# gtk_entry_get_text_length
# flags: {isMethod} container: Entry
# need sugar: is method
# return: UINT16 'uint16' 'uint16'
proc gtk_entry_get_text_length(self: ptr TEntry): uint16 {.cdecl, dynlib: lib, importc: "gtk_entry_get_text_length".}
proc get_text_length*(self: Entry): uint16 {.inline.} =
  gtk_entry_get_text_length(self)
# proc get_text_length*(self: Entry): uint16 {.inline.} =

# gtk_entry_get_visibility
# flags: {isMethod} container: Entry
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_entry_get_visibility(self: ptr TEntry): bool {.cdecl, dynlib: lib, importc: "gtk_entry_get_visibility".}
proc get_visibility*(self: Entry): bool {.inline.} =
  gtk_entry_get_visibility(self)
# proc get_visibility*(self: Entry): bool {.inline.} =

# gtk_entry_get_width_chars
# flags: {isMethod} container: Entry
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_entry_get_width_chars(self: ptr TEntry): int32 {.cdecl, dynlib: lib, importc: "gtk_entry_get_width_chars".}
proc get_width_chars*(self: Entry): int32 {.inline.} =
  gtk_entry_get_width_chars(self)
# proc get_width_chars*(self: Entry): int32 {.inline.} =

# gtk_entry_grab_focus_without_selecting
# flags: {isMethod} container: Entry
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_grab_focus_without_selecting(self: ptr TEntry) {.cdecl, dynlib: lib, importc: "gtk_entry_grab_focus_without_selecting".}
proc grab_focus_without_selecting*(self: Entry) {.inline.} =
  gtk_entry_grab_focus_without_selecting(self)
# proc grab_focus_without_selecting*(self: Entry) {.inline.} =

# gtk_entry_im_context_filter_keypress
# flags: {isMethod} container: Entry
# need sugar: is method
# arg event: INTERFACE (STRUCT) 'ptr Gdk3.TEventKey' 'ptr Gdk3.TEventKey' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_entry_im_context_filter_keypress(self: ptr TEntry, event: ptr Gdk3.TEventKey): bool {.cdecl, dynlib: lib, importc: "gtk_entry_im_context_filter_keypress".}
proc im_context_filter_keypress*(self: Entry, event: ptr Gdk3.TEventKey): bool {.inline.} =
  gtk_entry_im_context_filter_keypress(self, event)
# proc im_context_filter_keypress*(self: Entry, event: ptr Gdk3.TEventKey): bool {.inline.} =

# gtk_entry_layout_index_to_text_index
# flags: {isMethod} container: Entry
# need sugar: is method
# arg layout_index: INT32 'int32' 'int32' IN
# return: INT32 'int32' 'int32'
proc gtk_entry_layout_index_to_text_index(self: ptr TEntry, layout_index: int32): int32 {.cdecl, dynlib: lib, importc: "gtk_entry_layout_index_to_text_index".}
proc layout_index_to_text_index*(self: Entry, layout_index: int32): int32 {.inline.} =
  gtk_entry_layout_index_to_text_index(self, layout_index)
# proc layout_index_to_text_index*(self: Entry, layout_index: int32): int32 {.inline.} =

# gtk_entry_progress_pulse
# flags: {isMethod} container: Entry
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_progress_pulse(self: ptr TEntry) {.cdecl, dynlib: lib, importc: "gtk_entry_progress_pulse".}
proc progress_pulse*(self: Entry) {.inline.} =
  gtk_entry_progress_pulse(self)
# proc progress_pulse*(self: Entry) {.inline.} =

# gtk_entry_reset_im_context
# flags: {isMethod} container: Entry
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_reset_im_context(self: ptr TEntry) {.cdecl, dynlib: lib, importc: "gtk_entry_reset_im_context".}
proc reset_im_context*(self: Entry) {.inline.} =
  gtk_entry_reset_im_context(self)
# proc reset_im_context*(self: Entry) {.inline.} =

# gtk_entry_set_activates_default
# flags: {isMethod} container: Entry
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_activates_default(self: ptr TEntry, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_entry_set_activates_default".}
proc set_activates_default*(self: Entry, setting: bool) {.inline.} =
  gtk_entry_set_activates_default(self, setting)
# proc set_activates_default*(self: Entry, setting: bool) {.inline.} =

# gtk_entry_set_alignment
# flags: {isMethod} container: Entry
# need sugar: is method
# arg xalign: FLOAT 'float32' 'float32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_alignment(self: ptr TEntry, xalign: float32) {.cdecl, dynlib: lib, importc: "gtk_entry_set_alignment".}
proc set_alignment*(self: Entry, xalign: float32) {.inline.} =
  gtk_entry_set_alignment(self, xalign)
# proc set_alignment*(self: Entry, xalign: float32) {.inline.} =

# gtk_entry_set_attributes
# flags: {isMethod} container: Entry
# need sugar: is method
# arg attrs: INTERFACE (STRUCT) 'ptr Pango1.TAttrList' 'ptr Pango1.TAttrList' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_attributes(self: ptr TEntry, attrs: ptr Pango1.TAttrList) {.cdecl, dynlib: lib, importc: "gtk_entry_set_attributes".}
proc set_attributes*(self: Entry, attrs: ptr Pango1.TAttrList) {.inline.} =
  gtk_entry_set_attributes(self, attrs)
# proc set_attributes*(self: Entry, attrs: ptr Pango1.TAttrList) {.inline.} =

# gtk_entry_set_buffer
# flags: {isMethod} container: Entry
# need sugar: is method
# arg buffer: INTERFACE (OBJECT) 'EntryBuffer' 'ptr TEntryBuffer' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_buffer(self: ptr TEntry, buffer: ptr TEntryBuffer) {.cdecl, dynlib: lib, importc: "gtk_entry_set_buffer".}
proc set_buffer*(self: Entry, buffer: EntryBuffer) {.inline.} =
  gtk_entry_set_buffer(self, buffer.getPointer)
# proc set_buffer*(self: Entry, buffer: EntryBuffer) {.inline.} =

# gtk_entry_set_completion
# flags: {isMethod} container: Entry
# need sugar: is method
# arg completion: INTERFACE (OBJECT) 'EntryCompletion' 'ptr TEntryCompletion' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_completion(self: ptr TEntry, completion: ptr TEntryCompletion) {.cdecl, dynlib: lib, importc: "gtk_entry_set_completion".}
proc set_completion*(self: Entry, completion: EntryCompletion) {.inline.} =
  gtk_entry_set_completion(self, completion.getPointer)
# proc set_completion*(self: Entry, completion: EntryCompletion) {.inline.} =

# gtk_entry_set_cursor_hadjustment
# flags: {isMethod} container: Entry
# need sugar: is method
# arg adjustment: INTERFACE (OBJECT) 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_cursor_hadjustment(self: ptr TEntry, adjustment: ptr TAdjustment) {.cdecl, dynlib: lib, importc: "gtk_entry_set_cursor_hadjustment".}
proc set_cursor_hadjustment*(self: Entry, adjustment: Adjustment) {.inline.} =
  gtk_entry_set_cursor_hadjustment(self, adjustment.getPointer)
# proc set_cursor_hadjustment*(self: Entry, adjustment: Adjustment) {.inline.} =

# gtk_entry_set_has_frame
# flags: {isMethod} container: Entry
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_has_frame(self: ptr TEntry, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_entry_set_has_frame".}
proc set_has_frame*(self: Entry, setting: bool) {.inline.} =
  gtk_entry_set_has_frame(self, setting)
# proc set_has_frame*(self: Entry, setting: bool) {.inline.} =

# gtk_entry_set_icon_activatable
# flags: {isMethod} container: Entry
# need sugar: is method
# arg icon_pos: INTERFACE (ENUM) 'EntryIconPosition' 'EntryIconPosition' IN
# arg activatable: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_icon_activatable(self: ptr TEntry, icon_pos: EntryIconPosition, activatable: bool) {.cdecl, dynlib: lib, importc: "gtk_entry_set_icon_activatable".}
proc set_icon_activatable*(self: Entry, icon_pos: EntryIconPosition, activatable: bool) {.inline.} =
  gtk_entry_set_icon_activatable(self, icon_pos, activatable)
# proc set_icon_activatable*(self: Entry, icon_pos: EntryIconPosition, activatable: bool) {.inline.} =

# gtk_entry_set_icon_drag_source
# flags: {isMethod} container: Entry
# need sugar: is method
# arg icon_pos: INTERFACE (ENUM) 'EntryIconPosition' 'EntryIconPosition' IN
# arg target_list: INTERFACE (STRUCT) 'ptr TTargetList' 'ptr TTargetList' IN
# arg actions: INTERFACE (FLAGS) 'Gdk3.SDragAction' 'Gdk3.SDragAction' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_icon_drag_source(self: ptr TEntry, icon_pos: EntryIconPosition, target_list: ptr TTargetList, actions: Gdk3.SDragAction) {.cdecl, dynlib: lib, importc: "gtk_entry_set_icon_drag_source".}
proc set_icon_drag_source*(self: Entry, icon_pos: EntryIconPosition, target_list: ptr TTargetList, actions: Gdk3.SDragAction) {.inline.} =
  gtk_entry_set_icon_drag_source(self, icon_pos, target_list, actions)
# proc set_icon_drag_source*(self: Entry, icon_pos: EntryIconPosition, target_list: ptr TTargetList, actions: Gdk3.SDragAction) {.inline.} =

# gtk_entry_set_icon_from_gicon
# flags: {isMethod} container: Entry
# need sugar: is method
# arg icon_pos: INTERFACE (ENUM) 'EntryIconPosition' 'EntryIconPosition' IN
# arg icon: INTERFACE (INTERFACE) 'ptr Gio2.TIcon' 'ptr Gio2.TIcon' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_icon_from_gicon(self: ptr TEntry, icon_pos: EntryIconPosition, icon: ptr Gio2.TIcon) {.cdecl, dynlib: lib, importc: "gtk_entry_set_icon_from_gicon".}
proc set_icon_from_gicon*(self: Entry, icon_pos: EntryIconPosition, icon: ptr Gio2.TIcon) {.inline.} =
  gtk_entry_set_icon_from_gicon(self, icon_pos, icon)
# proc set_icon_from_gicon*(self: Entry, icon_pos: EntryIconPosition, icon: ptr Gio2.TIcon) {.inline.} =

# gtk_entry_set_icon_from_icon_name
# flags: {isMethod} container: Entry
# need sugar: is method
# arg icon_pos: INTERFACE (ENUM) 'EntryIconPosition' 'EntryIconPosition' IN
# arg icon_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_icon_from_icon_name(self: ptr TEntry, icon_pos: EntryIconPosition, icon_name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_entry_set_icon_from_icon_name".}
proc set_icon_from_icon_name*(self: Entry, icon_pos: EntryIconPosition, icon_name: ustring) {.inline.} =
  gtk_entry_set_icon_from_icon_name(self, icon_pos, ucstring(icon_name))
# proc set_icon_from_icon_name*(self: Entry, icon_pos: EntryIconPosition, icon_name: ustring) {.inline.} =

# gtk_entry_set_icon_from_pixbuf
# flags: {isMethod} container: Entry
# need sugar: is method
# arg icon_pos: INTERFACE (ENUM) 'EntryIconPosition' 'EntryIconPosition' IN
# arg pixbuf: INTERFACE (OBJECT) 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_icon_from_pixbuf(self: ptr TEntry, icon_pos: EntryIconPosition, pixbuf: ptr GdkPixbuf2.TPixbuf) {.cdecl, dynlib: lib, importc: "gtk_entry_set_icon_from_pixbuf".}
proc set_icon_from_pixbuf*(self: Entry, icon_pos: EntryIconPosition, pixbuf: GdkPixbuf2.Pixbuf) {.inline.} =
  gtk_entry_set_icon_from_pixbuf(self, icon_pos, pixbuf.getPointer)
# proc set_icon_from_pixbuf*(self: Entry, icon_pos: EntryIconPosition, pixbuf: GdkPixbuf2.Pixbuf) {.inline.} =

# gtk_entry_set_icon_from_stock
# flags: {isMethod} container: Entry (deprecated)
# gtk_entry_set_icon_sensitive
# flags: {isMethod} container: Entry
# need sugar: is method
# arg icon_pos: INTERFACE (ENUM) 'EntryIconPosition' 'EntryIconPosition' IN
# arg sensitive: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_icon_sensitive(self: ptr TEntry, icon_pos: EntryIconPosition, sensitive: bool) {.cdecl, dynlib: lib, importc: "gtk_entry_set_icon_sensitive".}
proc set_icon_sensitive*(self: Entry, icon_pos: EntryIconPosition, sensitive: bool) {.inline.} =
  gtk_entry_set_icon_sensitive(self, icon_pos, sensitive)
# proc set_icon_sensitive*(self: Entry, icon_pos: EntryIconPosition, sensitive: bool) {.inline.} =

# gtk_entry_set_icon_tooltip_markup
# flags: {isMethod} container: Entry
# need sugar: is method
# arg icon_pos: INTERFACE (ENUM) 'EntryIconPosition' 'EntryIconPosition' IN
# arg tooltip: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_icon_tooltip_markup(self: ptr TEntry, icon_pos: EntryIconPosition, tooltip: ucstring) {.cdecl, dynlib: lib, importc: "gtk_entry_set_icon_tooltip_markup".}
proc set_icon_tooltip_markup*(self: Entry, icon_pos: EntryIconPosition, tooltip: ustring) {.inline.} =
  gtk_entry_set_icon_tooltip_markup(self, icon_pos, ucstring(tooltip))
# proc set_icon_tooltip_markup*(self: Entry, icon_pos: EntryIconPosition, tooltip: ustring) {.inline.} =

# gtk_entry_set_icon_tooltip_text
# flags: {isMethod} container: Entry
# need sugar: is method
# arg icon_pos: INTERFACE (ENUM) 'EntryIconPosition' 'EntryIconPosition' IN
# arg tooltip: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_icon_tooltip_text(self: ptr TEntry, icon_pos: EntryIconPosition, tooltip: ucstring) {.cdecl, dynlib: lib, importc: "gtk_entry_set_icon_tooltip_text".}
proc set_icon_tooltip_text*(self: Entry, icon_pos: EntryIconPosition, tooltip: ustring) {.inline.} =
  gtk_entry_set_icon_tooltip_text(self, icon_pos, ucstring(tooltip))
# proc set_icon_tooltip_text*(self: Entry, icon_pos: EntryIconPosition, tooltip: ustring) {.inline.} =

# gtk_entry_set_inner_border
# flags: {isMethod} container: Entry (deprecated)
# gtk_entry_set_input_hints
# flags: {isMethod} container: Entry
# need sugar: is method
# arg hints: INTERFACE (FLAGS) 'SInputHints' 'SInputHints' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_input_hints(self: ptr TEntry, hints: SInputHints) {.cdecl, dynlib: lib, importc: "gtk_entry_set_input_hints".}
proc set_input_hints*(self: Entry, hints: SInputHints) {.inline.} =
  gtk_entry_set_input_hints(self, hints)
# proc set_input_hints*(self: Entry, hints: SInputHints) {.inline.} =

# gtk_entry_set_input_purpose
# flags: {isMethod} container: Entry
# need sugar: is method
# arg purpose: INTERFACE (ENUM) 'InputPurpose' 'InputPurpose' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_input_purpose(self: ptr TEntry, purpose: InputPurpose) {.cdecl, dynlib: lib, importc: "gtk_entry_set_input_purpose".}
proc set_input_purpose*(self: Entry, purpose: InputPurpose) {.inline.} =
  gtk_entry_set_input_purpose(self, purpose)
# proc set_input_purpose*(self: Entry, purpose: InputPurpose) {.inline.} =

# gtk_entry_set_invisible_char
# flags: {isMethod} container: Entry
# need sugar: is method
# arg ch: UNICHAR 'unichar' 'unichar' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_invisible_char(self: ptr TEntry, ch: unichar) {.cdecl, dynlib: lib, importc: "gtk_entry_set_invisible_char".}
proc set_invisible_char*(self: Entry, ch: unichar) {.inline.} =
  gtk_entry_set_invisible_char(self, ch)
# proc set_invisible_char*(self: Entry, ch: unichar) {.inline.} =

# gtk_entry_set_max_length
# flags: {isMethod} container: Entry
# need sugar: is method
# arg max: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_max_length(self: ptr TEntry, max: int32) {.cdecl, dynlib: lib, importc: "gtk_entry_set_max_length".}
proc set_max_length*(self: Entry, max: int32) {.inline.} =
  gtk_entry_set_max_length(self, max)
# proc set_max_length*(self: Entry, max: int32) {.inline.} =

# gtk_entry_set_max_width_chars
# flags: {isMethod} container: Entry
# need sugar: is method
# arg n_chars: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_max_width_chars(self: ptr TEntry, n_chars: int32) {.cdecl, dynlib: lib, importc: "gtk_entry_set_max_width_chars".}
proc set_max_width_chars*(self: Entry, n_chars: int32) {.inline.} =
  gtk_entry_set_max_width_chars(self, n_chars)
# proc set_max_width_chars*(self: Entry, n_chars: int32) {.inline.} =

# gtk_entry_set_overwrite_mode
# flags: {isMethod} container: Entry
# need sugar: is method
# arg overwrite: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_overwrite_mode(self: ptr TEntry, overwrite: bool) {.cdecl, dynlib: lib, importc: "gtk_entry_set_overwrite_mode".}
proc set_overwrite_mode*(self: Entry, overwrite: bool) {.inline.} =
  gtk_entry_set_overwrite_mode(self, overwrite)
# proc set_overwrite_mode*(self: Entry, overwrite: bool) {.inline.} =

# gtk_entry_set_placeholder_text
# flags: {isMethod} container: Entry
# need sugar: is method
# arg text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_placeholder_text(self: ptr TEntry, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_entry_set_placeholder_text".}
proc set_placeholder_text*(self: Entry, text: ustring) {.inline.} =
  gtk_entry_set_placeholder_text(self, ucstring(text))
# proc set_placeholder_text*(self: Entry, text: ustring) {.inline.} =

# gtk_entry_set_progress_fraction
# flags: {isMethod} container: Entry
# need sugar: is method
# arg fraction: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_progress_fraction(self: ptr TEntry, fraction: float64) {.cdecl, dynlib: lib, importc: "gtk_entry_set_progress_fraction".}
proc set_progress_fraction*(self: Entry, fraction: float64) {.inline.} =
  gtk_entry_set_progress_fraction(self, fraction)
# proc set_progress_fraction*(self: Entry, fraction: float64) {.inline.} =

# gtk_entry_set_progress_pulse_step
# flags: {isMethod} container: Entry
# need sugar: is method
# arg fraction: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_progress_pulse_step(self: ptr TEntry, fraction: float64) {.cdecl, dynlib: lib, importc: "gtk_entry_set_progress_pulse_step".}
proc set_progress_pulse_step*(self: Entry, fraction: float64) {.inline.} =
  gtk_entry_set_progress_pulse_step(self, fraction)
# proc set_progress_pulse_step*(self: Entry, fraction: float64) {.inline.} =

# gtk_entry_set_tabs
# flags: {isMethod} container: Entry
# need sugar: is method
# arg tabs: INTERFACE (STRUCT) 'ptr Pango1.TTabArray' 'ptr Pango1.TTabArray' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_tabs(self: ptr TEntry, tabs: ptr Pango1.TTabArray) {.cdecl, dynlib: lib, importc: "gtk_entry_set_tabs".}
proc set_tabs*(self: Entry, tabs: ptr Pango1.TTabArray) {.inline.} =
  gtk_entry_set_tabs(self, tabs)
# proc set_tabs*(self: Entry, tabs: ptr Pango1.TTabArray) {.inline.} =

# gtk_entry_set_text
# flags: {isMethod} container: Entry
# need sugar: is method
# arg text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_text(self: ptr TEntry, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_entry_set_text".}
proc set_text*(self: Entry, text: ustring) {.inline.} =
  gtk_entry_set_text(self, ucstring(text))
# proc set_text*(self: Entry, text: ustring) {.inline.} =

# gtk_entry_set_visibility
# flags: {isMethod} container: Entry
# need sugar: is method
# arg visible: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_visibility(self: ptr TEntry, visible: bool) {.cdecl, dynlib: lib, importc: "gtk_entry_set_visibility".}
proc set_visibility*(self: Entry, visible: bool) {.inline.} =
  gtk_entry_set_visibility(self, visible)
# proc set_visibility*(self: Entry, visible: bool) {.inline.} =

# gtk_entry_set_width_chars
# flags: {isMethod} container: Entry
# need sugar: is method
# arg n_chars: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_set_width_chars(self: ptr TEntry, n_chars: int32) {.cdecl, dynlib: lib, importc: "gtk_entry_set_width_chars".}
proc set_width_chars*(self: Entry, n_chars: int32) {.inline.} =
  gtk_entry_set_width_chars(self, n_chars)
# proc set_width_chars*(self: Entry, n_chars: int32) {.inline.} =

# gtk_entry_text_index_to_layout_index
# flags: {isMethod} container: Entry
# need sugar: is method
# arg text_index: INT32 'int32' 'int32' IN
# return: INT32 'int32' 'int32'
proc gtk_entry_text_index_to_layout_index(self: ptr TEntry, text_index: int32): int32 {.cdecl, dynlib: lib, importc: "gtk_entry_text_index_to_layout_index".}
proc text_index_to_layout_index*(self: Entry, text_index: int32): int32 {.inline.} =
  gtk_entry_text_index_to_layout_index(self, text_index)
# proc text_index_to_layout_index*(self: Entry, text_index: int32): int32 {.inline.} =

# gtk_entry_unset_invisible_char
# flags: {isMethod} container: Entry
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_unset_invisible_char(self: ptr TEntry) {.cdecl, dynlib: lib, importc: "gtk_entry_unset_invisible_char".}
proc unset_invisible_char*(self: Entry) {.inline.} =
  gtk_entry_unset_invisible_char(self)
# proc unset_invisible_char*(self: Entry) {.inline.} =

# initializer for EntryAccessible: gtk_entry_accessible_get_type
proc gtk_entry_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_entry_accessible_get_type".}
template gtype*(klass_parameter: typedesc[EntryAccessible]): GType = gtk_entry_accessible_get_type()
# initializer for EntryBuffer: gtk_entry_buffer_get_type
proc gtk_entry_buffer_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_entry_buffer_get_type".}
template gtype*(klass_parameter: typedesc[EntryBuffer]): GType = gtk_entry_buffer_get_type()
# gtk_entry_buffer_new
# flags: {isConstructor} container: EntryBuffer
# need sugar: is static method
# arg initial_chars: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg n_initial_chars: INT32 'int32' 'int32' IN
# return: INTERFACE 'EntryBuffer' 'TransferFull[TEntryBuffer]' (diff., need sugar)
proc gtk_entry_buffer_new(initial_chars: ucstring, n_initial_chars: int32): TransferFull[TEntryBuffer] {.cdecl, dynlib: lib, importc: "gtk_entry_buffer_new".}
proc new_entrybuffer*(initial_chars: ustring, n_initial_chars: int32): EntryBuffer {.inline.} =
  wrap(gtk_entry_buffer_new(ucstring(initial_chars), n_initial_chars))
# proc new_entrybuffer*(initial_chars: ustring, n_initial_chars: int32): EntryBuffer {.inline.} =

# gtk_entry_buffer_delete_text
# flags: {isMethod} container: EntryBuffer
# need sugar: is method
# arg position: UINT32 'uint32' 'uint32' IN
# arg n_chars: INT32 'int32' 'int32' IN
# return: UINT32 'uint32' 'uint32'
proc gtk_entry_buffer_delete_text(self: ptr TEntryBuffer, position: uint32, n_chars: int32): uint32 {.cdecl, dynlib: lib, importc: "gtk_entry_buffer_delete_text".}
proc delete_text*(self: EntryBuffer, position: uint32, n_chars: int32): uint32 {.inline.} =
  gtk_entry_buffer_delete_text(self, position, n_chars)
# proc delete_text*(self: EntryBuffer, position: uint32, n_chars: int32): uint32 {.inline.} =

# gtk_entry_buffer_emit_deleted_text
# flags: {isMethod} container: EntryBuffer
# need sugar: is method
# arg position: UINT32 'uint32' 'uint32' IN
# arg n_chars: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_buffer_emit_deleted_text(self: ptr TEntryBuffer, position: uint32, n_chars: uint32) {.cdecl, dynlib: lib, importc: "gtk_entry_buffer_emit_deleted_text".}
proc emit_deleted_text*(self: EntryBuffer, position: uint32, n_chars: uint32) {.inline.} =
  gtk_entry_buffer_emit_deleted_text(self, position, n_chars)
# proc emit_deleted_text*(self: EntryBuffer, position: uint32, n_chars: uint32) {.inline.} =

# gtk_entry_buffer_emit_inserted_text
# flags: {isMethod} container: EntryBuffer
# need sugar: is method
# arg position: UINT32 'uint32' 'uint32' IN
# arg chars: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg n_chars: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_buffer_emit_inserted_text(self: ptr TEntryBuffer, position: uint32, chars: ucstring, n_chars: uint32) {.cdecl, dynlib: lib, importc: "gtk_entry_buffer_emit_inserted_text".}
proc emit_inserted_text*(self: EntryBuffer, position: uint32, chars: ustring, n_chars: uint32) {.inline.} =
  gtk_entry_buffer_emit_inserted_text(self, position, ucstring(chars), n_chars)
# proc emit_inserted_text*(self: EntryBuffer, position: uint32, chars: ustring, n_chars: uint32) {.inline.} =

# gtk_entry_buffer_get_bytes
# flags: {isMethod} container: EntryBuffer
# need sugar: is method
# return: UINT32 'uint32' 'uint32'
proc gtk_entry_buffer_get_bytes(self: ptr TEntryBuffer): uint32 {.cdecl, dynlib: lib, importc: "gtk_entry_buffer_get_bytes".}
proc get_bytes*(self: EntryBuffer): uint32 {.inline.} =
  gtk_entry_buffer_get_bytes(self)
# proc get_bytes*(self: EntryBuffer): uint32 {.inline.} =

# gtk_entry_buffer_get_length
# flags: {isMethod} container: EntryBuffer
# need sugar: is method
# return: UINT32 'uint32' 'uint32'
proc gtk_entry_buffer_get_length(self: ptr TEntryBuffer): uint32 {.cdecl, dynlib: lib, importc: "gtk_entry_buffer_get_length".}
proc get_length*(self: EntryBuffer): uint32 {.inline.} =
  gtk_entry_buffer_get_length(self)
# proc get_length*(self: EntryBuffer): uint32 {.inline.} =

# gtk_entry_buffer_get_max_length
# flags: {isMethod} container: EntryBuffer
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_entry_buffer_get_max_length(self: ptr TEntryBuffer): int32 {.cdecl, dynlib: lib, importc: "gtk_entry_buffer_get_max_length".}
proc get_max_length*(self: EntryBuffer): int32 {.inline.} =
  gtk_entry_buffer_get_max_length(self)
# proc get_max_length*(self: EntryBuffer): int32 {.inline.} =

# gtk_entry_buffer_get_text
# flags: {isMethod} container: EntryBuffer
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_entry_buffer_get_text(self: ptr TEntryBuffer): ucstring {.cdecl, dynlib: lib, importc: "gtk_entry_buffer_get_text".}
proc get_text*(self: EntryBuffer): ucstring {.inline.} =
  gtk_entry_buffer_get_text(self)
# proc get_text*(self: EntryBuffer): ucstring {.inline.} =

# gtk_entry_buffer_insert_text
# flags: {isMethod} container: EntryBuffer
# need sugar: is method
# arg position: UINT32 'uint32' 'uint32' IN
# arg chars: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg n_chars: INT32 'int32' 'int32' IN
# return: UINT32 'uint32' 'uint32'
proc gtk_entry_buffer_insert_text(self: ptr TEntryBuffer, position: uint32, chars: ucstring, n_chars: int32): uint32 {.cdecl, dynlib: lib, importc: "gtk_entry_buffer_insert_text".}
proc insert_text*(self: EntryBuffer, position: uint32, chars: ustring, n_chars: int32): uint32 {.inline.} =
  gtk_entry_buffer_insert_text(self, position, ucstring(chars), n_chars)
# proc insert_text*(self: EntryBuffer, position: uint32, chars: ustring, n_chars: int32): uint32 {.inline.} =

# gtk_entry_buffer_set_max_length
# flags: {isMethod} container: EntryBuffer
# need sugar: is method
# arg max_length: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_buffer_set_max_length(self: ptr TEntryBuffer, max_length: int32) {.cdecl, dynlib: lib, importc: "gtk_entry_buffer_set_max_length".}
proc set_max_length*(self: EntryBuffer, max_length: int32) {.inline.} =
  gtk_entry_buffer_set_max_length(self, max_length)
# proc set_max_length*(self: EntryBuffer, max_length: int32) {.inline.} =

# gtk_entry_buffer_set_text
# flags: {isMethod} container: EntryBuffer
# need sugar: is method
# arg chars: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg n_chars: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_buffer_set_text(self: ptr TEntryBuffer, chars: ucstring, n_chars: int32) {.cdecl, dynlib: lib, importc: "gtk_entry_buffer_set_text".}
proc set_text*(self: EntryBuffer, chars: ustring, n_chars: int32) {.inline.} =
  gtk_entry_buffer_set_text(self, ucstring(chars), n_chars)
# proc set_text*(self: EntryBuffer, chars: ustring, n_chars: int32) {.inline.} =

# initializer for EntryCompletion: gtk_entry_completion_get_type
proc gtk_entry_completion_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_entry_completion_get_type".}
template gtype*(klass_parameter: typedesc[EntryCompletion]): GType = gtk_entry_completion_get_type()
# gtk_entry_completion_new
# flags: {isConstructor} container: EntryCompletion
# need sugar: is static method
# return: INTERFACE 'EntryCompletion' 'TransferFull[TEntryCompletion]' (diff., need sugar)
proc gtk_entry_completion_new(): TransferFull[TEntryCompletion] {.cdecl, dynlib: lib, importc: "gtk_entry_completion_new".}
proc new_entrycompletion*(): EntryCompletion {.inline.} =
  wrap(gtk_entry_completion_new())
# proc new_entrycompletion*(): EntryCompletion {.inline.} =

# gtk_entry_completion_new_with_area
# flags: {isConstructor} container: EntryCompletion
# need sugar: is static method
# arg area: INTERFACE (OBJECT) 'CellArea' 'ptr TCellArea' IN (diff., need sugar)
# return: INTERFACE 'EntryCompletion' 'TransferFull[TEntryCompletion]' (diff., need sugar)
proc gtk_entry_completion_new_with_area(area: ptr TCellArea): TransferFull[TEntryCompletion] {.cdecl, dynlib: lib, importc: "gtk_entry_completion_new_with_area".}
proc new_entrycompletion_with_area*(area: CellArea): EntryCompletion {.inline.} =
  wrap(gtk_entry_completion_new_with_area(area.getPointer))
# proc new_entrycompletion_with_area*(area: CellArea): EntryCompletion {.inline.} =

# gtk_entry_completion_complete
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_complete(self: ptr TEntryCompletion) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_complete".}
proc complete*(self: EntryCompletion) {.inline.} =
  gtk_entry_completion_complete(self)
# proc complete*(self: EntryCompletion) {.inline.} =

# gtk_entry_completion_compute_prefix
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# arg key: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: UTF8 'ucstring' 'ucstring'
proc gtk_entry_completion_compute_prefix(self: ptr TEntryCompletion, key: ucstring): ucstring {.cdecl, dynlib: lib, importc: "gtk_entry_completion_compute_prefix".}
proc compute_prefix*(self: EntryCompletion, key: ustring): ucstring {.inline.} =
  gtk_entry_completion_compute_prefix(self, ucstring(key))
# proc compute_prefix*(self: EntryCompletion, key: ustring): ucstring {.inline.} =

# gtk_entry_completion_delete_action
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# arg index_: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_delete_action(self: ptr TEntryCompletion, index_x: int32) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_delete_action".}
proc delete_action*(self: EntryCompletion, index_x: int32) {.inline.} =
  gtk_entry_completion_delete_action(self, index_x)
# proc delete_action*(self: EntryCompletion, index_x: int32) {.inline.} =

# gtk_entry_completion_get_completion_prefix
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_entry_completion_get_completion_prefix(self: ptr TEntryCompletion): ucstring {.cdecl, dynlib: lib, importc: "gtk_entry_completion_get_completion_prefix".}
proc get_completion_prefix*(self: EntryCompletion): ucstring {.inline.} =
  gtk_entry_completion_get_completion_prefix(self)
# proc get_completion_prefix*(self: EntryCompletion): ucstring {.inline.} =

# gtk_entry_completion_get_entry
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_entry_completion_get_entry(self: ptr TEntryCompletion): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_entry_completion_get_entry".}
proc get_entry*(self: EntryCompletion): Widget {.inline.} =
  wrap(gtk_entry_completion_get_entry(self))
# proc get_entry*(self: EntryCompletion): Widget {.inline.} =

# gtk_entry_completion_get_inline_completion
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_entry_completion_get_inline_completion(self: ptr TEntryCompletion): bool {.cdecl, dynlib: lib, importc: "gtk_entry_completion_get_inline_completion".}
proc get_inline_completion*(self: EntryCompletion): bool {.inline.} =
  gtk_entry_completion_get_inline_completion(self)
# proc get_inline_completion*(self: EntryCompletion): bool {.inline.} =

# gtk_entry_completion_get_inline_selection
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_entry_completion_get_inline_selection(self: ptr TEntryCompletion): bool {.cdecl, dynlib: lib, importc: "gtk_entry_completion_get_inline_selection".}
proc get_inline_selection*(self: EntryCompletion): bool {.inline.} =
  gtk_entry_completion_get_inline_selection(self)
# proc get_inline_selection*(self: EntryCompletion): bool {.inline.} =

# gtk_entry_completion_get_minimum_key_length
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_entry_completion_get_minimum_key_length(self: ptr TEntryCompletion): int32 {.cdecl, dynlib: lib, importc: "gtk_entry_completion_get_minimum_key_length".}
proc get_minimum_key_length*(self: EntryCompletion): int32 {.inline.} =
  gtk_entry_completion_get_minimum_key_length(self)
# proc get_minimum_key_length*(self: EntryCompletion): int32 {.inline.} =

# gtk_entry_completion_get_model
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# return: INTERFACE 'ptr TTreeModel' 'TransferNone[TTreeModel]' (diff., need sugar)
proc gtk_entry_completion_get_model(self: ptr TEntryCompletion): TransferNone[TTreeModel] {.cdecl, dynlib: lib, importc: "gtk_entry_completion_get_model".}
proc get_model*(self: EntryCompletion): ptr TTreeModel {.inline.} =
  wrap(gtk_entry_completion_get_model(self))
# proc get_model*(self: EntryCompletion): ptr TTreeModel {.inline.} =

# gtk_entry_completion_get_popup_completion
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_entry_completion_get_popup_completion(self: ptr TEntryCompletion): bool {.cdecl, dynlib: lib, importc: "gtk_entry_completion_get_popup_completion".}
proc get_popup_completion*(self: EntryCompletion): bool {.inline.} =
  gtk_entry_completion_get_popup_completion(self)
# proc get_popup_completion*(self: EntryCompletion): bool {.inline.} =

# gtk_entry_completion_get_popup_set_width
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_entry_completion_get_popup_set_width(self: ptr TEntryCompletion): bool {.cdecl, dynlib: lib, importc: "gtk_entry_completion_get_popup_set_width".}
proc get_popup_set_width*(self: EntryCompletion): bool {.inline.} =
  gtk_entry_completion_get_popup_set_width(self)
# proc get_popup_set_width*(self: EntryCompletion): bool {.inline.} =

# gtk_entry_completion_get_popup_single_match
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_entry_completion_get_popup_single_match(self: ptr TEntryCompletion): bool {.cdecl, dynlib: lib, importc: "gtk_entry_completion_get_popup_single_match".}
proc get_popup_single_match*(self: EntryCompletion): bool {.inline.} =
  gtk_entry_completion_get_popup_single_match(self)
# proc get_popup_single_match*(self: EntryCompletion): bool {.inline.} =

# gtk_entry_completion_get_text_column
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_entry_completion_get_text_column(self: ptr TEntryCompletion): int32 {.cdecl, dynlib: lib, importc: "gtk_entry_completion_get_text_column".}
proc get_text_column*(self: EntryCompletion): int32 {.inline.} =
  gtk_entry_completion_get_text_column(self)
# proc get_text_column*(self: EntryCompletion): int32 {.inline.} =

# gtk_entry_completion_insert_action_markup
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# arg index_: INT32 'int32' 'int32' IN
# arg markup: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_insert_action_markup(self: ptr TEntryCompletion, index_x: int32, markup: ucstring) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_insert_action_markup".}
proc insert_action_markup*(self: EntryCompletion, index_x: int32, markup: ustring) {.inline.} =
  gtk_entry_completion_insert_action_markup(self, index_x, ucstring(markup))
# proc insert_action_markup*(self: EntryCompletion, index_x: int32, markup: ustring) {.inline.} =

# gtk_entry_completion_insert_action_text
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# arg index_: INT32 'int32' 'int32' IN
# arg text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_insert_action_text(self: ptr TEntryCompletion, index_x: int32, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_insert_action_text".}
proc insert_action_text*(self: EntryCompletion, index_x: int32, text: ustring) {.inline.} =
  gtk_entry_completion_insert_action_text(self, index_x, ucstring(text))
# proc insert_action_text*(self: EntryCompletion, index_x: int32, text: ustring) {.inline.} =

# gtk_entry_completion_insert_prefix
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_insert_prefix(self: ptr TEntryCompletion) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_insert_prefix".}
proc insert_prefix*(self: EntryCompletion) {.inline.} =
  gtk_entry_completion_insert_prefix(self)
# proc insert_prefix*(self: EntryCompletion) {.inline.} =

# gtk_entry_completion_set_inline_completion
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# arg inline_completion: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_set_inline_completion(self: ptr TEntryCompletion, inline_completion: bool) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_set_inline_completion".}
proc set_inline_completion*(self: EntryCompletion, inline_completion: bool) {.inline.} =
  gtk_entry_completion_set_inline_completion(self, inline_completion)
# proc set_inline_completion*(self: EntryCompletion, inline_completion: bool) {.inline.} =

# gtk_entry_completion_set_inline_selection
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# arg inline_selection: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_set_inline_selection(self: ptr TEntryCompletion, inline_selection: bool) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_set_inline_selection".}
proc set_inline_selection*(self: EntryCompletion, inline_selection: bool) {.inline.} =
  gtk_entry_completion_set_inline_selection(self, inline_selection)
# proc set_inline_selection*(self: EntryCompletion, inline_selection: bool) {.inline.} =

# gtk_entry_completion_set_match_func
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# arg func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg func_data: VOID 'pointer' 'pointer' IN
# arg func_notify: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_set_match_func(self: ptr TEntryCompletion, func_x: pointer, func_data: pointer, func_notify: pointer) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_set_match_func".}
proc set_match_func*(self: EntryCompletion, func_x: pointer, func_data: pointer, func_notify: pointer) {.inline.} =
  gtk_entry_completion_set_match_func(self, func_x, func_data, func_notify)
# proc set_match_func*(self: EntryCompletion, func_x: pointer, func_data: pointer, func_notify: pointer) {.inline.} =

# gtk_entry_completion_set_minimum_key_length
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# arg length: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_set_minimum_key_length(self: ptr TEntryCompletion, length: int32) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_set_minimum_key_length".}
proc set_minimum_key_length*(self: EntryCompletion, length: int32) {.inline.} =
  gtk_entry_completion_set_minimum_key_length(self, length)
# proc set_minimum_key_length*(self: EntryCompletion, length: int32) {.inline.} =

# gtk_entry_completion_set_model
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# arg model: INTERFACE (INTERFACE) 'ptr TTreeModel' 'ptr TTreeModel' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_set_model(self: ptr TEntryCompletion, model: ptr TTreeModel) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_set_model".}
proc set_model*(self: EntryCompletion, model: ptr TTreeModel) {.inline.} =
  gtk_entry_completion_set_model(self, model)
# proc set_model*(self: EntryCompletion, model: ptr TTreeModel) {.inline.} =

# gtk_entry_completion_set_popup_completion
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# arg popup_completion: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_set_popup_completion(self: ptr TEntryCompletion, popup_completion: bool) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_set_popup_completion".}
proc set_popup_completion*(self: EntryCompletion, popup_completion: bool) {.inline.} =
  gtk_entry_completion_set_popup_completion(self, popup_completion)
# proc set_popup_completion*(self: EntryCompletion, popup_completion: bool) {.inline.} =

# gtk_entry_completion_set_popup_set_width
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# arg popup_set_width: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_set_popup_set_width(self: ptr TEntryCompletion, popup_set_width: bool) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_set_popup_set_width".}
proc set_popup_set_width*(self: EntryCompletion, popup_set_width: bool) {.inline.} =
  gtk_entry_completion_set_popup_set_width(self, popup_set_width)
# proc set_popup_set_width*(self: EntryCompletion, popup_set_width: bool) {.inline.} =

# gtk_entry_completion_set_popup_single_match
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# arg popup_single_match: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_set_popup_single_match(self: ptr TEntryCompletion, popup_single_match: bool) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_set_popup_single_match".}
proc set_popup_single_match*(self: EntryCompletion, popup_single_match: bool) {.inline.} =
  gtk_entry_completion_set_popup_single_match(self, popup_single_match)
# proc set_popup_single_match*(self: EntryCompletion, popup_single_match: bool) {.inline.} =

# gtk_entry_completion_set_text_column
# flags: {isMethod} container: EntryCompletion
# need sugar: is method
# arg column: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_entry_completion_set_text_column(self: ptr TEntryCompletion, column: int32) {.cdecl, dynlib: lib, importc: "gtk_entry_completion_set_text_column".}
proc set_text_column*(self: EntryCompletion, column: int32) {.inline.} =
  gtk_entry_completion_set_text_column(self, column)
# proc set_text_column*(self: EntryCompletion, column: int32) {.inline.} =

# initializer for EntryIconAccessible: gtk_entry_icon_accessible_get_type
proc gtk_entry_icon_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_entry_icon_accessible_get_type".}
template gtype*(klass_parameter: typedesc[EntryIconAccessible]): GType = gtk_entry_icon_accessible_get_type()
# initializer for EventBox: gtk_event_box_get_type
proc gtk_event_box_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_event_box_get_type".}
template gtype*(klass_parameter: typedesc[EventBox]): GType = gtk_event_box_get_type()
# gtk_event_box_new
# flags: {isConstructor} container: EventBox
# need sugar: is static method
# return: INTERFACE 'EventBox' 'TransferNone[TEventBox]' (diff., need sugar)
proc gtk_event_box_new(): TransferNone[TEventBox] {.cdecl, dynlib: lib, importc: "gtk_event_box_new".}
proc new_eventbox*(): EventBox {.inline.} =
  wrap(gtk_event_box_new())
# proc new_eventbox*(): EventBox {.inline.} =

# gtk_event_box_get_above_child
# flags: {isMethod} container: EventBox
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_event_box_get_above_child(self: ptr TEventBox): bool {.cdecl, dynlib: lib, importc: "gtk_event_box_get_above_child".}
proc get_above_child*(self: EventBox): bool {.inline.} =
  gtk_event_box_get_above_child(self)
# proc get_above_child*(self: EventBox): bool {.inline.} =

# gtk_event_box_get_visible_window
# flags: {isMethod} container: EventBox
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_event_box_get_visible_window(self: ptr TEventBox): bool {.cdecl, dynlib: lib, importc: "gtk_event_box_get_visible_window".}
proc get_visible_window*(self: EventBox): bool {.inline.} =
  gtk_event_box_get_visible_window(self)
# proc get_visible_window*(self: EventBox): bool {.inline.} =

# gtk_event_box_set_above_child
# flags: {isMethod} container: EventBox
# need sugar: is method
# arg above_child: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_event_box_set_above_child(self: ptr TEventBox, above_child: bool) {.cdecl, dynlib: lib, importc: "gtk_event_box_set_above_child".}
proc set_above_child*(self: EventBox, above_child: bool) {.inline.} =
  gtk_event_box_set_above_child(self, above_child)
# proc set_above_child*(self: EventBox, above_child: bool) {.inline.} =

# gtk_event_box_set_visible_window
# flags: {isMethod} container: EventBox
# need sugar: is method
# arg visible_window: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_event_box_set_visible_window(self: ptr TEventBox, visible_window: bool) {.cdecl, dynlib: lib, importc: "gtk_event_box_set_visible_window".}
proc set_visible_window*(self: EventBox, visible_window: bool) {.inline.} =
  gtk_event_box_set_visible_window(self, visible_window)
# proc set_visible_window*(self: EventBox, visible_window: bool) {.inline.} =

# initializer for EventController: gtk_event_controller_get_type
proc gtk_event_controller_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_event_controller_get_type".}
template gtype*(klass_parameter: typedesc[EventController]): GType = gtk_event_controller_get_type()
# gtk_event_controller_get_propagation_phase
# flags: {isMethod} container: EventController
# need sugar: is method
# return: INTERFACE 'PropagationPhase' 'PropagationPhase'
proc gtk_event_controller_get_propagation_phase(self: ptr TEventController): PropagationPhase {.cdecl, dynlib: lib, importc: "gtk_event_controller_get_propagation_phase".}
proc get_propagation_phase*(self: EventController): PropagationPhase {.inline.} =
  gtk_event_controller_get_propagation_phase(self)
# proc get_propagation_phase*(self: EventController): PropagationPhase {.inline.} =

# gtk_event_controller_get_widget
# flags: {isMethod} container: EventController
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_event_controller_get_widget(self: ptr TEventController): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_event_controller_get_widget".}
proc get_widget*(self: EventController): Widget {.inline.} =
  wrap(gtk_event_controller_get_widget(self))
# proc get_widget*(self: EventController): Widget {.inline.} =

# gtk_event_controller_handle_event
# flags: {isMethod} container: EventController
# need sugar: is method
# arg event: INTERFACE (UNION) 'ptr Gdk3.TEvent' 'ptr Gdk3.TEvent' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_event_controller_handle_event(self: ptr TEventController, event: ptr Gdk3.TEvent): bool {.cdecl, dynlib: lib, importc: "gtk_event_controller_handle_event".}
proc handle_event*(self: EventController, event: ptr Gdk3.TEvent): bool {.inline.} =
  gtk_event_controller_handle_event(self, event)
# proc handle_event*(self: EventController, event: ptr Gdk3.TEvent): bool {.inline.} =

# gtk_event_controller_reset
# flags: {isMethod} container: EventController
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_event_controller_reset(self: ptr TEventController) {.cdecl, dynlib: lib, importc: "gtk_event_controller_reset".}
proc reset*(self: EventController) {.inline.} =
  gtk_event_controller_reset(self)
# proc reset*(self: EventController) {.inline.} =

# gtk_event_controller_set_propagation_phase
# flags: {isMethod} container: EventController
# need sugar: is method
# arg phase: INTERFACE (ENUM) 'PropagationPhase' 'PropagationPhase' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_event_controller_set_propagation_phase(self: ptr TEventController, phase: PropagationPhase) {.cdecl, dynlib: lib, importc: "gtk_event_controller_set_propagation_phase".}
proc set_propagation_phase*(self: EventController, phase: PropagationPhase) {.inline.} =
  gtk_event_controller_set_propagation_phase(self, phase)
# proc set_propagation_phase*(self: EventController, phase: PropagationPhase) {.inline.} =

# initializer for Expander: gtk_expander_get_type
proc gtk_expander_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_expander_get_type".}
template gtype*(klass_parameter: typedesc[Expander]): GType = gtk_expander_get_type()
# gtk_expander_new
# flags: {isConstructor} container: Expander
# need sugar: is static method
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'Expander' 'TransferNone[TExpander]' (diff., need sugar)
proc gtk_expander_new(label: ucstring): TransferNone[TExpander] {.cdecl, dynlib: lib, importc: "gtk_expander_new".}
proc new_expander*(label: ustring): Expander {.inline.} =
  wrap(gtk_expander_new(ucstring(label)))
# proc new_expander*(label: ustring): Expander {.inline.} =

# gtk_expander_new_with_mnemonic
# flags: {isConstructor} container: Expander
# need sugar: is static method
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'Expander' 'TransferNone[TExpander]' (diff., need sugar)
proc gtk_expander_new_with_mnemonic(label: ucstring): TransferNone[TExpander] {.cdecl, dynlib: lib, importc: "gtk_expander_new_with_mnemonic".}
proc new_expander_with_mnemonic*(label: ustring): Expander {.inline.} =
  wrap(gtk_expander_new_with_mnemonic(ucstring(label)))
# proc new_expander_with_mnemonic*(label: ustring): Expander {.inline.} =

# gtk_expander_get_expanded
# flags: {isMethod} container: Expander
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_expander_get_expanded(self: ptr TExpander): bool {.cdecl, dynlib: lib, importc: "gtk_expander_get_expanded".}
proc get_expanded*(self: Expander): bool {.inline.} =
  gtk_expander_get_expanded(self)
# proc get_expanded*(self: Expander): bool {.inline.} =

# gtk_expander_get_label
# flags: {isMethod} container: Expander
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_expander_get_label(self: ptr TExpander): ucstring {.cdecl, dynlib: lib, importc: "gtk_expander_get_label".}
proc get_label*(self: Expander): ucstring {.inline.} =
  gtk_expander_get_label(self)
# proc get_label*(self: Expander): ucstring {.inline.} =

# gtk_expander_get_label_fill
# flags: {isMethod} container: Expander
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_expander_get_label_fill(self: ptr TExpander): bool {.cdecl, dynlib: lib, importc: "gtk_expander_get_label_fill".}
proc get_label_fill*(self: Expander): bool {.inline.} =
  gtk_expander_get_label_fill(self)
# proc get_label_fill*(self: Expander): bool {.inline.} =

# gtk_expander_get_label_widget
# flags: {isMethod} container: Expander
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_expander_get_label_widget(self: ptr TExpander): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_expander_get_label_widget".}
proc get_label_widget*(self: Expander): Widget {.inline.} =
  wrap(gtk_expander_get_label_widget(self))
# proc get_label_widget*(self: Expander): Widget {.inline.} =

# gtk_expander_get_resize_toplevel
# flags: {isMethod} container: Expander
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_expander_get_resize_toplevel(self: ptr TExpander): bool {.cdecl, dynlib: lib, importc: "gtk_expander_get_resize_toplevel".}
proc get_resize_toplevel*(self: Expander): bool {.inline.} =
  gtk_expander_get_resize_toplevel(self)
# proc get_resize_toplevel*(self: Expander): bool {.inline.} =

# gtk_expander_get_spacing
# flags: {isMethod} container: Expander
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_expander_get_spacing(self: ptr TExpander): int32 {.cdecl, dynlib: lib, importc: "gtk_expander_get_spacing".}
proc get_spacing*(self: Expander): int32 {.inline.} =
  gtk_expander_get_spacing(self)
# proc get_spacing*(self: Expander): int32 {.inline.} =

# gtk_expander_get_use_markup
# flags: {isMethod} container: Expander
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_expander_get_use_markup(self: ptr TExpander): bool {.cdecl, dynlib: lib, importc: "gtk_expander_get_use_markup".}
proc get_use_markup*(self: Expander): bool {.inline.} =
  gtk_expander_get_use_markup(self)
# proc get_use_markup*(self: Expander): bool {.inline.} =

# gtk_expander_get_use_underline
# flags: {isMethod} container: Expander
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_expander_get_use_underline(self: ptr TExpander): bool {.cdecl, dynlib: lib, importc: "gtk_expander_get_use_underline".}
proc get_use_underline*(self: Expander): bool {.inline.} =
  gtk_expander_get_use_underline(self)
# proc get_use_underline*(self: Expander): bool {.inline.} =

# gtk_expander_set_expanded
# flags: {isMethod} container: Expander
# need sugar: is method
# arg expanded: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_expander_set_expanded(self: ptr TExpander, expanded: bool) {.cdecl, dynlib: lib, importc: "gtk_expander_set_expanded".}
proc set_expanded*(self: Expander, expanded: bool) {.inline.} =
  gtk_expander_set_expanded(self, expanded)
# proc set_expanded*(self: Expander, expanded: bool) {.inline.} =

# gtk_expander_set_label
# flags: {isMethod} container: Expander
# need sugar: is method
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_expander_set_label(self: ptr TExpander, label: ucstring) {.cdecl, dynlib: lib, importc: "gtk_expander_set_label".}
proc set_label*(self: Expander, label: ustring) {.inline.} =
  gtk_expander_set_label(self, ucstring(label))
# proc set_label*(self: Expander, label: ustring) {.inline.} =

# gtk_expander_set_label_fill
# flags: {isMethod} container: Expander
# need sugar: is method
# arg label_fill: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_expander_set_label_fill(self: ptr TExpander, label_fill: bool) {.cdecl, dynlib: lib, importc: "gtk_expander_set_label_fill".}
proc set_label_fill*(self: Expander, label_fill: bool) {.inline.} =
  gtk_expander_set_label_fill(self, label_fill)
# proc set_label_fill*(self: Expander, label_fill: bool) {.inline.} =

# gtk_expander_set_label_widget
# flags: {isMethod} container: Expander
# need sugar: is method
# arg label_widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_expander_set_label_widget(self: ptr TExpander, label_widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_expander_set_label_widget".}
proc set_label_widget*(self: Expander, label_widget: Widget) {.inline.} =
  gtk_expander_set_label_widget(self, label_widget.getPointer)
# proc set_label_widget*(self: Expander, label_widget: Widget) {.inline.} =

# gtk_expander_set_resize_toplevel
# flags: {isMethod} container: Expander
# need sugar: is method
# arg resize_toplevel: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_expander_set_resize_toplevel(self: ptr TExpander, resize_toplevel: bool) {.cdecl, dynlib: lib, importc: "gtk_expander_set_resize_toplevel".}
proc set_resize_toplevel*(self: Expander, resize_toplevel: bool) {.inline.} =
  gtk_expander_set_resize_toplevel(self, resize_toplevel)
# proc set_resize_toplevel*(self: Expander, resize_toplevel: bool) {.inline.} =

# gtk_expander_set_spacing
# flags: {isMethod} container: Expander
# need sugar: is method
# arg spacing: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_expander_set_spacing(self: ptr TExpander, spacing: int32) {.cdecl, dynlib: lib, importc: "gtk_expander_set_spacing".}
proc set_spacing*(self: Expander, spacing: int32) {.inline.} =
  gtk_expander_set_spacing(self, spacing)
# proc set_spacing*(self: Expander, spacing: int32) {.inline.} =

# gtk_expander_set_use_markup
# flags: {isMethod} container: Expander
# need sugar: is method
# arg use_markup: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_expander_set_use_markup(self: ptr TExpander, use_markup: bool) {.cdecl, dynlib: lib, importc: "gtk_expander_set_use_markup".}
proc set_use_markup*(self: Expander, use_markup: bool) {.inline.} =
  gtk_expander_set_use_markup(self, use_markup)
# proc set_use_markup*(self: Expander, use_markup: bool) {.inline.} =

# gtk_expander_set_use_underline
# flags: {isMethod} container: Expander
# need sugar: is method
# arg use_underline: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_expander_set_use_underline(self: ptr TExpander, use_underline: bool) {.cdecl, dynlib: lib, importc: "gtk_expander_set_use_underline".}
proc set_use_underline*(self: Expander, use_underline: bool) {.inline.} =
  gtk_expander_set_use_underline(self, use_underline)
# proc set_use_underline*(self: Expander, use_underline: bool) {.inline.} =

# initializer for ExpanderAccessible: gtk_expander_accessible_get_type
proc gtk_expander_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_expander_accessible_get_type".}
template gtype*(klass_parameter: typedesc[ExpanderAccessible]): GType = gtk_expander_accessible_get_type()
# initializer for FileChooserButton: gtk_file_chooser_button_get_type
proc gtk_file_chooser_button_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_file_chooser_button_get_type".}
template gtype*(klass_parameter: typedesc[FileChooserButton]): GType = gtk_file_chooser_button_get_type()
# gtk_file_chooser_button_new
# flags: {isConstructor} container: FileChooserButton
# need sugar: is static method
# arg title: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg action: INTERFACE (ENUM) 'FileChooserAction' 'FileChooserAction' IN
# return: INTERFACE 'FileChooserButton' 'TransferNone[TFileChooserButton]' (diff., need sugar)
proc gtk_file_chooser_button_new(title: ucstring, action: FileChooserAction): TransferNone[TFileChooserButton] {.cdecl, dynlib: lib, importc: "gtk_file_chooser_button_new".}
proc new_filechooserbutton*(title: ustring, action: FileChooserAction): FileChooserButton {.inline.} =
  wrap(gtk_file_chooser_button_new(ucstring(title), action))
# proc new_filechooserbutton*(title: ustring, action: FileChooserAction): FileChooserButton {.inline.} =

# gtk_file_chooser_button_new_with_dialog
# flags: {isConstructor} container: FileChooserButton
# need sugar: is static method
# arg dialog: INTERFACE (OBJECT) 'Dialog' 'ptr TDialog' IN (diff., need sugar)
# return: INTERFACE 'FileChooserButton' 'TransferNone[TFileChooserButton]' (diff., need sugar)
proc gtk_file_chooser_button_new_with_dialog(dialog: ptr TDialog): TransferNone[TFileChooserButton] {.cdecl, dynlib: lib, importc: "gtk_file_chooser_button_new_with_dialog".}
proc new_filechooserbutton_with_dialog*(dialog: Dialog): FileChooserButton {.inline.} =
  wrap(gtk_file_chooser_button_new_with_dialog(dialog.getPointer))
# proc new_filechooserbutton_with_dialog*(dialog: Dialog): FileChooserButton {.inline.} =

# gtk_file_chooser_button_get_focus_on_click
# flags: {isMethod} container: FileChooserButton
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_file_chooser_button_get_focus_on_click(self: ptr TFileChooserButton): bool {.cdecl, dynlib: lib, importc: "gtk_file_chooser_button_get_focus_on_click".}
proc get_focus_on_click*(self: FileChooserButton): bool {.inline.} =
  gtk_file_chooser_button_get_focus_on_click(self)
# proc get_focus_on_click*(self: FileChooserButton): bool {.inline.} =

# gtk_file_chooser_button_get_title
# flags: {isMethod} container: FileChooserButton
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_file_chooser_button_get_title(self: ptr TFileChooserButton): ucstring {.cdecl, dynlib: lib, importc: "gtk_file_chooser_button_get_title".}
proc get_title*(self: FileChooserButton): ucstring {.inline.} =
  gtk_file_chooser_button_get_title(self)
# proc get_title*(self: FileChooserButton): ucstring {.inline.} =

# gtk_file_chooser_button_get_width_chars
# flags: {isMethod} container: FileChooserButton
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_file_chooser_button_get_width_chars(self: ptr TFileChooserButton): int32 {.cdecl, dynlib: lib, importc: "gtk_file_chooser_button_get_width_chars".}
proc get_width_chars*(self: FileChooserButton): int32 {.inline.} =
  gtk_file_chooser_button_get_width_chars(self)
# proc get_width_chars*(self: FileChooserButton): int32 {.inline.} =

# gtk_file_chooser_button_set_focus_on_click
# flags: {isMethod} container: FileChooserButton
# need sugar: is method
# arg focus_on_click: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_file_chooser_button_set_focus_on_click(self: ptr TFileChooserButton, focus_on_click: bool) {.cdecl, dynlib: lib, importc: "gtk_file_chooser_button_set_focus_on_click".}
proc set_focus_on_click*(self: FileChooserButton, focus_on_click: bool) {.inline.} =
  gtk_file_chooser_button_set_focus_on_click(self, focus_on_click)
# proc set_focus_on_click*(self: FileChooserButton, focus_on_click: bool) {.inline.} =

# gtk_file_chooser_button_set_title
# flags: {isMethod} container: FileChooserButton
# need sugar: is method
# arg title: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_file_chooser_button_set_title(self: ptr TFileChooserButton, title: ucstring) {.cdecl, dynlib: lib, importc: "gtk_file_chooser_button_set_title".}
proc set_title*(self: FileChooserButton, title: ustring) {.inline.} =
  gtk_file_chooser_button_set_title(self, ucstring(title))
# proc set_title*(self: FileChooserButton, title: ustring) {.inline.} =

# gtk_file_chooser_button_set_width_chars
# flags: {isMethod} container: FileChooserButton
# need sugar: is method
# arg n_chars: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_file_chooser_button_set_width_chars(self: ptr TFileChooserButton, n_chars: int32) {.cdecl, dynlib: lib, importc: "gtk_file_chooser_button_set_width_chars".}
proc set_width_chars*(self: FileChooserButton, n_chars: int32) {.inline.} =
  gtk_file_chooser_button_set_width_chars(self, n_chars)
# proc set_width_chars*(self: FileChooserButton, n_chars: int32) {.inline.} =

# initializer for FileChooserDialog: gtk_file_chooser_dialog_get_type
proc gtk_file_chooser_dialog_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_file_chooser_dialog_get_type".}
template gtype*(klass_parameter: typedesc[FileChooserDialog]): GType = gtk_file_chooser_dialog_get_type()
# initializer for FileChooserWidget: gtk_file_chooser_widget_get_type
proc gtk_file_chooser_widget_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_file_chooser_widget_get_type".}
template gtype*(klass_parameter: typedesc[FileChooserWidget]): GType = gtk_file_chooser_widget_get_type()
# gtk_file_chooser_widget_new
# flags: {isConstructor} container: FileChooserWidget
# need sugar: is static method
# arg action: INTERFACE (ENUM) 'FileChooserAction' 'FileChooserAction' IN
# return: INTERFACE 'FileChooserWidget' 'TransferNone[TFileChooserWidget]' (diff., need sugar)
proc gtk_file_chooser_widget_new(action: FileChooserAction): TransferNone[TFileChooserWidget] {.cdecl, dynlib: lib, importc: "gtk_file_chooser_widget_new".}
proc new_filechooserwidget*(action: FileChooserAction): FileChooserWidget {.inline.} =
  wrap(gtk_file_chooser_widget_new(action))
# proc new_filechooserwidget*(action: FileChooserAction): FileChooserWidget {.inline.} =

# initializer for FileFilter: gtk_file_filter_get_type
proc gtk_file_filter_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_file_filter_get_type".}
template gtype*(klass_parameter: typedesc[FileFilter]): GType = gtk_file_filter_get_type()
# gtk_file_filter_new
# flags: {isConstructor} container: FileFilter
# need sugar: is static method
# return: INTERFACE 'FileFilter' 'TransferNone[TFileFilter]' (diff., need sugar)
proc gtk_file_filter_new(): TransferNone[TFileFilter] {.cdecl, dynlib: lib, importc: "gtk_file_filter_new".}
proc new_filefilter*(): FileFilter {.inline.} =
  wrap(gtk_file_filter_new())
# proc new_filefilter*(): FileFilter {.inline.} =

# gtk_file_filter_add_custom
# flags: {isMethod} container: FileFilter
# need sugar: is method
# arg needed: INTERFACE (FLAGS) 'SFileFilterFlags' 'SFileFilterFlags' IN
# arg func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg data: VOID 'pointer' 'pointer' IN
# arg notify: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_file_filter_add_custom(self: ptr TFileFilter, needed: SFileFilterFlags, func_x: pointer, data: pointer, notify: pointer) {.cdecl, dynlib: lib, importc: "gtk_file_filter_add_custom".}
proc add_custom*(self: FileFilter, needed: SFileFilterFlags, func_x: pointer, data: pointer, notify: pointer) {.inline.} =
  gtk_file_filter_add_custom(self, needed, func_x, data, notify)
# proc add_custom*(self: FileFilter, needed: SFileFilterFlags, func_x: pointer, data: pointer, notify: pointer) {.inline.} =

# gtk_file_filter_add_mime_type
# flags: {isMethod} container: FileFilter
# need sugar: is method
# arg mime_type: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_file_filter_add_mime_type(self: ptr TFileFilter, mime_type: ucstring) {.cdecl, dynlib: lib, importc: "gtk_file_filter_add_mime_type".}
proc add_mime_type*(self: FileFilter, mime_type: ustring) {.inline.} =
  gtk_file_filter_add_mime_type(self, ucstring(mime_type))
# proc add_mime_type*(self: FileFilter, mime_type: ustring) {.inline.} =

# gtk_file_filter_add_pattern
# flags: {isMethod} container: FileFilter
# need sugar: is method
# arg pattern: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_file_filter_add_pattern(self: ptr TFileFilter, pattern: ucstring) {.cdecl, dynlib: lib, importc: "gtk_file_filter_add_pattern".}
proc add_pattern*(self: FileFilter, pattern: ustring) {.inline.} =
  gtk_file_filter_add_pattern(self, ucstring(pattern))
# proc add_pattern*(self: FileFilter, pattern: ustring) {.inline.} =

# gtk_file_filter_add_pixbuf_formats
# flags: {isMethod} container: FileFilter
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_file_filter_add_pixbuf_formats(self: ptr TFileFilter) {.cdecl, dynlib: lib, importc: "gtk_file_filter_add_pixbuf_formats".}
proc add_pixbuf_formats*(self: FileFilter) {.inline.} =
  gtk_file_filter_add_pixbuf_formats(self)
# proc add_pixbuf_formats*(self: FileFilter) {.inline.} =

# gtk_file_filter_filter
# flags: {isMethod} container: FileFilter
# need sugar: is method
# arg filter_info: INTERFACE (STRUCT) 'ptr TFileFilterInfo' 'ptr TFileFilterInfo' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_file_filter_filter(self: ptr TFileFilter, filter_info: ptr TFileFilterInfo): bool {.cdecl, dynlib: lib, importc: "gtk_file_filter_filter".}
proc filter*(self: FileFilter, filter_info: ptr TFileFilterInfo): bool {.inline.} =
  gtk_file_filter_filter(self, filter_info)
# proc filter*(self: FileFilter, filter_info: ptr TFileFilterInfo): bool {.inline.} =

# gtk_file_filter_get_name
# flags: {isMethod} container: FileFilter
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_file_filter_get_name(self: ptr TFileFilter): ucstring {.cdecl, dynlib: lib, importc: "gtk_file_filter_get_name".}
proc get_name*(self: FileFilter): ucstring {.inline.} =
  gtk_file_filter_get_name(self)
# proc get_name*(self: FileFilter): ucstring {.inline.} =

# gtk_file_filter_get_needed
# flags: {isMethod} container: FileFilter
# need sugar: is method
# return: INTERFACE 'SFileFilterFlags' 'SFileFilterFlags'
proc gtk_file_filter_get_needed(self: ptr TFileFilter): SFileFilterFlags {.cdecl, dynlib: lib, importc: "gtk_file_filter_get_needed".}
proc get_needed*(self: FileFilter): SFileFilterFlags {.inline.} =
  gtk_file_filter_get_needed(self)
# proc get_needed*(self: FileFilter): SFileFilterFlags {.inline.} =

# gtk_file_filter_set_name
# flags: {isMethod} container: FileFilter
# need sugar: is method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_file_filter_set_name(self: ptr TFileFilter, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_file_filter_set_name".}
proc set_name*(self: FileFilter, name: ustring) {.inline.} =
  gtk_file_filter_set_name(self, ucstring(name))
# proc set_name*(self: FileFilter, name: ustring) {.inline.} =

# initializer for Fixed: gtk_fixed_get_type
proc gtk_fixed_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_fixed_get_type".}
template gtype*(klass_parameter: typedesc[Fixed]): GType = gtk_fixed_get_type()
# gtk_fixed_new
# flags: {isConstructor} container: Fixed
# need sugar: is static method
# return: INTERFACE 'Fixed' 'TransferNone[TFixed]' (diff., need sugar)
proc gtk_fixed_new(): TransferNone[TFixed] {.cdecl, dynlib: lib, importc: "gtk_fixed_new".}
proc new_fixed*(): Fixed {.inline.} =
  wrap(gtk_fixed_new())
# proc new_fixed*(): Fixed {.inline.} =

# gtk_fixed_move
# flags: {isMethod} container: Fixed
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg x: INT32 'int32' 'int32' IN
# arg y: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_fixed_move(self: ptr TFixed, widget: ptr TWidget, x: int32, y: int32) {.cdecl, dynlib: lib, importc: "gtk_fixed_move".}
proc move*(self: Fixed, widget: Widget, x: int32, y: int32) {.inline.} =
  gtk_fixed_move(self, widget.getPointer, x, y)
# proc move*(self: Fixed, widget: Widget, x: int32, y: int32) {.inline.} =

# gtk_fixed_put
# flags: {isMethod} container: Fixed
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg x: INT32 'int32' 'int32' IN
# arg y: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_fixed_put(self: ptr TFixed, widget: ptr TWidget, x: int32, y: int32) {.cdecl, dynlib: lib, importc: "gtk_fixed_put".}
proc put*(self: Fixed, widget: Widget, x: int32, y: int32) {.inline.} =
  gtk_fixed_put(self, widget.getPointer, x, y)
# proc put*(self: Fixed, widget: Widget, x: int32, y: int32) {.inline.} =

# initializer for FlowBox: gtk_flow_box_get_type
proc gtk_flow_box_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_flow_box_get_type".}
template gtype*(klass_parameter: typedesc[FlowBox]): GType = gtk_flow_box_get_type()
# gtk_flow_box_new
# flags: {isConstructor} container: FlowBox
# need sugar: is static method
# return: INTERFACE 'FlowBox' 'TransferNone[TFlowBox]' (diff., need sugar)
proc gtk_flow_box_new(): TransferNone[TFlowBox] {.cdecl, dynlib: lib, importc: "gtk_flow_box_new".}
proc new_flowbox*(): FlowBox {.inline.} =
  wrap(gtk_flow_box_new())
# proc new_flowbox*(): FlowBox {.inline.} =

# gtk_flow_box_get_activate_on_single_click
# flags: {isMethod} container: FlowBox
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_flow_box_get_activate_on_single_click(self: ptr TFlowBox): bool {.cdecl, dynlib: lib, importc: "gtk_flow_box_get_activate_on_single_click".}
proc get_activate_on_single_click*(self: FlowBox): bool {.inline.} =
  gtk_flow_box_get_activate_on_single_click(self)
# proc get_activate_on_single_click*(self: FlowBox): bool {.inline.} =

# gtk_flow_box_get_child_at_index
# flags: {isMethod} container: FlowBox
# need sugar: is method
# arg idx: INT32 'int32' 'int32' IN
# return: INTERFACE 'FlowBoxChild' 'TransferNone[TFlowBoxChild]' (diff., need sugar)
proc gtk_flow_box_get_child_at_index(self: ptr TFlowBox, idx: int32): TransferNone[TFlowBoxChild] {.cdecl, dynlib: lib, importc: "gtk_flow_box_get_child_at_index".}
proc get_child_at_index*(self: FlowBox, idx: int32): FlowBoxChild {.inline.} =
  wrap(gtk_flow_box_get_child_at_index(self, idx))
# proc get_child_at_index*(self: FlowBox, idx: int32): FlowBoxChild {.inline.} =

# gtk_flow_box_get_column_spacing
# flags: {isMethod} container: FlowBox
# need sugar: is method
# return: UINT32 'uint32' 'uint32'
proc gtk_flow_box_get_column_spacing(self: ptr TFlowBox): uint32 {.cdecl, dynlib: lib, importc: "gtk_flow_box_get_column_spacing".}
proc get_column_spacing*(self: FlowBox): uint32 {.inline.} =
  gtk_flow_box_get_column_spacing(self)
# proc get_column_spacing*(self: FlowBox): uint32 {.inline.} =

# gtk_flow_box_get_homogeneous
# flags: {isMethod} container: FlowBox
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_flow_box_get_homogeneous(self: ptr TFlowBox): bool {.cdecl, dynlib: lib, importc: "gtk_flow_box_get_homogeneous".}
proc get_homogeneous*(self: FlowBox): bool {.inline.} =
  gtk_flow_box_get_homogeneous(self)
# proc get_homogeneous*(self: FlowBox): bool {.inline.} =

# gtk_flow_box_get_max_children_per_line
# flags: {isMethod} container: FlowBox
# need sugar: is method
# return: UINT32 'uint32' 'uint32'
proc gtk_flow_box_get_max_children_per_line(self: ptr TFlowBox): uint32 {.cdecl, dynlib: lib, importc: "gtk_flow_box_get_max_children_per_line".}
proc get_max_children_per_line*(self: FlowBox): uint32 {.inline.} =
  gtk_flow_box_get_max_children_per_line(self)
# proc get_max_children_per_line*(self: FlowBox): uint32 {.inline.} =

# gtk_flow_box_get_min_children_per_line
# flags: {isMethod} container: FlowBox
# need sugar: is method
# return: UINT32 'uint32' 'uint32'
proc gtk_flow_box_get_min_children_per_line(self: ptr TFlowBox): uint32 {.cdecl, dynlib: lib, importc: "gtk_flow_box_get_min_children_per_line".}
proc get_min_children_per_line*(self: FlowBox): uint32 {.inline.} =
  gtk_flow_box_get_min_children_per_line(self)
# proc get_min_children_per_line*(self: FlowBox): uint32 {.inline.} =

# gtk_flow_box_get_row_spacing
# flags: {isMethod} container: FlowBox
# need sugar: is method
# return: UINT32 'uint32' 'uint32'
proc gtk_flow_box_get_row_spacing(self: ptr TFlowBox): uint32 {.cdecl, dynlib: lib, importc: "gtk_flow_box_get_row_spacing".}
proc get_row_spacing*(self: FlowBox): uint32 {.inline.} =
  gtk_flow_box_get_row_spacing(self)
# proc get_row_spacing*(self: FlowBox): uint32 {.inline.} =

# gtk_flow_box_get_selected_children
# flags: {isMethod} container: FlowBox
# need sugar: is method
# return: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_flow_box_get_selected_children(self: ptr TFlowBox): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_flow_box_get_selected_children".}
proc get_selected_children*(self: FlowBox): ptr GLIST_TODO {.inline.} =
  gtk_flow_box_get_selected_children(self)
# proc get_selected_children*(self: FlowBox): ptr GLIST_TODO {.inline.} =

# gtk_flow_box_get_selection_mode
# flags: {isMethod} container: FlowBox
# need sugar: is method
# return: INTERFACE 'SelectionMode' 'SelectionMode'
proc gtk_flow_box_get_selection_mode(self: ptr TFlowBox): SelectionMode {.cdecl, dynlib: lib, importc: "gtk_flow_box_get_selection_mode".}
proc get_selection_mode*(self: FlowBox): SelectionMode {.inline.} =
  gtk_flow_box_get_selection_mode(self)
# proc get_selection_mode*(self: FlowBox): SelectionMode {.inline.} =

# gtk_flow_box_insert
# flags: {isMethod} container: FlowBox
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg position: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_insert(self: ptr TFlowBox, widget: ptr TWidget, position: int32) {.cdecl, dynlib: lib, importc: "gtk_flow_box_insert".}
proc insert*(self: FlowBox, widget: Widget, position: int32) {.inline.} =
  gtk_flow_box_insert(self, widget.getPointer, position)
# proc insert*(self: FlowBox, widget: Widget, position: int32) {.inline.} =

# gtk_flow_box_invalidate_filter
# flags: {isMethod} container: FlowBox
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_invalidate_filter(self: ptr TFlowBox) {.cdecl, dynlib: lib, importc: "gtk_flow_box_invalidate_filter".}
proc invalidate_filter*(self: FlowBox) {.inline.} =
  gtk_flow_box_invalidate_filter(self)
# proc invalidate_filter*(self: FlowBox) {.inline.} =

# gtk_flow_box_invalidate_sort
# flags: {isMethod} container: FlowBox
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_invalidate_sort(self: ptr TFlowBox) {.cdecl, dynlib: lib, importc: "gtk_flow_box_invalidate_sort".}
proc invalidate_sort*(self: FlowBox) {.inline.} =
  gtk_flow_box_invalidate_sort(self)
# proc invalidate_sort*(self: FlowBox) {.inline.} =

# gtk_flow_box_select_all
# flags: {isMethod} container: FlowBox
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_select_all(self: ptr TFlowBox) {.cdecl, dynlib: lib, importc: "gtk_flow_box_select_all".}
proc select_all*(self: FlowBox) {.inline.} =
  gtk_flow_box_select_all(self)
# proc select_all*(self: FlowBox) {.inline.} =

# gtk_flow_box_select_child
# flags: {isMethod} container: FlowBox
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'FlowBoxChild' 'ptr TFlowBoxChild' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_select_child(self: ptr TFlowBox, child: ptr TFlowBoxChild) {.cdecl, dynlib: lib, importc: "gtk_flow_box_select_child".}
proc select_child*(self: FlowBox, child: FlowBoxChild) {.inline.} =
  gtk_flow_box_select_child(self, child.getPointer)
# proc select_child*(self: FlowBox, child: FlowBoxChild) {.inline.} =

# gtk_flow_box_selected_foreach
# flags: {isMethod} container: FlowBox
# need sugar: is method
# arg func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg data: VOID 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_selected_foreach(self: ptr TFlowBox, func_x: pointer, data: pointer) {.cdecl, dynlib: lib, importc: "gtk_flow_box_selected_foreach".}
proc selected_foreach*(self: FlowBox, func_x: pointer, data: pointer) {.inline.} =
  gtk_flow_box_selected_foreach(self, func_x, data)
# proc selected_foreach*(self: FlowBox, func_x: pointer, data: pointer) {.inline.} =

# gtk_flow_box_set_activate_on_single_click
# flags: {isMethod} container: FlowBox
# need sugar: is method
# arg single: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_set_activate_on_single_click(self: ptr TFlowBox, single: bool) {.cdecl, dynlib: lib, importc: "gtk_flow_box_set_activate_on_single_click".}
proc set_activate_on_single_click*(self: FlowBox, single: bool) {.inline.} =
  gtk_flow_box_set_activate_on_single_click(self, single)
# proc set_activate_on_single_click*(self: FlowBox, single: bool) {.inline.} =

# gtk_flow_box_set_column_spacing
# flags: {isMethod} container: FlowBox
# need sugar: is method
# arg spacing: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_set_column_spacing(self: ptr TFlowBox, spacing: uint32) {.cdecl, dynlib: lib, importc: "gtk_flow_box_set_column_spacing".}
proc set_column_spacing*(self: FlowBox, spacing: uint32) {.inline.} =
  gtk_flow_box_set_column_spacing(self, spacing)
# proc set_column_spacing*(self: FlowBox, spacing: uint32) {.inline.} =

# gtk_flow_box_set_filter_func
# flags: {isMethod} container: FlowBox
# need sugar: is method
# arg filter_func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg user_data: VOID 'pointer' 'pointer' IN
# arg destroy: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_set_filter_func(self: ptr TFlowBox, filter_func: pointer, user_data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_flow_box_set_filter_func".}
proc set_filter_func*(self: FlowBox, filter_func: pointer, user_data: pointer, destroy: pointer) {.inline.} =
  gtk_flow_box_set_filter_func(self, filter_func, user_data, destroy)
# proc set_filter_func*(self: FlowBox, filter_func: pointer, user_data: pointer, destroy: pointer) {.inline.} =

# gtk_flow_box_set_hadjustment
# flags: {isMethod} container: FlowBox
# need sugar: is method
# arg adjustment: INTERFACE (OBJECT) 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_set_hadjustment(self: ptr TFlowBox, adjustment: ptr TAdjustment) {.cdecl, dynlib: lib, importc: "gtk_flow_box_set_hadjustment".}
proc set_hadjustment*(self: FlowBox, adjustment: Adjustment) {.inline.} =
  gtk_flow_box_set_hadjustment(self, adjustment.getPointer)
# proc set_hadjustment*(self: FlowBox, adjustment: Adjustment) {.inline.} =

# gtk_flow_box_set_homogeneous
# flags: {isMethod} container: FlowBox
# need sugar: is method
# arg homogeneous: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_set_homogeneous(self: ptr TFlowBox, homogeneous: bool) {.cdecl, dynlib: lib, importc: "gtk_flow_box_set_homogeneous".}
proc set_homogeneous*(self: FlowBox, homogeneous: bool) {.inline.} =
  gtk_flow_box_set_homogeneous(self, homogeneous)
# proc set_homogeneous*(self: FlowBox, homogeneous: bool) {.inline.} =

# gtk_flow_box_set_max_children_per_line
# flags: {isMethod} container: FlowBox
# need sugar: is method
# arg n_children: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_set_max_children_per_line(self: ptr TFlowBox, n_children: uint32) {.cdecl, dynlib: lib, importc: "gtk_flow_box_set_max_children_per_line".}
proc set_max_children_per_line*(self: FlowBox, n_children: uint32) {.inline.} =
  gtk_flow_box_set_max_children_per_line(self, n_children)
# proc set_max_children_per_line*(self: FlowBox, n_children: uint32) {.inline.} =

# gtk_flow_box_set_min_children_per_line
# flags: {isMethod} container: FlowBox
# need sugar: is method
# arg n_children: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_set_min_children_per_line(self: ptr TFlowBox, n_children: uint32) {.cdecl, dynlib: lib, importc: "gtk_flow_box_set_min_children_per_line".}
proc set_min_children_per_line*(self: FlowBox, n_children: uint32) {.inline.} =
  gtk_flow_box_set_min_children_per_line(self, n_children)
# proc set_min_children_per_line*(self: FlowBox, n_children: uint32) {.inline.} =

# gtk_flow_box_set_row_spacing
# flags: {isMethod} container: FlowBox
# need sugar: is method
# arg spacing: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_set_row_spacing(self: ptr TFlowBox, spacing: uint32) {.cdecl, dynlib: lib, importc: "gtk_flow_box_set_row_spacing".}
proc set_row_spacing*(self: FlowBox, spacing: uint32) {.inline.} =
  gtk_flow_box_set_row_spacing(self, spacing)
# proc set_row_spacing*(self: FlowBox, spacing: uint32) {.inline.} =

# gtk_flow_box_set_selection_mode
# flags: {isMethod} container: FlowBox
# need sugar: is method
# arg mode: INTERFACE (ENUM) 'SelectionMode' 'SelectionMode' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_set_selection_mode(self: ptr TFlowBox, mode: SelectionMode) {.cdecl, dynlib: lib, importc: "gtk_flow_box_set_selection_mode".}
proc set_selection_mode*(self: FlowBox, mode: SelectionMode) {.inline.} =
  gtk_flow_box_set_selection_mode(self, mode)
# proc set_selection_mode*(self: FlowBox, mode: SelectionMode) {.inline.} =

# gtk_flow_box_set_sort_func
# flags: {isMethod} container: FlowBox
# need sugar: is method
# arg sort_func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg user_data: VOID 'pointer' 'pointer' IN
# arg destroy: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_set_sort_func(self: ptr TFlowBox, sort_func: pointer, user_data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_flow_box_set_sort_func".}
proc set_sort_func*(self: FlowBox, sort_func: pointer, user_data: pointer, destroy: pointer) {.inline.} =
  gtk_flow_box_set_sort_func(self, sort_func, user_data, destroy)
# proc set_sort_func*(self: FlowBox, sort_func: pointer, user_data: pointer, destroy: pointer) {.inline.} =

# gtk_flow_box_set_vadjustment
# flags: {isMethod} container: FlowBox
# need sugar: is method
# arg adjustment: INTERFACE (OBJECT) 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_set_vadjustment(self: ptr TFlowBox, adjustment: ptr TAdjustment) {.cdecl, dynlib: lib, importc: "gtk_flow_box_set_vadjustment".}
proc set_vadjustment*(self: FlowBox, adjustment: Adjustment) {.inline.} =
  gtk_flow_box_set_vadjustment(self, adjustment.getPointer)
# proc set_vadjustment*(self: FlowBox, adjustment: Adjustment) {.inline.} =

# gtk_flow_box_unselect_all
# flags: {isMethod} container: FlowBox
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_unselect_all(self: ptr TFlowBox) {.cdecl, dynlib: lib, importc: "gtk_flow_box_unselect_all".}
proc unselect_all*(self: FlowBox) {.inline.} =
  gtk_flow_box_unselect_all(self)
# proc unselect_all*(self: FlowBox) {.inline.} =

# gtk_flow_box_unselect_child
# flags: {isMethod} container: FlowBox
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'FlowBoxChild' 'ptr TFlowBoxChild' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_unselect_child(self: ptr TFlowBox, child: ptr TFlowBoxChild) {.cdecl, dynlib: lib, importc: "gtk_flow_box_unselect_child".}
proc unselect_child*(self: FlowBox, child: FlowBoxChild) {.inline.} =
  gtk_flow_box_unselect_child(self, child.getPointer)
# proc unselect_child*(self: FlowBox, child: FlowBoxChild) {.inline.} =

# initializer for FlowBoxAccessible: gtk_flow_box_accessible_get_type
proc gtk_flow_box_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_flow_box_accessible_get_type".}
template gtype*(klass_parameter: typedesc[FlowBoxAccessible]): GType = gtk_flow_box_accessible_get_type()
# initializer for FlowBoxChild: gtk_flow_box_child_get_type
proc gtk_flow_box_child_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_flow_box_child_get_type".}
template gtype*(klass_parameter: typedesc[FlowBoxChild]): GType = gtk_flow_box_child_get_type()
# gtk_flow_box_child_new
# flags: {isConstructor} container: FlowBoxChild
# need sugar: is static method
# return: INTERFACE 'FlowBoxChild' 'TransferNone[TFlowBoxChild]' (diff., need sugar)
proc gtk_flow_box_child_new(): TransferNone[TFlowBoxChild] {.cdecl, dynlib: lib, importc: "gtk_flow_box_child_new".}
proc new_flowboxchild*(): FlowBoxChild {.inline.} =
  wrap(gtk_flow_box_child_new())
# proc new_flowboxchild*(): FlowBoxChild {.inline.} =

# gtk_flow_box_child_changed
# flags: {isMethod} container: FlowBoxChild
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_flow_box_child_changed(self: ptr TFlowBoxChild) {.cdecl, dynlib: lib, importc: "gtk_flow_box_child_changed".}
proc changed*(self: FlowBoxChild) {.inline.} =
  gtk_flow_box_child_changed(self)
# proc changed*(self: FlowBoxChild) {.inline.} =

# gtk_flow_box_child_get_index
# flags: {isMethod} container: FlowBoxChild
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_flow_box_child_get_index(self: ptr TFlowBoxChild): int32 {.cdecl, dynlib: lib, importc: "gtk_flow_box_child_get_index".}
proc get_index*(self: FlowBoxChild): int32 {.inline.} =
  gtk_flow_box_child_get_index(self)
# proc get_index*(self: FlowBoxChild): int32 {.inline.} =

# gtk_flow_box_child_is_selected
# flags: {isMethod} container: FlowBoxChild
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_flow_box_child_is_selected(self: ptr TFlowBoxChild): bool {.cdecl, dynlib: lib, importc: "gtk_flow_box_child_is_selected".}
proc is_selected*(self: FlowBoxChild): bool {.inline.} =
  gtk_flow_box_child_is_selected(self)
# proc is_selected*(self: FlowBoxChild): bool {.inline.} =

# initializer for FlowBoxChildAccessible: gtk_flow_box_child_accessible_get_type
proc gtk_flow_box_child_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_flow_box_child_accessible_get_type".}
template gtype*(klass_parameter: typedesc[FlowBoxChildAccessible]): GType = gtk_flow_box_child_accessible_get_type()
# initializer for FontButton: gtk_font_button_get_type
proc gtk_font_button_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_font_button_get_type".}
template gtype*(klass_parameter: typedesc[FontButton]): GType = gtk_font_button_get_type()
# gtk_font_button_new
# flags: {isConstructor} container: FontButton
# need sugar: is static method
# return: INTERFACE 'FontButton' 'TransferNone[TFontButton]' (diff., need sugar)
proc gtk_font_button_new(): TransferNone[TFontButton] {.cdecl, dynlib: lib, importc: "gtk_font_button_new".}
proc new_fontbutton*(): FontButton {.inline.} =
  wrap(gtk_font_button_new())
# proc new_fontbutton*(): FontButton {.inline.} =

# gtk_font_button_new_with_font
# flags: {isConstructor} container: FontButton
# need sugar: is static method
# arg fontname: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'FontButton' 'TransferNone[TFontButton]' (diff., need sugar)
proc gtk_font_button_new_with_font(fontname: ucstring): TransferNone[TFontButton] {.cdecl, dynlib: lib, importc: "gtk_font_button_new_with_font".}
proc new_fontbutton_with_font*(fontname: ustring): FontButton {.inline.} =
  wrap(gtk_font_button_new_with_font(ucstring(fontname)))
# proc new_fontbutton_with_font*(fontname: ustring): FontButton {.inline.} =

# gtk_font_button_get_font_name
# flags: {isMethod} container: FontButton
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_font_button_get_font_name(self: ptr TFontButton): ucstring {.cdecl, dynlib: lib, importc: "gtk_font_button_get_font_name".}
proc get_font_name*(self: FontButton): ucstring {.inline.} =
  gtk_font_button_get_font_name(self)
# proc get_font_name*(self: FontButton): ucstring {.inline.} =

# gtk_font_button_get_show_size
# flags: {isMethod} container: FontButton
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_font_button_get_show_size(self: ptr TFontButton): bool {.cdecl, dynlib: lib, importc: "gtk_font_button_get_show_size".}
proc get_show_size*(self: FontButton): bool {.inline.} =
  gtk_font_button_get_show_size(self)
# proc get_show_size*(self: FontButton): bool {.inline.} =

# gtk_font_button_get_show_style
# flags: {isMethod} container: FontButton
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_font_button_get_show_style(self: ptr TFontButton): bool {.cdecl, dynlib: lib, importc: "gtk_font_button_get_show_style".}
proc get_show_style*(self: FontButton): bool {.inline.} =
  gtk_font_button_get_show_style(self)
# proc get_show_style*(self: FontButton): bool {.inline.} =

# gtk_font_button_get_title
# flags: {isMethod} container: FontButton
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_font_button_get_title(self: ptr TFontButton): ucstring {.cdecl, dynlib: lib, importc: "gtk_font_button_get_title".}
proc get_title*(self: FontButton): ucstring {.inline.} =
  gtk_font_button_get_title(self)
# proc get_title*(self: FontButton): ucstring {.inline.} =

# gtk_font_button_get_use_font
# flags: {isMethod} container: FontButton
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_font_button_get_use_font(self: ptr TFontButton): bool {.cdecl, dynlib: lib, importc: "gtk_font_button_get_use_font".}
proc get_use_font*(self: FontButton): bool {.inline.} =
  gtk_font_button_get_use_font(self)
# proc get_use_font*(self: FontButton): bool {.inline.} =

# gtk_font_button_get_use_size
# flags: {isMethod} container: FontButton
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_font_button_get_use_size(self: ptr TFontButton): bool {.cdecl, dynlib: lib, importc: "gtk_font_button_get_use_size".}
proc get_use_size*(self: FontButton): bool {.inline.} =
  gtk_font_button_get_use_size(self)
# proc get_use_size*(self: FontButton): bool {.inline.} =

# gtk_font_button_set_font_name
# flags: {isMethod} container: FontButton
# need sugar: is method
# arg fontname: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_font_button_set_font_name(self: ptr TFontButton, fontname: ucstring): bool {.cdecl, dynlib: lib, importc: "gtk_font_button_set_font_name".}
proc set_font_name*(self: FontButton, fontname: ustring): bool {.inline.} =
  gtk_font_button_set_font_name(self, ucstring(fontname))
# proc set_font_name*(self: FontButton, fontname: ustring): bool {.inline.} =

# gtk_font_button_set_show_size
# flags: {isMethod} container: FontButton
# need sugar: is method
# arg show_size: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_font_button_set_show_size(self: ptr TFontButton, show_size: bool) {.cdecl, dynlib: lib, importc: "gtk_font_button_set_show_size".}
proc set_show_size*(self: FontButton, show_size: bool) {.inline.} =
  gtk_font_button_set_show_size(self, show_size)
# proc set_show_size*(self: FontButton, show_size: bool) {.inline.} =

# gtk_font_button_set_show_style
# flags: {isMethod} container: FontButton
# need sugar: is method
# arg show_style: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_font_button_set_show_style(self: ptr TFontButton, show_style: bool) {.cdecl, dynlib: lib, importc: "gtk_font_button_set_show_style".}
proc set_show_style*(self: FontButton, show_style: bool) {.inline.} =
  gtk_font_button_set_show_style(self, show_style)
# proc set_show_style*(self: FontButton, show_style: bool) {.inline.} =

# gtk_font_button_set_title
# flags: {isMethod} container: FontButton
# need sugar: is method
# arg title: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_font_button_set_title(self: ptr TFontButton, title: ucstring) {.cdecl, dynlib: lib, importc: "gtk_font_button_set_title".}
proc set_title*(self: FontButton, title: ustring) {.inline.} =
  gtk_font_button_set_title(self, ucstring(title))
# proc set_title*(self: FontButton, title: ustring) {.inline.} =

# gtk_font_button_set_use_font
# flags: {isMethod} container: FontButton
# need sugar: is method
# arg use_font: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_font_button_set_use_font(self: ptr TFontButton, use_font: bool) {.cdecl, dynlib: lib, importc: "gtk_font_button_set_use_font".}
proc set_use_font*(self: FontButton, use_font: bool) {.inline.} =
  gtk_font_button_set_use_font(self, use_font)
# proc set_use_font*(self: FontButton, use_font: bool) {.inline.} =

# gtk_font_button_set_use_size
# flags: {isMethod} container: FontButton
# need sugar: is method
# arg use_size: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_font_button_set_use_size(self: ptr TFontButton, use_size: bool) {.cdecl, dynlib: lib, importc: "gtk_font_button_set_use_size".}
proc set_use_size*(self: FontButton, use_size: bool) {.inline.} =
  gtk_font_button_set_use_size(self, use_size)
# proc set_use_size*(self: FontButton, use_size: bool) {.inline.} =

# initializer for FontChooserDialog: gtk_font_chooser_dialog_get_type
proc gtk_font_chooser_dialog_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_font_chooser_dialog_get_type".}
template gtype*(klass_parameter: typedesc[FontChooserDialog]): GType = gtk_font_chooser_dialog_get_type()
# gtk_font_chooser_dialog_new
# flags: {isConstructor} container: FontChooserDialog
# need sugar: is static method
# arg title: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg parent: INTERFACE (OBJECT) 'Window' 'ptr TWindow' IN (diff., need sugar)
# return: INTERFACE 'FontChooserDialog' 'TransferNone[TFontChooserDialog]' (diff., need sugar)
proc gtk_font_chooser_dialog_new(title: ucstring, parent: ptr TWindow): TransferNone[TFontChooserDialog] {.cdecl, dynlib: lib, importc: "gtk_font_chooser_dialog_new".}
proc new_fontchooserdialog*(title: ustring, parent: Window): FontChooserDialog {.inline.} =
  wrap(gtk_font_chooser_dialog_new(ucstring(title), parent.getPointer))
# proc new_fontchooserdialog*(title: ustring, parent: Window): FontChooserDialog {.inline.} =

# initializer for FontChooserWidget: gtk_font_chooser_widget_get_type
proc gtk_font_chooser_widget_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_font_chooser_widget_get_type".}
template gtype*(klass_parameter: typedesc[FontChooserWidget]): GType = gtk_font_chooser_widget_get_type()
# gtk_font_chooser_widget_new
# flags: {isConstructor} container: FontChooserWidget
# need sugar: is static method
# return: INTERFACE 'FontChooserWidget' 'TransferNone[TFontChooserWidget]' (diff., need sugar)
proc gtk_font_chooser_widget_new(): TransferNone[TFontChooserWidget] {.cdecl, dynlib: lib, importc: "gtk_font_chooser_widget_new".}
proc new_fontchooserwidget*(): FontChooserWidget {.inline.} =
  wrap(gtk_font_chooser_widget_new())
# proc new_fontchooserwidget*(): FontChooserWidget {.inline.} =

# initializer for FontSelection: gtk_font_selection_get_type
proc gtk_font_selection_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_font_selection_get_type".}
template gtype*(klass_parameter: typedesc[FontSelection]): GType = gtk_font_selection_get_type()
# gtk_font_selection_new
# flags: {isConstructor} container: FontSelection (deprecated)
# gtk_font_selection_get_face
# flags: {isMethod} container: FontSelection (deprecated)
# gtk_font_selection_get_face_list
# flags: {isMethod} container: FontSelection (deprecated)
# gtk_font_selection_get_family
# flags: {isMethod} container: FontSelection (deprecated)
# gtk_font_selection_get_family_list
# flags: {isMethod} container: FontSelection (deprecated)
# gtk_font_selection_get_font_name
# flags: {isMethod} container: FontSelection (deprecated)
# gtk_font_selection_get_preview_entry
# flags: {isMethod} container: FontSelection (deprecated)
# gtk_font_selection_get_preview_text
# flags: {isMethod} container: FontSelection (deprecated)
# gtk_font_selection_get_size
# flags: {isMethod} container: FontSelection (deprecated)
# gtk_font_selection_get_size_entry
# flags: {isMethod} container: FontSelection (deprecated)
# gtk_font_selection_get_size_list
# flags: {isMethod} container: FontSelection (deprecated)
# gtk_font_selection_set_font_name
# flags: {isMethod} container: FontSelection (deprecated)
# gtk_font_selection_set_preview_text
# flags: {isMethod} container: FontSelection (deprecated)
# initializer for FontSelectionDialog: gtk_font_selection_dialog_get_type
proc gtk_font_selection_dialog_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_font_selection_dialog_get_type".}
template gtype*(klass_parameter: typedesc[FontSelectionDialog]): GType = gtk_font_selection_dialog_get_type()
# gtk_font_selection_dialog_new
# flags: {isConstructor} container: FontSelectionDialog (deprecated)
# gtk_font_selection_dialog_get_cancel_button
# flags: {isMethod} container: FontSelectionDialog (deprecated)
# gtk_font_selection_dialog_get_font_name
# flags: {isMethod} container: FontSelectionDialog (deprecated)
# gtk_font_selection_dialog_get_font_selection
# flags: {isMethod} container: FontSelectionDialog (deprecated)
# gtk_font_selection_dialog_get_ok_button
# flags: {isMethod} container: FontSelectionDialog (deprecated)
# gtk_font_selection_dialog_get_preview_text
# flags: {isMethod} container: FontSelectionDialog (deprecated)
# gtk_font_selection_dialog_set_font_name
# flags: {isMethod} container: FontSelectionDialog (deprecated)
# gtk_font_selection_dialog_set_preview_text
# flags: {isMethod} container: FontSelectionDialog (deprecated)
# initializer for Frame: gtk_frame_get_type
proc gtk_frame_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_frame_get_type".}
template gtype*(klass_parameter: typedesc[Frame]): GType = gtk_frame_get_type()
# gtk_frame_new
# flags: {isConstructor} container: Frame
# need sugar: is static method
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'Frame' 'TransferNone[TFrame]' (diff., need sugar)
proc gtk_frame_new(label: ucstring): TransferNone[TFrame] {.cdecl, dynlib: lib, importc: "gtk_frame_new".}
proc new_frame*(label: ustring): Frame {.inline.} =
  wrap(gtk_frame_new(ucstring(label)))
# proc new_frame*(label: ustring): Frame {.inline.} =

# gtk_frame_get_label
# flags: {isMethod} container: Frame
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_frame_get_label(self: ptr TFrame): ucstring {.cdecl, dynlib: lib, importc: "gtk_frame_get_label".}
proc get_label*(self: Frame): ucstring {.inline.} =
  gtk_frame_get_label(self)
# proc get_label*(self: Frame): ucstring {.inline.} =

# gtk_frame_get_label_align
# flags: {isMethod} container: Frame
# need sugar: is method
# arg xalign: FLOAT 'var float32' 'ptr float32' OUT (diff., need sugar) optional
# arg yalign: FLOAT 'var float32' 'ptr float32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_frame_get_label_align(self: ptr TFrame, xalign: ptr float32, yalign: ptr float32) {.cdecl, dynlib: lib, importc: "gtk_frame_get_label_align".}
proc get_label_align*(self: Frame, xalign: var float32, yalign: var float32) {.inline.} =
  gtk_frame_get_label_align(self, addr(xalign), addr(yalign))
# tuple-return
# xalign: var float32
# yalign: var float32
# proc get_label_align*(self: Frame) {.inline.} =

# gtk_frame_get_label_widget
# flags: {isMethod} container: Frame
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_frame_get_label_widget(self: ptr TFrame): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_frame_get_label_widget".}
proc get_label_widget*(self: Frame): Widget {.inline.} =
  wrap(gtk_frame_get_label_widget(self))
# proc get_label_widget*(self: Frame): Widget {.inline.} =

# gtk_frame_get_shadow_type
# flags: {isMethod} container: Frame
# need sugar: is method
# return: INTERFACE 'ShadowType' 'ShadowType'
proc gtk_frame_get_shadow_type(self: ptr TFrame): ShadowType {.cdecl, dynlib: lib, importc: "gtk_frame_get_shadow_type".}
proc get_shadow_type*(self: Frame): ShadowType {.inline.} =
  gtk_frame_get_shadow_type(self)
# proc get_shadow_type*(self: Frame): ShadowType {.inline.} =

# gtk_frame_set_label
# flags: {isMethod} container: Frame
# need sugar: is method
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_frame_set_label(self: ptr TFrame, label: ucstring) {.cdecl, dynlib: lib, importc: "gtk_frame_set_label".}
proc set_label*(self: Frame, label: ustring) {.inline.} =
  gtk_frame_set_label(self, ucstring(label))
# proc set_label*(self: Frame, label: ustring) {.inline.} =

# gtk_frame_set_label_align
# flags: {isMethod} container: Frame
# need sugar: is method
# arg xalign: FLOAT 'float32' 'float32' IN
# arg yalign: FLOAT 'float32' 'float32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_frame_set_label_align(self: ptr TFrame, xalign: float32, yalign: float32) {.cdecl, dynlib: lib, importc: "gtk_frame_set_label_align".}
proc set_label_align*(self: Frame, xalign: float32, yalign: float32) {.inline.} =
  gtk_frame_set_label_align(self, xalign, yalign)
# proc set_label_align*(self: Frame, xalign: float32, yalign: float32) {.inline.} =

# gtk_frame_set_label_widget
# flags: {isMethod} container: Frame
# need sugar: is method
# arg label_widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_frame_set_label_widget(self: ptr TFrame, label_widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_frame_set_label_widget".}
proc set_label_widget*(self: Frame, label_widget: Widget) {.inline.} =
  gtk_frame_set_label_widget(self, label_widget.getPointer)
# proc set_label_widget*(self: Frame, label_widget: Widget) {.inline.} =

# gtk_frame_set_shadow_type
# flags: {isMethod} container: Frame
# need sugar: is method
# arg type: INTERFACE (ENUM) 'ShadowType' 'ShadowType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_frame_set_shadow_type(self: ptr TFrame, type_x: ShadowType) {.cdecl, dynlib: lib, importc: "gtk_frame_set_shadow_type".}
proc set_shadow_type*(self: Frame, type_x: ShadowType) {.inline.} =
  gtk_frame_set_shadow_type(self, type_x)
# proc set_shadow_type*(self: Frame, type_x: ShadowType) {.inline.} =

# initializer for FrameAccessible: gtk_frame_accessible_get_type
proc gtk_frame_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_frame_accessible_get_type".}
template gtype*(klass_parameter: typedesc[FrameAccessible]): GType = gtk_frame_accessible_get_type()
# initializer for GLArea: gtk_gl_area_get_type
proc gtk_gl_area_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_gl_area_get_type".}
template gtype*(klass_parameter: typedesc[GLArea]): GType = gtk_gl_area_get_type()
# gtk_gl_area_new
# flags: {isConstructor} container: GLArea
# need sugar: is static method
# return: INTERFACE 'GLArea' 'TransferFull[TGLArea]' (diff., need sugar)
proc gtk_gl_area_new(): TransferFull[TGLArea] {.cdecl, dynlib: lib, importc: "gtk_gl_area_new".}
proc new_glarea*(): GLArea {.inline.} =
  wrap(gtk_gl_area_new())
# proc new_glarea*(): GLArea {.inline.} =

# gtk_gl_area_attach_buffers
# flags: {isMethod} container: GLArea
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_gl_area_attach_buffers(self: ptr TGLArea) {.cdecl, dynlib: lib, importc: "gtk_gl_area_attach_buffers".}
proc attach_buffers*(self: GLArea) {.inline.} =
  gtk_gl_area_attach_buffers(self)
# proc attach_buffers*(self: GLArea) {.inline.} =

# gtk_gl_area_get_auto_render
# flags: {isMethod} container: GLArea
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_gl_area_get_auto_render(self: ptr TGLArea): bool {.cdecl, dynlib: lib, importc: "gtk_gl_area_get_auto_render".}
proc get_auto_render*(self: GLArea): bool {.inline.} =
  gtk_gl_area_get_auto_render(self)
# proc get_auto_render*(self: GLArea): bool {.inline.} =

# gtk_gl_area_get_context
# flags: {isMethod} container: GLArea
# need sugar: is method
# return: INTERFACE 'Gdk3.GLContext' 'TransferNone[Gdk3.TGLContext]' (diff., need sugar)
proc gtk_gl_area_get_context(self: ptr TGLArea): TransferNone[Gdk3.TGLContext] {.cdecl, dynlib: lib, importc: "gtk_gl_area_get_context".}
proc get_context*(self: GLArea): Gdk3.GLContext {.inline.} =
  wrap(gtk_gl_area_get_context(self))
# proc get_context*(self: GLArea): Gdk3.GLContext {.inline.} =

# gtk_gl_area_get_error
# flags: {isMethod} container: GLArea
# need sugar: is method
# return: ERROR 'ptr ERROR_TODO' 'ptr ERROR_TODO'
proc gtk_gl_area_get_error(self: ptr TGLArea): ptr ERROR_TODO {.cdecl, dynlib: lib, importc: "gtk_gl_area_get_error".}
proc get_error*(self: GLArea): ptr ERROR_TODO {.inline.} =
  gtk_gl_area_get_error(self)
# proc get_error*(self: GLArea): ptr ERROR_TODO {.inline.} =

# gtk_gl_area_get_has_alpha
# flags: {isMethod} container: GLArea
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_gl_area_get_has_alpha(self: ptr TGLArea): bool {.cdecl, dynlib: lib, importc: "gtk_gl_area_get_has_alpha".}
proc get_has_alpha*(self: GLArea): bool {.inline.} =
  gtk_gl_area_get_has_alpha(self)
# proc get_has_alpha*(self: GLArea): bool {.inline.} =

# gtk_gl_area_get_has_depth_buffer
# flags: {isMethod} container: GLArea
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_gl_area_get_has_depth_buffer(self: ptr TGLArea): bool {.cdecl, dynlib: lib, importc: "gtk_gl_area_get_has_depth_buffer".}
proc get_has_depth_buffer*(self: GLArea): bool {.inline.} =
  gtk_gl_area_get_has_depth_buffer(self)
# proc get_has_depth_buffer*(self: GLArea): bool {.inline.} =

# gtk_gl_area_get_has_stencil_buffer
# flags: {isMethod} container: GLArea
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_gl_area_get_has_stencil_buffer(self: ptr TGLArea): bool {.cdecl, dynlib: lib, importc: "gtk_gl_area_get_has_stencil_buffer".}
proc get_has_stencil_buffer*(self: GLArea): bool {.inline.} =
  gtk_gl_area_get_has_stencil_buffer(self)
# proc get_has_stencil_buffer*(self: GLArea): bool {.inline.} =

# gtk_gl_area_get_required_version
# flags: {isMethod} container: GLArea
# need sugar: is method
# arg major: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# arg minor: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_gl_area_get_required_version(self: ptr TGLArea, major: ptr int32, minor: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_gl_area_get_required_version".}
proc get_required_version*(self: GLArea, major: var int32, minor: var int32) {.inline.} =
  gtk_gl_area_get_required_version(self, addr(major), addr(minor))
# tuple-return
# major: var int32
# minor: var int32
# proc get_required_version*(self: GLArea) {.inline.} =

# gtk_gl_area_make_current
# flags: {isMethod} container: GLArea
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_gl_area_make_current(self: ptr TGLArea) {.cdecl, dynlib: lib, importc: "gtk_gl_area_make_current".}
proc make_current*(self: GLArea) {.inline.} =
  gtk_gl_area_make_current(self)
# proc make_current*(self: GLArea) {.inline.} =

# gtk_gl_area_queue_render
# flags: {isMethod} container: GLArea
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_gl_area_queue_render(self: ptr TGLArea) {.cdecl, dynlib: lib, importc: "gtk_gl_area_queue_render".}
proc queue_render*(self: GLArea) {.inline.} =
  gtk_gl_area_queue_render(self)
# proc queue_render*(self: GLArea) {.inline.} =

# gtk_gl_area_set_auto_render
# flags: {isMethod} container: GLArea
# need sugar: is method
# arg auto_render: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_gl_area_set_auto_render(self: ptr TGLArea, auto_render: bool) {.cdecl, dynlib: lib, importc: "gtk_gl_area_set_auto_render".}
proc set_auto_render*(self: GLArea, auto_render: bool) {.inline.} =
  gtk_gl_area_set_auto_render(self, auto_render)
# proc set_auto_render*(self: GLArea, auto_render: bool) {.inline.} =

# gtk_gl_area_set_error
# flags: {isMethod} container: GLArea
# need sugar: is method
# arg error: ERROR 'ptr ERROR_TODO' 'ptr ERROR_TODO' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_gl_area_set_error(self: ptr TGLArea, error: ptr ERROR_TODO) {.cdecl, dynlib: lib, importc: "gtk_gl_area_set_error".}
proc set_error*(self: GLArea, error: ptr ERROR_TODO) {.inline.} =
  gtk_gl_area_set_error(self, error)
# proc set_error*(self: GLArea, error: ptr ERROR_TODO) {.inline.} =

# gtk_gl_area_set_has_alpha
# flags: {isMethod} container: GLArea
# need sugar: is method
# arg has_alpha: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_gl_area_set_has_alpha(self: ptr TGLArea, has_alpha: bool) {.cdecl, dynlib: lib, importc: "gtk_gl_area_set_has_alpha".}
proc set_has_alpha*(self: GLArea, has_alpha: bool) {.inline.} =
  gtk_gl_area_set_has_alpha(self, has_alpha)
# proc set_has_alpha*(self: GLArea, has_alpha: bool) {.inline.} =

# gtk_gl_area_set_has_depth_buffer
# flags: {isMethod} container: GLArea
# need sugar: is method
# arg has_depth_buffer: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_gl_area_set_has_depth_buffer(self: ptr TGLArea, has_depth_buffer: bool) {.cdecl, dynlib: lib, importc: "gtk_gl_area_set_has_depth_buffer".}
proc set_has_depth_buffer*(self: GLArea, has_depth_buffer: bool) {.inline.} =
  gtk_gl_area_set_has_depth_buffer(self, has_depth_buffer)
# proc set_has_depth_buffer*(self: GLArea, has_depth_buffer: bool) {.inline.} =

# gtk_gl_area_set_has_stencil_buffer
# flags: {isMethod} container: GLArea
# need sugar: is method
# arg has_stencil_buffer: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_gl_area_set_has_stencil_buffer(self: ptr TGLArea, has_stencil_buffer: bool) {.cdecl, dynlib: lib, importc: "gtk_gl_area_set_has_stencil_buffer".}
proc set_has_stencil_buffer*(self: GLArea, has_stencil_buffer: bool) {.inline.} =
  gtk_gl_area_set_has_stencil_buffer(self, has_stencil_buffer)
# proc set_has_stencil_buffer*(self: GLArea, has_stencil_buffer: bool) {.inline.} =

# gtk_gl_area_set_required_version
# flags: {isMethod} container: GLArea
# need sugar: is method
# arg major: INT32 'int32' 'int32' IN
# arg minor: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_gl_area_set_required_version(self: ptr TGLArea, major: int32, minor: int32) {.cdecl, dynlib: lib, importc: "gtk_gl_area_set_required_version".}
proc set_required_version*(self: GLArea, major: int32, minor: int32) {.inline.} =
  gtk_gl_area_set_required_version(self, major, minor)
# proc set_required_version*(self: GLArea, major: int32, minor: int32) {.inline.} =

# initializer for Gesture: gtk_gesture_get_type
proc gtk_gesture_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_gesture_get_type".}
template gtype*(klass_parameter: typedesc[Gesture]): GType = gtk_gesture_get_type()
# gtk_gesture_get_bounding_box
# flags: {isMethod} container: Gesture
# need sugar: is method
# arg rect: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' OUT caller-allocates
# return: BOOLEAN 'bool' 'bool'
proc gtk_gesture_get_bounding_box(self: ptr TGesture, rect: ptr Gdk3.TRectangle): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_get_bounding_box".}
proc get_bounding_box*(self: Gesture, rect: ptr Gdk3.TRectangle): bool {.inline.} =
  gtk_gesture_get_bounding_box(self, rect)
# tuple-return
# rect: ptr Gdk3.TRectangle
# proc get_bounding_box*(self: Gesture): bool {.inline.} =

# gtk_gesture_get_bounding_box_center
# flags: {isMethod} container: Gesture
# need sugar: is method
# arg x: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar)
# arg y: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_gesture_get_bounding_box_center(self: ptr TGesture, x: ptr float64, y: ptr float64): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_get_bounding_box_center".}
proc get_bounding_box_center*(self: Gesture, x: var float64, y: var float64): bool {.inline.} =
  gtk_gesture_get_bounding_box_center(self, addr(x), addr(y))
# tuple-return
# x: var float64
# y: var float64
# proc get_bounding_box_center*(self: Gesture): bool {.inline.} =

# gtk_gesture_get_device
# flags: {isMethod} container: Gesture
# need sugar: is method
# return: INTERFACE 'Gdk3.Device' 'TransferNone[Gdk3.TDevice]' (diff., need sugar)
proc gtk_gesture_get_device(self: ptr TGesture): TransferNone[Gdk3.TDevice] {.cdecl, dynlib: lib, importc: "gtk_gesture_get_device".}
proc get_device*(self: Gesture): Gdk3.Device {.inline.} =
  wrap(gtk_gesture_get_device(self))
# proc get_device*(self: Gesture): Gdk3.Device {.inline.} =

# gtk_gesture_get_group
# flags: {isMethod} container: Gesture
# need sugar: is method
# return: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_gesture_get_group(self: ptr TGesture): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_gesture_get_group".}
proc get_group*(self: Gesture): ptr GLIST_TODO {.inline.} =
  gtk_gesture_get_group(self)
# proc get_group*(self: Gesture): ptr GLIST_TODO {.inline.} =

# gtk_gesture_get_last_event
# flags: {isMethod} container: Gesture
# need sugar: is method
# arg sequence: INTERFACE (STRUCT) 'ptr Gdk3.TEventSequence' 'ptr Gdk3.TEventSequence' IN
# return: INTERFACE 'ptr Gdk3.TEvent' 'ptr Gdk3.TEvent'
proc gtk_gesture_get_last_event(self: ptr TGesture, sequence: ptr Gdk3.TEventSequence): ptr Gdk3.TEvent {.cdecl, dynlib: lib, importc: "gtk_gesture_get_last_event".}
proc get_last_event*(self: Gesture, sequence: ptr Gdk3.TEventSequence): ptr Gdk3.TEvent {.inline.} =
  gtk_gesture_get_last_event(self, sequence)
# proc get_last_event*(self: Gesture, sequence: ptr Gdk3.TEventSequence): ptr Gdk3.TEvent {.inline.} =

# gtk_gesture_get_last_updated_sequence
# flags: {isMethod} container: Gesture
# need sugar: is method
# return: INTERFACE 'ptr Gdk3.TEventSequence' 'ptr Gdk3.TEventSequence'
proc gtk_gesture_get_last_updated_sequence(self: ptr TGesture): ptr Gdk3.TEventSequence {.cdecl, dynlib: lib, importc: "gtk_gesture_get_last_updated_sequence".}
proc get_last_updated_sequence*(self: Gesture): ptr Gdk3.TEventSequence {.inline.} =
  gtk_gesture_get_last_updated_sequence(self)
# proc get_last_updated_sequence*(self: Gesture): ptr Gdk3.TEventSequence {.inline.} =

# gtk_gesture_get_point
# flags: {isMethod} container: Gesture
# need sugar: is method
# arg sequence: INTERFACE (STRUCT) 'ptr Gdk3.TEventSequence' 'ptr Gdk3.TEventSequence' IN
# arg x: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar) optional
# arg y: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar) optional
# return: BOOLEAN 'bool' 'bool'
proc gtk_gesture_get_point(self: ptr TGesture, sequence: ptr Gdk3.TEventSequence, x: ptr float64, y: ptr float64): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_get_point".}
proc get_point*(self: Gesture, sequence: ptr Gdk3.TEventSequence, x: var float64, y: var float64): bool {.inline.} =
  gtk_gesture_get_point(self, sequence, addr(x), addr(y))
# tuple-return
# x: var float64
# y: var float64
# proc get_point*(self: Gesture, sequence: ptr Gdk3.TEventSequence): bool {.inline.} =

# gtk_gesture_get_sequence_state
# flags: {isMethod} container: Gesture
# need sugar: is method
# arg sequence: INTERFACE (STRUCT) 'ptr Gdk3.TEventSequence' 'ptr Gdk3.TEventSequence' IN
# return: INTERFACE 'EventSequenceState' 'EventSequenceState'
proc gtk_gesture_get_sequence_state(self: ptr TGesture, sequence: ptr Gdk3.TEventSequence): EventSequenceState {.cdecl, dynlib: lib, importc: "gtk_gesture_get_sequence_state".}
proc get_sequence_state*(self: Gesture, sequence: ptr Gdk3.TEventSequence): EventSequenceState {.inline.} =
  gtk_gesture_get_sequence_state(self, sequence)
# proc get_sequence_state*(self: Gesture, sequence: ptr Gdk3.TEventSequence): EventSequenceState {.inline.} =

# gtk_gesture_get_sequences
# flags: {isMethod} container: Gesture
# need sugar: is method
# return: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_gesture_get_sequences(self: ptr TGesture): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_gesture_get_sequences".}
proc get_sequences*(self: Gesture): ptr GLIST_TODO {.inline.} =
  gtk_gesture_get_sequences(self)
# proc get_sequences*(self: Gesture): ptr GLIST_TODO {.inline.} =

# gtk_gesture_get_window
# flags: {isMethod} container: Gesture
# need sugar: is method
# return: INTERFACE 'Gdk3.Window' 'TransferNone[Gdk3.TWindow]' (diff., need sugar)
proc gtk_gesture_get_window(self: ptr TGesture): TransferNone[Gdk3.TWindow] {.cdecl, dynlib: lib, importc: "gtk_gesture_get_window".}
proc get_window*(self: Gesture): Gdk3.Window {.inline.} =
  wrap(gtk_gesture_get_window(self))
# proc get_window*(self: Gesture): Gdk3.Window {.inline.} =

# gtk_gesture_group
# flags: {isMethod} container: Gesture
# need sugar: is method
# arg gesture: INTERFACE (OBJECT) 'Gesture' 'ptr TGesture' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_gesture_group(self: ptr TGesture, gesture: ptr TGesture) {.cdecl, dynlib: lib, importc: "gtk_gesture_group".}
proc group*(self: Gesture, gesture: Gesture) {.inline.} =
  gtk_gesture_group(self, gesture.getPointer)
# proc group*(self: Gesture, gesture: Gesture) {.inline.} =

# gtk_gesture_handles_sequence
# flags: {isMethod} container: Gesture
# need sugar: is method
# arg sequence: INTERFACE (STRUCT) 'ptr Gdk3.TEventSequence' 'ptr Gdk3.TEventSequence' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_gesture_handles_sequence(self: ptr TGesture, sequence: ptr Gdk3.TEventSequence): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_handles_sequence".}
proc handles_sequence*(self: Gesture, sequence: ptr Gdk3.TEventSequence): bool {.inline.} =
  gtk_gesture_handles_sequence(self, sequence)
# proc handles_sequence*(self: Gesture, sequence: ptr Gdk3.TEventSequence): bool {.inline.} =

# gtk_gesture_is_active
# flags: {isMethod} container: Gesture
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_gesture_is_active(self: ptr TGesture): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_is_active".}
proc is_active*(self: Gesture): bool {.inline.} =
  gtk_gesture_is_active(self)
# proc is_active*(self: Gesture): bool {.inline.} =

# gtk_gesture_is_grouped_with
# flags: {isMethod} container: Gesture
# need sugar: is method
# arg other: INTERFACE (OBJECT) 'Gesture' 'ptr TGesture' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_gesture_is_grouped_with(self: ptr TGesture, other: ptr TGesture): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_is_grouped_with".}
proc is_grouped_with*(self: Gesture, other: Gesture): bool {.inline.} =
  gtk_gesture_is_grouped_with(self, other.getPointer)
# proc is_grouped_with*(self: Gesture, other: Gesture): bool {.inline.} =

# gtk_gesture_is_recognized
# flags: {isMethod} container: Gesture
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_gesture_is_recognized(self: ptr TGesture): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_is_recognized".}
proc is_recognized*(self: Gesture): bool {.inline.} =
  gtk_gesture_is_recognized(self)
# proc is_recognized*(self: Gesture): bool {.inline.} =

# gtk_gesture_set_sequence_state
# flags: {isMethod} container: Gesture
# need sugar: is method
# arg sequence: INTERFACE (STRUCT) 'ptr Gdk3.TEventSequence' 'ptr Gdk3.TEventSequence' IN
# arg state: INTERFACE (ENUM) 'EventSequenceState' 'EventSequenceState' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_gesture_set_sequence_state(self: ptr TGesture, sequence: ptr Gdk3.TEventSequence, state: EventSequenceState): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_set_sequence_state".}
proc set_sequence_state*(self: Gesture, sequence: ptr Gdk3.TEventSequence, state: EventSequenceState): bool {.inline.} =
  gtk_gesture_set_sequence_state(self, sequence, state)
# proc set_sequence_state*(self: Gesture, sequence: ptr Gdk3.TEventSequence, state: EventSequenceState): bool {.inline.} =

# gtk_gesture_set_state
# flags: {isMethod} container: Gesture
# need sugar: is method
# arg state: INTERFACE (ENUM) 'EventSequenceState' 'EventSequenceState' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_gesture_set_state(self: ptr TGesture, state: EventSequenceState): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_set_state".}
proc set_state*(self: Gesture, state: EventSequenceState): bool {.inline.} =
  gtk_gesture_set_state(self, state)
# proc set_state*(self: Gesture, state: EventSequenceState): bool {.inline.} =

# gtk_gesture_set_window
# flags: {isMethod} container: Gesture
# need sugar: is method
# arg window: INTERFACE (OBJECT) 'Gdk3.Window' 'ptr Gdk3.TWindow' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_gesture_set_window(self: ptr TGesture, window: ptr Gdk3.TWindow) {.cdecl, dynlib: lib, importc: "gtk_gesture_set_window".}
proc set_window*(self: Gesture, window: Gdk3.Window) {.inline.} =
  gtk_gesture_set_window(self, window.getPointer)
# proc set_window*(self: Gesture, window: Gdk3.Window) {.inline.} =

# gtk_gesture_ungroup
# flags: {isMethod} container: Gesture
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_gesture_ungroup(self: ptr TGesture) {.cdecl, dynlib: lib, importc: "gtk_gesture_ungroup".}
proc ungroup*(self: Gesture) {.inline.} =
  gtk_gesture_ungroup(self)
# proc ungroup*(self: Gesture) {.inline.} =

# initializer for GestureDrag: gtk_gesture_drag_get_type
proc gtk_gesture_drag_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_gesture_drag_get_type".}
template gtype*(klass_parameter: typedesc[GestureDrag]): GType = gtk_gesture_drag_get_type()
# gtk_gesture_drag_new
# flags: {isConstructor} container: GestureDrag
# need sugar: is static method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: INTERFACE 'GestureDrag' 'TransferFull[TGestureDrag]' (diff., need sugar)
proc gtk_gesture_drag_new(widget: ptr TWidget): TransferFull[TGestureDrag] {.cdecl, dynlib: lib, importc: "gtk_gesture_drag_new".}
proc new_gesturedrag*(widget: Widget): GestureDrag {.inline.} =
  wrap(gtk_gesture_drag_new(widget.getPointer))
# proc new_gesturedrag*(widget: Widget): GestureDrag {.inline.} =

# gtk_gesture_drag_get_offset
# flags: {isMethod} container: GestureDrag
# need sugar: is method
# arg x: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar)
# arg y: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_gesture_drag_get_offset(self: ptr TGestureDrag, x: ptr float64, y: ptr float64): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_drag_get_offset".}
proc get_offset*(self: GestureDrag, x: var float64, y: var float64): bool {.inline.} =
  gtk_gesture_drag_get_offset(self, addr(x), addr(y))
# tuple-return
# x: var float64
# y: var float64
# proc get_offset*(self: GestureDrag): bool {.inline.} =

# gtk_gesture_drag_get_start_point
# flags: {isMethod} container: GestureDrag
# need sugar: is method
# arg x: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar)
# arg y: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_gesture_drag_get_start_point(self: ptr TGestureDrag, x: ptr float64, y: ptr float64): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_drag_get_start_point".}
proc get_start_point*(self: GestureDrag, x: var float64, y: var float64): bool {.inline.} =
  gtk_gesture_drag_get_start_point(self, addr(x), addr(y))
# tuple-return
# x: var float64
# y: var float64
# proc get_start_point*(self: GestureDrag): bool {.inline.} =

# initializer for GestureLongPress: gtk_gesture_long_press_get_type
proc gtk_gesture_long_press_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_gesture_long_press_get_type".}
template gtype*(klass_parameter: typedesc[GestureLongPress]): GType = gtk_gesture_long_press_get_type()
# gtk_gesture_long_press_new
# flags: {isConstructor} container: GestureLongPress
# need sugar: is static method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: INTERFACE 'GestureLongPress' 'TransferFull[TGestureLongPress]' (diff., need sugar)
proc gtk_gesture_long_press_new(widget: ptr TWidget): TransferFull[TGestureLongPress] {.cdecl, dynlib: lib, importc: "gtk_gesture_long_press_new".}
proc new_gesturelongpress*(widget: Widget): GestureLongPress {.inline.} =
  wrap(gtk_gesture_long_press_new(widget.getPointer))
# proc new_gesturelongpress*(widget: Widget): GestureLongPress {.inline.} =

# initializer for GestureMultiPress: gtk_gesture_multi_press_get_type
proc gtk_gesture_multi_press_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_gesture_multi_press_get_type".}
template gtype*(klass_parameter: typedesc[GestureMultiPress]): GType = gtk_gesture_multi_press_get_type()
# gtk_gesture_multi_press_new
# flags: {isConstructor} container: GestureMultiPress
# need sugar: is static method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: INTERFACE 'GestureMultiPress' 'TransferFull[TGestureMultiPress]' (diff., need sugar)
proc gtk_gesture_multi_press_new(widget: ptr TWidget): TransferFull[TGestureMultiPress] {.cdecl, dynlib: lib, importc: "gtk_gesture_multi_press_new".}
proc new_gesturemultipress*(widget: Widget): GestureMultiPress {.inline.} =
  wrap(gtk_gesture_multi_press_new(widget.getPointer))
# proc new_gesturemultipress*(widget: Widget): GestureMultiPress {.inline.} =

# gtk_gesture_multi_press_get_area
# flags: {isMethod} container: GestureMultiPress
# need sugar: is method
# arg rect: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' OUT caller-allocates
# return: BOOLEAN 'bool' 'bool'
proc gtk_gesture_multi_press_get_area(self: ptr TGestureMultiPress, rect: ptr Gdk3.TRectangle): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_multi_press_get_area".}
proc get_area*(self: GestureMultiPress, rect: ptr Gdk3.TRectangle): bool {.inline.} =
  gtk_gesture_multi_press_get_area(self, rect)
# tuple-return
# rect: ptr Gdk3.TRectangle
# proc get_area*(self: GestureMultiPress): bool {.inline.} =

# gtk_gesture_multi_press_set_area
# flags: {isMethod} container: GestureMultiPress
# need sugar: is method
# arg rect: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_gesture_multi_press_set_area(self: ptr TGestureMultiPress, rect: ptr Gdk3.TRectangle) {.cdecl, dynlib: lib, importc: "gtk_gesture_multi_press_set_area".}
proc set_area*(self: GestureMultiPress, rect: ptr Gdk3.TRectangle) {.inline.} =
  gtk_gesture_multi_press_set_area(self, rect)
# proc set_area*(self: GestureMultiPress, rect: ptr Gdk3.TRectangle) {.inline.} =

# initializer for GesturePan: gtk_gesture_pan_get_type
proc gtk_gesture_pan_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_gesture_pan_get_type".}
template gtype*(klass_parameter: typedesc[GesturePan]): GType = gtk_gesture_pan_get_type()
# gtk_gesture_pan_new
# flags: {isConstructor} container: GesturePan
# need sugar: is static method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg orientation: INTERFACE (ENUM) 'Orientation' 'Orientation' IN
# return: INTERFACE 'GesturePan' 'TransferFull[TGesturePan]' (diff., need sugar)
proc gtk_gesture_pan_new(widget: ptr TWidget, orientation: Orientation): TransferFull[TGesturePan] {.cdecl, dynlib: lib, importc: "gtk_gesture_pan_new".}
proc new_gesturepan*(widget: Widget, orientation: Orientation): GesturePan {.inline.} =
  wrap(gtk_gesture_pan_new(widget.getPointer, orientation))
# proc new_gesturepan*(widget: Widget, orientation: Orientation): GesturePan {.inline.} =

# gtk_gesture_pan_get_orientation
# flags: {isMethod} container: GesturePan
# need sugar: is method
# return: INTERFACE 'Orientation' 'Orientation'
proc gtk_gesture_pan_get_orientation(self: ptr TGesturePan): Orientation {.cdecl, dynlib: lib, importc: "gtk_gesture_pan_get_orientation".}
proc get_orientation*(self: GesturePan): Orientation {.inline.} =
  gtk_gesture_pan_get_orientation(self)
# proc get_orientation*(self: GesturePan): Orientation {.inline.} =

# gtk_gesture_pan_set_orientation
# flags: {isMethod} container: GesturePan
# need sugar: is method
# arg orientation: INTERFACE (ENUM) 'Orientation' 'Orientation' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_gesture_pan_set_orientation(self: ptr TGesturePan, orientation: Orientation) {.cdecl, dynlib: lib, importc: "gtk_gesture_pan_set_orientation".}
proc set_orientation*(self: GesturePan, orientation: Orientation) {.inline.} =
  gtk_gesture_pan_set_orientation(self, orientation)
# proc set_orientation*(self: GesturePan, orientation: Orientation) {.inline.} =

# initializer for GestureRotate: gtk_gesture_rotate_get_type
proc gtk_gesture_rotate_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_gesture_rotate_get_type".}
template gtype*(klass_parameter: typedesc[GestureRotate]): GType = gtk_gesture_rotate_get_type()
# gtk_gesture_rotate_new
# flags: {isConstructor} container: GestureRotate
# need sugar: is static method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: INTERFACE 'GestureRotate' 'TransferFull[TGestureRotate]' (diff., need sugar)
proc gtk_gesture_rotate_new(widget: ptr TWidget): TransferFull[TGestureRotate] {.cdecl, dynlib: lib, importc: "gtk_gesture_rotate_new".}
proc new_gesturerotate*(widget: Widget): GestureRotate {.inline.} =
  wrap(gtk_gesture_rotate_new(widget.getPointer))
# proc new_gesturerotate*(widget: Widget): GestureRotate {.inline.} =

# gtk_gesture_rotate_get_angle_delta
# flags: {isMethod} container: GestureRotate
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_gesture_rotate_get_angle_delta(self: ptr TGestureRotate): float64 {.cdecl, dynlib: lib, importc: "gtk_gesture_rotate_get_angle_delta".}
proc get_angle_delta*(self: GestureRotate): float64 {.inline.} =
  gtk_gesture_rotate_get_angle_delta(self)
# proc get_angle_delta*(self: GestureRotate): float64 {.inline.} =

# initializer for GestureSingle: gtk_gesture_single_get_type
proc gtk_gesture_single_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_gesture_single_get_type".}
template gtype*(klass_parameter: typedesc[GestureSingle]): GType = gtk_gesture_single_get_type()
# gtk_gesture_single_get_button
# flags: {isMethod} container: GestureSingle
# need sugar: is method
# return: UINT32 'uint32' 'uint32'
proc gtk_gesture_single_get_button(self: ptr TGestureSingle): uint32 {.cdecl, dynlib: lib, importc: "gtk_gesture_single_get_button".}
proc get_button*(self: GestureSingle): uint32 {.inline.} =
  gtk_gesture_single_get_button(self)
# proc get_button*(self: GestureSingle): uint32 {.inline.} =

# gtk_gesture_single_get_current_button
# flags: {isMethod} container: GestureSingle
# need sugar: is method
# return: UINT32 'uint32' 'uint32'
proc gtk_gesture_single_get_current_button(self: ptr TGestureSingle): uint32 {.cdecl, dynlib: lib, importc: "gtk_gesture_single_get_current_button".}
proc get_current_button*(self: GestureSingle): uint32 {.inline.} =
  gtk_gesture_single_get_current_button(self)
# proc get_current_button*(self: GestureSingle): uint32 {.inline.} =

# gtk_gesture_single_get_current_sequence
# flags: {isMethod} container: GestureSingle
# need sugar: is method
# return: INTERFACE 'ptr Gdk3.TEventSequence' 'ptr Gdk3.TEventSequence'
proc gtk_gesture_single_get_current_sequence(self: ptr TGestureSingle): ptr Gdk3.TEventSequence {.cdecl, dynlib: lib, importc: "gtk_gesture_single_get_current_sequence".}
proc get_current_sequence*(self: GestureSingle): ptr Gdk3.TEventSequence {.inline.} =
  gtk_gesture_single_get_current_sequence(self)
# proc get_current_sequence*(self: GestureSingle): ptr Gdk3.TEventSequence {.inline.} =

# gtk_gesture_single_get_exclusive
# flags: {isMethod} container: GestureSingle
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_gesture_single_get_exclusive(self: ptr TGestureSingle): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_single_get_exclusive".}
proc get_exclusive*(self: GestureSingle): bool {.inline.} =
  gtk_gesture_single_get_exclusive(self)
# proc get_exclusive*(self: GestureSingle): bool {.inline.} =

# gtk_gesture_single_get_touch_only
# flags: {isMethod} container: GestureSingle
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_gesture_single_get_touch_only(self: ptr TGestureSingle): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_single_get_touch_only".}
proc get_touch_only*(self: GestureSingle): bool {.inline.} =
  gtk_gesture_single_get_touch_only(self)
# proc get_touch_only*(self: GestureSingle): bool {.inline.} =

# gtk_gesture_single_set_button
# flags: {isMethod} container: GestureSingle
# need sugar: is method
# arg button: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_gesture_single_set_button(self: ptr TGestureSingle, button: uint32) {.cdecl, dynlib: lib, importc: "gtk_gesture_single_set_button".}
proc set_button*(self: GestureSingle, button: uint32) {.inline.} =
  gtk_gesture_single_set_button(self, button)
# proc set_button*(self: GestureSingle, button: uint32) {.inline.} =

# gtk_gesture_single_set_exclusive
# flags: {isMethod} container: GestureSingle
# need sugar: is method
# arg exclusive: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_gesture_single_set_exclusive(self: ptr TGestureSingle, exclusive: bool) {.cdecl, dynlib: lib, importc: "gtk_gesture_single_set_exclusive".}
proc set_exclusive*(self: GestureSingle, exclusive: bool) {.inline.} =
  gtk_gesture_single_set_exclusive(self, exclusive)
# proc set_exclusive*(self: GestureSingle, exclusive: bool) {.inline.} =

# gtk_gesture_single_set_touch_only
# flags: {isMethod} container: GestureSingle
# need sugar: is method
# arg touch_only: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_gesture_single_set_touch_only(self: ptr TGestureSingle, touch_only: bool) {.cdecl, dynlib: lib, importc: "gtk_gesture_single_set_touch_only".}
proc set_touch_only*(self: GestureSingle, touch_only: bool) {.inline.} =
  gtk_gesture_single_set_touch_only(self, touch_only)
# proc set_touch_only*(self: GestureSingle, touch_only: bool) {.inline.} =

# initializer for GestureSwipe: gtk_gesture_swipe_get_type
proc gtk_gesture_swipe_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_gesture_swipe_get_type".}
template gtype*(klass_parameter: typedesc[GestureSwipe]): GType = gtk_gesture_swipe_get_type()
# gtk_gesture_swipe_new
# flags: {isConstructor} container: GestureSwipe
# need sugar: is static method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: INTERFACE 'GestureSwipe' 'TransferFull[TGestureSwipe]' (diff., need sugar)
proc gtk_gesture_swipe_new(widget: ptr TWidget): TransferFull[TGestureSwipe] {.cdecl, dynlib: lib, importc: "gtk_gesture_swipe_new".}
proc new_gestureswipe*(widget: Widget): GestureSwipe {.inline.} =
  wrap(gtk_gesture_swipe_new(widget.getPointer))
# proc new_gestureswipe*(widget: Widget): GestureSwipe {.inline.} =

# gtk_gesture_swipe_get_velocity
# flags: {isMethod} container: GestureSwipe
# need sugar: is method
# arg velocity_x: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar)
# arg velocity_y: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_gesture_swipe_get_velocity(self: ptr TGestureSwipe, velocity_x: ptr float64, velocity_y: ptr float64): bool {.cdecl, dynlib: lib, importc: "gtk_gesture_swipe_get_velocity".}
proc get_velocity*(self: GestureSwipe, velocity_x: var float64, velocity_y: var float64): bool {.inline.} =
  gtk_gesture_swipe_get_velocity(self, addr(velocity_x), addr(velocity_y))
# tuple-return
# velocity_x: var float64
# velocity_y: var float64
# proc get_velocity*(self: GestureSwipe): bool {.inline.} =

# initializer for GestureZoom: gtk_gesture_zoom_get_type
proc gtk_gesture_zoom_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_gesture_zoom_get_type".}
template gtype*(klass_parameter: typedesc[GestureZoom]): GType = gtk_gesture_zoom_get_type()
# gtk_gesture_zoom_new
# flags: {isConstructor} container: GestureZoom
# need sugar: is static method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: INTERFACE 'GestureZoom' 'TransferFull[TGestureZoom]' (diff., need sugar)
proc gtk_gesture_zoom_new(widget: ptr TWidget): TransferFull[TGestureZoom] {.cdecl, dynlib: lib, importc: "gtk_gesture_zoom_new".}
proc new_gesturezoom*(widget: Widget): GestureZoom {.inline.} =
  wrap(gtk_gesture_zoom_new(widget.getPointer))
# proc new_gesturezoom*(widget: Widget): GestureZoom {.inline.} =

# gtk_gesture_zoom_get_scale_delta
# flags: {isMethod} container: GestureZoom
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_gesture_zoom_get_scale_delta(self: ptr TGestureZoom): float64 {.cdecl, dynlib: lib, importc: "gtk_gesture_zoom_get_scale_delta".}
proc get_scale_delta*(self: GestureZoom): float64 {.inline.} =
  gtk_gesture_zoom_get_scale_delta(self)
# proc get_scale_delta*(self: GestureZoom): float64 {.inline.} =

# initializer for Grid: gtk_grid_get_type
proc gtk_grid_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_grid_get_type".}
template gtype*(klass_parameter: typedesc[Grid]): GType = gtk_grid_get_type()
# gtk_grid_new
# flags: {isConstructor} container: Grid
# need sugar: is static method
# return: INTERFACE 'Grid' 'TransferNone[TGrid]' (diff., need sugar)
proc gtk_grid_new(): TransferNone[TGrid] {.cdecl, dynlib: lib, importc: "gtk_grid_new".}
proc new_grid*(): Grid {.inline.} =
  wrap(gtk_grid_new())
# proc new_grid*(): Grid {.inline.} =

# gtk_grid_attach
# flags: {isMethod} container: Grid
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg left: INT32 'int32' 'int32' IN
# arg top: INT32 'int32' 'int32' IN
# arg width: INT32 'int32' 'int32' IN
# arg height: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_grid_attach(self: ptr TGrid, child: ptr TWidget, left: int32, top: int32, width: int32, height: int32) {.cdecl, dynlib: lib, importc: "gtk_grid_attach".}
proc attach*(self: Grid, child: Widget, left: int32, top: int32, width: int32, height: int32) {.inline.} =
  gtk_grid_attach(self, child.getPointer, left, top, width, height)
# proc attach*(self: Grid, child: Widget, left: int32, top: int32, width: int32, height: int32) {.inline.} =

# gtk_grid_attach_next_to
# flags: {isMethod} container: Grid
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg sibling: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg side: INTERFACE (ENUM) 'PositionType' 'PositionType' IN
# arg width: INT32 'int32' 'int32' IN
# arg height: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_grid_attach_next_to(self: ptr TGrid, child: ptr TWidget, sibling: ptr TWidget, side: PositionType, width: int32, height: int32) {.cdecl, dynlib: lib, importc: "gtk_grid_attach_next_to".}
proc attach_next_to*(self: Grid, child: Widget, sibling: Widget, side: PositionType, width: int32, height: int32) {.inline.} =
  gtk_grid_attach_next_to(self, child.getPointer, sibling.getPointer, side, width, height)
# proc attach_next_to*(self: Grid, child: Widget, sibling: Widget, side: PositionType, width: int32, height: int32) {.inline.} =

# gtk_grid_get_baseline_row
# flags: {isMethod} container: Grid
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_grid_get_baseline_row(self: ptr TGrid): int32 {.cdecl, dynlib: lib, importc: "gtk_grid_get_baseline_row".}
proc get_baseline_row*(self: Grid): int32 {.inline.} =
  gtk_grid_get_baseline_row(self)
# proc get_baseline_row*(self: Grid): int32 {.inline.} =

# gtk_grid_get_child_at
# flags: {isMethod} container: Grid
# need sugar: is method
# arg left: INT32 'int32' 'int32' IN
# arg top: INT32 'int32' 'int32' IN
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_grid_get_child_at(self: ptr TGrid, left: int32, top: int32): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_grid_get_child_at".}
proc get_child_at*(self: Grid, left: int32, top: int32): Widget {.inline.} =
  wrap(gtk_grid_get_child_at(self, left, top))
# proc get_child_at*(self: Grid, left: int32, top: int32): Widget {.inline.} =

# gtk_grid_get_column_homogeneous
# flags: {isMethod} container: Grid
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_grid_get_column_homogeneous(self: ptr TGrid): bool {.cdecl, dynlib: lib, importc: "gtk_grid_get_column_homogeneous".}
proc get_column_homogeneous*(self: Grid): bool {.inline.} =
  gtk_grid_get_column_homogeneous(self)
# proc get_column_homogeneous*(self: Grid): bool {.inline.} =

# gtk_grid_get_column_spacing
# flags: {isMethod} container: Grid
# need sugar: is method
# return: UINT32 'uint32' 'uint32'
proc gtk_grid_get_column_spacing(self: ptr TGrid): uint32 {.cdecl, dynlib: lib, importc: "gtk_grid_get_column_spacing".}
proc get_column_spacing*(self: Grid): uint32 {.inline.} =
  gtk_grid_get_column_spacing(self)
# proc get_column_spacing*(self: Grid): uint32 {.inline.} =

# gtk_grid_get_row_baseline_position
# flags: {isMethod} container: Grid
# need sugar: is method
# arg row: INT32 'int32' 'int32' IN
# return: INTERFACE 'BaselinePosition' 'BaselinePosition'
proc gtk_grid_get_row_baseline_position(self: ptr TGrid, row: int32): BaselinePosition {.cdecl, dynlib: lib, importc: "gtk_grid_get_row_baseline_position".}
proc get_row_baseline_position*(self: Grid, row: int32): BaselinePosition {.inline.} =
  gtk_grid_get_row_baseline_position(self, row)
# proc get_row_baseline_position*(self: Grid, row: int32): BaselinePosition {.inline.} =

# gtk_grid_get_row_homogeneous
# flags: {isMethod} container: Grid
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_grid_get_row_homogeneous(self: ptr TGrid): bool {.cdecl, dynlib: lib, importc: "gtk_grid_get_row_homogeneous".}
proc get_row_homogeneous*(self: Grid): bool {.inline.} =
  gtk_grid_get_row_homogeneous(self)
# proc get_row_homogeneous*(self: Grid): bool {.inline.} =

# gtk_grid_get_row_spacing
# flags: {isMethod} container: Grid
# need sugar: is method
# return: UINT32 'uint32' 'uint32'
proc gtk_grid_get_row_spacing(self: ptr TGrid): uint32 {.cdecl, dynlib: lib, importc: "gtk_grid_get_row_spacing".}
proc get_row_spacing*(self: Grid): uint32 {.inline.} =
  gtk_grid_get_row_spacing(self)
# proc get_row_spacing*(self: Grid): uint32 {.inline.} =

# gtk_grid_insert_column
# flags: {isMethod} container: Grid
# need sugar: is method
# arg position: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_grid_insert_column(self: ptr TGrid, position: int32) {.cdecl, dynlib: lib, importc: "gtk_grid_insert_column".}
proc insert_column*(self: Grid, position: int32) {.inline.} =
  gtk_grid_insert_column(self, position)
# proc insert_column*(self: Grid, position: int32) {.inline.} =

# gtk_grid_insert_next_to
# flags: {isMethod} container: Grid
# need sugar: is method
# arg sibling: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg side: INTERFACE (ENUM) 'PositionType' 'PositionType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_grid_insert_next_to(self: ptr TGrid, sibling: ptr TWidget, side: PositionType) {.cdecl, dynlib: lib, importc: "gtk_grid_insert_next_to".}
proc insert_next_to*(self: Grid, sibling: Widget, side: PositionType) {.inline.} =
  gtk_grid_insert_next_to(self, sibling.getPointer, side)
# proc insert_next_to*(self: Grid, sibling: Widget, side: PositionType) {.inline.} =

# gtk_grid_insert_row
# flags: {isMethod} container: Grid
# need sugar: is method
# arg position: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_grid_insert_row(self: ptr TGrid, position: int32) {.cdecl, dynlib: lib, importc: "gtk_grid_insert_row".}
proc insert_row*(self: Grid, position: int32) {.inline.} =
  gtk_grid_insert_row(self, position)
# proc insert_row*(self: Grid, position: int32) {.inline.} =

# gtk_grid_remove_column
# flags: {isMethod} container: Grid
# need sugar: is method
# arg position: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_grid_remove_column(self: ptr TGrid, position: int32) {.cdecl, dynlib: lib, importc: "gtk_grid_remove_column".}
proc remove_column*(self: Grid, position: int32) {.inline.} =
  gtk_grid_remove_column(self, position)
# proc remove_column*(self: Grid, position: int32) {.inline.} =

# gtk_grid_remove_row
# flags: {isMethod} container: Grid
# need sugar: is method
# arg position: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_grid_remove_row(self: ptr TGrid, position: int32) {.cdecl, dynlib: lib, importc: "gtk_grid_remove_row".}
proc remove_row*(self: Grid, position: int32) {.inline.} =
  gtk_grid_remove_row(self, position)
# proc remove_row*(self: Grid, position: int32) {.inline.} =

# gtk_grid_set_baseline_row
# flags: {isMethod} container: Grid
# need sugar: is method
# arg row: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_grid_set_baseline_row(self: ptr TGrid, row: int32) {.cdecl, dynlib: lib, importc: "gtk_grid_set_baseline_row".}
proc set_baseline_row*(self: Grid, row: int32) {.inline.} =
  gtk_grid_set_baseline_row(self, row)
# proc set_baseline_row*(self: Grid, row: int32) {.inline.} =

# gtk_grid_set_column_homogeneous
# flags: {isMethod} container: Grid
# need sugar: is method
# arg homogeneous: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_grid_set_column_homogeneous(self: ptr TGrid, homogeneous: bool) {.cdecl, dynlib: lib, importc: "gtk_grid_set_column_homogeneous".}
proc set_column_homogeneous*(self: Grid, homogeneous: bool) {.inline.} =
  gtk_grid_set_column_homogeneous(self, homogeneous)
# proc set_column_homogeneous*(self: Grid, homogeneous: bool) {.inline.} =

# gtk_grid_set_column_spacing
# flags: {isMethod} container: Grid
# need sugar: is method
# arg spacing: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_grid_set_column_spacing(self: ptr TGrid, spacing: uint32) {.cdecl, dynlib: lib, importc: "gtk_grid_set_column_spacing".}
proc set_column_spacing*(self: Grid, spacing: uint32) {.inline.} =
  gtk_grid_set_column_spacing(self, spacing)
# proc set_column_spacing*(self: Grid, spacing: uint32) {.inline.} =

# gtk_grid_set_row_baseline_position
# flags: {isMethod} container: Grid
# need sugar: is method
# arg row: INT32 'int32' 'int32' IN
# arg pos: INTERFACE (ENUM) 'BaselinePosition' 'BaselinePosition' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_grid_set_row_baseline_position(self: ptr TGrid, row: int32, pos: BaselinePosition) {.cdecl, dynlib: lib, importc: "gtk_grid_set_row_baseline_position".}
proc set_row_baseline_position*(self: Grid, row: int32, pos: BaselinePosition) {.inline.} =
  gtk_grid_set_row_baseline_position(self, row, pos)
# proc set_row_baseline_position*(self: Grid, row: int32, pos: BaselinePosition) {.inline.} =

# gtk_grid_set_row_homogeneous
# flags: {isMethod} container: Grid
# need sugar: is method
# arg homogeneous: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_grid_set_row_homogeneous(self: ptr TGrid, homogeneous: bool) {.cdecl, dynlib: lib, importc: "gtk_grid_set_row_homogeneous".}
proc set_row_homogeneous*(self: Grid, homogeneous: bool) {.inline.} =
  gtk_grid_set_row_homogeneous(self, homogeneous)
# proc set_row_homogeneous*(self: Grid, homogeneous: bool) {.inline.} =

# gtk_grid_set_row_spacing
# flags: {isMethod} container: Grid
# need sugar: is method
# arg spacing: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_grid_set_row_spacing(self: ptr TGrid, spacing: uint32) {.cdecl, dynlib: lib, importc: "gtk_grid_set_row_spacing".}
proc set_row_spacing*(self: Grid, spacing: uint32) {.inline.} =
  gtk_grid_set_row_spacing(self, spacing)
# proc set_row_spacing*(self: Grid, spacing: uint32) {.inline.} =

# initializer for HBox: gtk_hbox_get_type
proc gtk_hbox_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_hbox_get_type".}
template gtype*(klass_parameter: typedesc[HBox]): GType = gtk_hbox_get_type()
# gtk_hbox_new
# flags: {isConstructor} container: HBox (deprecated)
# initializer for HButtonBox: gtk_hbutton_box_get_type
proc gtk_hbutton_box_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_hbutton_box_get_type".}
template gtype*(klass_parameter: typedesc[HButtonBox]): GType = gtk_hbutton_box_get_type()
# gtk_hbutton_box_new
# flags: {isConstructor} container: HButtonBox (deprecated)
# initializer for HPaned: gtk_hpaned_get_type
proc gtk_hpaned_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_hpaned_get_type".}
template gtype*(klass_parameter: typedesc[HPaned]): GType = gtk_hpaned_get_type()
# gtk_hpaned_new
# flags: {isConstructor} container: HPaned (deprecated)
# initializer for HSV: gtk_hsv_get_type
proc gtk_hsv_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_hsv_get_type".}
template gtype*(klass_parameter: typedesc[HSV]): GType = gtk_hsv_get_type()
# gtk_hsv_new
# flags: {isConstructor} container: HSV
# need sugar: is static method
# return: INTERFACE 'HSV' 'TransferNone[THSV]' (diff., need sugar)
proc gtk_hsv_new(): TransferNone[THSV] {.cdecl, dynlib: lib, importc: "gtk_hsv_new".}
proc new_hsv*(): HSV {.inline.} =
  wrap(gtk_hsv_new())
# proc new_hsv*(): HSV {.inline.} =

# gtk_hsv_to_rgb
# flags: {} container: HSV
# need sugar: is static method
# arg h: DOUBLE 'float64' 'float64' IN
# arg s: DOUBLE 'float64' 'float64' IN
# arg v: DOUBLE 'float64' 'float64' IN
# arg r: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar)
# arg g: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar)
# arg b: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_hsv_to_rgb(h: float64, s: float64, v: float64, r: ptr float64, g: ptr float64, b: ptr float64) {.cdecl, dynlib: lib, importc: "gtk_hsv_to_rgb".}
template to_rgb*(klass_parameter: typedesc[HSV], h: float64, s: float64, v: float64, r: var float64, g: var float64, b: var float64) =
  gtk_hsv_to_rgb(h, s, v, addr(r), addr(g), addr(b))
# tuple-return
# r: var float64
# g: var float64
# b: var float64
# template to_rgb*(klass_parameter: typedesc[HSV], h: float64, s: float64, v: float64) =

# gtk_hsv_get_color
# flags: {isMethod} container: HSV
# need sugar: is method
# arg h: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar)
# arg s: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar)
# arg v: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_hsv_get_color(self: ptr THSV, h: ptr float64, s: ptr float64, v: ptr float64) {.cdecl, dynlib: lib, importc: "gtk_hsv_get_color".}
proc get_color*(self: HSV, h: var float64, s: var float64, v: var float64) {.inline.} =
  gtk_hsv_get_color(self, addr(h), addr(s), addr(v))
# tuple-return
# h: var float64
# s: var float64
# v: var float64
# proc get_color*(self: HSV) {.inline.} =

# gtk_hsv_get_metrics
# flags: {isMethod} container: HSV
# need sugar: is method
# arg size: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# arg ring_width: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_hsv_get_metrics(self: ptr THSV, size: ptr int32, ring_width: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_hsv_get_metrics".}
proc get_metrics*(self: HSV, size: var int32, ring_width: var int32) {.inline.} =
  gtk_hsv_get_metrics(self, addr(size), addr(ring_width))
# tuple-return
# size: var int32
# ring_width: var int32
# proc get_metrics*(self: HSV) {.inline.} =

# gtk_hsv_is_adjusting
# flags: {isMethod} container: HSV
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_hsv_is_adjusting(self: ptr THSV): bool {.cdecl, dynlib: lib, importc: "gtk_hsv_is_adjusting".}
proc is_adjusting*(self: HSV): bool {.inline.} =
  gtk_hsv_is_adjusting(self)
# proc is_adjusting*(self: HSV): bool {.inline.} =

# gtk_hsv_set_color
# flags: {isMethod} container: HSV
# need sugar: is method
# arg h: DOUBLE 'float64' 'float64' IN
# arg s: DOUBLE 'float64' 'float64' IN
# arg v: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_hsv_set_color(self: ptr THSV, h: float64, s: float64, v: float64) {.cdecl, dynlib: lib, importc: "gtk_hsv_set_color".}
proc set_color*(self: HSV, h: float64, s: float64, v: float64) {.inline.} =
  gtk_hsv_set_color(self, h, s, v)
# proc set_color*(self: HSV, h: float64, s: float64, v: float64) {.inline.} =

# gtk_hsv_set_metrics
# flags: {isMethod} container: HSV
# need sugar: is method
# arg size: INT32 'int32' 'int32' IN
# arg ring_width: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_hsv_set_metrics(self: ptr THSV, size: int32, ring_width: int32) {.cdecl, dynlib: lib, importc: "gtk_hsv_set_metrics".}
proc set_metrics*(self: HSV, size: int32, ring_width: int32) {.inline.} =
  gtk_hsv_set_metrics(self, size, ring_width)
# proc set_metrics*(self: HSV, size: int32, ring_width: int32) {.inline.} =

# initializer for HScale: gtk_hscale_get_type
proc gtk_hscale_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_hscale_get_type".}
template gtype*(klass_parameter: typedesc[HScale]): GType = gtk_hscale_get_type()
# gtk_hscale_new
# flags: {isConstructor} container: HScale (deprecated)
# gtk_hscale_new_with_range
# flags: {isConstructor} container: HScale (deprecated)
# initializer for HScrollbar: gtk_hscrollbar_get_type
proc gtk_hscrollbar_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_hscrollbar_get_type".}
template gtype*(klass_parameter: typedesc[HScrollbar]): GType = gtk_hscrollbar_get_type()
# gtk_hscrollbar_new
# flags: {isConstructor} container: HScrollbar (deprecated)
# initializer for HSeparator: gtk_hseparator_get_type
proc gtk_hseparator_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_hseparator_get_type".}
template gtype*(klass_parameter: typedesc[HSeparator]): GType = gtk_hseparator_get_type()
# gtk_hseparator_new
# flags: {isConstructor} container: HSeparator (deprecated)
# initializer for HandleBox: gtk_handle_box_get_type
proc gtk_handle_box_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_handle_box_get_type".}
template gtype*(klass_parameter: typedesc[HandleBox]): GType = gtk_handle_box_get_type()
# gtk_handle_box_new
# flags: {isConstructor} container: HandleBox (deprecated)
# gtk_handle_box_get_child_detached
# flags: {isMethod} container: HandleBox (deprecated)
# gtk_handle_box_get_handle_position
# flags: {isMethod} container: HandleBox (deprecated)
# gtk_handle_box_get_shadow_type
# flags: {isMethod} container: HandleBox (deprecated)
# gtk_handle_box_get_snap_edge
# flags: {isMethod} container: HandleBox (deprecated)
# gtk_handle_box_set_handle_position
# flags: {isMethod} container: HandleBox (deprecated)
# gtk_handle_box_set_shadow_type
# flags: {isMethod} container: HandleBox (deprecated)
# gtk_handle_box_set_snap_edge
# flags: {isMethod} container: HandleBox (deprecated)
# initializer for HeaderBar: gtk_header_bar_get_type
proc gtk_header_bar_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_header_bar_get_type".}
template gtype*(klass_parameter: typedesc[HeaderBar]): GType = gtk_header_bar_get_type()
# gtk_header_bar_new
# flags: {isConstructor} container: HeaderBar
# need sugar: is static method
# return: INTERFACE 'HeaderBar' 'TransferNone[THeaderBar]' (diff., need sugar)
proc gtk_header_bar_new(): TransferNone[THeaderBar] {.cdecl, dynlib: lib, importc: "gtk_header_bar_new".}
proc new_headerbar*(): HeaderBar {.inline.} =
  wrap(gtk_header_bar_new())
# proc new_headerbar*(): HeaderBar {.inline.} =

# gtk_header_bar_get_custom_title
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_header_bar_get_custom_title(self: ptr THeaderBar): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_header_bar_get_custom_title".}
proc get_custom_title*(self: HeaderBar): Widget {.inline.} =
  wrap(gtk_header_bar_get_custom_title(self))
# proc get_custom_title*(self: HeaderBar): Widget {.inline.} =

# gtk_header_bar_get_decoration_layout
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_header_bar_get_decoration_layout(self: ptr THeaderBar): ucstring {.cdecl, dynlib: lib, importc: "gtk_header_bar_get_decoration_layout".}
proc get_decoration_layout*(self: HeaderBar): ucstring {.inline.} =
  gtk_header_bar_get_decoration_layout(self)
# proc get_decoration_layout*(self: HeaderBar): ucstring {.inline.} =

# gtk_header_bar_get_has_subtitle
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_header_bar_get_has_subtitle(self: ptr THeaderBar): bool {.cdecl, dynlib: lib, importc: "gtk_header_bar_get_has_subtitle".}
proc get_has_subtitle*(self: HeaderBar): bool {.inline.} =
  gtk_header_bar_get_has_subtitle(self)
# proc get_has_subtitle*(self: HeaderBar): bool {.inline.} =

# gtk_header_bar_get_show_close_button
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_header_bar_get_show_close_button(self: ptr THeaderBar): bool {.cdecl, dynlib: lib, importc: "gtk_header_bar_get_show_close_button".}
proc get_show_close_button*(self: HeaderBar): bool {.inline.} =
  gtk_header_bar_get_show_close_button(self)
# proc get_show_close_button*(self: HeaderBar): bool {.inline.} =

# gtk_header_bar_get_subtitle
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_header_bar_get_subtitle(self: ptr THeaderBar): ucstring {.cdecl, dynlib: lib, importc: "gtk_header_bar_get_subtitle".}
proc get_subtitle*(self: HeaderBar): ucstring {.inline.} =
  gtk_header_bar_get_subtitle(self)
# proc get_subtitle*(self: HeaderBar): ucstring {.inline.} =

# gtk_header_bar_get_title
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_header_bar_get_title(self: ptr THeaderBar): ucstring {.cdecl, dynlib: lib, importc: "gtk_header_bar_get_title".}
proc get_title*(self: HeaderBar): ucstring {.inline.} =
  gtk_header_bar_get_title(self)
# proc get_title*(self: HeaderBar): ucstring {.inline.} =

# gtk_header_bar_pack_end
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_header_bar_pack_end(self: ptr THeaderBar, child: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_header_bar_pack_end".}
proc pack_end*(self: HeaderBar, child: Widget) {.inline.} =
  gtk_header_bar_pack_end(self, child.getPointer)
# proc pack_end*(self: HeaderBar, child: Widget) {.inline.} =

# gtk_header_bar_pack_start
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_header_bar_pack_start(self: ptr THeaderBar, child: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_header_bar_pack_start".}
proc pack_start*(self: HeaderBar, child: Widget) {.inline.} =
  gtk_header_bar_pack_start(self, child.getPointer)
# proc pack_start*(self: HeaderBar, child: Widget) {.inline.} =

# gtk_header_bar_set_custom_title
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# arg title_widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_header_bar_set_custom_title(self: ptr THeaderBar, title_widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_header_bar_set_custom_title".}
proc set_custom_title*(self: HeaderBar, title_widget: Widget) {.inline.} =
  gtk_header_bar_set_custom_title(self, title_widget.getPointer)
# proc set_custom_title*(self: HeaderBar, title_widget: Widget) {.inline.} =

# gtk_header_bar_set_decoration_layout
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# arg layout: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_header_bar_set_decoration_layout(self: ptr THeaderBar, layout: ucstring) {.cdecl, dynlib: lib, importc: "gtk_header_bar_set_decoration_layout".}
proc set_decoration_layout*(self: HeaderBar, layout: ustring) {.inline.} =
  gtk_header_bar_set_decoration_layout(self, ucstring(layout))
# proc set_decoration_layout*(self: HeaderBar, layout: ustring) {.inline.} =

# gtk_header_bar_set_has_subtitle
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_header_bar_set_has_subtitle(self: ptr THeaderBar, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_header_bar_set_has_subtitle".}
proc set_has_subtitle*(self: HeaderBar, setting: bool) {.inline.} =
  gtk_header_bar_set_has_subtitle(self, setting)
# proc set_has_subtitle*(self: HeaderBar, setting: bool) {.inline.} =

# gtk_header_bar_set_show_close_button
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_header_bar_set_show_close_button(self: ptr THeaderBar, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_header_bar_set_show_close_button".}
proc set_show_close_button*(self: HeaderBar, setting: bool) {.inline.} =
  gtk_header_bar_set_show_close_button(self, setting)
# proc set_show_close_button*(self: HeaderBar, setting: bool) {.inline.} =

# gtk_header_bar_set_subtitle
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# arg subtitle: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_header_bar_set_subtitle(self: ptr THeaderBar, subtitle: ucstring) {.cdecl, dynlib: lib, importc: "gtk_header_bar_set_subtitle".}
proc set_subtitle*(self: HeaderBar, subtitle: ustring) {.inline.} =
  gtk_header_bar_set_subtitle(self, ucstring(subtitle))
# proc set_subtitle*(self: HeaderBar, subtitle: ustring) {.inline.} =

# gtk_header_bar_set_title
# flags: {isMethod} container: HeaderBar
# need sugar: is method
# arg title: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_header_bar_set_title(self: ptr THeaderBar, title: ucstring) {.cdecl, dynlib: lib, importc: "gtk_header_bar_set_title".}
proc set_title*(self: HeaderBar, title: ustring) {.inline.} =
  gtk_header_bar_set_title(self, ucstring(title))
# proc set_title*(self: HeaderBar, title: ustring) {.inline.} =

# initializer for IMContext: gtk_im_context_get_type
proc gtk_im_context_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_im_context_get_type".}
template gtype*(klass_parameter: typedesc[IMContext]): GType = gtk_im_context_get_type()
# gtk_im_context_delete_surrounding
# flags: {isMethod} container: IMContext
# need sugar: is method
# arg offset: INT32 'int32' 'int32' IN
# arg n_chars: INT32 'int32' 'int32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_im_context_delete_surrounding(self: ptr TIMContext, offset: int32, n_chars: int32): bool {.cdecl, dynlib: lib, importc: "gtk_im_context_delete_surrounding".}
proc delete_surrounding*(self: IMContext, offset: int32, n_chars: int32): bool {.inline.} =
  gtk_im_context_delete_surrounding(self, offset, n_chars)
# proc delete_surrounding*(self: IMContext, offset: int32, n_chars: int32): bool {.inline.} =

# gtk_im_context_filter_keypress
# flags: {isMethod} container: IMContext
# need sugar: is method
# arg event: INTERFACE (STRUCT) 'ptr Gdk3.TEventKey' 'ptr Gdk3.TEventKey' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_im_context_filter_keypress(self: ptr TIMContext, event: ptr Gdk3.TEventKey): bool {.cdecl, dynlib: lib, importc: "gtk_im_context_filter_keypress".}
proc filter_keypress*(self: IMContext, event: ptr Gdk3.TEventKey): bool {.inline.} =
  gtk_im_context_filter_keypress(self, event)
# proc filter_keypress*(self: IMContext, event: ptr Gdk3.TEventKey): bool {.inline.} =

# gtk_im_context_focus_in
# flags: {isMethod} container: IMContext
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_im_context_focus_in(self: ptr TIMContext) {.cdecl, dynlib: lib, importc: "gtk_im_context_focus_in".}
proc focus_in*(self: IMContext) {.inline.} =
  gtk_im_context_focus_in(self)
# proc focus_in*(self: IMContext) {.inline.} =

# gtk_im_context_focus_out
# flags: {isMethod} container: IMContext
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_im_context_focus_out(self: ptr TIMContext) {.cdecl, dynlib: lib, importc: "gtk_im_context_focus_out".}
proc focus_out*(self: IMContext) {.inline.} =
  gtk_im_context_focus_out(self)
# proc focus_out*(self: IMContext) {.inline.} =

# gtk_im_context_get_preedit_string
# flags: {isMethod} container: IMContext
# need sugar: is method
# arg str: UTF8 'var ucstring' 'ptr ucstring' OUT (diff., need sugar)
# arg attrs: INTERFACE (STRUCT) 'ptr Pango1.TAttrList' 'ptr Pango1.TAttrList' OUT
# arg cursor_pos: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_im_context_get_preedit_string(self: ptr TIMContext, str: ptr ucstring, attrs: ptr Pango1.TAttrList, cursor_pos: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_im_context_get_preedit_string".}
proc get_preedit_string*(self: IMContext, str: var ucstring, attrs: ptr Pango1.TAttrList, cursor_pos: var int32) {.inline.} =
  gtk_im_context_get_preedit_string(self, addr(str), attrs, addr(cursor_pos))
# tuple-return
# str: var ucstring
# attrs: ptr Pango1.TAttrList
# cursor_pos: var int32
# proc get_preedit_string*(self: IMContext) {.inline.} =

# gtk_im_context_get_surrounding
# flags: {isMethod} container: IMContext
# need sugar: is method
# arg text: UTF8 'var ucstring' 'ptr ucstring' OUT (diff., need sugar)
# arg cursor_index: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_im_context_get_surrounding(self: ptr TIMContext, text: ptr ucstring, cursor_index: ptr int32): bool {.cdecl, dynlib: lib, importc: "gtk_im_context_get_surrounding".}
proc get_surrounding*(self: IMContext, text: var ucstring, cursor_index: var int32): bool {.inline.} =
  gtk_im_context_get_surrounding(self, addr(text), addr(cursor_index))
# tuple-return
# text: var ucstring
# cursor_index: var int32
# proc get_surrounding*(self: IMContext): bool {.inline.} =

# gtk_im_context_reset
# flags: {isMethod} container: IMContext
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_im_context_reset(self: ptr TIMContext) {.cdecl, dynlib: lib, importc: "gtk_im_context_reset".}
proc reset*(self: IMContext) {.inline.} =
  gtk_im_context_reset(self)
# proc reset*(self: IMContext) {.inline.} =

# gtk_im_context_set_client_window
# flags: {isMethod} container: IMContext
# need sugar: is method
# arg window: INTERFACE (OBJECT) 'Gdk3.Window' 'ptr Gdk3.TWindow' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_im_context_set_client_window(self: ptr TIMContext, window: ptr Gdk3.TWindow) {.cdecl, dynlib: lib, importc: "gtk_im_context_set_client_window".}
proc set_client_window*(self: IMContext, window: Gdk3.Window) {.inline.} =
  gtk_im_context_set_client_window(self, window.getPointer)
# proc set_client_window*(self: IMContext, window: Gdk3.Window) {.inline.} =

# gtk_im_context_set_cursor_location
# flags: {isMethod} container: IMContext
# need sugar: is method
# arg area: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_im_context_set_cursor_location(self: ptr TIMContext, area: ptr Gdk3.TRectangle) {.cdecl, dynlib: lib, importc: "gtk_im_context_set_cursor_location".}
proc set_cursor_location*(self: IMContext, area: ptr Gdk3.TRectangle) {.inline.} =
  gtk_im_context_set_cursor_location(self, area)
# proc set_cursor_location*(self: IMContext, area: ptr Gdk3.TRectangle) {.inline.} =

# gtk_im_context_set_surrounding
# flags: {isMethod} container: IMContext
# need sugar: is method
# arg text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg len: INT32 'int32' 'int32' IN
# arg cursor_index: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_im_context_set_surrounding(self: ptr TIMContext, text: ucstring, len: int32, cursor_index: int32) {.cdecl, dynlib: lib, importc: "gtk_im_context_set_surrounding".}
proc set_surrounding*(self: IMContext, text: ustring, len: int32, cursor_index: int32) {.inline.} =
  gtk_im_context_set_surrounding(self, ucstring(text), len, cursor_index)
# proc set_surrounding*(self: IMContext, text: ustring, len: int32, cursor_index: int32) {.inline.} =

# gtk_im_context_set_use_preedit
# flags: {isMethod} container: IMContext
# need sugar: is method
# arg use_preedit: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_im_context_set_use_preedit(self: ptr TIMContext, use_preedit: bool) {.cdecl, dynlib: lib, importc: "gtk_im_context_set_use_preedit".}
proc set_use_preedit*(self: IMContext, use_preedit: bool) {.inline.} =
  gtk_im_context_set_use_preedit(self, use_preedit)
# proc set_use_preedit*(self: IMContext, use_preedit: bool) {.inline.} =

# initializer for IMContextSimple: gtk_im_context_simple_get_type
proc gtk_im_context_simple_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_im_context_simple_get_type".}
template gtype*(klass_parameter: typedesc[IMContextSimple]): GType = gtk_im_context_simple_get_type()
# gtk_im_context_simple_new
# flags: {isConstructor} container: IMContextSimple
# need sugar: is static method
# return: INTERFACE 'IMContextSimple' 'TransferFull[TIMContextSimple]' (diff., need sugar)
proc gtk_im_context_simple_new(): TransferFull[TIMContextSimple] {.cdecl, dynlib: lib, importc: "gtk_im_context_simple_new".}
proc new_imcontextsimple*(): IMContextSimple {.inline.} =
  wrap(gtk_im_context_simple_new())
# proc new_imcontextsimple*(): IMContextSimple {.inline.} =

# initializer for IMMulticontext: gtk_im_multicontext_get_type
proc gtk_im_multicontext_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_im_multicontext_get_type".}
template gtype*(klass_parameter: typedesc[IMMulticontext]): GType = gtk_im_multicontext_get_type()
# gtk_im_multicontext_new
# flags: {isConstructor} container: IMMulticontext
# need sugar: is static method
# return: INTERFACE 'IMMulticontext' 'TransferFull[TIMMulticontext]' (diff., need sugar)
proc gtk_im_multicontext_new(): TransferFull[TIMMulticontext] {.cdecl, dynlib: lib, importc: "gtk_im_multicontext_new".}
proc new_immulticontext*(): IMMulticontext {.inline.} =
  wrap(gtk_im_multicontext_new())
# proc new_immulticontext*(): IMMulticontext {.inline.} =

# gtk_im_multicontext_append_menuitems
# flags: {isMethod} container: IMMulticontext (deprecated)
# gtk_im_multicontext_get_context_id
# flags: {isMethod} container: IMMulticontext
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_im_multicontext_get_context_id(self: ptr TIMMulticontext): ucstring {.cdecl, dynlib: lib, importc: "gtk_im_multicontext_get_context_id".}
proc get_context_id*(self: IMMulticontext): ucstring {.inline.} =
  gtk_im_multicontext_get_context_id(self)
# proc get_context_id*(self: IMMulticontext): ucstring {.inline.} =

# gtk_im_multicontext_set_context_id
# flags: {isMethod} container: IMMulticontext
# need sugar: is method
# arg context_id: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_im_multicontext_set_context_id(self: ptr TIMMulticontext, context_id: ucstring) {.cdecl, dynlib: lib, importc: "gtk_im_multicontext_set_context_id".}
proc set_context_id*(self: IMMulticontext, context_id: ustring) {.inline.} =
  gtk_im_multicontext_set_context_id(self, ucstring(context_id))
# proc set_context_id*(self: IMMulticontext, context_id: ustring) {.inline.} =

# initializer for IconFactory: gtk_icon_factory_get_type
proc gtk_icon_factory_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_icon_factory_get_type".}
template gtype*(klass_parameter: typedesc[IconFactory]): GType = gtk_icon_factory_get_type()
# gtk_icon_factory_new
# flags: {isConstructor} container: IconFactory (deprecated)
# gtk_icon_factory_lookup_default
# flags: {} container: IconFactory (deprecated)
# gtk_icon_factory_add
# flags: {isMethod} container: IconFactory (deprecated)
# gtk_icon_factory_add_default
# flags: {isMethod} container: IconFactory (deprecated)
# gtk_icon_factory_lookup
# flags: {isMethod} container: IconFactory (deprecated)
# gtk_icon_factory_remove_default
# flags: {isMethod} container: IconFactory (deprecated)
# initializer for IconInfo: gtk_icon_info_get_type
proc gtk_icon_info_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_icon_info_get_type".}
template gtype*(klass_parameter: typedesc[IconInfo]): GType = gtk_icon_info_get_type()
# gtk_icon_info_new_for_pixbuf
# flags: {isConstructor} container: IconInfo
# need sugar: is static method
# arg icon_theme: INTERFACE (OBJECT) 'IconTheme' 'ptr TIconTheme' IN (diff., need sugar)
# arg pixbuf: INTERFACE (OBJECT) 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# return: INTERFACE 'IconInfo' 'TransferFull[TIconInfo]' (diff., need sugar)
proc gtk_icon_info_new_for_pixbuf(icon_theme: ptr TIconTheme, pixbuf: ptr GdkPixbuf2.TPixbuf): TransferFull[TIconInfo] {.cdecl, dynlib: lib, importc: "gtk_icon_info_new_for_pixbuf".}
proc new_iconinfo_for_pixbuf*(icon_theme: IconTheme, pixbuf: GdkPixbuf2.Pixbuf): IconInfo {.inline.} =
  wrap(gtk_icon_info_new_for_pixbuf(icon_theme.getPointer, pixbuf.getPointer))
# proc new_iconinfo_for_pixbuf*(icon_theme: IconTheme, pixbuf: GdkPixbuf2.Pixbuf): IconInfo {.inline.} =

# gtk_icon_info_get_attach_points
# flags: {isMethod} container: IconInfo (deprecated)
# gtk_icon_info_get_base_scale
# flags: {isMethod} container: IconInfo
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_icon_info_get_base_scale(self: ptr TIconInfo): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_info_get_base_scale".}
proc get_base_scale*(self: IconInfo): int32 {.inline.} =
  gtk_icon_info_get_base_scale(self)
# proc get_base_scale*(self: IconInfo): int32 {.inline.} =

# gtk_icon_info_get_base_size
# flags: {isMethod} container: IconInfo
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_icon_info_get_base_size(self: ptr TIconInfo): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_info_get_base_size".}
proc get_base_size*(self: IconInfo): int32 {.inline.} =
  gtk_icon_info_get_base_size(self)
# proc get_base_size*(self: IconInfo): int32 {.inline.} =

# gtk_icon_info_get_builtin_pixbuf
# flags: {isMethod} container: IconInfo (deprecated)
# gtk_icon_info_get_display_name
# flags: {isMethod} container: IconInfo (deprecated)
# gtk_icon_info_get_embedded_rect
# flags: {isMethod} container: IconInfo (deprecated)
# gtk_icon_info_get_filename
# flags: {isMethod} container: IconInfo
# need sugar: is method
# return: FILENAME 'string' 'cstring' (diff., need sugar)
proc gtk_icon_info_get_filename(self: ptr TIconInfo): cstring {.cdecl, dynlib: lib, importc: "gtk_icon_info_get_filename".}
proc get_filename*(self: IconInfo): string {.inline.} =
  $(gtk_icon_info_get_filename(self))
# proc get_filename*(self: IconInfo): string {.inline.} =

# gtk_icon_info_is_symbolic
# flags: {isMethod} container: IconInfo
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_icon_info_is_symbolic(self: ptr TIconInfo): bool {.cdecl, dynlib: lib, importc: "gtk_icon_info_is_symbolic".}
proc is_symbolic*(self: IconInfo): bool {.inline.} =
  gtk_icon_info_is_symbolic(self)
# proc is_symbolic*(self: IconInfo): bool {.inline.} =

# gtk_icon_info_load_icon
# flags: {isMethod, throws} container: IconInfo
# can throw
# need sugar: is method
# return: INTERFACE 'GdkPixbuf2.Pixbuf' 'TransferFull[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_icon_info_load_icon(self: ptr TIconInfo, error: ptr PGError=nil): TransferFull[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_icon_info_load_icon".}
proc load_icon*(self: IconInfo): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_icon_info_load_icon(self))
# proc load_icon*(self: IconInfo): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_icon_info_load_icon_async
# flags: {isMethod} container: IconInfo
# need sugar: is method
# arg cancellable: INTERFACE (OBJECT) 'Gio2.Cancellable' 'ptr Gio2.TCancellable' IN (diff., need sugar)
# arg callback: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg user_data: VOID 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_info_load_icon_async(self: ptr TIconInfo, cancellable: ptr Gio2.TCancellable, callback: pointer, user_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_icon_info_load_icon_async".}
proc load_icon_async*(self: IconInfo, cancellable: Gio2.Cancellable, callback: pointer, user_data: pointer) {.inline.} =
  gtk_icon_info_load_icon_async(self, cancellable.getPointer, callback, user_data)
# proc load_icon_async*(self: IconInfo, cancellable: Gio2.Cancellable, callback: pointer, user_data: pointer) {.inline.} =

# gtk_icon_info_load_icon_finish
# flags: {isMethod, throws} container: IconInfo
# can throw
# need sugar: is method
# arg res: INTERFACE (INTERFACE) 'ptr Gio2.TAsyncResult' 'ptr Gio2.TAsyncResult' IN
# return: INTERFACE 'GdkPixbuf2.Pixbuf' 'TransferFull[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_icon_info_load_icon_finish(self: ptr TIconInfo, res: ptr Gio2.TAsyncResult, error: ptr PGError=nil): TransferFull[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_icon_info_load_icon_finish".}
proc load_icon_finish*(self: IconInfo, res: ptr Gio2.TAsyncResult): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_icon_info_load_icon_finish(self, res))
# proc load_icon_finish*(self: IconInfo, res: ptr Gio2.TAsyncResult): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_icon_info_load_surface
# flags: {isMethod, throws} container: IconInfo
# can throw
# need sugar: is method
# arg for_window: INTERFACE (OBJECT) 'Gdk3.Window' 'ptr Gdk3.TWindow' IN (diff., need sugar)
# return: INTERFACE 'ptr cairo1.TSurface' 'ptr cairo1.TSurface'
proc gtk_icon_info_load_surface(self: ptr TIconInfo, for_window: ptr Gdk3.TWindow, error: ptr PGError=nil): ptr cairo1.TSurface {.cdecl, dynlib: lib, importc: "gtk_icon_info_load_surface".}
proc load_surface*(self: IconInfo, for_window: Gdk3.Window): ptr cairo1.TSurface {.inline.} =
  gtk_icon_info_load_surface(self, for_window.getPointer)
# proc load_surface*(self: IconInfo, for_window: Gdk3.Window): ptr cairo1.TSurface {.inline.} =

# gtk_icon_info_load_symbolic
# flags: {isMethod, throws} container: IconInfo
# can throw
# need sugar: is method
# arg fg: INTERFACE (STRUCT) 'ptr Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN
# arg success_color: INTERFACE (STRUCT) 'ptr Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN
# arg warning_color: INTERFACE (STRUCT) 'ptr Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN
# arg error_color: INTERFACE (STRUCT) 'ptr Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN
# arg was_symbolic: BOOLEAN 'var bool' 'ptr bool' OUT (diff., need sugar) optional
# return: INTERFACE 'GdkPixbuf2.Pixbuf' 'TransferFull[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_icon_info_load_symbolic(self: ptr TIconInfo, fg: ptr Gdk3.TRGBA, success_color: ptr Gdk3.TRGBA, warning_color: ptr Gdk3.TRGBA, error_color: ptr Gdk3.TRGBA, was_symbolic: ptr bool, error: ptr PGError=nil): TransferFull[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_icon_info_load_symbolic".}
proc load_symbolic*(self: IconInfo, fg: ptr Gdk3.TRGBA, success_color: ptr Gdk3.TRGBA, warning_color: ptr Gdk3.TRGBA, error_color: ptr Gdk3.TRGBA, was_symbolic: var bool): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_icon_info_load_symbolic(self, fg, success_color, warning_color, error_color, addr(was_symbolic)))
# tuple-return
# was_symbolic: var bool
# proc load_symbolic*(self: IconInfo, fg: ptr Gdk3.TRGBA, success_color: ptr Gdk3.TRGBA, warning_color: ptr Gdk3.TRGBA, error_color: ptr Gdk3.TRGBA): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_icon_info_load_symbolic_async
# flags: {isMethod} container: IconInfo
# need sugar: is method
# arg fg: INTERFACE (STRUCT) 'ptr Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN
# arg success_color: INTERFACE (STRUCT) 'ptr Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN
# arg warning_color: INTERFACE (STRUCT) 'ptr Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN
# arg error_color: INTERFACE (STRUCT) 'ptr Gdk3.TRGBA' 'ptr Gdk3.TRGBA' IN
# arg cancellable: INTERFACE (OBJECT) 'Gio2.Cancellable' 'ptr Gio2.TCancellable' IN (diff., need sugar)
# arg callback: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg user_data: VOID 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_info_load_symbolic_async(self: ptr TIconInfo, fg: ptr Gdk3.TRGBA, success_color: ptr Gdk3.TRGBA, warning_color: ptr Gdk3.TRGBA, error_color: ptr Gdk3.TRGBA, cancellable: ptr Gio2.TCancellable, callback: pointer, user_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_icon_info_load_symbolic_async".}
proc load_symbolic_async*(self: IconInfo, fg: ptr Gdk3.TRGBA, success_color: ptr Gdk3.TRGBA, warning_color: ptr Gdk3.TRGBA, error_color: ptr Gdk3.TRGBA, cancellable: Gio2.Cancellable, callback: pointer, user_data: pointer) {.inline.} =
  gtk_icon_info_load_symbolic_async(self, fg, success_color, warning_color, error_color, cancellable.getPointer, callback, user_data)
# proc load_symbolic_async*(self: IconInfo, fg: ptr Gdk3.TRGBA, success_color: ptr Gdk3.TRGBA, warning_color: ptr Gdk3.TRGBA, error_color: ptr Gdk3.TRGBA, cancellable: Gio2.Cancellable, callback: pointer, user_data: pointer) {.inline.} =

# gtk_icon_info_load_symbolic_finish
# flags: {isMethod, throws} container: IconInfo
# can throw
# need sugar: is method
# arg res: INTERFACE (INTERFACE) 'ptr Gio2.TAsyncResult' 'ptr Gio2.TAsyncResult' IN
# arg was_symbolic: BOOLEAN 'var bool' 'ptr bool' OUT (diff., need sugar) optional
# return: INTERFACE 'GdkPixbuf2.Pixbuf' 'TransferFull[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_icon_info_load_symbolic_finish(self: ptr TIconInfo, res: ptr Gio2.TAsyncResult, was_symbolic: ptr bool, error: ptr PGError=nil): TransferFull[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_icon_info_load_symbolic_finish".}
proc load_symbolic_finish*(self: IconInfo, res: ptr Gio2.TAsyncResult, was_symbolic: var bool): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_icon_info_load_symbolic_finish(self, res, addr(was_symbolic)))
# tuple-return
# was_symbolic: var bool
# proc load_symbolic_finish*(self: IconInfo, res: ptr Gio2.TAsyncResult): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_icon_info_load_symbolic_for_context
# flags: {isMethod, throws} container: IconInfo
# can throw
# need sugar: is method
# arg context: INTERFACE (OBJECT) 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# arg was_symbolic: BOOLEAN 'var bool' 'ptr bool' OUT (diff., need sugar) optional
# return: INTERFACE 'GdkPixbuf2.Pixbuf' 'TransferFull[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_icon_info_load_symbolic_for_context(self: ptr TIconInfo, context: ptr TStyleContext, was_symbolic: ptr bool, error: ptr PGError=nil): TransferFull[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_icon_info_load_symbolic_for_context".}
proc load_symbolic_for_context*(self: IconInfo, context: StyleContext, was_symbolic: var bool): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_icon_info_load_symbolic_for_context(self, context.getPointer, addr(was_symbolic)))
# tuple-return
# was_symbolic: var bool
# proc load_symbolic_for_context*(self: IconInfo, context: StyleContext): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_icon_info_load_symbolic_for_context_async
# flags: {isMethod} container: IconInfo
# need sugar: is method
# arg context: INTERFACE (OBJECT) 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# arg cancellable: INTERFACE (OBJECT) 'Gio2.Cancellable' 'ptr Gio2.TCancellable' IN (diff., need sugar)
# arg callback: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg user_data: VOID 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_info_load_symbolic_for_context_async(self: ptr TIconInfo, context: ptr TStyleContext, cancellable: ptr Gio2.TCancellable, callback: pointer, user_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_icon_info_load_symbolic_for_context_async".}
proc load_symbolic_for_context_async*(self: IconInfo, context: StyleContext, cancellable: Gio2.Cancellable, callback: pointer, user_data: pointer) {.inline.} =
  gtk_icon_info_load_symbolic_for_context_async(self, context.getPointer, cancellable.getPointer, callback, user_data)
# proc load_symbolic_for_context_async*(self: IconInfo, context: StyleContext, cancellable: Gio2.Cancellable, callback: pointer, user_data: pointer) {.inline.} =

# gtk_icon_info_load_symbolic_for_context_finish
# flags: {isMethod, throws} container: IconInfo
# can throw
# need sugar: is method
# arg res: INTERFACE (INTERFACE) 'ptr Gio2.TAsyncResult' 'ptr Gio2.TAsyncResult' IN
# arg was_symbolic: BOOLEAN 'var bool' 'ptr bool' OUT (diff., need sugar) optional
# return: INTERFACE 'GdkPixbuf2.Pixbuf' 'TransferFull[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_icon_info_load_symbolic_for_context_finish(self: ptr TIconInfo, res: ptr Gio2.TAsyncResult, was_symbolic: ptr bool, error: ptr PGError=nil): TransferFull[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_icon_info_load_symbolic_for_context_finish".}
proc load_symbolic_for_context_finish*(self: IconInfo, res: ptr Gio2.TAsyncResult, was_symbolic: var bool): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_icon_info_load_symbolic_for_context_finish(self, res, addr(was_symbolic)))
# tuple-return
# was_symbolic: var bool
# proc load_symbolic_for_context_finish*(self: IconInfo, res: ptr Gio2.TAsyncResult): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_icon_info_load_symbolic_for_style
# flags: {isMethod, throws} container: IconInfo (deprecated)
# can throw
# gtk_icon_info_set_raw_coordinates
# flags: {isMethod} container: IconInfo (deprecated)
# initializer for IconTheme: gtk_icon_theme_get_type
proc gtk_icon_theme_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_icon_theme_get_type".}
template gtype*(klass_parameter: typedesc[IconTheme]): GType = gtk_icon_theme_get_type()
# gtk_icon_theme_new
# flags: {isConstructor} container: IconTheme
# need sugar: is static method
# return: INTERFACE 'IconTheme' 'TransferFull[TIconTheme]' (diff., need sugar)
proc gtk_icon_theme_new(): TransferFull[TIconTheme] {.cdecl, dynlib: lib, importc: "gtk_icon_theme_new".}
proc new_icontheme*(): IconTheme {.inline.} =
  wrap(gtk_icon_theme_new())
# proc new_icontheme*(): IconTheme {.inline.} =

# gtk_icon_theme_add_builtin_icon
# flags: {} container: IconTheme (deprecated)
# gtk_icon_theme_get_default
# flags: {} container: IconTheme
# need sugar: is static method
# return: INTERFACE 'IconTheme' 'TransferNone[TIconTheme]' (diff., need sugar)
proc gtk_icon_theme_get_default(): TransferNone[TIconTheme] {.cdecl, dynlib: lib, importc: "gtk_icon_theme_get_default".}
template get_default*(klass_parameter: typedesc[IconTheme]): IconTheme =
  wrap(gtk_icon_theme_get_default())
# template get_default*(klass_parameter: typedesc[IconTheme]): IconTheme =

# gtk_icon_theme_get_for_screen
# flags: {} container: IconTheme
# need sugar: is static method
# arg screen: INTERFACE (OBJECT) 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# return: INTERFACE 'IconTheme' 'TransferNone[TIconTheme]' (diff., need sugar)
proc gtk_icon_theme_get_for_screen(screen: ptr Gdk3.TScreen): TransferNone[TIconTheme] {.cdecl, dynlib: lib, importc: "gtk_icon_theme_get_for_screen".}
template get_for_screen*(klass_parameter: typedesc[IconTheme], screen: Gdk3.Screen): IconTheme =
  wrap(gtk_icon_theme_get_for_screen(screen.getPointer))
# template get_for_screen*(klass_parameter: typedesc[IconTheme], screen: Gdk3.Screen): IconTheme =

# gtk_icon_theme_add_resource_path
# flags: {isMethod} container: IconTheme
# need sugar: is method
# arg path: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_theme_add_resource_path(self: ptr TIconTheme, path: ucstring) {.cdecl, dynlib: lib, importc: "gtk_icon_theme_add_resource_path".}
proc add_resource_path*(self: IconTheme, path: ustring) {.inline.} =
  gtk_icon_theme_add_resource_path(self, ucstring(path))
# proc add_resource_path*(self: IconTheme, path: ustring) {.inline.} =

# gtk_icon_theme_append_search_path
# flags: {isMethod} container: IconTheme
# need sugar: is method
# arg path: FILENAME 'string' 'cstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_theme_append_search_path(self: ptr TIconTheme, path: cstring) {.cdecl, dynlib: lib, importc: "gtk_icon_theme_append_search_path".}
proc append_search_path*(self: IconTheme, path: string) {.inline.} =
  gtk_icon_theme_append_search_path(self, cstring(path))
# proc append_search_path*(self: IconTheme, path: string) {.inline.} =

# gtk_icon_theme_choose_icon
# flags: {isMethod} container: IconTheme
# need sugar: is method
# arg icon_names: ARRAY 'uncheckedArray[ucstring]' 'uncheckedArray[ucstring]' IN array zero-terminated
# arg size: INT32 'int32' 'int32' IN
# arg flags: INTERFACE (FLAGS) 'SIconLookupFlags' 'SIconLookupFlags' IN
# return: INTERFACE 'IconInfo' 'TransferFull[TIconInfo]' (diff., need sugar)
proc gtk_icon_theme_choose_icon(self: ptr TIconTheme, icon_names: uncheckedArray[ucstring], size: int32, flags: SIconLookupFlags): TransferFull[TIconInfo] {.cdecl, dynlib: lib, importc: "gtk_icon_theme_choose_icon".}
proc choose_icon*(self: IconTheme, icon_names: uncheckedArray[ucstring], size: int32, flags: SIconLookupFlags): IconInfo {.inline.} =
  wrap(gtk_icon_theme_choose_icon(self, icon_names, size, flags))
# proc choose_icon*(self: IconTheme, icon_names: uncheckedArray[ucstring], size: int32, flags: SIconLookupFlags): IconInfo {.inline.} =

# gtk_icon_theme_choose_icon_for_scale
# flags: {isMethod} container: IconTheme
# need sugar: is method
# arg icon_names: ARRAY 'uncheckedArray[ucstring]' 'uncheckedArray[ucstring]' IN array zero-terminated
# arg size: INT32 'int32' 'int32' IN
# arg scale: INT32 'int32' 'int32' IN
# arg flags: INTERFACE (FLAGS) 'SIconLookupFlags' 'SIconLookupFlags' IN
# return: INTERFACE 'IconInfo' 'TransferFull[TIconInfo]' (diff., need sugar)
proc gtk_icon_theme_choose_icon_for_scale(self: ptr TIconTheme, icon_names: uncheckedArray[ucstring], size: int32, scale: int32, flags: SIconLookupFlags): TransferFull[TIconInfo] {.cdecl, dynlib: lib, importc: "gtk_icon_theme_choose_icon_for_scale".}
proc choose_icon_for_scale*(self: IconTheme, icon_names: uncheckedArray[ucstring], size: int32, scale: int32, flags: SIconLookupFlags): IconInfo {.inline.} =
  wrap(gtk_icon_theme_choose_icon_for_scale(self, icon_names, size, scale, flags))
# proc choose_icon_for_scale*(self: IconTheme, icon_names: uncheckedArray[ucstring], size: int32, scale: int32, flags: SIconLookupFlags): IconInfo {.inline.} =

# gtk_icon_theme_get_example_icon_name
# flags: {isMethod} container: IconTheme
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_icon_theme_get_example_icon_name(self: ptr TIconTheme): ucstring {.cdecl, dynlib: lib, importc: "gtk_icon_theme_get_example_icon_name".}
proc get_example_icon_name*(self: IconTheme): ucstring {.inline.} =
  gtk_icon_theme_get_example_icon_name(self)
# proc get_example_icon_name*(self: IconTheme): ucstring {.inline.} =

# gtk_icon_theme_get_icon_sizes
# flags: {isMethod} container: IconTheme
# need sugar: is method
# arg icon_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: ARRAY 'zeroTerminatedArray[int32]' 'zeroTerminatedArray[int32]'
proc gtk_icon_theme_get_icon_sizes(self: ptr TIconTheme, icon_name: ucstring): zeroTerminatedArray[int32] {.cdecl, dynlib: lib, importc: "gtk_icon_theme_get_icon_sizes".}
proc get_icon_sizes*(self: IconTheme, icon_name: ustring): zeroTerminatedArray[int32] {.inline.} =
  gtk_icon_theme_get_icon_sizes(self, ucstring(icon_name))
# proc get_icon_sizes*(self: IconTheme, icon_name: ustring): zeroTerminatedArray[int32] {.inline.} =

# gtk_icon_theme_get_search_path
# flags: {isMethod} container: IconTheme
# need sugar: is method
# arg path: ARRAY 'var openarray[cstring]' 'openarray[cstring]' OUT (diff., need sugar) array lengthArg: 1 optional
# arg n_elements: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_theme_get_search_path(self: ptr TIconTheme, path: openarray[cstring], n_elements: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_icon_theme_get_search_path".}
proc get_search_path*(self: IconTheme, path: var openarray[cstring], n_elements: var int32) {.inline.} =
  gtk_icon_theme_get_search_path(self, path, addr(n_elements))
# tuple-return
# path: var openarray[cstring]
# n_elements: var int32
# proc get_search_path*(self: IconTheme) {.inline.} =

# gtk_icon_theme_has_icon
# flags: {isMethod} container: IconTheme
# need sugar: is method
# arg icon_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_icon_theme_has_icon(self: ptr TIconTheme, icon_name: ucstring): bool {.cdecl, dynlib: lib, importc: "gtk_icon_theme_has_icon".}
proc has_icon*(self: IconTheme, icon_name: ustring): bool {.inline.} =
  gtk_icon_theme_has_icon(self, ucstring(icon_name))
# proc has_icon*(self: IconTheme, icon_name: ustring): bool {.inline.} =

# gtk_icon_theme_list_contexts
# flags: {isMethod} container: IconTheme
# need sugar: is method
# return: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_icon_theme_list_contexts(self: ptr TIconTheme): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_icon_theme_list_contexts".}
proc list_contexts*(self: IconTheme): ptr GLIST_TODO {.inline.} =
  gtk_icon_theme_list_contexts(self)
# proc list_contexts*(self: IconTheme): ptr GLIST_TODO {.inline.} =

# gtk_icon_theme_list_icons
# flags: {isMethod} container: IconTheme
# need sugar: is method
# arg context: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_icon_theme_list_icons(self: ptr TIconTheme, context: ucstring): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_icon_theme_list_icons".}
proc list_icons*(self: IconTheme, context: ustring): ptr GLIST_TODO {.inline.} =
  gtk_icon_theme_list_icons(self, ucstring(context))
# proc list_icons*(self: IconTheme, context: ustring): ptr GLIST_TODO {.inline.} =

# gtk_icon_theme_load_icon
# flags: {isMethod, throws} container: IconTheme
# can throw
# need sugar: is method
# arg icon_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg size: INT32 'int32' 'int32' IN
# arg flags: INTERFACE (FLAGS) 'SIconLookupFlags' 'SIconLookupFlags' IN
# return: INTERFACE 'GdkPixbuf2.Pixbuf' 'TransferFull[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_icon_theme_load_icon(self: ptr TIconTheme, icon_name: ucstring, size: int32, flags: SIconLookupFlags, error: ptr PGError=nil): TransferFull[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_icon_theme_load_icon".}
proc load_icon*(self: IconTheme, icon_name: ustring, size: int32, flags: SIconLookupFlags): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_icon_theme_load_icon(self, ucstring(icon_name), size, flags))
# proc load_icon*(self: IconTheme, icon_name: ustring, size: int32, flags: SIconLookupFlags): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_icon_theme_load_icon_for_scale
# flags: {isMethod, throws} container: IconTheme
# can throw
# need sugar: is method
# arg icon_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg size: INT32 'int32' 'int32' IN
# arg scale: INT32 'int32' 'int32' IN
# arg flags: INTERFACE (FLAGS) 'SIconLookupFlags' 'SIconLookupFlags' IN
# return: INTERFACE 'GdkPixbuf2.Pixbuf' 'TransferFull[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_icon_theme_load_icon_for_scale(self: ptr TIconTheme, icon_name: ucstring, size: int32, scale: int32, flags: SIconLookupFlags, error: ptr PGError=nil): TransferFull[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_icon_theme_load_icon_for_scale".}
proc load_icon_for_scale*(self: IconTheme, icon_name: ustring, size: int32, scale: int32, flags: SIconLookupFlags): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_icon_theme_load_icon_for_scale(self, ucstring(icon_name), size, scale, flags))
# proc load_icon_for_scale*(self: IconTheme, icon_name: ustring, size: int32, scale: int32, flags: SIconLookupFlags): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_icon_theme_load_surface
# flags: {isMethod, throws} container: IconTheme
# can throw
# need sugar: is method
# arg icon_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg size: INT32 'int32' 'int32' IN
# arg scale: INT32 'int32' 'int32' IN
# arg for_window: INTERFACE (OBJECT) 'Gdk3.Window' 'ptr Gdk3.TWindow' IN (diff., need sugar)
# arg flags: INTERFACE (FLAGS) 'SIconLookupFlags' 'SIconLookupFlags' IN
# return: INTERFACE 'ptr cairo1.TSurface' 'ptr cairo1.TSurface'
proc gtk_icon_theme_load_surface(self: ptr TIconTheme, icon_name: ucstring, size: int32, scale: int32, for_window: ptr Gdk3.TWindow, flags: SIconLookupFlags, error: ptr PGError=nil): ptr cairo1.TSurface {.cdecl, dynlib: lib, importc: "gtk_icon_theme_load_surface".}
proc load_surface*(self: IconTheme, icon_name: ustring, size: int32, scale: int32, for_window: Gdk3.Window, flags: SIconLookupFlags): ptr cairo1.TSurface {.inline.} =
  gtk_icon_theme_load_surface(self, ucstring(icon_name), size, scale, for_window.getPointer, flags)
# proc load_surface*(self: IconTheme, icon_name: ustring, size: int32, scale: int32, for_window: Gdk3.Window, flags: SIconLookupFlags): ptr cairo1.TSurface {.inline.} =

# gtk_icon_theme_lookup_by_gicon
# flags: {isMethod} container: IconTheme
# need sugar: is method
# arg icon: INTERFACE (INTERFACE) 'ptr Gio2.TIcon' 'ptr Gio2.TIcon' IN
# arg size: INT32 'int32' 'int32' IN
# arg flags: INTERFACE (FLAGS) 'SIconLookupFlags' 'SIconLookupFlags' IN
# return: INTERFACE 'IconInfo' 'TransferFull[TIconInfo]' (diff., need sugar)
proc gtk_icon_theme_lookup_by_gicon(self: ptr TIconTheme, icon: ptr Gio2.TIcon, size: int32, flags: SIconLookupFlags): TransferFull[TIconInfo] {.cdecl, dynlib: lib, importc: "gtk_icon_theme_lookup_by_gicon".}
proc lookup_by_gicon*(self: IconTheme, icon: ptr Gio2.TIcon, size: int32, flags: SIconLookupFlags): IconInfo {.inline.} =
  wrap(gtk_icon_theme_lookup_by_gicon(self, icon, size, flags))
# proc lookup_by_gicon*(self: IconTheme, icon: ptr Gio2.TIcon, size: int32, flags: SIconLookupFlags): IconInfo {.inline.} =

# gtk_icon_theme_lookup_by_gicon_for_scale
# flags: {isMethod} container: IconTheme
# need sugar: is method
# arg icon: INTERFACE (INTERFACE) 'ptr Gio2.TIcon' 'ptr Gio2.TIcon' IN
# arg size: INT32 'int32' 'int32' IN
# arg scale: INT32 'int32' 'int32' IN
# arg flags: INTERFACE (FLAGS) 'SIconLookupFlags' 'SIconLookupFlags' IN
# return: INTERFACE 'IconInfo' 'TransferFull[TIconInfo]' (diff., need sugar)
proc gtk_icon_theme_lookup_by_gicon_for_scale(self: ptr TIconTheme, icon: ptr Gio2.TIcon, size: int32, scale: int32, flags: SIconLookupFlags): TransferFull[TIconInfo] {.cdecl, dynlib: lib, importc: "gtk_icon_theme_lookup_by_gicon_for_scale".}
proc lookup_by_gicon_for_scale*(self: IconTheme, icon: ptr Gio2.TIcon, size: int32, scale: int32, flags: SIconLookupFlags): IconInfo {.inline.} =
  wrap(gtk_icon_theme_lookup_by_gicon_for_scale(self, icon, size, scale, flags))
# proc lookup_by_gicon_for_scale*(self: IconTheme, icon: ptr Gio2.TIcon, size: int32, scale: int32, flags: SIconLookupFlags): IconInfo {.inline.} =

# gtk_icon_theme_lookup_icon
# flags: {isMethod} container: IconTheme
# need sugar: is method
# arg icon_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg size: INT32 'int32' 'int32' IN
# arg flags: INTERFACE (FLAGS) 'SIconLookupFlags' 'SIconLookupFlags' IN
# return: INTERFACE 'IconInfo' 'TransferFull[TIconInfo]' (diff., need sugar)
proc gtk_icon_theme_lookup_icon(self: ptr TIconTheme, icon_name: ucstring, size: int32, flags: SIconLookupFlags): TransferFull[TIconInfo] {.cdecl, dynlib: lib, importc: "gtk_icon_theme_lookup_icon".}
proc lookup_icon*(self: IconTheme, icon_name: ustring, size: int32, flags: SIconLookupFlags): IconInfo {.inline.} =
  wrap(gtk_icon_theme_lookup_icon(self, ucstring(icon_name), size, flags))
# proc lookup_icon*(self: IconTheme, icon_name: ustring, size: int32, flags: SIconLookupFlags): IconInfo {.inline.} =

# gtk_icon_theme_lookup_icon_for_scale
# flags: {isMethod} container: IconTheme
# need sugar: is method
# arg icon_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg size: INT32 'int32' 'int32' IN
# arg scale: INT32 'int32' 'int32' IN
# arg flags: INTERFACE (FLAGS) 'SIconLookupFlags' 'SIconLookupFlags' IN
# return: INTERFACE 'IconInfo' 'TransferFull[TIconInfo]' (diff., need sugar)
proc gtk_icon_theme_lookup_icon_for_scale(self: ptr TIconTheme, icon_name: ucstring, size: int32, scale: int32, flags: SIconLookupFlags): TransferFull[TIconInfo] {.cdecl, dynlib: lib, importc: "gtk_icon_theme_lookup_icon_for_scale".}
proc lookup_icon_for_scale*(self: IconTheme, icon_name: ustring, size: int32, scale: int32, flags: SIconLookupFlags): IconInfo {.inline.} =
  wrap(gtk_icon_theme_lookup_icon_for_scale(self, ucstring(icon_name), size, scale, flags))
# proc lookup_icon_for_scale*(self: IconTheme, icon_name: ustring, size: int32, scale: int32, flags: SIconLookupFlags): IconInfo {.inline.} =

# gtk_icon_theme_prepend_search_path
# flags: {isMethod} container: IconTheme
# need sugar: is method
# arg path: FILENAME 'string' 'cstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_theme_prepend_search_path(self: ptr TIconTheme, path: cstring) {.cdecl, dynlib: lib, importc: "gtk_icon_theme_prepend_search_path".}
proc prepend_search_path*(self: IconTheme, path: string) {.inline.} =
  gtk_icon_theme_prepend_search_path(self, cstring(path))
# proc prepend_search_path*(self: IconTheme, path: string) {.inline.} =

# gtk_icon_theme_rescan_if_needed
# flags: {isMethod} container: IconTheme
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_icon_theme_rescan_if_needed(self: ptr TIconTheme): bool {.cdecl, dynlib: lib, importc: "gtk_icon_theme_rescan_if_needed".}
proc rescan_if_needed*(self: IconTheme): bool {.inline.} =
  gtk_icon_theme_rescan_if_needed(self)
# proc rescan_if_needed*(self: IconTheme): bool {.inline.} =

# gtk_icon_theme_set_custom_theme
# flags: {isMethod} container: IconTheme
# need sugar: is method
# arg theme_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_theme_set_custom_theme(self: ptr TIconTheme, theme_name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_icon_theme_set_custom_theme".}
proc set_custom_theme*(self: IconTheme, theme_name: ustring) {.inline.} =
  gtk_icon_theme_set_custom_theme(self, ucstring(theme_name))
# proc set_custom_theme*(self: IconTheme, theme_name: ustring) {.inline.} =

# gtk_icon_theme_set_screen
# flags: {isMethod} container: IconTheme
# need sugar: is method
# arg screen: INTERFACE (OBJECT) 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_theme_set_screen(self: ptr TIconTheme, screen: ptr Gdk3.TScreen) {.cdecl, dynlib: lib, importc: "gtk_icon_theme_set_screen".}
proc set_screen*(self: IconTheme, screen: Gdk3.Screen) {.inline.} =
  gtk_icon_theme_set_screen(self, screen.getPointer)
# proc set_screen*(self: IconTheme, screen: Gdk3.Screen) {.inline.} =

# gtk_icon_theme_set_search_path
# flags: {isMethod} container: IconTheme
# need sugar: is method
# arg path: ARRAY 'var openarray[cstring]' 'openarray[cstring]' IN (diff., need sugar) array lengthArg: 1
# arg n_elements: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_theme_set_search_path(self: ptr TIconTheme, path: openarray[cstring], n_elements: int32) {.cdecl, dynlib: lib, importc: "gtk_icon_theme_set_search_path".}
proc set_search_path*(self: IconTheme, path: var openarray[cstring]) {.inline.} =
  gtk_icon_theme_set_search_path(self, path, path.len.int32)
# proc set_search_path*(self: IconTheme, path: var openarray[cstring]) {.inline.} =

# initializer for IconView: gtk_icon_view_get_type
proc gtk_icon_view_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_type".}
template gtype*(klass_parameter: typedesc[IconView]): GType = gtk_icon_view_get_type()
# gtk_icon_view_new
# flags: {isConstructor} container: IconView
# need sugar: is static method
# return: INTERFACE 'IconView' 'TransferNone[TIconView]' (diff., need sugar)
proc gtk_icon_view_new(): TransferNone[TIconView] {.cdecl, dynlib: lib, importc: "gtk_icon_view_new".}
proc new_iconview*(): IconView {.inline.} =
  wrap(gtk_icon_view_new())
# proc new_iconview*(): IconView {.inline.} =

# gtk_icon_view_new_with_area
# flags: {isConstructor} container: IconView
# need sugar: is static method
# arg area: INTERFACE (OBJECT) 'CellArea' 'ptr TCellArea' IN (diff., need sugar)
# return: INTERFACE 'IconView' 'TransferNone[TIconView]' (diff., need sugar)
proc gtk_icon_view_new_with_area(area: ptr TCellArea): TransferNone[TIconView] {.cdecl, dynlib: lib, importc: "gtk_icon_view_new_with_area".}
proc new_iconview_with_area*(area: CellArea): IconView {.inline.} =
  wrap(gtk_icon_view_new_with_area(area.getPointer))
# proc new_iconview_with_area*(area: CellArea): IconView {.inline.} =

# gtk_icon_view_new_with_model
# flags: {isConstructor} container: IconView
# need sugar: is static method
# arg model: INTERFACE (INTERFACE) 'ptr TTreeModel' 'ptr TTreeModel' IN
# return: INTERFACE 'IconView' 'TransferNone[TIconView]' (diff., need sugar)
proc gtk_icon_view_new_with_model(model: ptr TTreeModel): TransferNone[TIconView] {.cdecl, dynlib: lib, importc: "gtk_icon_view_new_with_model".}
proc new_iconview_with_model*(model: ptr TTreeModel): IconView {.inline.} =
  wrap(gtk_icon_view_new_with_model(model))
# proc new_iconview_with_model*(model: ptr TTreeModel): IconView {.inline.} =

# gtk_icon_view_convert_widget_to_bin_window_coords
# flags: {isMethod} container: IconView
# need sugar: is method
# arg wx: INT32 'int32' 'int32' IN
# arg wy: INT32 'int32' 'int32' IN
# arg bx: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# arg by: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_convert_widget_to_bin_window_coords(self: ptr TIconView, wx: int32, wy: int32, bx: ptr int32, by: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_icon_view_convert_widget_to_bin_window_coords".}
proc convert_widget_to_bin_window_coords*(self: IconView, wx: int32, wy: int32, bx: var int32, by: var int32) {.inline.} =
  gtk_icon_view_convert_widget_to_bin_window_coords(self, wx, wy, addr(bx), addr(by))
# tuple-return
# bx: var int32
# by: var int32
# proc convert_widget_to_bin_window_coords*(self: IconView, wx: int32, wy: int32) {.inline.} =

# gtk_icon_view_create_drag_icon
# flags: {isMethod} container: IconView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: INTERFACE 'ptr cairo1.TSurface' 'ptr cairo1.TSurface'
proc gtk_icon_view_create_drag_icon(self: ptr TIconView, path: ptr TTreePath): ptr cairo1.TSurface {.cdecl, dynlib: lib, importc: "gtk_icon_view_create_drag_icon".}
proc create_drag_icon*(self: IconView, path: ptr TTreePath): ptr cairo1.TSurface {.inline.} =
  gtk_icon_view_create_drag_icon(self, path)
# proc create_drag_icon*(self: IconView, path: ptr TTreePath): ptr cairo1.TSurface {.inline.} =

# gtk_icon_view_enable_model_drag_dest
# flags: {isMethod} container: IconView
# need sugar: is method
# arg targets: ARRAY 'var openarray[TTargetEntry]' 'openarray[TTargetEntry]' IN (diff., need sugar) array lengthArg: 1
# arg n_targets: INT32 'int32' 'int32' IN
# arg actions: INTERFACE (FLAGS) 'Gdk3.SDragAction' 'Gdk3.SDragAction' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_enable_model_drag_dest(self: ptr TIconView, targets: openarray[TTargetEntry], n_targets: int32, actions: Gdk3.SDragAction) {.cdecl, dynlib: lib, importc: "gtk_icon_view_enable_model_drag_dest".}
proc enable_model_drag_dest*(self: IconView, targets: var openarray[TTargetEntry], actions: Gdk3.SDragAction) {.inline.} =
  gtk_icon_view_enable_model_drag_dest(self, targets, targets.len.int32, actions)
# proc enable_model_drag_dest*(self: IconView, targets: var openarray[TTargetEntry], actions: Gdk3.SDragAction) {.inline.} =

# gtk_icon_view_enable_model_drag_source
# flags: {isMethod} container: IconView
# need sugar: is method
# arg start_button_mask: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# arg targets: ARRAY 'var openarray[TTargetEntry]' 'openarray[TTargetEntry]' IN (diff., need sugar) array lengthArg: 2
# arg n_targets: INT32 'int32' 'int32' IN
# arg actions: INTERFACE (FLAGS) 'Gdk3.SDragAction' 'Gdk3.SDragAction' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_enable_model_drag_source(self: ptr TIconView, start_button_mask: Gdk3.SModifierType, targets: openarray[TTargetEntry], n_targets: int32, actions: Gdk3.SDragAction) {.cdecl, dynlib: lib, importc: "gtk_icon_view_enable_model_drag_source".}
proc enable_model_drag_source*(self: IconView, start_button_mask: Gdk3.SModifierType, targets: var openarray[TTargetEntry], actions: Gdk3.SDragAction) {.inline.} =
  gtk_icon_view_enable_model_drag_source(self, start_button_mask, targets, targets.len.int32, actions)
# proc enable_model_drag_source*(self: IconView, start_button_mask: Gdk3.SModifierType, targets: var openarray[TTargetEntry], actions: Gdk3.SDragAction) {.inline.} =

# gtk_icon_view_get_activate_on_single_click
# flags: {isMethod} container: IconView
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_icon_view_get_activate_on_single_click(self: ptr TIconView): bool {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_activate_on_single_click".}
proc get_activate_on_single_click*(self: IconView): bool {.inline.} =
  gtk_icon_view_get_activate_on_single_click(self)
# proc get_activate_on_single_click*(self: IconView): bool {.inline.} =

# gtk_icon_view_get_cell_rect
# flags: {isMethod} container: IconView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# arg cell: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# arg rect: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' OUT caller-allocates
# return: BOOLEAN 'bool' 'bool'
proc gtk_icon_view_get_cell_rect(self: ptr TIconView, path: ptr TTreePath, cell: ptr TCellRenderer, rect: ptr Gdk3.TRectangle): bool {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_cell_rect".}
proc get_cell_rect*(self: IconView, path: ptr TTreePath, cell: CellRenderer, rect: ptr Gdk3.TRectangle): bool {.inline.} =
  gtk_icon_view_get_cell_rect(self, path, cell.getPointer, rect)
# tuple-return
# rect: ptr Gdk3.TRectangle
# proc get_cell_rect*(self: IconView, path: ptr TTreePath, cell: CellRenderer): bool {.inline.} =

# gtk_icon_view_get_column_spacing
# flags: {isMethod} container: IconView
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_icon_view_get_column_spacing(self: ptr TIconView): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_column_spacing".}
proc get_column_spacing*(self: IconView): int32 {.inline.} =
  gtk_icon_view_get_column_spacing(self)
# proc get_column_spacing*(self: IconView): int32 {.inline.} =

# gtk_icon_view_get_columns
# flags: {isMethod} container: IconView
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_icon_view_get_columns(self: ptr TIconView): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_columns".}
proc get_columns*(self: IconView): int32 {.inline.} =
  gtk_icon_view_get_columns(self)
# proc get_columns*(self: IconView): int32 {.inline.} =

# gtk_icon_view_get_cursor
# flags: {isMethod} container: IconView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' OUT optional
# arg cell: INTERFACE (OBJECT) 'var CellRenderer' 'ptr TCellRenderer' OUT (diff., need sugar) optional
# return: BOOLEAN 'bool' 'bool'
proc gtk_icon_view_get_cursor(self: ptr TIconView, path: ptr TTreePath, cell: ptr TCellRenderer): bool {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_cursor".}
proc get_cursor*(self: IconView, path: ptr TTreePath, cell: var CellRenderer): bool {.inline.} =
  gtk_icon_view_get_cursor(self, path, cell.getPointer)
# tuple-return
# path: ptr TTreePath
# cell: var CellRenderer
# proc get_cursor*(self: IconView): bool {.inline.} =

# gtk_icon_view_get_dest_item_at_pos
# flags: {isMethod} container: IconView
# need sugar: is method
# arg drag_x: INT32 'int32' 'int32' IN
# arg drag_y: INT32 'int32' 'int32' IN
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' OUT optional
# arg pos: INTERFACE (ENUM) 'IconViewDropPosition' 'IconViewDropPosition' OUT optional
# return: BOOLEAN 'bool' 'bool'
proc gtk_icon_view_get_dest_item_at_pos(self: ptr TIconView, drag_x: int32, drag_y: int32, path: ptr TTreePath, pos: IconViewDropPosition): bool {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_dest_item_at_pos".}
proc get_dest_item_at_pos*(self: IconView, drag_x: int32, drag_y: int32, path: ptr TTreePath, pos: IconViewDropPosition): bool {.inline.} =
  gtk_icon_view_get_dest_item_at_pos(self, drag_x, drag_y, path, pos)
# tuple-return
# path: ptr TTreePath
# pos: IconViewDropPosition
# proc get_dest_item_at_pos*(self: IconView, drag_x: int32, drag_y: int32): bool {.inline.} =

# gtk_icon_view_get_drag_dest_item
# flags: {isMethod} container: IconView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' OUT optional
# arg pos: INTERFACE (ENUM) 'IconViewDropPosition' 'IconViewDropPosition' OUT optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_get_drag_dest_item(self: ptr TIconView, path: ptr TTreePath, pos: IconViewDropPosition) {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_drag_dest_item".}
proc get_drag_dest_item*(self: IconView, path: ptr TTreePath, pos: IconViewDropPosition) {.inline.} =
  gtk_icon_view_get_drag_dest_item(self, path, pos)
# tuple-return
# path: ptr TTreePath
# pos: IconViewDropPosition
# proc get_drag_dest_item*(self: IconView) {.inline.} =

# gtk_icon_view_get_item_at_pos
# flags: {isMethod} container: IconView
# need sugar: is method
# arg x: INT32 'int32' 'int32' IN
# arg y: INT32 'int32' 'int32' IN
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' OUT optional
# arg cell: INTERFACE (OBJECT) 'var CellRenderer' 'ptr TCellRenderer' OUT (diff., need sugar) optional
# return: BOOLEAN 'bool' 'bool'
proc gtk_icon_view_get_item_at_pos(self: ptr TIconView, x: int32, y: int32, path: ptr TTreePath, cell: ptr TCellRenderer): bool {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_item_at_pos".}
proc get_item_at_pos*(self: IconView, x: int32, y: int32, path: ptr TTreePath, cell: var CellRenderer): bool {.inline.} =
  gtk_icon_view_get_item_at_pos(self, x, y, path, cell.getPointer)
# tuple-return
# path: ptr TTreePath
# cell: var CellRenderer
# proc get_item_at_pos*(self: IconView, x: int32, y: int32): bool {.inline.} =

# gtk_icon_view_get_item_column
# flags: {isMethod} container: IconView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: INT32 'int32' 'int32'
proc gtk_icon_view_get_item_column(self: ptr TIconView, path: ptr TTreePath): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_item_column".}
proc get_item_column*(self: IconView, path: ptr TTreePath): int32 {.inline.} =
  gtk_icon_view_get_item_column(self, path)
# proc get_item_column*(self: IconView, path: ptr TTreePath): int32 {.inline.} =

# gtk_icon_view_get_item_orientation
# flags: {isMethod} container: IconView
# need sugar: is method
# return: INTERFACE 'Orientation' 'Orientation'
proc gtk_icon_view_get_item_orientation(self: ptr TIconView): Orientation {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_item_orientation".}
proc get_item_orientation*(self: IconView): Orientation {.inline.} =
  gtk_icon_view_get_item_orientation(self)
# proc get_item_orientation*(self: IconView): Orientation {.inline.} =

# gtk_icon_view_get_item_padding
# flags: {isMethod} container: IconView
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_icon_view_get_item_padding(self: ptr TIconView): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_item_padding".}
proc get_item_padding*(self: IconView): int32 {.inline.} =
  gtk_icon_view_get_item_padding(self)
# proc get_item_padding*(self: IconView): int32 {.inline.} =

# gtk_icon_view_get_item_row
# flags: {isMethod} container: IconView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: INT32 'int32' 'int32'
proc gtk_icon_view_get_item_row(self: ptr TIconView, path: ptr TTreePath): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_item_row".}
proc get_item_row*(self: IconView, path: ptr TTreePath): int32 {.inline.} =
  gtk_icon_view_get_item_row(self, path)
# proc get_item_row*(self: IconView, path: ptr TTreePath): int32 {.inline.} =

# gtk_icon_view_get_item_width
# flags: {isMethod} container: IconView
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_icon_view_get_item_width(self: ptr TIconView): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_item_width".}
proc get_item_width*(self: IconView): int32 {.inline.} =
  gtk_icon_view_get_item_width(self)
# proc get_item_width*(self: IconView): int32 {.inline.} =

# gtk_icon_view_get_margin
# flags: {isMethod} container: IconView
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_icon_view_get_margin(self: ptr TIconView): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_margin".}
proc get_margin*(self: IconView): int32 {.inline.} =
  gtk_icon_view_get_margin(self)
# proc get_margin*(self: IconView): int32 {.inline.} =

# gtk_icon_view_get_markup_column
# flags: {isMethod} container: IconView
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_icon_view_get_markup_column(self: ptr TIconView): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_markup_column".}
proc get_markup_column*(self: IconView): int32 {.inline.} =
  gtk_icon_view_get_markup_column(self)
# proc get_markup_column*(self: IconView): int32 {.inline.} =

# gtk_icon_view_get_model
# flags: {isMethod} container: IconView
# need sugar: is method
# return: INTERFACE 'ptr TTreeModel' 'TransferNone[TTreeModel]' (diff., need sugar)
proc gtk_icon_view_get_model(self: ptr TIconView): TransferNone[TTreeModel] {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_model".}
proc get_model*(self: IconView): ptr TTreeModel {.inline.} =
  wrap(gtk_icon_view_get_model(self))
# proc get_model*(self: IconView): ptr TTreeModel {.inline.} =

# gtk_icon_view_get_path_at_pos
# flags: {isMethod} container: IconView
# need sugar: is method
# arg x: INT32 'int32' 'int32' IN
# arg y: INT32 'int32' 'int32' IN
# return: INTERFACE 'ptr TTreePath' 'ptr TTreePath'
proc gtk_icon_view_get_path_at_pos(self: ptr TIconView, x: int32, y: int32): ptr TTreePath {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_path_at_pos".}
proc get_path_at_pos*(self: IconView, x: int32, y: int32): ptr TTreePath {.inline.} =
  gtk_icon_view_get_path_at_pos(self, x, y)
# proc get_path_at_pos*(self: IconView, x: int32, y: int32): ptr TTreePath {.inline.} =

# gtk_icon_view_get_pixbuf_column
# flags: {isMethod} container: IconView
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_icon_view_get_pixbuf_column(self: ptr TIconView): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_pixbuf_column".}
proc get_pixbuf_column*(self: IconView): int32 {.inline.} =
  gtk_icon_view_get_pixbuf_column(self)
# proc get_pixbuf_column*(self: IconView): int32 {.inline.} =

# gtk_icon_view_get_reorderable
# flags: {isMethod} container: IconView
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_icon_view_get_reorderable(self: ptr TIconView): bool {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_reorderable".}
proc get_reorderable*(self: IconView): bool {.inline.} =
  gtk_icon_view_get_reorderable(self)
# proc get_reorderable*(self: IconView): bool {.inline.} =

# gtk_icon_view_get_row_spacing
# flags: {isMethod} container: IconView
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_icon_view_get_row_spacing(self: ptr TIconView): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_row_spacing".}
proc get_row_spacing*(self: IconView): int32 {.inline.} =
  gtk_icon_view_get_row_spacing(self)
# proc get_row_spacing*(self: IconView): int32 {.inline.} =

# gtk_icon_view_get_selected_items
# flags: {isMethod} container: IconView
# need sugar: is method
# return: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_icon_view_get_selected_items(self: ptr TIconView): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_selected_items".}
proc get_selected_items*(self: IconView): ptr GLIST_TODO {.inline.} =
  gtk_icon_view_get_selected_items(self)
# proc get_selected_items*(self: IconView): ptr GLIST_TODO {.inline.} =

# gtk_icon_view_get_selection_mode
# flags: {isMethod} container: IconView
# need sugar: is method
# return: INTERFACE 'SelectionMode' 'SelectionMode'
proc gtk_icon_view_get_selection_mode(self: ptr TIconView): SelectionMode {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_selection_mode".}
proc get_selection_mode*(self: IconView): SelectionMode {.inline.} =
  gtk_icon_view_get_selection_mode(self)
# proc get_selection_mode*(self: IconView): SelectionMode {.inline.} =

# gtk_icon_view_get_spacing
# flags: {isMethod} container: IconView
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_icon_view_get_spacing(self: ptr TIconView): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_spacing".}
proc get_spacing*(self: IconView): int32 {.inline.} =
  gtk_icon_view_get_spacing(self)
# proc get_spacing*(self: IconView): int32 {.inline.} =

# gtk_icon_view_get_text_column
# flags: {isMethod} container: IconView
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_icon_view_get_text_column(self: ptr TIconView): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_text_column".}
proc get_text_column*(self: IconView): int32 {.inline.} =
  gtk_icon_view_get_text_column(self)
# proc get_text_column*(self: IconView): int32 {.inline.} =

# gtk_icon_view_get_tooltip_column
# flags: {isMethod} container: IconView
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_icon_view_get_tooltip_column(self: ptr TIconView): int32 {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_tooltip_column".}
proc get_tooltip_column*(self: IconView): int32 {.inline.} =
  gtk_icon_view_get_tooltip_column(self)
# proc get_tooltip_column*(self: IconView): int32 {.inline.} =

# gtk_icon_view_get_tooltip_context
# flags: {isMethod} container: IconView
# need sugar: is method
# arg x: INT32 'var int32' 'ptr int32' INOUT (diff., need sugar)
# arg y: INT32 'var int32' 'ptr int32' INOUT (diff., need sugar)
# arg keyboard_tip: BOOLEAN 'bool' 'bool' IN
# arg model: INTERFACE (INTERFACE) 'ptr TTreeModel' 'ptr TTreeModel' OUT optional
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' OUT optional
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' OUT caller-allocates optional
# return: BOOLEAN 'bool' 'bool'
proc gtk_icon_view_get_tooltip_context(self: ptr TIconView, x: ptr int32, y: ptr int32, keyboard_tip: bool, model: ptr TTreeModel, path: ptr TTreePath, iter: ptr TTreeIter): bool {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_tooltip_context".}
proc get_tooltip_context*(self: IconView, x: var int32, y: var int32, keyboard_tip: bool, model: ptr TTreeModel, path: ptr TTreePath, iter: ptr TTreeIter): bool {.inline.} =
  gtk_icon_view_get_tooltip_context(self, addr(x), addr(y), keyboard_tip, model, path, iter)
# tuple-return
# model: ptr TTreeModel
# path: ptr TTreePath
# iter: ptr TTreeIter
# proc get_tooltip_context*(self: IconView, x: var int32, y: var int32, keyboard_tip: bool): bool {.inline.} =

# gtk_icon_view_get_visible_range
# flags: {isMethod} container: IconView
# need sugar: is method
# arg start_path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' OUT optional
# arg end_path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' OUT optional
# return: BOOLEAN 'bool' 'bool'
proc gtk_icon_view_get_visible_range(self: ptr TIconView, start_path: ptr TTreePath, end_path: ptr TTreePath): bool {.cdecl, dynlib: lib, importc: "gtk_icon_view_get_visible_range".}
proc get_visible_range*(self: IconView, start_path: ptr TTreePath, end_path: ptr TTreePath): bool {.inline.} =
  gtk_icon_view_get_visible_range(self, start_path, end_path)
# tuple-return
# start_path: ptr TTreePath
# end_path: ptr TTreePath
# proc get_visible_range*(self: IconView): bool {.inline.} =

# gtk_icon_view_item_activated
# flags: {isMethod} container: IconView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_item_activated(self: ptr TIconView, path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_icon_view_item_activated".}
proc item_activated*(self: IconView, path: ptr TTreePath) {.inline.} =
  gtk_icon_view_item_activated(self, path)
# proc item_activated*(self: IconView, path: ptr TTreePath) {.inline.} =

# gtk_icon_view_path_is_selected
# flags: {isMethod} container: IconView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_icon_view_path_is_selected(self: ptr TIconView, path: ptr TTreePath): bool {.cdecl, dynlib: lib, importc: "gtk_icon_view_path_is_selected".}
proc path_is_selected*(self: IconView, path: ptr TTreePath): bool {.inline.} =
  gtk_icon_view_path_is_selected(self, path)
# proc path_is_selected*(self: IconView, path: ptr TTreePath): bool {.inline.} =

# gtk_icon_view_scroll_to_path
# flags: {isMethod} container: IconView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# arg use_align: BOOLEAN 'bool' 'bool' IN
# arg row_align: FLOAT 'float32' 'float32' IN
# arg col_align: FLOAT 'float32' 'float32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_scroll_to_path(self: ptr TIconView, path: ptr TTreePath, use_align: bool, row_align: float32, col_align: float32) {.cdecl, dynlib: lib, importc: "gtk_icon_view_scroll_to_path".}
proc scroll_to_path*(self: IconView, path: ptr TTreePath, use_align: bool, row_align: float32, col_align: float32) {.inline.} =
  gtk_icon_view_scroll_to_path(self, path, use_align, row_align, col_align)
# proc scroll_to_path*(self: IconView, path: ptr TTreePath, use_align: bool, row_align: float32, col_align: float32) {.inline.} =

# gtk_icon_view_select_all
# flags: {isMethod} container: IconView
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_select_all(self: ptr TIconView) {.cdecl, dynlib: lib, importc: "gtk_icon_view_select_all".}
proc select_all*(self: IconView) {.inline.} =
  gtk_icon_view_select_all(self)
# proc select_all*(self: IconView) {.inline.} =

# gtk_icon_view_select_path
# flags: {isMethod} container: IconView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_select_path(self: ptr TIconView, path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_icon_view_select_path".}
proc select_path*(self: IconView, path: ptr TTreePath) {.inline.} =
  gtk_icon_view_select_path(self, path)
# proc select_path*(self: IconView, path: ptr TTreePath) {.inline.} =

# gtk_icon_view_selected_foreach
# flags: {isMethod} container: IconView
# need sugar: is method
# arg func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg data: VOID 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_selected_foreach(self: ptr TIconView, func_x: pointer, data: pointer) {.cdecl, dynlib: lib, importc: "gtk_icon_view_selected_foreach".}
proc selected_foreach*(self: IconView, func_x: pointer, data: pointer) {.inline.} =
  gtk_icon_view_selected_foreach(self, func_x, data)
# proc selected_foreach*(self: IconView, func_x: pointer, data: pointer) {.inline.} =

# gtk_icon_view_set_activate_on_single_click
# flags: {isMethod} container: IconView
# need sugar: is method
# arg single: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_activate_on_single_click(self: ptr TIconView, single: bool) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_activate_on_single_click".}
proc set_activate_on_single_click*(self: IconView, single: bool) {.inline.} =
  gtk_icon_view_set_activate_on_single_click(self, single)
# proc set_activate_on_single_click*(self: IconView, single: bool) {.inline.} =

# gtk_icon_view_set_column_spacing
# flags: {isMethod} container: IconView
# need sugar: is method
# arg column_spacing: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_column_spacing(self: ptr TIconView, column_spacing: int32) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_column_spacing".}
proc set_column_spacing*(self: IconView, column_spacing: int32) {.inline.} =
  gtk_icon_view_set_column_spacing(self, column_spacing)
# proc set_column_spacing*(self: IconView, column_spacing: int32) {.inline.} =

# gtk_icon_view_set_columns
# flags: {isMethod} container: IconView
# need sugar: is method
# arg columns: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_columns(self: ptr TIconView, columns: int32) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_columns".}
proc set_columns*(self: IconView, columns: int32) {.inline.} =
  gtk_icon_view_set_columns(self, columns)
# proc set_columns*(self: IconView, columns: int32) {.inline.} =

# gtk_icon_view_set_cursor
# flags: {isMethod} container: IconView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# arg cell: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# arg start_editing: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_cursor(self: ptr TIconView, path: ptr TTreePath, cell: ptr TCellRenderer, start_editing: bool) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_cursor".}
proc set_cursor*(self: IconView, path: ptr TTreePath, cell: CellRenderer, start_editing: bool) {.inline.} =
  gtk_icon_view_set_cursor(self, path, cell.getPointer, start_editing)
# proc set_cursor*(self: IconView, path: ptr TTreePath, cell: CellRenderer, start_editing: bool) {.inline.} =

# gtk_icon_view_set_drag_dest_item
# flags: {isMethod} container: IconView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# arg pos: INTERFACE (ENUM) 'IconViewDropPosition' 'IconViewDropPosition' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_drag_dest_item(self: ptr TIconView, path: ptr TTreePath, pos: IconViewDropPosition) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_drag_dest_item".}
proc set_drag_dest_item*(self: IconView, path: ptr TTreePath, pos: IconViewDropPosition) {.inline.} =
  gtk_icon_view_set_drag_dest_item(self, path, pos)
# proc set_drag_dest_item*(self: IconView, path: ptr TTreePath, pos: IconViewDropPosition) {.inline.} =

# gtk_icon_view_set_item_orientation
# flags: {isMethod} container: IconView
# need sugar: is method
# arg orientation: INTERFACE (ENUM) 'Orientation' 'Orientation' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_item_orientation(self: ptr TIconView, orientation: Orientation) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_item_orientation".}
proc set_item_orientation*(self: IconView, orientation: Orientation) {.inline.} =
  gtk_icon_view_set_item_orientation(self, orientation)
# proc set_item_orientation*(self: IconView, orientation: Orientation) {.inline.} =

# gtk_icon_view_set_item_padding
# flags: {isMethod} container: IconView
# need sugar: is method
# arg item_padding: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_item_padding(self: ptr TIconView, item_padding: int32) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_item_padding".}
proc set_item_padding*(self: IconView, item_padding: int32) {.inline.} =
  gtk_icon_view_set_item_padding(self, item_padding)
# proc set_item_padding*(self: IconView, item_padding: int32) {.inline.} =

# gtk_icon_view_set_item_width
# flags: {isMethod} container: IconView
# need sugar: is method
# arg item_width: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_item_width(self: ptr TIconView, item_width: int32) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_item_width".}
proc set_item_width*(self: IconView, item_width: int32) {.inline.} =
  gtk_icon_view_set_item_width(self, item_width)
# proc set_item_width*(self: IconView, item_width: int32) {.inline.} =

# gtk_icon_view_set_margin
# flags: {isMethod} container: IconView
# need sugar: is method
# arg margin: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_margin(self: ptr TIconView, margin: int32) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_margin".}
proc set_margin*(self: IconView, margin: int32) {.inline.} =
  gtk_icon_view_set_margin(self, margin)
# proc set_margin*(self: IconView, margin: int32) {.inline.} =

# gtk_icon_view_set_markup_column
# flags: {isMethod} container: IconView
# need sugar: is method
# arg column: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_markup_column(self: ptr TIconView, column: int32) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_markup_column".}
proc set_markup_column*(self: IconView, column: int32) {.inline.} =
  gtk_icon_view_set_markup_column(self, column)
# proc set_markup_column*(self: IconView, column: int32) {.inline.} =

# gtk_icon_view_set_model
# flags: {isMethod} container: IconView
# need sugar: is method
# arg model: INTERFACE (INTERFACE) 'ptr TTreeModel' 'ptr TTreeModel' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_model(self: ptr TIconView, model: ptr TTreeModel) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_model".}
proc set_model*(self: IconView, model: ptr TTreeModel) {.inline.} =
  gtk_icon_view_set_model(self, model)
# proc set_model*(self: IconView, model: ptr TTreeModel) {.inline.} =

# gtk_icon_view_set_pixbuf_column
# flags: {isMethod} container: IconView
# need sugar: is method
# arg column: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_pixbuf_column(self: ptr TIconView, column: int32) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_pixbuf_column".}
proc set_pixbuf_column*(self: IconView, column: int32) {.inline.} =
  gtk_icon_view_set_pixbuf_column(self, column)
# proc set_pixbuf_column*(self: IconView, column: int32) {.inline.} =

# gtk_icon_view_set_reorderable
# flags: {isMethod} container: IconView
# need sugar: is method
# arg reorderable: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_reorderable(self: ptr TIconView, reorderable: bool) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_reorderable".}
proc set_reorderable*(self: IconView, reorderable: bool) {.inline.} =
  gtk_icon_view_set_reorderable(self, reorderable)
# proc set_reorderable*(self: IconView, reorderable: bool) {.inline.} =

# gtk_icon_view_set_row_spacing
# flags: {isMethod} container: IconView
# need sugar: is method
# arg row_spacing: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_row_spacing(self: ptr TIconView, row_spacing: int32) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_row_spacing".}
proc set_row_spacing*(self: IconView, row_spacing: int32) {.inline.} =
  gtk_icon_view_set_row_spacing(self, row_spacing)
# proc set_row_spacing*(self: IconView, row_spacing: int32) {.inline.} =

# gtk_icon_view_set_selection_mode
# flags: {isMethod} container: IconView
# need sugar: is method
# arg mode: INTERFACE (ENUM) 'SelectionMode' 'SelectionMode' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_selection_mode(self: ptr TIconView, mode: SelectionMode) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_selection_mode".}
proc set_selection_mode*(self: IconView, mode: SelectionMode) {.inline.} =
  gtk_icon_view_set_selection_mode(self, mode)
# proc set_selection_mode*(self: IconView, mode: SelectionMode) {.inline.} =

# gtk_icon_view_set_spacing
# flags: {isMethod} container: IconView
# need sugar: is method
# arg spacing: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_spacing(self: ptr TIconView, spacing: int32) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_spacing".}
proc set_spacing*(self: IconView, spacing: int32) {.inline.} =
  gtk_icon_view_set_spacing(self, spacing)
# proc set_spacing*(self: IconView, spacing: int32) {.inline.} =

# gtk_icon_view_set_text_column
# flags: {isMethod} container: IconView
# need sugar: is method
# arg column: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_text_column(self: ptr TIconView, column: int32) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_text_column".}
proc set_text_column*(self: IconView, column: int32) {.inline.} =
  gtk_icon_view_set_text_column(self, column)
# proc set_text_column*(self: IconView, column: int32) {.inline.} =

# gtk_icon_view_set_tooltip_cell
# flags: {isMethod} container: IconView
# need sugar: is method
# arg tooltip: INTERFACE (OBJECT) 'Tooltip' 'ptr TTooltip' IN (diff., need sugar)
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# arg cell: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_tooltip_cell(self: ptr TIconView, tooltip: ptr TTooltip, path: ptr TTreePath, cell: ptr TCellRenderer) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_tooltip_cell".}
proc set_tooltip_cell*(self: IconView, tooltip: Tooltip, path: ptr TTreePath, cell: CellRenderer) {.inline.} =
  gtk_icon_view_set_tooltip_cell(self, tooltip.getPointer, path, cell.getPointer)
# proc set_tooltip_cell*(self: IconView, tooltip: Tooltip, path: ptr TTreePath, cell: CellRenderer) {.inline.} =

# gtk_icon_view_set_tooltip_column
# flags: {isMethod} container: IconView
# need sugar: is method
# arg column: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_tooltip_column(self: ptr TIconView, column: int32) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_tooltip_column".}
proc set_tooltip_column*(self: IconView, column: int32) {.inline.} =
  gtk_icon_view_set_tooltip_column(self, column)
# proc set_tooltip_column*(self: IconView, column: int32) {.inline.} =

# gtk_icon_view_set_tooltip_item
# flags: {isMethod} container: IconView
# need sugar: is method
# arg tooltip: INTERFACE (OBJECT) 'Tooltip' 'ptr TTooltip' IN (diff., need sugar)
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_set_tooltip_item(self: ptr TIconView, tooltip: ptr TTooltip, path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_icon_view_set_tooltip_item".}
proc set_tooltip_item*(self: IconView, tooltip: Tooltip, path: ptr TTreePath) {.inline.} =
  gtk_icon_view_set_tooltip_item(self, tooltip.getPointer, path)
# proc set_tooltip_item*(self: IconView, tooltip: Tooltip, path: ptr TTreePath) {.inline.} =

# gtk_icon_view_unselect_all
# flags: {isMethod} container: IconView
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_unselect_all(self: ptr TIconView) {.cdecl, dynlib: lib, importc: "gtk_icon_view_unselect_all".}
proc unselect_all*(self: IconView) {.inline.} =
  gtk_icon_view_unselect_all(self)
# proc unselect_all*(self: IconView) {.inline.} =

# gtk_icon_view_unselect_path
# flags: {isMethod} container: IconView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_unselect_path(self: ptr TIconView, path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_icon_view_unselect_path".}
proc unselect_path*(self: IconView, path: ptr TTreePath) {.inline.} =
  gtk_icon_view_unselect_path(self, path)
# proc unselect_path*(self: IconView, path: ptr TTreePath) {.inline.} =

# gtk_icon_view_unset_model_drag_dest
# flags: {isMethod} container: IconView
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_unset_model_drag_dest(self: ptr TIconView) {.cdecl, dynlib: lib, importc: "gtk_icon_view_unset_model_drag_dest".}
proc unset_model_drag_dest*(self: IconView) {.inline.} =
  gtk_icon_view_unset_model_drag_dest(self)
# proc unset_model_drag_dest*(self: IconView) {.inline.} =

# gtk_icon_view_unset_model_drag_source
# flags: {isMethod} container: IconView
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_icon_view_unset_model_drag_source(self: ptr TIconView) {.cdecl, dynlib: lib, importc: "gtk_icon_view_unset_model_drag_source".}
proc unset_model_drag_source*(self: IconView) {.inline.} =
  gtk_icon_view_unset_model_drag_source(self)
# proc unset_model_drag_source*(self: IconView) {.inline.} =

# initializer for IconViewAccessible: gtk_icon_view_accessible_get_type
proc gtk_icon_view_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_icon_view_accessible_get_type".}
template gtype*(klass_parameter: typedesc[IconViewAccessible]): GType = gtk_icon_view_accessible_get_type()
# initializer for Image: gtk_image_get_type
proc gtk_image_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_image_get_type".}
template gtype*(klass_parameter: typedesc[Image]): GType = gtk_image_get_type()
# gtk_image_new
# flags: {isConstructor} container: Image
# need sugar: is static method
# return: INTERFACE 'Image' 'TransferNone[TImage]' (diff., need sugar)
proc gtk_image_new(): TransferNone[TImage] {.cdecl, dynlib: lib, importc: "gtk_image_new".}
proc new_image*(): Image {.inline.} =
  wrap(gtk_image_new())
# proc new_image*(): Image {.inline.} =

# gtk_image_new_from_animation
# flags: {isConstructor} container: Image
# need sugar: is static method
# arg animation: INTERFACE (OBJECT) 'GdkPixbuf2.PixbufAnimation' 'ptr GdkPixbuf2.TPixbufAnimation' IN (diff., need sugar)
# return: INTERFACE 'Image' 'TransferNone[TImage]' (diff., need sugar)
proc gtk_image_new_from_animation(animation: ptr GdkPixbuf2.TPixbufAnimation): TransferNone[TImage] {.cdecl, dynlib: lib, importc: "gtk_image_new_from_animation".}
proc new_image_from_animation*(animation: GdkPixbuf2.PixbufAnimation): Image {.inline.} =
  wrap(gtk_image_new_from_animation(animation.getPointer))
# proc new_image_from_animation*(animation: GdkPixbuf2.PixbufAnimation): Image {.inline.} =

# gtk_image_new_from_file
# flags: {isConstructor} container: Image
# need sugar: is static method
# arg filename: FILENAME 'string' 'cstring' IN (diff., need sugar)
# return: INTERFACE 'Image' 'TransferNone[TImage]' (diff., need sugar)
proc gtk_image_new_from_file(filename: cstring): TransferNone[TImage] {.cdecl, dynlib: lib, importc: "gtk_image_new_from_file".}
proc new_image_from_file*(filename: string): Image {.inline.} =
  wrap(gtk_image_new_from_file(cstring(filename)))
# proc new_image_from_file*(filename: string): Image {.inline.} =

# gtk_image_new_from_gicon
# flags: {isConstructor} container: Image
# need sugar: is static method
# arg icon: INTERFACE (INTERFACE) 'ptr Gio2.TIcon' 'ptr Gio2.TIcon' IN
# arg size: INT32 'int32' 'int32' IN
# return: INTERFACE 'Image' 'TransferNone[TImage]' (diff., need sugar)
proc gtk_image_new_from_gicon(icon: ptr Gio2.TIcon, size: int32): TransferNone[TImage] {.cdecl, dynlib: lib, importc: "gtk_image_new_from_gicon".}
proc new_image_from_gicon*(icon: ptr Gio2.TIcon, size: int32): Image {.inline.} =
  wrap(gtk_image_new_from_gicon(icon, size))
# proc new_image_from_gicon*(icon: ptr Gio2.TIcon, size: int32): Image {.inline.} =

# gtk_image_new_from_icon_name
# flags: {isConstructor} container: Image
# need sugar: is static method
# arg icon_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg size: INT32 'int32' 'int32' IN
# return: INTERFACE 'Image' 'TransferNone[TImage]' (diff., need sugar)
proc gtk_image_new_from_icon_name(icon_name: ucstring, size: int32): TransferNone[TImage] {.cdecl, dynlib: lib, importc: "gtk_image_new_from_icon_name".}
proc new_image_from_icon_name*(icon_name: ustring, size: int32): Image {.inline.} =
  wrap(gtk_image_new_from_icon_name(ucstring(icon_name), size))
# proc new_image_from_icon_name*(icon_name: ustring, size: int32): Image {.inline.} =

# gtk_image_new_from_icon_set
# flags: {isConstructor} container: Image (deprecated)
# gtk_image_new_from_pixbuf
# flags: {isConstructor} container: Image
# need sugar: is static method
# arg pixbuf: INTERFACE (OBJECT) 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# return: INTERFACE 'Image' 'TransferNone[TImage]' (diff., need sugar)
proc gtk_image_new_from_pixbuf(pixbuf: ptr GdkPixbuf2.TPixbuf): TransferNone[TImage] {.cdecl, dynlib: lib, importc: "gtk_image_new_from_pixbuf".}
proc new_image_from_pixbuf*(pixbuf: GdkPixbuf2.Pixbuf): Image {.inline.} =
  wrap(gtk_image_new_from_pixbuf(pixbuf.getPointer))
# proc new_image_from_pixbuf*(pixbuf: GdkPixbuf2.Pixbuf): Image {.inline.} =

# gtk_image_new_from_resource
# flags: {isConstructor} container: Image
# need sugar: is static method
# arg resource_path: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'Image' 'TransferNone[TImage]' (diff., need sugar)
proc gtk_image_new_from_resource(resource_path: ucstring): TransferNone[TImage] {.cdecl, dynlib: lib, importc: "gtk_image_new_from_resource".}
proc new_image_from_resource*(resource_path: ustring): Image {.inline.} =
  wrap(gtk_image_new_from_resource(ucstring(resource_path)))
# proc new_image_from_resource*(resource_path: ustring): Image {.inline.} =

# gtk_image_new_from_stock
# flags: {isConstructor} container: Image (deprecated)
# gtk_image_new_from_surface
# flags: {isConstructor} container: Image
# need sugar: is static method
# arg surface: INTERFACE (STRUCT) 'ptr cairo1.TSurface' 'ptr cairo1.TSurface' IN
# return: INTERFACE 'Image' 'TransferNone[TImage]' (diff., need sugar)
proc gtk_image_new_from_surface(surface: ptr cairo1.TSurface): TransferNone[TImage] {.cdecl, dynlib: lib, importc: "gtk_image_new_from_surface".}
proc new_image_from_surface*(surface: ptr cairo1.TSurface): Image {.inline.} =
  wrap(gtk_image_new_from_surface(surface))
# proc new_image_from_surface*(surface: ptr cairo1.TSurface): Image {.inline.} =

# gtk_image_clear
# flags: {isMethod} container: Image
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_image_clear(self: ptr TImage) {.cdecl, dynlib: lib, importc: "gtk_image_clear".}
proc clear*(self: Image) {.inline.} =
  gtk_image_clear(self)
# proc clear*(self: Image) {.inline.} =

# gtk_image_get_animation
# flags: {isMethod} container: Image
# need sugar: is method
# return: INTERFACE 'GdkPixbuf2.PixbufAnimation' 'TransferNone[GdkPixbuf2.TPixbufAnimation]' (diff., need sugar)
proc gtk_image_get_animation(self: ptr TImage): TransferNone[GdkPixbuf2.TPixbufAnimation] {.cdecl, dynlib: lib, importc: "gtk_image_get_animation".}
proc get_animation*(self: Image): GdkPixbuf2.PixbufAnimation {.inline.} =
  wrap(gtk_image_get_animation(self))
# proc get_animation*(self: Image): GdkPixbuf2.PixbufAnimation {.inline.} =

# gtk_image_get_gicon
# flags: {isMethod} container: Image
# need sugar: is method
# arg gicon: INTERFACE (INTERFACE) 'ptr Gio2.TIcon' 'ptr Gio2.TIcon' OUT optional
# arg size: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_image_get_gicon(self: ptr TImage, gicon: ptr Gio2.TIcon, size: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_image_get_gicon".}
proc get_gicon*(self: Image, gicon: ptr Gio2.TIcon, size: var int32) {.inline.} =
  gtk_image_get_gicon(self, gicon, addr(size))
# tuple-return
# gicon: ptr Gio2.TIcon
# size: var int32
# proc get_gicon*(self: Image) {.inline.} =

# gtk_image_get_icon_name
# flags: {isMethod} container: Image
# need sugar: is method
# arg icon_name: UTF8 'var ucstring' 'ptr ucstring' OUT (diff., need sugar) optional
# arg size: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_image_get_icon_name(self: ptr TImage, icon_name: ptr ucstring, size: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_image_get_icon_name".}
proc get_icon_name*(self: Image, icon_name: var ucstring, size: var int32) {.inline.} =
  gtk_image_get_icon_name(self, addr(icon_name), addr(size))
# tuple-return
# icon_name: var ucstring
# size: var int32
# proc get_icon_name*(self: Image) {.inline.} =

# gtk_image_get_icon_set
# flags: {isMethod} container: Image (deprecated)
# gtk_image_get_pixbuf
# flags: {isMethod} container: Image
# need sugar: is method
# return: INTERFACE 'GdkPixbuf2.Pixbuf' 'TransferNone[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_image_get_pixbuf(self: ptr TImage): TransferNone[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_image_get_pixbuf".}
proc get_pixbuf*(self: Image): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_image_get_pixbuf(self))
# proc get_pixbuf*(self: Image): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_image_get_pixel_size
# flags: {isMethod} container: Image
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_image_get_pixel_size(self: ptr TImage): int32 {.cdecl, dynlib: lib, importc: "gtk_image_get_pixel_size".}
proc get_pixel_size*(self: Image): int32 {.inline.} =
  gtk_image_get_pixel_size(self)
# proc get_pixel_size*(self: Image): int32 {.inline.} =

# gtk_image_get_stock
# flags: {isMethod} container: Image (deprecated)
# gtk_image_get_storage_type
# flags: {isMethod} container: Image
# need sugar: is method
# return: INTERFACE 'ImageType' 'ImageType'
proc gtk_image_get_storage_type(self: ptr TImage): ImageType {.cdecl, dynlib: lib, importc: "gtk_image_get_storage_type".}
proc get_storage_type*(self: Image): ImageType {.inline.} =
  gtk_image_get_storage_type(self)
# proc get_storage_type*(self: Image): ImageType {.inline.} =

# gtk_image_set_from_animation
# flags: {isMethod} container: Image
# need sugar: is method
# arg animation: INTERFACE (OBJECT) 'GdkPixbuf2.PixbufAnimation' 'ptr GdkPixbuf2.TPixbufAnimation' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_image_set_from_animation(self: ptr TImage, animation: ptr GdkPixbuf2.TPixbufAnimation) {.cdecl, dynlib: lib, importc: "gtk_image_set_from_animation".}
proc set_from_animation*(self: Image, animation: GdkPixbuf2.PixbufAnimation) {.inline.} =
  gtk_image_set_from_animation(self, animation.getPointer)
# proc set_from_animation*(self: Image, animation: GdkPixbuf2.PixbufAnimation) {.inline.} =

# gtk_image_set_from_file
# flags: {isMethod} container: Image
# need sugar: is method
# arg filename: FILENAME 'string' 'cstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_image_set_from_file(self: ptr TImage, filename: cstring) {.cdecl, dynlib: lib, importc: "gtk_image_set_from_file".}
proc set_from_file*(self: Image, filename: string) {.inline.} =
  gtk_image_set_from_file(self, cstring(filename))
# proc set_from_file*(self: Image, filename: string) {.inline.} =

# gtk_image_set_from_gicon
# flags: {isMethod} container: Image
# need sugar: is method
# arg icon: INTERFACE (INTERFACE) 'ptr Gio2.TIcon' 'ptr Gio2.TIcon' IN
# arg size: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_image_set_from_gicon(self: ptr TImage, icon: ptr Gio2.TIcon, size: int32) {.cdecl, dynlib: lib, importc: "gtk_image_set_from_gicon".}
proc set_from_gicon*(self: Image, icon: ptr Gio2.TIcon, size: int32) {.inline.} =
  gtk_image_set_from_gicon(self, icon, size)
# proc set_from_gicon*(self: Image, icon: ptr Gio2.TIcon, size: int32) {.inline.} =

# gtk_image_set_from_icon_name
# flags: {isMethod} container: Image
# need sugar: is method
# arg icon_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg size: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_image_set_from_icon_name(self: ptr TImage, icon_name: ucstring, size: int32) {.cdecl, dynlib: lib, importc: "gtk_image_set_from_icon_name".}
proc set_from_icon_name*(self: Image, icon_name: ustring, size: int32) {.inline.} =
  gtk_image_set_from_icon_name(self, ucstring(icon_name), size)
# proc set_from_icon_name*(self: Image, icon_name: ustring, size: int32) {.inline.} =

# gtk_image_set_from_icon_set
# flags: {isMethod} container: Image (deprecated)
# gtk_image_set_from_pixbuf
# flags: {isMethod} container: Image
# need sugar: is method
# arg pixbuf: INTERFACE (OBJECT) 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_image_set_from_pixbuf(self: ptr TImage, pixbuf: ptr GdkPixbuf2.TPixbuf) {.cdecl, dynlib: lib, importc: "gtk_image_set_from_pixbuf".}
proc set_from_pixbuf*(self: Image, pixbuf: GdkPixbuf2.Pixbuf) {.inline.} =
  gtk_image_set_from_pixbuf(self, pixbuf.getPointer)
# proc set_from_pixbuf*(self: Image, pixbuf: GdkPixbuf2.Pixbuf) {.inline.} =

# gtk_image_set_from_resource
# flags: {isMethod} container: Image
# need sugar: is method
# arg resource_path: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_image_set_from_resource(self: ptr TImage, resource_path: ucstring) {.cdecl, dynlib: lib, importc: "gtk_image_set_from_resource".}
proc set_from_resource*(self: Image, resource_path: ustring) {.inline.} =
  gtk_image_set_from_resource(self, ucstring(resource_path))
# proc set_from_resource*(self: Image, resource_path: ustring) {.inline.} =

# gtk_image_set_from_stock
# flags: {isMethod} container: Image (deprecated)
# gtk_image_set_from_surface
# flags: {isMethod} container: Image
# need sugar: is method
# arg surface: INTERFACE (STRUCT) 'ptr cairo1.TSurface' 'ptr cairo1.TSurface' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_image_set_from_surface(self: ptr TImage, surface: ptr cairo1.TSurface) {.cdecl, dynlib: lib, importc: "gtk_image_set_from_surface".}
proc set_from_surface*(self: Image, surface: ptr cairo1.TSurface) {.inline.} =
  gtk_image_set_from_surface(self, surface)
# proc set_from_surface*(self: Image, surface: ptr cairo1.TSurface) {.inline.} =

# gtk_image_set_pixel_size
# flags: {isMethod} container: Image
# need sugar: is method
# arg pixel_size: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_image_set_pixel_size(self: ptr TImage, pixel_size: int32) {.cdecl, dynlib: lib, importc: "gtk_image_set_pixel_size".}
proc set_pixel_size*(self: Image, pixel_size: int32) {.inline.} =
  gtk_image_set_pixel_size(self, pixel_size)
# proc set_pixel_size*(self: Image, pixel_size: int32) {.inline.} =

# initializer for ImageAccessible: gtk_image_accessible_get_type
proc gtk_image_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_image_accessible_get_type".}
template gtype*(klass_parameter: typedesc[ImageAccessible]): GType = gtk_image_accessible_get_type()
# initializer for ImageCellAccessible: gtk_image_cell_accessible_get_type
proc gtk_image_cell_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_image_cell_accessible_get_type".}
template gtype*(klass_parameter: typedesc[ImageCellAccessible]): GType = gtk_image_cell_accessible_get_type()
# initializer for ImageMenuItem: gtk_image_menu_item_get_type
proc gtk_image_menu_item_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_image_menu_item_get_type".}
template gtype*(klass_parameter: typedesc[ImageMenuItem]): GType = gtk_image_menu_item_get_type()
# gtk_image_menu_item_new
# flags: {isConstructor} container: ImageMenuItem (deprecated)
# gtk_image_menu_item_new_from_stock
# flags: {isConstructor} container: ImageMenuItem (deprecated)
# gtk_image_menu_item_new_with_label
# flags: {isConstructor} container: ImageMenuItem (deprecated)
# gtk_image_menu_item_new_with_mnemonic
# flags: {isConstructor} container: ImageMenuItem (deprecated)
# gtk_image_menu_item_get_always_show_image
# flags: {isMethod} container: ImageMenuItem (deprecated)
# gtk_image_menu_item_get_image
# flags: {isMethod} container: ImageMenuItem (deprecated)
# gtk_image_menu_item_get_use_stock
# flags: {isMethod} container: ImageMenuItem (deprecated)
# gtk_image_menu_item_set_accel_group
# flags: {isMethod} container: ImageMenuItem (deprecated)
# gtk_image_menu_item_set_always_show_image
# flags: {isMethod} container: ImageMenuItem (deprecated)
# gtk_image_menu_item_set_image
# flags: {isMethod} container: ImageMenuItem (deprecated)
# gtk_image_menu_item_set_use_stock
# flags: {isMethod} container: ImageMenuItem (deprecated)
# initializer for InfoBar: gtk_info_bar_get_type
proc gtk_info_bar_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_info_bar_get_type".}
template gtype*(klass_parameter: typedesc[InfoBar]): GType = gtk_info_bar_get_type()
# gtk_info_bar_new
# flags: {isConstructor} container: InfoBar
# need sugar: is static method
# return: INTERFACE 'InfoBar' 'TransferNone[TInfoBar]' (diff., need sugar)
proc gtk_info_bar_new(): TransferNone[TInfoBar] {.cdecl, dynlib: lib, importc: "gtk_info_bar_new".}
proc new_infobar*(): InfoBar {.inline.} =
  wrap(gtk_info_bar_new())
# proc new_infobar*(): InfoBar {.inline.} =

# gtk_info_bar_add_action_widget
# flags: {isMethod} container: InfoBar
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg response_id: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_info_bar_add_action_widget(self: ptr TInfoBar, child: ptr TWidget, response_id: int32) {.cdecl, dynlib: lib, importc: "gtk_info_bar_add_action_widget".}
proc add_action_widget*(self: InfoBar, child: Widget, response_id: int32) {.inline.} =
  gtk_info_bar_add_action_widget(self, child.getPointer, response_id)
# proc add_action_widget*(self: InfoBar, child: Widget, response_id: int32) {.inline.} =

# gtk_info_bar_add_button
# flags: {isMethod} container: InfoBar
# need sugar: is method
# arg button_text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg response_id: INT32 'int32' 'int32' IN
# return: INTERFACE 'Button' 'TransferNone[TButton]' (diff., need sugar)
proc gtk_info_bar_add_button(self: ptr TInfoBar, button_text: ucstring, response_id: int32): TransferNone[TButton] {.cdecl, dynlib: lib, importc: "gtk_info_bar_add_button".}
proc add_button*(self: InfoBar, button_text: ustring, response_id: int32): Button {.inline.} =
  wrap(gtk_info_bar_add_button(self, ucstring(button_text), response_id))
# proc add_button*(self: InfoBar, button_text: ustring, response_id: int32): Button {.inline.} =

# gtk_info_bar_get_action_area
# flags: {isMethod} container: InfoBar
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_info_bar_get_action_area(self: ptr TInfoBar): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_info_bar_get_action_area".}
proc get_action_area*(self: InfoBar): Widget {.inline.} =
  wrap(gtk_info_bar_get_action_area(self))
# proc get_action_area*(self: InfoBar): Widget {.inline.} =

# gtk_info_bar_get_content_area
# flags: {isMethod} container: InfoBar
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_info_bar_get_content_area(self: ptr TInfoBar): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_info_bar_get_content_area".}
proc get_content_area*(self: InfoBar): Widget {.inline.} =
  wrap(gtk_info_bar_get_content_area(self))
# proc get_content_area*(self: InfoBar): Widget {.inline.} =

# gtk_info_bar_get_message_type
# flags: {isMethod} container: InfoBar
# need sugar: is method
# return: INTERFACE 'MessageType' 'MessageType'
proc gtk_info_bar_get_message_type(self: ptr TInfoBar): MessageType {.cdecl, dynlib: lib, importc: "gtk_info_bar_get_message_type".}
proc get_message_type*(self: InfoBar): MessageType {.inline.} =
  gtk_info_bar_get_message_type(self)
# proc get_message_type*(self: InfoBar): MessageType {.inline.} =

# gtk_info_bar_get_show_close_button
# flags: {isMethod} container: InfoBar
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_info_bar_get_show_close_button(self: ptr TInfoBar): bool {.cdecl, dynlib: lib, importc: "gtk_info_bar_get_show_close_button".}
proc get_show_close_button*(self: InfoBar): bool {.inline.} =
  gtk_info_bar_get_show_close_button(self)
# proc get_show_close_button*(self: InfoBar): bool {.inline.} =

# gtk_info_bar_response
# flags: {isMethod} container: InfoBar
# need sugar: is method
# arg response_id: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_info_bar_response(self: ptr TInfoBar, response_id: int32) {.cdecl, dynlib: lib, importc: "gtk_info_bar_response".}
proc response*(self: InfoBar, response_id: int32) {.inline.} =
  gtk_info_bar_response(self, response_id)
# proc response*(self: InfoBar, response_id: int32) {.inline.} =

# gtk_info_bar_set_default_response
# flags: {isMethod} container: InfoBar
# need sugar: is method
# arg response_id: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_info_bar_set_default_response(self: ptr TInfoBar, response_id: int32) {.cdecl, dynlib: lib, importc: "gtk_info_bar_set_default_response".}
proc set_default_response*(self: InfoBar, response_id: int32) {.inline.} =
  gtk_info_bar_set_default_response(self, response_id)
# proc set_default_response*(self: InfoBar, response_id: int32) {.inline.} =

# gtk_info_bar_set_message_type
# flags: {isMethod} container: InfoBar
# need sugar: is method
# arg message_type: INTERFACE (ENUM) 'MessageType' 'MessageType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_info_bar_set_message_type(self: ptr TInfoBar, message_type: MessageType) {.cdecl, dynlib: lib, importc: "gtk_info_bar_set_message_type".}
proc set_message_type*(self: InfoBar, message_type: MessageType) {.inline.} =
  gtk_info_bar_set_message_type(self, message_type)
# proc set_message_type*(self: InfoBar, message_type: MessageType) {.inline.} =

# gtk_info_bar_set_response_sensitive
# flags: {isMethod} container: InfoBar
# need sugar: is method
# arg response_id: INT32 'int32' 'int32' IN
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_info_bar_set_response_sensitive(self: ptr TInfoBar, response_id: int32, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_info_bar_set_response_sensitive".}
proc set_response_sensitive*(self: InfoBar, response_id: int32, setting: bool) {.inline.} =
  gtk_info_bar_set_response_sensitive(self, response_id, setting)
# proc set_response_sensitive*(self: InfoBar, response_id: int32, setting: bool) {.inline.} =

# gtk_info_bar_set_show_close_button
# flags: {isMethod} container: InfoBar
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_info_bar_set_show_close_button(self: ptr TInfoBar, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_info_bar_set_show_close_button".}
proc set_show_close_button*(self: InfoBar, setting: bool) {.inline.} =
  gtk_info_bar_set_show_close_button(self, setting)
# proc set_show_close_button*(self: InfoBar, setting: bool) {.inline.} =

# initializer for Invisible: gtk_invisible_get_type
proc gtk_invisible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_invisible_get_type".}
template gtype*(klass_parameter: typedesc[Invisible]): GType = gtk_invisible_get_type()
# gtk_invisible_new
# flags: {isConstructor} container: Invisible
# need sugar: is static method
# return: INTERFACE 'Invisible' 'TransferNone[TInvisible]' (diff., need sugar)
proc gtk_invisible_new(): TransferNone[TInvisible] {.cdecl, dynlib: lib, importc: "gtk_invisible_new".}
proc new_invisible*(): Invisible {.inline.} =
  wrap(gtk_invisible_new())
# proc new_invisible*(): Invisible {.inline.} =

# gtk_invisible_new_for_screen
# flags: {isConstructor} container: Invisible
# need sugar: is static method
# arg screen: INTERFACE (OBJECT) 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# return: INTERFACE 'Invisible' 'TransferNone[TInvisible]' (diff., need sugar)
proc gtk_invisible_new_for_screen(screen: ptr Gdk3.TScreen): TransferNone[TInvisible] {.cdecl, dynlib: lib, importc: "gtk_invisible_new_for_screen".}
proc new_invisible_for_screen*(screen: Gdk3.Screen): Invisible {.inline.} =
  wrap(gtk_invisible_new_for_screen(screen.getPointer))
# proc new_invisible_for_screen*(screen: Gdk3.Screen): Invisible {.inline.} =

# gtk_invisible_get_screen
# flags: {isMethod} container: Invisible
# need sugar: is method
# return: INTERFACE 'Gdk3.Screen' 'TransferNone[Gdk3.TScreen]' (diff., need sugar)
proc gtk_invisible_get_screen(self: ptr TInvisible): TransferNone[Gdk3.TScreen] {.cdecl, dynlib: lib, importc: "gtk_invisible_get_screen".}
proc get_screen*(self: Invisible): Gdk3.Screen {.inline.} =
  wrap(gtk_invisible_get_screen(self))
# proc get_screen*(self: Invisible): Gdk3.Screen {.inline.} =

# gtk_invisible_set_screen
# flags: {isMethod} container: Invisible
# need sugar: is method
# arg screen: INTERFACE (OBJECT) 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_invisible_set_screen(self: ptr TInvisible, screen: ptr Gdk3.TScreen) {.cdecl, dynlib: lib, importc: "gtk_invisible_set_screen".}
proc set_screen*(self: Invisible, screen: Gdk3.Screen) {.inline.} =
  gtk_invisible_set_screen(self, screen.getPointer)
# proc set_screen*(self: Invisible, screen: Gdk3.Screen) {.inline.} =

# initializer for Label: gtk_label_get_type
proc gtk_label_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_label_get_type".}
template gtype*(klass_parameter: typedesc[Label]): GType = gtk_label_get_type()
# gtk_label_new
# flags: {isConstructor} container: Label
# need sugar: is static method
# arg str: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'Label' 'TransferNone[TLabel]' (diff., need sugar)
proc gtk_label_new(str: ucstring): TransferNone[TLabel] {.cdecl, dynlib: lib, importc: "gtk_label_new".}
proc new_label*(str: ustring): Label {.inline.} =
  wrap(gtk_label_new(ucstring(str)))
# proc new_label*(str: ustring): Label {.inline.} =

# gtk_label_new_with_mnemonic
# flags: {isConstructor} container: Label
# need sugar: is static method
# arg str: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'Label' 'TransferNone[TLabel]' (diff., need sugar)
proc gtk_label_new_with_mnemonic(str: ucstring): TransferNone[TLabel] {.cdecl, dynlib: lib, importc: "gtk_label_new_with_mnemonic".}
proc new_label_with_mnemonic*(str: ustring): Label {.inline.} =
  wrap(gtk_label_new_with_mnemonic(ucstring(str)))
# proc new_label_with_mnemonic*(str: ustring): Label {.inline.} =

# gtk_label_get_angle
# flags: {isMethod} container: Label
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_label_get_angle(self: ptr TLabel): float64 {.cdecl, dynlib: lib, importc: "gtk_label_get_angle".}
proc get_angle*(self: Label): float64 {.inline.} =
  gtk_label_get_angle(self)
# proc get_angle*(self: Label): float64 {.inline.} =

# gtk_label_get_attributes
# flags: {isMethod} container: Label
# need sugar: is method
# return: INTERFACE 'ptr Pango1.TAttrList' 'ptr Pango1.TAttrList'
proc gtk_label_get_attributes(self: ptr TLabel): ptr Pango1.TAttrList {.cdecl, dynlib: lib, importc: "gtk_label_get_attributes".}
proc get_attributes*(self: Label): ptr Pango1.TAttrList {.inline.} =
  gtk_label_get_attributes(self)
# proc get_attributes*(self: Label): ptr Pango1.TAttrList {.inline.} =

# gtk_label_get_current_uri
# flags: {isMethod} container: Label
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_label_get_current_uri(self: ptr TLabel): ucstring {.cdecl, dynlib: lib, importc: "gtk_label_get_current_uri".}
proc get_current_uri*(self: Label): ucstring {.inline.} =
  gtk_label_get_current_uri(self)
# proc get_current_uri*(self: Label): ucstring {.inline.} =

# gtk_label_get_ellipsize
# flags: {isMethod} container: Label
# need sugar: is method
# return: INTERFACE 'Pango1.EllipsizeMode' 'Pango1.EllipsizeMode'
proc gtk_label_get_ellipsize(self: ptr TLabel): Pango1.EllipsizeMode {.cdecl, dynlib: lib, importc: "gtk_label_get_ellipsize".}
proc get_ellipsize*(self: Label): Pango1.EllipsizeMode {.inline.} =
  gtk_label_get_ellipsize(self)
# proc get_ellipsize*(self: Label): Pango1.EllipsizeMode {.inline.} =

# gtk_label_get_justify
# flags: {isMethod} container: Label
# need sugar: is method
# return: INTERFACE 'Justification' 'Justification'
proc gtk_label_get_justify(self: ptr TLabel): Justification {.cdecl, dynlib: lib, importc: "gtk_label_get_justify".}
proc get_justify*(self: Label): Justification {.inline.} =
  gtk_label_get_justify(self)
# proc get_justify*(self: Label): Justification {.inline.} =

# gtk_label_get_label
# flags: {isMethod} container: Label
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_label_get_label(self: ptr TLabel): ucstring {.cdecl, dynlib: lib, importc: "gtk_label_get_label".}
proc get_label*(self: Label): ucstring {.inline.} =
  gtk_label_get_label(self)
# proc get_label*(self: Label): ucstring {.inline.} =

# gtk_label_get_layout
# flags: {isMethod} container: Label
# need sugar: is method
# return: INTERFACE 'Pango1.Layout' 'TransferNone[Pango1.TLayout]' (diff., need sugar)
proc gtk_label_get_layout(self: ptr TLabel): TransferNone[Pango1.TLayout] {.cdecl, dynlib: lib, importc: "gtk_label_get_layout".}
proc get_layout*(self: Label): Pango1.Layout {.inline.} =
  wrap(gtk_label_get_layout(self))
# proc get_layout*(self: Label): Pango1.Layout {.inline.} =

# gtk_label_get_layout_offsets
# flags: {isMethod} container: Label
# need sugar: is method
# arg x: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg y: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_label_get_layout_offsets(self: ptr TLabel, x: ptr int32, y: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_label_get_layout_offsets".}
proc get_layout_offsets*(self: Label, x: var int32, y: var int32) {.inline.} =
  gtk_label_get_layout_offsets(self, addr(x), addr(y))
# tuple-return
# x: var int32
# y: var int32
# proc get_layout_offsets*(self: Label) {.inline.} =

# gtk_label_get_line_wrap
# flags: {isMethod} container: Label
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_label_get_line_wrap(self: ptr TLabel): bool {.cdecl, dynlib: lib, importc: "gtk_label_get_line_wrap".}
proc get_line_wrap*(self: Label): bool {.inline.} =
  gtk_label_get_line_wrap(self)
# proc get_line_wrap*(self: Label): bool {.inline.} =

# gtk_label_get_line_wrap_mode
# flags: {isMethod} container: Label
# need sugar: is method
# return: INTERFACE 'Pango1.WrapMode' 'Pango1.WrapMode'
proc gtk_label_get_line_wrap_mode(self: ptr TLabel): Pango1.WrapMode {.cdecl, dynlib: lib, importc: "gtk_label_get_line_wrap_mode".}
proc get_line_wrap_mode*(self: Label): Pango1.WrapMode {.inline.} =
  gtk_label_get_line_wrap_mode(self)
# proc get_line_wrap_mode*(self: Label): Pango1.WrapMode {.inline.} =

# gtk_label_get_lines
# flags: {isMethod} container: Label
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_label_get_lines(self: ptr TLabel): int32 {.cdecl, dynlib: lib, importc: "gtk_label_get_lines".}
proc get_lines*(self: Label): int32 {.inline.} =
  gtk_label_get_lines(self)
# proc get_lines*(self: Label): int32 {.inline.} =

# gtk_label_get_max_width_chars
# flags: {isMethod} container: Label
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_label_get_max_width_chars(self: ptr TLabel): int32 {.cdecl, dynlib: lib, importc: "gtk_label_get_max_width_chars".}
proc get_max_width_chars*(self: Label): int32 {.inline.} =
  gtk_label_get_max_width_chars(self)
# proc get_max_width_chars*(self: Label): int32 {.inline.} =

# gtk_label_get_mnemonic_keyval
# flags: {isMethod} container: Label
# need sugar: is method
# return: UINT32 'uint32' 'uint32'
proc gtk_label_get_mnemonic_keyval(self: ptr TLabel): uint32 {.cdecl, dynlib: lib, importc: "gtk_label_get_mnemonic_keyval".}
proc get_mnemonic_keyval*(self: Label): uint32 {.inline.} =
  gtk_label_get_mnemonic_keyval(self)
# proc get_mnemonic_keyval*(self: Label): uint32 {.inline.} =

# gtk_label_get_mnemonic_widget
# flags: {isMethod} container: Label
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_label_get_mnemonic_widget(self: ptr TLabel): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_label_get_mnemonic_widget".}
proc get_mnemonic_widget*(self: Label): Widget {.inline.} =
  wrap(gtk_label_get_mnemonic_widget(self))
# proc get_mnemonic_widget*(self: Label): Widget {.inline.} =

# gtk_label_get_selectable
# flags: {isMethod} container: Label
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_label_get_selectable(self: ptr TLabel): bool {.cdecl, dynlib: lib, importc: "gtk_label_get_selectable".}
proc get_selectable*(self: Label): bool {.inline.} =
  gtk_label_get_selectable(self)
# proc get_selectable*(self: Label): bool {.inline.} =

# gtk_label_get_selection_bounds
# flags: {isMethod} container: Label
# need sugar: is method
# arg start: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# arg end: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_label_get_selection_bounds(self: ptr TLabel, start: ptr int32, end_x: ptr int32): bool {.cdecl, dynlib: lib, importc: "gtk_label_get_selection_bounds".}
proc get_selection_bounds*(self: Label, start: var int32, end_x: var int32): bool {.inline.} =
  gtk_label_get_selection_bounds(self, addr(start), addr(end_x))
# tuple-return
# start: var int32
# end: var int32
# proc get_selection_bounds*(self: Label): bool {.inline.} =

# gtk_label_get_single_line_mode
# flags: {isMethod} container: Label
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_label_get_single_line_mode(self: ptr TLabel): bool {.cdecl, dynlib: lib, importc: "gtk_label_get_single_line_mode".}
proc get_single_line_mode*(self: Label): bool {.inline.} =
  gtk_label_get_single_line_mode(self)
# proc get_single_line_mode*(self: Label): bool {.inline.} =

# gtk_label_get_text
# flags: {isMethod} container: Label
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_label_get_text(self: ptr TLabel): ucstring {.cdecl, dynlib: lib, importc: "gtk_label_get_text".}
proc get_text*(self: Label): ucstring {.inline.} =
  gtk_label_get_text(self)
# proc get_text*(self: Label): ucstring {.inline.} =

# gtk_label_get_track_visited_links
# flags: {isMethod} container: Label
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_label_get_track_visited_links(self: ptr TLabel): bool {.cdecl, dynlib: lib, importc: "gtk_label_get_track_visited_links".}
proc get_track_visited_links*(self: Label): bool {.inline.} =
  gtk_label_get_track_visited_links(self)
# proc get_track_visited_links*(self: Label): bool {.inline.} =

# gtk_label_get_use_markup
# flags: {isMethod} container: Label
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_label_get_use_markup(self: ptr TLabel): bool {.cdecl, dynlib: lib, importc: "gtk_label_get_use_markup".}
proc get_use_markup*(self: Label): bool {.inline.} =
  gtk_label_get_use_markup(self)
# proc get_use_markup*(self: Label): bool {.inline.} =

# gtk_label_get_use_underline
# flags: {isMethod} container: Label
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_label_get_use_underline(self: ptr TLabel): bool {.cdecl, dynlib: lib, importc: "gtk_label_get_use_underline".}
proc get_use_underline*(self: Label): bool {.inline.} =
  gtk_label_get_use_underline(self)
# proc get_use_underline*(self: Label): bool {.inline.} =

# gtk_label_get_width_chars
# flags: {isMethod} container: Label
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_label_get_width_chars(self: ptr TLabel): int32 {.cdecl, dynlib: lib, importc: "gtk_label_get_width_chars".}
proc get_width_chars*(self: Label): int32 {.inline.} =
  gtk_label_get_width_chars(self)
# proc get_width_chars*(self: Label): int32 {.inline.} =

# gtk_label_get_xalign
# flags: {isMethod} container: Label
# need sugar: is method
# return: FLOAT 'float32' 'float32'
proc gtk_label_get_xalign(self: ptr TLabel): float32 {.cdecl, dynlib: lib, importc: "gtk_label_get_xalign".}
proc get_xalign*(self: Label): float32 {.inline.} =
  gtk_label_get_xalign(self)
# proc get_xalign*(self: Label): float32 {.inline.} =

# gtk_label_get_yalign
# flags: {isMethod} container: Label
# need sugar: is method
# return: FLOAT 'float32' 'float32'
proc gtk_label_get_yalign(self: ptr TLabel): float32 {.cdecl, dynlib: lib, importc: "gtk_label_get_yalign".}
proc get_yalign*(self: Label): float32 {.inline.} =
  gtk_label_get_yalign(self)
# proc get_yalign*(self: Label): float32 {.inline.} =

# gtk_label_select_region
# flags: {isMethod} container: Label
# need sugar: is method
# arg start_offset: INT32 'int32' 'int32' IN
# arg end_offset: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_label_select_region(self: ptr TLabel, start_offset: int32, end_offset: int32) {.cdecl, dynlib: lib, importc: "gtk_label_select_region".}
proc select_region*(self: Label, start_offset: int32, end_offset: int32) {.inline.} =
  gtk_label_select_region(self, start_offset, end_offset)
# proc select_region*(self: Label, start_offset: int32, end_offset: int32) {.inline.} =

# gtk_label_set_angle
# flags: {isMethod} container: Label
# need sugar: is method
# arg angle: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_angle(self: ptr TLabel, angle: float64) {.cdecl, dynlib: lib, importc: "gtk_label_set_angle".}
proc set_angle*(self: Label, angle: float64) {.inline.} =
  gtk_label_set_angle(self, angle)
# proc set_angle*(self: Label, angle: float64) {.inline.} =

# gtk_label_set_attributes
# flags: {isMethod} container: Label
# need sugar: is method
# arg attrs: INTERFACE (STRUCT) 'ptr Pango1.TAttrList' 'ptr Pango1.TAttrList' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_attributes(self: ptr TLabel, attrs: ptr Pango1.TAttrList) {.cdecl, dynlib: lib, importc: "gtk_label_set_attributes".}
proc set_attributes*(self: Label, attrs: ptr Pango1.TAttrList) {.inline.} =
  gtk_label_set_attributes(self, attrs)
# proc set_attributes*(self: Label, attrs: ptr Pango1.TAttrList) {.inline.} =

# gtk_label_set_ellipsize
# flags: {isMethod} container: Label
# need sugar: is method
# arg mode: INTERFACE (ENUM) 'Pango1.EllipsizeMode' 'Pango1.EllipsizeMode' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_ellipsize(self: ptr TLabel, mode: Pango1.EllipsizeMode) {.cdecl, dynlib: lib, importc: "gtk_label_set_ellipsize".}
proc set_ellipsize*(self: Label, mode: Pango1.EllipsizeMode) {.inline.} =
  gtk_label_set_ellipsize(self, mode)
# proc set_ellipsize*(self: Label, mode: Pango1.EllipsizeMode) {.inline.} =

# gtk_label_set_justify
# flags: {isMethod} container: Label
# need sugar: is method
# arg jtype: INTERFACE (ENUM) 'Justification' 'Justification' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_justify(self: ptr TLabel, jtype: Justification) {.cdecl, dynlib: lib, importc: "gtk_label_set_justify".}
proc set_justify*(self: Label, jtype: Justification) {.inline.} =
  gtk_label_set_justify(self, jtype)
# proc set_justify*(self: Label, jtype: Justification) {.inline.} =

# gtk_label_set_label
# flags: {isMethod} container: Label
# need sugar: is method
# arg str: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_label(self: ptr TLabel, str: ucstring) {.cdecl, dynlib: lib, importc: "gtk_label_set_label".}
proc set_label*(self: Label, str: ustring) {.inline.} =
  gtk_label_set_label(self, ucstring(str))
# proc set_label*(self: Label, str: ustring) {.inline.} =

# gtk_label_set_line_wrap
# flags: {isMethod} container: Label
# need sugar: is method
# arg wrap: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_line_wrap(self: ptr TLabel, wrap: bool) {.cdecl, dynlib: lib, importc: "gtk_label_set_line_wrap".}
proc set_line_wrap*(self: Label, wrap: bool) {.inline.} =
  gtk_label_set_line_wrap(self, wrap)
# proc set_line_wrap*(self: Label, wrap: bool) {.inline.} =

# gtk_label_set_line_wrap_mode
# flags: {isMethod} container: Label
# need sugar: is method
# arg wrap_mode: INTERFACE (ENUM) 'Pango1.WrapMode' 'Pango1.WrapMode' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_line_wrap_mode(self: ptr TLabel, wrap_mode: Pango1.WrapMode) {.cdecl, dynlib: lib, importc: "gtk_label_set_line_wrap_mode".}
proc set_line_wrap_mode*(self: Label, wrap_mode: Pango1.WrapMode) {.inline.} =
  gtk_label_set_line_wrap_mode(self, wrap_mode)
# proc set_line_wrap_mode*(self: Label, wrap_mode: Pango1.WrapMode) {.inline.} =

# gtk_label_set_lines
# flags: {isMethod} container: Label
# need sugar: is method
# arg lines: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_lines(self: ptr TLabel, lines: int32) {.cdecl, dynlib: lib, importc: "gtk_label_set_lines".}
proc set_lines*(self: Label, lines: int32) {.inline.} =
  gtk_label_set_lines(self, lines)
# proc set_lines*(self: Label, lines: int32) {.inline.} =

# gtk_label_set_markup
# flags: {isMethod} container: Label
# need sugar: is method
# arg str: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_markup(self: ptr TLabel, str: ucstring) {.cdecl, dynlib: lib, importc: "gtk_label_set_markup".}
proc set_markup*(self: Label, str: ustring) {.inline.} =
  gtk_label_set_markup(self, ucstring(str))
# proc set_markup*(self: Label, str: ustring) {.inline.} =

# gtk_label_set_markup_with_mnemonic
# flags: {isMethod} container: Label
# need sugar: is method
# arg str: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_markup_with_mnemonic(self: ptr TLabel, str: ucstring) {.cdecl, dynlib: lib, importc: "gtk_label_set_markup_with_mnemonic".}
proc set_markup_with_mnemonic*(self: Label, str: ustring) {.inline.} =
  gtk_label_set_markup_with_mnemonic(self, ucstring(str))
# proc set_markup_with_mnemonic*(self: Label, str: ustring) {.inline.} =

# gtk_label_set_max_width_chars
# flags: {isMethod} container: Label
# need sugar: is method
# arg n_chars: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_max_width_chars(self: ptr TLabel, n_chars: int32) {.cdecl, dynlib: lib, importc: "gtk_label_set_max_width_chars".}
proc set_max_width_chars*(self: Label, n_chars: int32) {.inline.} =
  gtk_label_set_max_width_chars(self, n_chars)
# proc set_max_width_chars*(self: Label, n_chars: int32) {.inline.} =

# gtk_label_set_mnemonic_widget
# flags: {isMethod} container: Label
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_mnemonic_widget(self: ptr TLabel, widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_label_set_mnemonic_widget".}
proc set_mnemonic_widget*(self: Label, widget: Widget) {.inline.} =
  gtk_label_set_mnemonic_widget(self, widget.getPointer)
# proc set_mnemonic_widget*(self: Label, widget: Widget) {.inline.} =

# gtk_label_set_pattern
# flags: {isMethod} container: Label
# need sugar: is method
# arg pattern: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_pattern(self: ptr TLabel, pattern: ucstring) {.cdecl, dynlib: lib, importc: "gtk_label_set_pattern".}
proc set_pattern*(self: Label, pattern: ustring) {.inline.} =
  gtk_label_set_pattern(self, ucstring(pattern))
# proc set_pattern*(self: Label, pattern: ustring) {.inline.} =

# gtk_label_set_selectable
# flags: {isMethod} container: Label
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_selectable(self: ptr TLabel, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_label_set_selectable".}
proc set_selectable*(self: Label, setting: bool) {.inline.} =
  gtk_label_set_selectable(self, setting)
# proc set_selectable*(self: Label, setting: bool) {.inline.} =

# gtk_label_set_single_line_mode
# flags: {isMethod} container: Label
# need sugar: is method
# arg single_line_mode: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_single_line_mode(self: ptr TLabel, single_line_mode: bool) {.cdecl, dynlib: lib, importc: "gtk_label_set_single_line_mode".}
proc set_single_line_mode*(self: Label, single_line_mode: bool) {.inline.} =
  gtk_label_set_single_line_mode(self, single_line_mode)
# proc set_single_line_mode*(self: Label, single_line_mode: bool) {.inline.} =

# gtk_label_set_text
# flags: {isMethod} container: Label
# need sugar: is method
# arg str: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_text(self: ptr TLabel, str: ucstring) {.cdecl, dynlib: lib, importc: "gtk_label_set_text".}
proc set_text*(self: Label, str: ustring) {.inline.} =
  gtk_label_set_text(self, ucstring(str))
# proc set_text*(self: Label, str: ustring) {.inline.} =

# gtk_label_set_text_with_mnemonic
# flags: {isMethod} container: Label
# need sugar: is method
# arg str: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_text_with_mnemonic(self: ptr TLabel, str: ucstring) {.cdecl, dynlib: lib, importc: "gtk_label_set_text_with_mnemonic".}
proc set_text_with_mnemonic*(self: Label, str: ustring) {.inline.} =
  gtk_label_set_text_with_mnemonic(self, ucstring(str))
# proc set_text_with_mnemonic*(self: Label, str: ustring) {.inline.} =

# gtk_label_set_track_visited_links
# flags: {isMethod} container: Label
# need sugar: is method
# arg track_links: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_track_visited_links(self: ptr TLabel, track_links: bool) {.cdecl, dynlib: lib, importc: "gtk_label_set_track_visited_links".}
proc set_track_visited_links*(self: Label, track_links: bool) {.inline.} =
  gtk_label_set_track_visited_links(self, track_links)
# proc set_track_visited_links*(self: Label, track_links: bool) {.inline.} =

# gtk_label_set_use_markup
# flags: {isMethod} container: Label
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_use_markup(self: ptr TLabel, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_label_set_use_markup".}
proc set_use_markup*(self: Label, setting: bool) {.inline.} =
  gtk_label_set_use_markup(self, setting)
# proc set_use_markup*(self: Label, setting: bool) {.inline.} =

# gtk_label_set_use_underline
# flags: {isMethod} container: Label
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_use_underline(self: ptr TLabel, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_label_set_use_underline".}
proc set_use_underline*(self: Label, setting: bool) {.inline.} =
  gtk_label_set_use_underline(self, setting)
# proc set_use_underline*(self: Label, setting: bool) {.inline.} =

# gtk_label_set_width_chars
# flags: {isMethod} container: Label
# need sugar: is method
# arg n_chars: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_width_chars(self: ptr TLabel, n_chars: int32) {.cdecl, dynlib: lib, importc: "gtk_label_set_width_chars".}
proc set_width_chars*(self: Label, n_chars: int32) {.inline.} =
  gtk_label_set_width_chars(self, n_chars)
# proc set_width_chars*(self: Label, n_chars: int32) {.inline.} =

# gtk_label_set_xalign
# flags: {isMethod} container: Label
# need sugar: is method
# arg xalign: FLOAT 'float32' 'float32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_xalign(self: ptr TLabel, xalign: float32) {.cdecl, dynlib: lib, importc: "gtk_label_set_xalign".}
proc set_xalign*(self: Label, xalign: float32) {.inline.} =
  gtk_label_set_xalign(self, xalign)
# proc set_xalign*(self: Label, xalign: float32) {.inline.} =

# gtk_label_set_yalign
# flags: {isMethod} container: Label
# need sugar: is method
# arg yalign: FLOAT 'float32' 'float32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_label_set_yalign(self: ptr TLabel, yalign: float32) {.cdecl, dynlib: lib, importc: "gtk_label_set_yalign".}
proc set_yalign*(self: Label, yalign: float32) {.inline.} =
  gtk_label_set_yalign(self, yalign)
# proc set_yalign*(self: Label, yalign: float32) {.inline.} =

# initializer for LabelAccessible: gtk_label_accessible_get_type
proc gtk_label_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_label_accessible_get_type".}
template gtype*(klass_parameter: typedesc[LabelAccessible]): GType = gtk_label_accessible_get_type()
# initializer for Layout: gtk_layout_get_type
proc gtk_layout_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_layout_get_type".}
template gtype*(klass_parameter: typedesc[Layout]): GType = gtk_layout_get_type()
# gtk_layout_new
# flags: {isConstructor} container: Layout
# need sugar: is static method
# arg hadjustment: INTERFACE (OBJECT) 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# arg vadjustment: INTERFACE (OBJECT) 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# return: INTERFACE 'Layout' 'TransferNone[TLayout]' (diff., need sugar)
proc gtk_layout_new(hadjustment: ptr TAdjustment, vadjustment: ptr TAdjustment): TransferNone[TLayout] {.cdecl, dynlib: lib, importc: "gtk_layout_new".}
proc new_layout*(hadjustment: Adjustment, vadjustment: Adjustment): Layout {.inline.} =
  wrap(gtk_layout_new(hadjustment.getPointer, vadjustment.getPointer))
# proc new_layout*(hadjustment: Adjustment, vadjustment: Adjustment): Layout {.inline.} =

# gtk_layout_get_bin_window
# flags: {isMethod} container: Layout
# need sugar: is method
# return: INTERFACE 'Gdk3.Window' 'TransferNone[Gdk3.TWindow]' (diff., need sugar)
proc gtk_layout_get_bin_window(self: ptr TLayout): TransferNone[Gdk3.TWindow] {.cdecl, dynlib: lib, importc: "gtk_layout_get_bin_window".}
proc get_bin_window*(self: Layout): Gdk3.Window {.inline.} =
  wrap(gtk_layout_get_bin_window(self))
# proc get_bin_window*(self: Layout): Gdk3.Window {.inline.} =

# gtk_layout_get_hadjustment
# flags: {isMethod} container: Layout (deprecated)
# gtk_layout_get_size
# flags: {isMethod} container: Layout
# need sugar: is method
# arg width: UINT32 'var uint32' 'ptr uint32' OUT (diff., need sugar) optional
# arg height: UINT32 'var uint32' 'ptr uint32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_layout_get_size(self: ptr TLayout, width: ptr uint32, height: ptr uint32) {.cdecl, dynlib: lib, importc: "gtk_layout_get_size".}
proc get_size*(self: Layout, width: var uint32, height: var uint32) {.inline.} =
  gtk_layout_get_size(self, addr(width), addr(height))
# tuple-return
# width: var uint32
# height: var uint32
# proc get_size*(self: Layout) {.inline.} =

# gtk_layout_get_vadjustment
# flags: {isMethod} container: Layout (deprecated)
# gtk_layout_move
# flags: {isMethod} container: Layout
# need sugar: is method
# arg child_widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg x: INT32 'int32' 'int32' IN
# arg y: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_layout_move(self: ptr TLayout, child_widget: ptr TWidget, x: int32, y: int32) {.cdecl, dynlib: lib, importc: "gtk_layout_move".}
proc move*(self: Layout, child_widget: Widget, x: int32, y: int32) {.inline.} =
  gtk_layout_move(self, child_widget.getPointer, x, y)
# proc move*(self: Layout, child_widget: Widget, x: int32, y: int32) {.inline.} =

# gtk_layout_put
# flags: {isMethod} container: Layout
# need sugar: is method
# arg child_widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg x: INT32 'int32' 'int32' IN
# arg y: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_layout_put(self: ptr TLayout, child_widget: ptr TWidget, x: int32, y: int32) {.cdecl, dynlib: lib, importc: "gtk_layout_put".}
proc put*(self: Layout, child_widget: Widget, x: int32, y: int32) {.inline.} =
  gtk_layout_put(self, child_widget.getPointer, x, y)
# proc put*(self: Layout, child_widget: Widget, x: int32, y: int32) {.inline.} =

# gtk_layout_set_hadjustment
# flags: {isMethod} container: Layout (deprecated)
# gtk_layout_set_size
# flags: {isMethod} container: Layout
# need sugar: is method
# arg width: UINT32 'uint32' 'uint32' IN
# arg height: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_layout_set_size(self: ptr TLayout, width: uint32, height: uint32) {.cdecl, dynlib: lib, importc: "gtk_layout_set_size".}
proc set_size*(self: Layout, width: uint32, height: uint32) {.inline.} =
  gtk_layout_set_size(self, width, height)
# proc set_size*(self: Layout, width: uint32, height: uint32) {.inline.} =

# gtk_layout_set_vadjustment
# flags: {isMethod} container: Layout (deprecated)
# initializer for LevelBar: gtk_level_bar_get_type
proc gtk_level_bar_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_level_bar_get_type".}
template gtype*(klass_parameter: typedesc[LevelBar]): GType = gtk_level_bar_get_type()
# gtk_level_bar_new
# flags: {isConstructor} container: LevelBar
# need sugar: is static method
# return: INTERFACE 'LevelBar' 'TransferNone[TLevelBar]' (diff., need sugar)
proc gtk_level_bar_new(): TransferNone[TLevelBar] {.cdecl, dynlib: lib, importc: "gtk_level_bar_new".}
proc new_levelbar*(): LevelBar {.inline.} =
  wrap(gtk_level_bar_new())
# proc new_levelbar*(): LevelBar {.inline.} =

# gtk_level_bar_new_for_interval
# flags: {isConstructor} container: LevelBar
# need sugar: is static method
# arg min_value: DOUBLE 'float64' 'float64' IN
# arg max_value: DOUBLE 'float64' 'float64' IN
# return: INTERFACE 'LevelBar' 'TransferNone[TLevelBar]' (diff., need sugar)
proc gtk_level_bar_new_for_interval(min_value: float64, max_value: float64): TransferNone[TLevelBar] {.cdecl, dynlib: lib, importc: "gtk_level_bar_new_for_interval".}
proc new_levelbar_for_interval*(min_value: float64, max_value: float64): LevelBar {.inline.} =
  wrap(gtk_level_bar_new_for_interval(min_value, max_value))
# proc new_levelbar_for_interval*(min_value: float64, max_value: float64): LevelBar {.inline.} =

# gtk_level_bar_add_offset_value
# flags: {isMethod} container: LevelBar
# need sugar: is method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg value: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_level_bar_add_offset_value(self: ptr TLevelBar, name: ucstring, value: float64) {.cdecl, dynlib: lib, importc: "gtk_level_bar_add_offset_value".}
proc add_offset_value*(self: LevelBar, name: ustring, value: float64) {.inline.} =
  gtk_level_bar_add_offset_value(self, ucstring(name), value)
# proc add_offset_value*(self: LevelBar, name: ustring, value: float64) {.inline.} =

# gtk_level_bar_get_inverted
# flags: {isMethod} container: LevelBar
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_level_bar_get_inverted(self: ptr TLevelBar): bool {.cdecl, dynlib: lib, importc: "gtk_level_bar_get_inverted".}
proc get_inverted*(self: LevelBar): bool {.inline.} =
  gtk_level_bar_get_inverted(self)
# proc get_inverted*(self: LevelBar): bool {.inline.} =

# gtk_level_bar_get_max_value
# flags: {isMethod} container: LevelBar
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_level_bar_get_max_value(self: ptr TLevelBar): float64 {.cdecl, dynlib: lib, importc: "gtk_level_bar_get_max_value".}
proc get_max_value*(self: LevelBar): float64 {.inline.} =
  gtk_level_bar_get_max_value(self)
# proc get_max_value*(self: LevelBar): float64 {.inline.} =

# gtk_level_bar_get_min_value
# flags: {isMethod} container: LevelBar
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_level_bar_get_min_value(self: ptr TLevelBar): float64 {.cdecl, dynlib: lib, importc: "gtk_level_bar_get_min_value".}
proc get_min_value*(self: LevelBar): float64 {.inline.} =
  gtk_level_bar_get_min_value(self)
# proc get_min_value*(self: LevelBar): float64 {.inline.} =

# gtk_level_bar_get_mode
# flags: {isMethod} container: LevelBar
# need sugar: is method
# return: INTERFACE 'LevelBarMode' 'LevelBarMode'
proc gtk_level_bar_get_mode(self: ptr TLevelBar): LevelBarMode {.cdecl, dynlib: lib, importc: "gtk_level_bar_get_mode".}
proc get_mode*(self: LevelBar): LevelBarMode {.inline.} =
  gtk_level_bar_get_mode(self)
# proc get_mode*(self: LevelBar): LevelBarMode {.inline.} =

# gtk_level_bar_get_offset_value
# flags: {isMethod} container: LevelBar
# need sugar: is method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg value: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_level_bar_get_offset_value(self: ptr TLevelBar, name: ucstring, value: ptr float64): bool {.cdecl, dynlib: lib, importc: "gtk_level_bar_get_offset_value".}
proc get_offset_value*(self: LevelBar, name: ustring, value: var float64): bool {.inline.} =
  gtk_level_bar_get_offset_value(self, ucstring(name), addr(value))
# tuple-return
# value: var float64
# proc get_offset_value*(self: LevelBar, name: ustring): bool {.inline.} =

# gtk_level_bar_get_value
# flags: {isMethod} container: LevelBar
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_level_bar_get_value(self: ptr TLevelBar): float64 {.cdecl, dynlib: lib, importc: "gtk_level_bar_get_value".}
proc get_value*(self: LevelBar): float64 {.inline.} =
  gtk_level_bar_get_value(self)
# proc get_value*(self: LevelBar): float64 {.inline.} =

# gtk_level_bar_remove_offset_value
# flags: {isMethod} container: LevelBar
# need sugar: is method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_level_bar_remove_offset_value(self: ptr TLevelBar, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_level_bar_remove_offset_value".}
proc remove_offset_value*(self: LevelBar, name: ustring) {.inline.} =
  gtk_level_bar_remove_offset_value(self, ucstring(name))
# proc remove_offset_value*(self: LevelBar, name: ustring) {.inline.} =

# gtk_level_bar_set_inverted
# flags: {isMethod} container: LevelBar
# need sugar: is method
# arg inverted: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_level_bar_set_inverted(self: ptr TLevelBar, inverted: bool) {.cdecl, dynlib: lib, importc: "gtk_level_bar_set_inverted".}
proc set_inverted*(self: LevelBar, inverted: bool) {.inline.} =
  gtk_level_bar_set_inverted(self, inverted)
# proc set_inverted*(self: LevelBar, inverted: bool) {.inline.} =

# gtk_level_bar_set_max_value
# flags: {isMethod} container: LevelBar
# need sugar: is method
# arg value: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_level_bar_set_max_value(self: ptr TLevelBar, value: float64) {.cdecl, dynlib: lib, importc: "gtk_level_bar_set_max_value".}
proc set_max_value*(self: LevelBar, value: float64) {.inline.} =
  gtk_level_bar_set_max_value(self, value)
# proc set_max_value*(self: LevelBar, value: float64) {.inline.} =

# gtk_level_bar_set_min_value
# flags: {isMethod} container: LevelBar
# need sugar: is method
# arg value: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_level_bar_set_min_value(self: ptr TLevelBar, value: float64) {.cdecl, dynlib: lib, importc: "gtk_level_bar_set_min_value".}
proc set_min_value*(self: LevelBar, value: float64) {.inline.} =
  gtk_level_bar_set_min_value(self, value)
# proc set_min_value*(self: LevelBar, value: float64) {.inline.} =

# gtk_level_bar_set_mode
# flags: {isMethod} container: LevelBar
# need sugar: is method
# arg mode: INTERFACE (ENUM) 'LevelBarMode' 'LevelBarMode' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_level_bar_set_mode(self: ptr TLevelBar, mode: LevelBarMode) {.cdecl, dynlib: lib, importc: "gtk_level_bar_set_mode".}
proc set_mode*(self: LevelBar, mode: LevelBarMode) {.inline.} =
  gtk_level_bar_set_mode(self, mode)
# proc set_mode*(self: LevelBar, mode: LevelBarMode) {.inline.} =

# gtk_level_bar_set_value
# flags: {isMethod} container: LevelBar
# need sugar: is method
# arg value: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_level_bar_set_value(self: ptr TLevelBar, value: float64) {.cdecl, dynlib: lib, importc: "gtk_level_bar_set_value".}
proc set_value*(self: LevelBar, value: float64) {.inline.} =
  gtk_level_bar_set_value(self, value)
# proc set_value*(self: LevelBar, value: float64) {.inline.} =

# initializer for LevelBarAccessible: gtk_level_bar_accessible_get_type
proc gtk_level_bar_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_level_bar_accessible_get_type".}
template gtype*(klass_parameter: typedesc[LevelBarAccessible]): GType = gtk_level_bar_accessible_get_type()
# initializer for LinkButton: gtk_link_button_get_type
proc gtk_link_button_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_link_button_get_type".}
template gtype*(klass_parameter: typedesc[LinkButton]): GType = gtk_link_button_get_type()
# gtk_link_button_new
# flags: {isConstructor} container: LinkButton
# need sugar: is static method
# arg uri: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'LinkButton' 'TransferNone[TLinkButton]' (diff., need sugar)
proc gtk_link_button_new(uri: ucstring): TransferNone[TLinkButton] {.cdecl, dynlib: lib, importc: "gtk_link_button_new".}
proc new_linkbutton*(uri: ustring): LinkButton {.inline.} =
  wrap(gtk_link_button_new(ucstring(uri)))
# proc new_linkbutton*(uri: ustring): LinkButton {.inline.} =

# gtk_link_button_new_with_label
# flags: {isConstructor} container: LinkButton
# need sugar: is static method
# arg uri: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'LinkButton' 'TransferNone[TLinkButton]' (diff., need sugar)
proc gtk_link_button_new_with_label(uri: ucstring, label: ucstring): TransferNone[TLinkButton] {.cdecl, dynlib: lib, importc: "gtk_link_button_new_with_label".}
proc new_linkbutton_with_label*(uri: ustring, label: ustring): LinkButton {.inline.} =
  wrap(gtk_link_button_new_with_label(ucstring(uri), ucstring(label)))
# proc new_linkbutton_with_label*(uri: ustring, label: ustring): LinkButton {.inline.} =

# gtk_link_button_get_uri
# flags: {isMethod} container: LinkButton
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_link_button_get_uri(self: ptr TLinkButton): ucstring {.cdecl, dynlib: lib, importc: "gtk_link_button_get_uri".}
proc get_uri*(self: LinkButton): ucstring {.inline.} =
  gtk_link_button_get_uri(self)
# proc get_uri*(self: LinkButton): ucstring {.inline.} =

# gtk_link_button_get_visited
# flags: {isMethod} container: LinkButton
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_link_button_get_visited(self: ptr TLinkButton): bool {.cdecl, dynlib: lib, importc: "gtk_link_button_get_visited".}
proc get_visited*(self: LinkButton): bool {.inline.} =
  gtk_link_button_get_visited(self)
# proc get_visited*(self: LinkButton): bool {.inline.} =

# gtk_link_button_set_uri
# flags: {isMethod} container: LinkButton
# need sugar: is method
# arg uri: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_link_button_set_uri(self: ptr TLinkButton, uri: ucstring) {.cdecl, dynlib: lib, importc: "gtk_link_button_set_uri".}
proc set_uri*(self: LinkButton, uri: ustring) {.inline.} =
  gtk_link_button_set_uri(self, ucstring(uri))
# proc set_uri*(self: LinkButton, uri: ustring) {.inline.} =

# gtk_link_button_set_visited
# flags: {isMethod} container: LinkButton
# need sugar: is method
# arg visited: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_link_button_set_visited(self: ptr TLinkButton, visited: bool) {.cdecl, dynlib: lib, importc: "gtk_link_button_set_visited".}
proc set_visited*(self: LinkButton, visited: bool) {.inline.} =
  gtk_link_button_set_visited(self, visited)
# proc set_visited*(self: LinkButton, visited: bool) {.inline.} =

# initializer for LinkButtonAccessible: gtk_link_button_accessible_get_type
proc gtk_link_button_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_link_button_accessible_get_type".}
template gtype*(klass_parameter: typedesc[LinkButtonAccessible]): GType = gtk_link_button_accessible_get_type()
# initializer for ListBox: gtk_list_box_get_type
proc gtk_list_box_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_list_box_get_type".}
template gtype*(klass_parameter: typedesc[ListBox]): GType = gtk_list_box_get_type()
# gtk_list_box_new
# flags: {isConstructor} container: ListBox
# need sugar: is static method
# return: INTERFACE 'ListBox' 'TransferNone[TListBox]' (diff., need sugar)
proc gtk_list_box_new(): TransferNone[TListBox] {.cdecl, dynlib: lib, importc: "gtk_list_box_new".}
proc new_listbox*(): ListBox {.inline.} =
  wrap(gtk_list_box_new())
# proc new_listbox*(): ListBox {.inline.} =

# gtk_list_box_bind_model
# flags: {isMethod} container: ListBox
# need sugar: is method
# arg model: INTERFACE (INTERFACE) 'ptr Gio2.TListModel' 'ptr Gio2.TListModel' IN
# arg create_widget_func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg user_data: VOID 'pointer' 'pointer' IN
# arg user_data_free_func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_bind_model(self: ptr TListBox, model: ptr Gio2.TListModel, create_widget_func: pointer, user_data: pointer, user_data_free_func: pointer) {.cdecl, dynlib: lib, importc: "gtk_list_box_bind_model".}
proc bind_model*(self: ListBox, model: ptr Gio2.TListModel, create_widget_func: pointer, user_data: pointer, user_data_free_func: pointer) {.inline.} =
  gtk_list_box_bind_model(self, model, create_widget_func, user_data, user_data_free_func)
# proc bind_model*(self: ListBox, model: ptr Gio2.TListModel, create_widget_func: pointer, user_data: pointer, user_data_free_func: pointer) {.inline.} =

# gtk_list_box_drag_highlight_row
# flags: {isMethod} container: ListBox
# need sugar: is method
# arg row: INTERFACE (OBJECT) 'ListBoxRow' 'ptr TListBoxRow' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_drag_highlight_row(self: ptr TListBox, row: ptr TListBoxRow) {.cdecl, dynlib: lib, importc: "gtk_list_box_drag_highlight_row".}
proc drag_highlight_row*(self: ListBox, row: ListBoxRow) {.inline.} =
  gtk_list_box_drag_highlight_row(self, row.getPointer)
# proc drag_highlight_row*(self: ListBox, row: ListBoxRow) {.inline.} =

# gtk_list_box_drag_unhighlight_row
# flags: {isMethod} container: ListBox
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_drag_unhighlight_row(self: ptr TListBox) {.cdecl, dynlib: lib, importc: "gtk_list_box_drag_unhighlight_row".}
proc drag_unhighlight_row*(self: ListBox) {.inline.} =
  gtk_list_box_drag_unhighlight_row(self)
# proc drag_unhighlight_row*(self: ListBox) {.inline.} =

# gtk_list_box_get_activate_on_single_click
# flags: {isMethod} container: ListBox
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_list_box_get_activate_on_single_click(self: ptr TListBox): bool {.cdecl, dynlib: lib, importc: "gtk_list_box_get_activate_on_single_click".}
proc get_activate_on_single_click*(self: ListBox): bool {.inline.} =
  gtk_list_box_get_activate_on_single_click(self)
# proc get_activate_on_single_click*(self: ListBox): bool {.inline.} =

# gtk_list_box_get_adjustment
# flags: {isMethod} container: ListBox
# need sugar: is method
# return: INTERFACE 'Adjustment' 'TransferNone[TAdjustment]' (diff., need sugar)
proc gtk_list_box_get_adjustment(self: ptr TListBox): TransferNone[TAdjustment] {.cdecl, dynlib: lib, importc: "gtk_list_box_get_adjustment".}
proc get_adjustment*(self: ListBox): Adjustment {.inline.} =
  wrap(gtk_list_box_get_adjustment(self))
# proc get_adjustment*(self: ListBox): Adjustment {.inline.} =

# gtk_list_box_get_row_at_index
# flags: {isMethod} container: ListBox
# need sugar: is method
# arg index_: INT32 'int32' 'int32' IN
# return: INTERFACE 'ListBoxRow' 'TransferNone[TListBoxRow]' (diff., need sugar)
proc gtk_list_box_get_row_at_index(self: ptr TListBox, index_x: int32): TransferNone[TListBoxRow] {.cdecl, dynlib: lib, importc: "gtk_list_box_get_row_at_index".}
proc get_row_at_index*(self: ListBox, index_x: int32): ListBoxRow {.inline.} =
  wrap(gtk_list_box_get_row_at_index(self, index_x))
# proc get_row_at_index*(self: ListBox, index_x: int32): ListBoxRow {.inline.} =

# gtk_list_box_get_row_at_y
# flags: {isMethod} container: ListBox
# need sugar: is method
# arg y: INT32 'int32' 'int32' IN
# return: INTERFACE 'ListBoxRow' 'TransferNone[TListBoxRow]' (diff., need sugar)
proc gtk_list_box_get_row_at_y(self: ptr TListBox, y: int32): TransferNone[TListBoxRow] {.cdecl, dynlib: lib, importc: "gtk_list_box_get_row_at_y".}
proc get_row_at_y*(self: ListBox, y: int32): ListBoxRow {.inline.} =
  wrap(gtk_list_box_get_row_at_y(self, y))
# proc get_row_at_y*(self: ListBox, y: int32): ListBoxRow {.inline.} =

# gtk_list_box_get_selected_row
# flags: {isMethod} container: ListBox
# need sugar: is method
# return: INTERFACE 'ListBoxRow' 'TransferNone[TListBoxRow]' (diff., need sugar)
proc gtk_list_box_get_selected_row(self: ptr TListBox): TransferNone[TListBoxRow] {.cdecl, dynlib: lib, importc: "gtk_list_box_get_selected_row".}
proc get_selected_row*(self: ListBox): ListBoxRow {.inline.} =
  wrap(gtk_list_box_get_selected_row(self))
# proc get_selected_row*(self: ListBox): ListBoxRow {.inline.} =

# gtk_list_box_get_selected_rows
# flags: {isMethod} container: ListBox
# need sugar: is method
# return: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_list_box_get_selected_rows(self: ptr TListBox): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_list_box_get_selected_rows".}
proc get_selected_rows*(self: ListBox): ptr GLIST_TODO {.inline.} =
  gtk_list_box_get_selected_rows(self)
# proc get_selected_rows*(self: ListBox): ptr GLIST_TODO {.inline.} =

# gtk_list_box_get_selection_mode
# flags: {isMethod} container: ListBox
# need sugar: is method
# return: INTERFACE 'SelectionMode' 'SelectionMode'
proc gtk_list_box_get_selection_mode(self: ptr TListBox): SelectionMode {.cdecl, dynlib: lib, importc: "gtk_list_box_get_selection_mode".}
proc get_selection_mode*(self: ListBox): SelectionMode {.inline.} =
  gtk_list_box_get_selection_mode(self)
# proc get_selection_mode*(self: ListBox): SelectionMode {.inline.} =

# gtk_list_box_insert
# flags: {isMethod} container: ListBox
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg position: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_insert(self: ptr TListBox, child: ptr TWidget, position: int32) {.cdecl, dynlib: lib, importc: "gtk_list_box_insert".}
proc insert*(self: ListBox, child: Widget, position: int32) {.inline.} =
  gtk_list_box_insert(self, child.getPointer, position)
# proc insert*(self: ListBox, child: Widget, position: int32) {.inline.} =

# gtk_list_box_invalidate_filter
# flags: {isMethod} container: ListBox
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_invalidate_filter(self: ptr TListBox) {.cdecl, dynlib: lib, importc: "gtk_list_box_invalidate_filter".}
proc invalidate_filter*(self: ListBox) {.inline.} =
  gtk_list_box_invalidate_filter(self)
# proc invalidate_filter*(self: ListBox) {.inline.} =

# gtk_list_box_invalidate_headers
# flags: {isMethod} container: ListBox
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_invalidate_headers(self: ptr TListBox) {.cdecl, dynlib: lib, importc: "gtk_list_box_invalidate_headers".}
proc invalidate_headers*(self: ListBox) {.inline.} =
  gtk_list_box_invalidate_headers(self)
# proc invalidate_headers*(self: ListBox) {.inline.} =

# gtk_list_box_invalidate_sort
# flags: {isMethod} container: ListBox
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_invalidate_sort(self: ptr TListBox) {.cdecl, dynlib: lib, importc: "gtk_list_box_invalidate_sort".}
proc invalidate_sort*(self: ListBox) {.inline.} =
  gtk_list_box_invalidate_sort(self)
# proc invalidate_sort*(self: ListBox) {.inline.} =

# gtk_list_box_prepend
# flags: {isMethod} container: ListBox
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_prepend(self: ptr TListBox, child: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_list_box_prepend".}
proc prepend*(self: ListBox, child: Widget) {.inline.} =
  gtk_list_box_prepend(self, child.getPointer)
# proc prepend*(self: ListBox, child: Widget) {.inline.} =

# gtk_list_box_select_all
# flags: {isMethod} container: ListBox
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_select_all(self: ptr TListBox) {.cdecl, dynlib: lib, importc: "gtk_list_box_select_all".}
proc select_all*(self: ListBox) {.inline.} =
  gtk_list_box_select_all(self)
# proc select_all*(self: ListBox) {.inline.} =

# gtk_list_box_select_row
# flags: {isMethod} container: ListBox
# need sugar: is method
# arg row: INTERFACE (OBJECT) 'ListBoxRow' 'ptr TListBoxRow' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_select_row(self: ptr TListBox, row: ptr TListBoxRow) {.cdecl, dynlib: lib, importc: "gtk_list_box_select_row".}
proc select_row*(self: ListBox, row: ListBoxRow) {.inline.} =
  gtk_list_box_select_row(self, row.getPointer)
# proc select_row*(self: ListBox, row: ListBoxRow) {.inline.} =

# gtk_list_box_selected_foreach
# flags: {isMethod} container: ListBox
# need sugar: is method
# arg func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg data: VOID 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_selected_foreach(self: ptr TListBox, func_x: pointer, data: pointer) {.cdecl, dynlib: lib, importc: "gtk_list_box_selected_foreach".}
proc selected_foreach*(self: ListBox, func_x: pointer, data: pointer) {.inline.} =
  gtk_list_box_selected_foreach(self, func_x, data)
# proc selected_foreach*(self: ListBox, func_x: pointer, data: pointer) {.inline.} =

# gtk_list_box_set_activate_on_single_click
# flags: {isMethod} container: ListBox
# need sugar: is method
# arg single: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_set_activate_on_single_click(self: ptr TListBox, single: bool) {.cdecl, dynlib: lib, importc: "gtk_list_box_set_activate_on_single_click".}
proc set_activate_on_single_click*(self: ListBox, single: bool) {.inline.} =
  gtk_list_box_set_activate_on_single_click(self, single)
# proc set_activate_on_single_click*(self: ListBox, single: bool) {.inline.} =

# gtk_list_box_set_adjustment
# flags: {isMethod} container: ListBox
# need sugar: is method
# arg adjustment: INTERFACE (OBJECT) 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_set_adjustment(self: ptr TListBox, adjustment: ptr TAdjustment) {.cdecl, dynlib: lib, importc: "gtk_list_box_set_adjustment".}
proc set_adjustment*(self: ListBox, adjustment: Adjustment) {.inline.} =
  gtk_list_box_set_adjustment(self, adjustment.getPointer)
# proc set_adjustment*(self: ListBox, adjustment: Adjustment) {.inline.} =

# gtk_list_box_set_filter_func
# flags: {isMethod} container: ListBox
# need sugar: is method
# arg filter_func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg user_data: VOID 'pointer' 'pointer' IN
# arg destroy: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_set_filter_func(self: ptr TListBox, filter_func: pointer, user_data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_list_box_set_filter_func".}
proc set_filter_func*(self: ListBox, filter_func: pointer, user_data: pointer, destroy: pointer) {.inline.} =
  gtk_list_box_set_filter_func(self, filter_func, user_data, destroy)
# proc set_filter_func*(self: ListBox, filter_func: pointer, user_data: pointer, destroy: pointer) {.inline.} =

# gtk_list_box_set_header_func
# flags: {isMethod} container: ListBox
# need sugar: is method
# arg update_header: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg user_data: VOID 'pointer' 'pointer' IN
# arg destroy: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_set_header_func(self: ptr TListBox, update_header: pointer, user_data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_list_box_set_header_func".}
proc set_header_func*(self: ListBox, update_header: pointer, user_data: pointer, destroy: pointer) {.inline.} =
  gtk_list_box_set_header_func(self, update_header, user_data, destroy)
# proc set_header_func*(self: ListBox, update_header: pointer, user_data: pointer, destroy: pointer) {.inline.} =

# gtk_list_box_set_placeholder
# flags: {isMethod} container: ListBox
# need sugar: is method
# arg placeholder: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_set_placeholder(self: ptr TListBox, placeholder: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_list_box_set_placeholder".}
proc set_placeholder*(self: ListBox, placeholder: Widget) {.inline.} =
  gtk_list_box_set_placeholder(self, placeholder.getPointer)
# proc set_placeholder*(self: ListBox, placeholder: Widget) {.inline.} =

# gtk_list_box_set_selection_mode
# flags: {isMethod} container: ListBox
# need sugar: is method
# arg mode: INTERFACE (ENUM) 'SelectionMode' 'SelectionMode' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_set_selection_mode(self: ptr TListBox, mode: SelectionMode) {.cdecl, dynlib: lib, importc: "gtk_list_box_set_selection_mode".}
proc set_selection_mode*(self: ListBox, mode: SelectionMode) {.inline.} =
  gtk_list_box_set_selection_mode(self, mode)
# proc set_selection_mode*(self: ListBox, mode: SelectionMode) {.inline.} =

# gtk_list_box_set_sort_func
# flags: {isMethod} container: ListBox
# need sugar: is method
# arg sort_func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg user_data: VOID 'pointer' 'pointer' IN
# arg destroy: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_set_sort_func(self: ptr TListBox, sort_func: pointer, user_data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_list_box_set_sort_func".}
proc set_sort_func*(self: ListBox, sort_func: pointer, user_data: pointer, destroy: pointer) {.inline.} =
  gtk_list_box_set_sort_func(self, sort_func, user_data, destroy)
# proc set_sort_func*(self: ListBox, sort_func: pointer, user_data: pointer, destroy: pointer) {.inline.} =

# gtk_list_box_unselect_all
# flags: {isMethod} container: ListBox
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_unselect_all(self: ptr TListBox) {.cdecl, dynlib: lib, importc: "gtk_list_box_unselect_all".}
proc unselect_all*(self: ListBox) {.inline.} =
  gtk_list_box_unselect_all(self)
# proc unselect_all*(self: ListBox) {.inline.} =

# gtk_list_box_unselect_row
# flags: {isMethod} container: ListBox
# need sugar: is method
# arg row: INTERFACE (OBJECT) 'ListBoxRow' 'ptr TListBoxRow' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_unselect_row(self: ptr TListBox, row: ptr TListBoxRow) {.cdecl, dynlib: lib, importc: "gtk_list_box_unselect_row".}
proc unselect_row*(self: ListBox, row: ListBoxRow) {.inline.} =
  gtk_list_box_unselect_row(self, row.getPointer)
# proc unselect_row*(self: ListBox, row: ListBoxRow) {.inline.} =

# initializer for ListBoxAccessible: gtk_list_box_accessible_get_type
proc gtk_list_box_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_list_box_accessible_get_type".}
template gtype*(klass_parameter: typedesc[ListBoxAccessible]): GType = gtk_list_box_accessible_get_type()
# initializer for ListBoxRow: gtk_list_box_row_get_type
proc gtk_list_box_row_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_list_box_row_get_type".}
template gtype*(klass_parameter: typedesc[ListBoxRow]): GType = gtk_list_box_row_get_type()
# gtk_list_box_row_new
# flags: {isConstructor} container: ListBoxRow
# need sugar: is static method
# return: INTERFACE 'ListBoxRow' 'TransferNone[TListBoxRow]' (diff., need sugar)
proc gtk_list_box_row_new(): TransferNone[TListBoxRow] {.cdecl, dynlib: lib, importc: "gtk_list_box_row_new".}
proc new_listboxrow*(): ListBoxRow {.inline.} =
  wrap(gtk_list_box_row_new())
# proc new_listboxrow*(): ListBoxRow {.inline.} =

# gtk_list_box_row_changed
# flags: {isMethod} container: ListBoxRow
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_row_changed(self: ptr TListBoxRow) {.cdecl, dynlib: lib, importc: "gtk_list_box_row_changed".}
proc changed*(self: ListBoxRow) {.inline.} =
  gtk_list_box_row_changed(self)
# proc changed*(self: ListBoxRow) {.inline.} =

# gtk_list_box_row_get_activatable
# flags: {isMethod} container: ListBoxRow
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_list_box_row_get_activatable(self: ptr TListBoxRow): bool {.cdecl, dynlib: lib, importc: "gtk_list_box_row_get_activatable".}
proc get_activatable*(self: ListBoxRow): bool {.inline.} =
  gtk_list_box_row_get_activatable(self)
# proc get_activatable*(self: ListBoxRow): bool {.inline.} =

# gtk_list_box_row_get_header
# flags: {isMethod} container: ListBoxRow
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_list_box_row_get_header(self: ptr TListBoxRow): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_list_box_row_get_header".}
proc get_header*(self: ListBoxRow): Widget {.inline.} =
  wrap(gtk_list_box_row_get_header(self))
# proc get_header*(self: ListBoxRow): Widget {.inline.} =

# gtk_list_box_row_get_index
# flags: {isMethod} container: ListBoxRow
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_list_box_row_get_index(self: ptr TListBoxRow): int32 {.cdecl, dynlib: lib, importc: "gtk_list_box_row_get_index".}
proc get_index*(self: ListBoxRow): int32 {.inline.} =
  gtk_list_box_row_get_index(self)
# proc get_index*(self: ListBoxRow): int32 {.inline.} =

# gtk_list_box_row_get_selectable
# flags: {isMethod} container: ListBoxRow
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_list_box_row_get_selectable(self: ptr TListBoxRow): bool {.cdecl, dynlib: lib, importc: "gtk_list_box_row_get_selectable".}
proc get_selectable*(self: ListBoxRow): bool {.inline.} =
  gtk_list_box_row_get_selectable(self)
# proc get_selectable*(self: ListBoxRow): bool {.inline.} =

# gtk_list_box_row_is_selected
# flags: {isMethod} container: ListBoxRow
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_list_box_row_is_selected(self: ptr TListBoxRow): bool {.cdecl, dynlib: lib, importc: "gtk_list_box_row_is_selected".}
proc is_selected*(self: ListBoxRow): bool {.inline.} =
  gtk_list_box_row_is_selected(self)
# proc is_selected*(self: ListBoxRow): bool {.inline.} =

# gtk_list_box_row_set_activatable
# flags: {isMethod} container: ListBoxRow
# need sugar: is method
# arg activatable: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_row_set_activatable(self: ptr TListBoxRow, activatable: bool) {.cdecl, dynlib: lib, importc: "gtk_list_box_row_set_activatable".}
proc set_activatable*(self: ListBoxRow, activatable: bool) {.inline.} =
  gtk_list_box_row_set_activatable(self, activatable)
# proc set_activatable*(self: ListBoxRow, activatable: bool) {.inline.} =

# gtk_list_box_row_set_header
# flags: {isMethod} container: ListBoxRow
# need sugar: is method
# arg header: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_row_set_header(self: ptr TListBoxRow, header: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_list_box_row_set_header".}
proc set_header*(self: ListBoxRow, header: Widget) {.inline.} =
  gtk_list_box_row_set_header(self, header.getPointer)
# proc set_header*(self: ListBoxRow, header: Widget) {.inline.} =

# gtk_list_box_row_set_selectable
# flags: {isMethod} container: ListBoxRow
# need sugar: is method
# arg selectable: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_box_row_set_selectable(self: ptr TListBoxRow, selectable: bool) {.cdecl, dynlib: lib, importc: "gtk_list_box_row_set_selectable".}
proc set_selectable*(self: ListBoxRow, selectable: bool) {.inline.} =
  gtk_list_box_row_set_selectable(self, selectable)
# proc set_selectable*(self: ListBoxRow, selectable: bool) {.inline.} =

# initializer for ListBoxRowAccessible: gtk_list_box_row_accessible_get_type
proc gtk_list_box_row_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_list_box_row_accessible_get_type".}
template gtype*(klass_parameter: typedesc[ListBoxRowAccessible]): GType = gtk_list_box_row_accessible_get_type()
# initializer for ListStore: gtk_list_store_get_type
proc gtk_list_store_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_list_store_get_type".}
template gtype*(klass_parameter: typedesc[ListStore]): GType = gtk_list_store_get_type()
# gtk_list_store_newv
# flags: {isConstructor} container: ListStore
# need sugar: is static method
# arg n_columns: INT32 'int32' 'int32' IN
# arg types: ARRAY 'var openarray[GType]' 'openarray[GType]' IN (diff., need sugar) array lengthArg: 0
# return: INTERFACE 'ListStore' 'TransferFull[TListStore]' (diff., need sugar)
proc gtk_list_store_newv(n_columns: int32, types: openarray[GType]): TransferFull[TListStore] {.cdecl, dynlib: lib, importc: "gtk_list_store_newv".}
proc new_liststore*(types: var openarray[GType]): ListStore {.inline.} =
  wrap(gtk_list_store_newv(types.len.int32, types))
# proc new_liststore*(types: var openarray[GType]): ListStore {.inline.} =

# gtk_list_store_append
# flags: {isMethod} container: ListStore
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' OUT caller-allocates
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_append(self: ptr TListStore, iter: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_list_store_append".}
proc append*(self: ListStore, iter: ptr TTreeIter) {.inline.} =
  gtk_list_store_append(self, iter)
# tuple-return
# iter: ptr TTreeIter
# proc append*(self: ListStore) {.inline.} =

# gtk_list_store_clear
# flags: {isMethod} container: ListStore
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_clear(self: ptr TListStore) {.cdecl, dynlib: lib, importc: "gtk_list_store_clear".}
proc clear*(self: ListStore) {.inline.} =
  gtk_list_store_clear(self)
# proc clear*(self: ListStore) {.inline.} =

# gtk_list_store_insert
# flags: {isMethod} container: ListStore
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' OUT caller-allocates
# arg position: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_insert(self: ptr TListStore, iter: ptr TTreeIter, position: int32) {.cdecl, dynlib: lib, importc: "gtk_list_store_insert".}
proc insert*(self: ListStore, iter: ptr TTreeIter, position: int32) {.inline.} =
  gtk_list_store_insert(self, iter, position)
# tuple-return
# iter: ptr TTreeIter
# proc insert*(self: ListStore, position: int32) {.inline.} =

# gtk_list_store_insert_after
# flags: {isMethod} container: ListStore
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' OUT caller-allocates
# arg sibling: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_insert_after(self: ptr TListStore, iter: ptr TTreeIter, sibling: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_list_store_insert_after".}
proc insert_after*(self: ListStore, iter: ptr TTreeIter, sibling: ptr TTreeIter) {.inline.} =
  gtk_list_store_insert_after(self, iter, sibling)
# tuple-return
# iter: ptr TTreeIter
# proc insert_after*(self: ListStore, sibling: ptr TTreeIter) {.inline.} =

# gtk_list_store_insert_before
# flags: {isMethod} container: ListStore
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' OUT caller-allocates
# arg sibling: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_insert_before(self: ptr TListStore, iter: ptr TTreeIter, sibling: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_list_store_insert_before".}
proc insert_before*(self: ListStore, iter: ptr TTreeIter, sibling: ptr TTreeIter) {.inline.} =
  gtk_list_store_insert_before(self, iter, sibling)
# tuple-return
# iter: ptr TTreeIter
# proc insert_before*(self: ListStore, sibling: ptr TTreeIter) {.inline.} =

# gtk_list_store_insert_with_valuesv
# flags: {isMethod} container: ListStore
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' OUT caller-allocates optional
# arg position: INT32 'int32' 'int32' IN
# arg columns: ARRAY 'var openarray[int32]' 'openarray[int32]' IN (diff., need sugar) array lengthArg: 4
# arg values: ARRAY 'var openarray[GObject2.TValue]' 'openarray[GObject2.TValue]' IN (diff., need sugar) array lengthArg: 4
# arg n_values: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_insert_with_valuesv(self: ptr TListStore, iter: ptr TTreeIter, position: int32, columns: openarray[int32], values: openarray[GObject2.TValue], n_values: int32) {.cdecl, dynlib: lib, importc: "gtk_list_store_insert_with_valuesv".}
proc insert_with_valuesv*(self: ListStore, iter: ptr TTreeIter, position: int32, columns: var openarray[int32], values: var openarray[GObject2.TValue]) {.inline.} =
  gtk_list_store_insert_with_valuesv(self, iter, position, columns, values, values.len.int32)
# tuple-return
# iter: ptr TTreeIter
# proc insert_with_valuesv*(self: ListStore, position: int32, columns: var openarray[int32], values: var openarray[GObject2.TValue]) {.inline.} =

# gtk_list_store_iter_is_valid
# flags: {isMethod} container: ListStore
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_list_store_iter_is_valid(self: ptr TListStore, iter: ptr TTreeIter): bool {.cdecl, dynlib: lib, importc: "gtk_list_store_iter_is_valid".}
proc iter_is_valid*(self: ListStore, iter: ptr TTreeIter): bool {.inline.} =
  gtk_list_store_iter_is_valid(self, iter)
# proc iter_is_valid*(self: ListStore, iter: ptr TTreeIter): bool {.inline.} =

# gtk_list_store_move_after
# flags: {isMethod} container: ListStore
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# arg position: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_move_after(self: ptr TListStore, iter: ptr TTreeIter, position: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_list_store_move_after".}
proc move_after*(self: ListStore, iter: ptr TTreeIter, position: ptr TTreeIter) {.inline.} =
  gtk_list_store_move_after(self, iter, position)
# proc move_after*(self: ListStore, iter: ptr TTreeIter, position: ptr TTreeIter) {.inline.} =

# gtk_list_store_move_before
# flags: {isMethod} container: ListStore
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# arg position: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_move_before(self: ptr TListStore, iter: ptr TTreeIter, position: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_list_store_move_before".}
proc move_before*(self: ListStore, iter: ptr TTreeIter, position: ptr TTreeIter) {.inline.} =
  gtk_list_store_move_before(self, iter, position)
# proc move_before*(self: ListStore, iter: ptr TTreeIter, position: ptr TTreeIter) {.inline.} =

# gtk_list_store_prepend
# flags: {isMethod} container: ListStore
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' OUT caller-allocates
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_prepend(self: ptr TListStore, iter: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_list_store_prepend".}
proc prepend*(self: ListStore, iter: ptr TTreeIter) {.inline.} =
  gtk_list_store_prepend(self, iter)
# tuple-return
# iter: ptr TTreeIter
# proc prepend*(self: ListStore) {.inline.} =

# gtk_list_store_remove
# flags: {isMethod} container: ListStore
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_list_store_remove(self: ptr TListStore, iter: ptr TTreeIter): bool {.cdecl, dynlib: lib, importc: "gtk_list_store_remove".}
proc remove*(self: ListStore, iter: ptr TTreeIter): bool {.inline.} =
  gtk_list_store_remove(self, iter)
# proc remove*(self: ListStore, iter: ptr TTreeIter): bool {.inline.} =

# gtk_list_store_reorder
# flags: {isMethod} container: ListStore
# need sugar: is method
# arg new_order: ARRAY 'uncheckedArray[int32]' 'uncheckedArray[int32]' IN array zero-terminated
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_reorder(self: ptr TListStore, new_order: uncheckedArray[int32]) {.cdecl, dynlib: lib, importc: "gtk_list_store_reorder".}
proc reorder*(self: ListStore, new_order: uncheckedArray[int32]) {.inline.} =
  gtk_list_store_reorder(self, new_order)
# proc reorder*(self: ListStore, new_order: uncheckedArray[int32]) {.inline.} =

# gtk_list_store_set_column_types
# flags: {isMethod} container: ListStore
# need sugar: is method
# arg n_columns: INT32 'int32' 'int32' IN
# arg types: ARRAY 'var openarray[GType]' 'openarray[GType]' IN (diff., need sugar) array lengthArg: 0
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_set_column_types(self: ptr TListStore, n_columns: int32, types: openarray[GType]) {.cdecl, dynlib: lib, importc: "gtk_list_store_set_column_types".}
proc set_column_types*(self: ListStore, types: var openarray[GType]) {.inline.} =
  gtk_list_store_set_column_types(self, types.len.int32, types)
# proc set_column_types*(self: ListStore, types: var openarray[GType]) {.inline.} =

# gtk_list_store_set_value
# flags: {isMethod} container: ListStore
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# arg column: INT32 'int32' 'int32' IN
# arg value: INTERFACE (STRUCT) 'ptr GObject2.TValue' 'ptr GObject2.TValue' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_set_value(self: ptr TListStore, iter: ptr TTreeIter, column: int32, value: ptr GObject2.TValue) {.cdecl, dynlib: lib, importc: "gtk_list_store_set_value".}
proc set_value*(self: ListStore, iter: ptr TTreeIter, column: int32, value: ptr GObject2.TValue) {.inline.} =
  gtk_list_store_set_value(self, iter, column, value)
# proc set_value*(self: ListStore, iter: ptr TTreeIter, column: int32, value: ptr GObject2.TValue) {.inline.} =

# gtk_list_store_set_valuesv
# flags: {isMethod} container: ListStore
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# arg columns: ARRAY 'var openarray[int32]' 'openarray[int32]' IN (diff., need sugar) array lengthArg: 3
# arg values: ARRAY 'var openarray[GObject2.TValue]' 'openarray[GObject2.TValue]' IN (diff., need sugar) array lengthArg: 3
# arg n_values: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_set_valuesv(self: ptr TListStore, iter: ptr TTreeIter, columns: openarray[int32], values: openarray[GObject2.TValue], n_values: int32) {.cdecl, dynlib: lib, importc: "gtk_list_store_set_valuesv".}
proc set*(self: ListStore, iter: ptr TTreeIter, columns: var openarray[int32], values: var openarray[GObject2.TValue]) {.inline.} =
  gtk_list_store_set_valuesv(self, iter, columns, values, values.len.int32)
# proc set*(self: ListStore, iter: ptr TTreeIter, columns: var openarray[int32], values: var openarray[GObject2.TValue]) {.inline.} =

# gtk_list_store_swap
# flags: {isMethod} container: ListStore
# need sugar: is method
# arg a: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# arg b: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_list_store_swap(self: ptr TListStore, a: ptr TTreeIter, b: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_list_store_swap".}
proc swap*(self: ListStore, a: ptr TTreeIter, b: ptr TTreeIter) {.inline.} =
  gtk_list_store_swap(self, a, b)
# proc swap*(self: ListStore, a: ptr TTreeIter, b: ptr TTreeIter) {.inline.} =

# initializer for LockButton: gtk_lock_button_get_type
proc gtk_lock_button_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_lock_button_get_type".}
template gtype*(klass_parameter: typedesc[LockButton]): GType = gtk_lock_button_get_type()
# gtk_lock_button_new
# flags: {isConstructor} container: LockButton
# need sugar: is static method
# arg permission: INTERFACE (OBJECT) 'Gio2.Permission' 'ptr Gio2.TPermission' IN (diff., need sugar)
# return: INTERFACE 'LockButton' 'TransferNone[TLockButton]' (diff., need sugar)
proc gtk_lock_button_new(permission: ptr Gio2.TPermission): TransferNone[TLockButton] {.cdecl, dynlib: lib, importc: "gtk_lock_button_new".}
proc new_lockbutton*(permission: Gio2.Permission): LockButton {.inline.} =
  wrap(gtk_lock_button_new(permission.getPointer))
# proc new_lockbutton*(permission: Gio2.Permission): LockButton {.inline.} =

# gtk_lock_button_get_permission
# flags: {isMethod} container: LockButton
# need sugar: is method
# return: INTERFACE 'Gio2.Permission' 'TransferNone[Gio2.TPermission]' (diff., need sugar)
proc gtk_lock_button_get_permission(self: ptr TLockButton): TransferNone[Gio2.TPermission] {.cdecl, dynlib: lib, importc: "gtk_lock_button_get_permission".}
proc get_permission*(self: LockButton): Gio2.Permission {.inline.} =
  wrap(gtk_lock_button_get_permission(self))
# proc get_permission*(self: LockButton): Gio2.Permission {.inline.} =

# gtk_lock_button_set_permission
# flags: {isMethod} container: LockButton
# need sugar: is method
# arg permission: INTERFACE (OBJECT) 'Gio2.Permission' 'ptr Gio2.TPermission' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_lock_button_set_permission(self: ptr TLockButton, permission: ptr Gio2.TPermission) {.cdecl, dynlib: lib, importc: "gtk_lock_button_set_permission".}
proc set_permission*(self: LockButton, permission: Gio2.Permission) {.inline.} =
  gtk_lock_button_set_permission(self, permission.getPointer)
# proc set_permission*(self: LockButton, permission: Gio2.Permission) {.inline.} =

# initializer for LockButtonAccessible: gtk_lock_button_accessible_get_type
proc gtk_lock_button_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_lock_button_accessible_get_type".}
template gtype*(klass_parameter: typedesc[LockButtonAccessible]): GType = gtk_lock_button_accessible_get_type()
# initializer for Menu: gtk_menu_get_type
proc gtk_menu_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_menu_get_type".}
template gtype*(klass_parameter: typedesc[Menu]): GType = gtk_menu_get_type()
# gtk_menu_new
# flags: {isConstructor} container: Menu
# need sugar: is static method
# return: INTERFACE 'Menu' 'TransferNone[TMenu]' (diff., need sugar)
proc gtk_menu_new(): TransferNone[TMenu] {.cdecl, dynlib: lib, importc: "gtk_menu_new".}
proc new_menu*(): Menu {.inline.} =
  wrap(gtk_menu_new())
# proc new_menu*(): Menu {.inline.} =

# gtk_menu_new_from_model
# flags: {isConstructor} container: Menu
# need sugar: is static method
# arg model: INTERFACE (OBJECT) 'Gio2.MenuModel' 'ptr Gio2.TMenuModel' IN (diff., need sugar)
# return: INTERFACE 'Menu' 'TransferNone[TMenu]' (diff., need sugar)
proc gtk_menu_new_from_model(model: ptr Gio2.TMenuModel): TransferNone[TMenu] {.cdecl, dynlib: lib, importc: "gtk_menu_new_from_model".}
proc new_menu_from_model*(model: Gio2.MenuModel): Menu {.inline.} =
  wrap(gtk_menu_new_from_model(model.getPointer))
# proc new_menu_from_model*(model: Gio2.MenuModel): Menu {.inline.} =

# gtk_menu_get_for_attach_widget
# flags: {} container: Menu
# need sugar: is static method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_menu_get_for_attach_widget(widget: ptr TWidget): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_menu_get_for_attach_widget".}
template get_for_attach_widget*(klass_parameter: typedesc[Menu], widget: Widget): ptr GLIST_TODO =
  gtk_menu_get_for_attach_widget(widget.getPointer)
# template get_for_attach_widget*(klass_parameter: typedesc[Menu], widget: Widget): ptr GLIST_TODO =

# gtk_menu_attach
# flags: {isMethod} container: Menu
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg left_attach: UINT32 'uint32' 'uint32' IN
# arg right_attach: UINT32 'uint32' 'uint32' IN
# arg top_attach: UINT32 'uint32' 'uint32' IN
# arg bottom_attach: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_attach(self: ptr TMenu, child: ptr TWidget, left_attach: uint32, right_attach: uint32, top_attach: uint32, bottom_attach: uint32) {.cdecl, dynlib: lib, importc: "gtk_menu_attach".}
proc attach*(self: Menu, child: Widget, left_attach: uint32, right_attach: uint32, top_attach: uint32, bottom_attach: uint32) {.inline.} =
  gtk_menu_attach(self, child.getPointer, left_attach, right_attach, top_attach, bottom_attach)
# proc attach*(self: Menu, child: Widget, left_attach: uint32, right_attach: uint32, top_attach: uint32, bottom_attach: uint32) {.inline.} =

# gtk_menu_attach_to_widget
# flags: {isMethod} container: Menu
# need sugar: is method
# arg attach_widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg detacher: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_attach_to_widget(self: ptr TMenu, attach_widget: ptr TWidget, detacher: pointer) {.cdecl, dynlib: lib, importc: "gtk_menu_attach_to_widget".}
proc attach_to_widget*(self: Menu, attach_widget: Widget, detacher: pointer) {.inline.} =
  gtk_menu_attach_to_widget(self, attach_widget.getPointer, detacher)
# proc attach_to_widget*(self: Menu, attach_widget: Widget, detacher: pointer) {.inline.} =

# gtk_menu_detach
# flags: {isMethod} container: Menu
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_detach(self: ptr TMenu) {.cdecl, dynlib: lib, importc: "gtk_menu_detach".}
proc detach*(self: Menu) {.inline.} =
  gtk_menu_detach(self)
# proc detach*(self: Menu) {.inline.} =

# gtk_menu_get_accel_group
# flags: {isMethod} container: Menu
# need sugar: is method
# return: INTERFACE 'AccelGroup' 'TransferNone[TAccelGroup]' (diff., need sugar)
proc gtk_menu_get_accel_group(self: ptr TMenu): TransferNone[TAccelGroup] {.cdecl, dynlib: lib, importc: "gtk_menu_get_accel_group".}
proc get_accel_group*(self: Menu): AccelGroup {.inline.} =
  wrap(gtk_menu_get_accel_group(self))
# proc get_accel_group*(self: Menu): AccelGroup {.inline.} =

# gtk_menu_get_accel_path
# flags: {isMethod} container: Menu
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_menu_get_accel_path(self: ptr TMenu): ucstring {.cdecl, dynlib: lib, importc: "gtk_menu_get_accel_path".}
proc get_accel_path*(self: Menu): ucstring {.inline.} =
  gtk_menu_get_accel_path(self)
# proc get_accel_path*(self: Menu): ucstring {.inline.} =

# gtk_menu_get_active
# flags: {isMethod} container: Menu
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_menu_get_active(self: ptr TMenu): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_menu_get_active".}
proc get_active*(self: Menu): Widget {.inline.} =
  wrap(gtk_menu_get_active(self))
# proc get_active*(self: Menu): Widget {.inline.} =

# gtk_menu_get_attach_widget
# flags: {isMethod} container: Menu
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_menu_get_attach_widget(self: ptr TMenu): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_menu_get_attach_widget".}
proc get_attach_widget*(self: Menu): Widget {.inline.} =
  wrap(gtk_menu_get_attach_widget(self))
# proc get_attach_widget*(self: Menu): Widget {.inline.} =

# gtk_menu_get_monitor
# flags: {isMethod} container: Menu
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_menu_get_monitor(self: ptr TMenu): int32 {.cdecl, dynlib: lib, importc: "gtk_menu_get_monitor".}
proc get_monitor*(self: Menu): int32 {.inline.} =
  gtk_menu_get_monitor(self)
# proc get_monitor*(self: Menu): int32 {.inline.} =

# gtk_menu_get_reserve_toggle_size
# flags: {isMethod} container: Menu
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_menu_get_reserve_toggle_size(self: ptr TMenu): bool {.cdecl, dynlib: lib, importc: "gtk_menu_get_reserve_toggle_size".}
proc get_reserve_toggle_size*(self: Menu): bool {.inline.} =
  gtk_menu_get_reserve_toggle_size(self)
# proc get_reserve_toggle_size*(self: Menu): bool {.inline.} =

# gtk_menu_get_tearoff_state
# flags: {isMethod} container: Menu (deprecated)
# gtk_menu_get_title
# flags: {isMethod} container: Menu (deprecated)
# gtk_menu_popdown
# flags: {isMethod} container: Menu
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_popdown(self: ptr TMenu) {.cdecl, dynlib: lib, importc: "gtk_menu_popdown".}
proc popdown*(self: Menu) {.inline.} =
  gtk_menu_popdown(self)
# proc popdown*(self: Menu) {.inline.} =

# gtk_menu_popup
# flags: {isMethod} container: Menu
# need sugar: is method
# arg parent_menu_shell: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg parent_menu_item: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg data: VOID 'pointer' 'pointer' IN
# arg button: UINT32 'uint32' 'uint32' IN
# arg activate_time: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_popup(self: ptr TMenu, parent_menu_shell: ptr TWidget, parent_menu_item: ptr TWidget, func_x: pointer, data: pointer, button: uint32, activate_time: uint32) {.cdecl, dynlib: lib, importc: "gtk_menu_popup".}
proc popup*(self: Menu, parent_menu_shell: Widget, parent_menu_item: Widget, func_x: pointer, data: pointer, button: uint32, activate_time: uint32) {.inline.} =
  gtk_menu_popup(self, parent_menu_shell.getPointer, parent_menu_item.getPointer, func_x, data, button, activate_time)
# proc popup*(self: Menu, parent_menu_shell: Widget, parent_menu_item: Widget, func_x: pointer, data: pointer, button: uint32, activate_time: uint32) {.inline.} =

# gtk_menu_popup_for_device
# flags: {isMethod} container: Menu
# need sugar: is method
# arg device: INTERFACE (OBJECT) 'Gdk3.Device' 'ptr Gdk3.TDevice' IN (diff., need sugar)
# arg parent_menu_shell: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg parent_menu_item: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg data: VOID 'pointer' 'pointer' IN
# arg destroy: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg button: UINT32 'uint32' 'uint32' IN
# arg activate_time: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_popup_for_device(self: ptr TMenu, device: ptr Gdk3.TDevice, parent_menu_shell: ptr TWidget, parent_menu_item: ptr TWidget, func_x: pointer, data: pointer, destroy: pointer, button: uint32, activate_time: uint32) {.cdecl, dynlib: lib, importc: "gtk_menu_popup_for_device".}
proc popup_for_device*(self: Menu, device: Gdk3.Device, parent_menu_shell: Widget, parent_menu_item: Widget, func_x: pointer, data: pointer, destroy: pointer, button: uint32, activate_time: uint32) {.inline.} =
  gtk_menu_popup_for_device(self, device.getPointer, parent_menu_shell.getPointer, parent_menu_item.getPointer, func_x, data, destroy, button, activate_time)
# proc popup_for_device*(self: Menu, device: Gdk3.Device, parent_menu_shell: Widget, parent_menu_item: Widget, func_x: pointer, data: pointer, destroy: pointer, button: uint32, activate_time: uint32) {.inline.} =

# gtk_menu_reorder_child
# flags: {isMethod} container: Menu
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg position: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_reorder_child(self: ptr TMenu, child: ptr TWidget, position: int32) {.cdecl, dynlib: lib, importc: "gtk_menu_reorder_child".}
proc reorder_child*(self: Menu, child: Widget, position: int32) {.inline.} =
  gtk_menu_reorder_child(self, child.getPointer, position)
# proc reorder_child*(self: Menu, child: Widget, position: int32) {.inline.} =

# gtk_menu_reposition
# flags: {isMethod} container: Menu
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_reposition(self: ptr TMenu) {.cdecl, dynlib: lib, importc: "gtk_menu_reposition".}
proc reposition*(self: Menu) {.inline.} =
  gtk_menu_reposition(self)
# proc reposition*(self: Menu) {.inline.} =

# gtk_menu_set_accel_group
# flags: {isMethod} container: Menu
# need sugar: is method
# arg accel_group: INTERFACE (OBJECT) 'AccelGroup' 'ptr TAccelGroup' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_set_accel_group(self: ptr TMenu, accel_group: ptr TAccelGroup) {.cdecl, dynlib: lib, importc: "gtk_menu_set_accel_group".}
proc set_accel_group*(self: Menu, accel_group: AccelGroup) {.inline.} =
  gtk_menu_set_accel_group(self, accel_group.getPointer)
# proc set_accel_group*(self: Menu, accel_group: AccelGroup) {.inline.} =

# gtk_menu_set_accel_path
# flags: {isMethod} container: Menu
# need sugar: is method
# arg accel_path: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_set_accel_path(self: ptr TMenu, accel_path: ucstring) {.cdecl, dynlib: lib, importc: "gtk_menu_set_accel_path".}
proc set_accel_path*(self: Menu, accel_path: ustring) {.inline.} =
  gtk_menu_set_accel_path(self, ucstring(accel_path))
# proc set_accel_path*(self: Menu, accel_path: ustring) {.inline.} =

# gtk_menu_set_active
# flags: {isMethod} container: Menu
# need sugar: is method
# arg index: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_set_active(self: ptr TMenu, index: uint32) {.cdecl, dynlib: lib, importc: "gtk_menu_set_active".}
proc set_active*(self: Menu, index: uint32) {.inline.} =
  gtk_menu_set_active(self, index)
# proc set_active*(self: Menu, index: uint32) {.inline.} =

# gtk_menu_set_monitor
# flags: {isMethod} container: Menu
# need sugar: is method
# arg monitor_num: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_set_monitor(self: ptr TMenu, monitor_num: int32) {.cdecl, dynlib: lib, importc: "gtk_menu_set_monitor".}
proc set_monitor*(self: Menu, monitor_num: int32) {.inline.} =
  gtk_menu_set_monitor(self, monitor_num)
# proc set_monitor*(self: Menu, monitor_num: int32) {.inline.} =

# gtk_menu_set_reserve_toggle_size
# flags: {isMethod} container: Menu
# need sugar: is method
# arg reserve_toggle_size: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_set_reserve_toggle_size(self: ptr TMenu, reserve_toggle_size: bool) {.cdecl, dynlib: lib, importc: "gtk_menu_set_reserve_toggle_size".}
proc set_reserve_toggle_size*(self: Menu, reserve_toggle_size: bool) {.inline.} =
  gtk_menu_set_reserve_toggle_size(self, reserve_toggle_size)
# proc set_reserve_toggle_size*(self: Menu, reserve_toggle_size: bool) {.inline.} =

# gtk_menu_set_screen
# flags: {isMethod} container: Menu
# need sugar: is method
# arg screen: INTERFACE (OBJECT) 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_set_screen(self: ptr TMenu, screen: ptr Gdk3.TScreen) {.cdecl, dynlib: lib, importc: "gtk_menu_set_screen".}
proc set_screen*(self: Menu, screen: Gdk3.Screen) {.inline.} =
  gtk_menu_set_screen(self, screen.getPointer)
# proc set_screen*(self: Menu, screen: Gdk3.Screen) {.inline.} =

# gtk_menu_set_tearoff_state
# flags: {isMethod} container: Menu (deprecated)
# gtk_menu_set_title
# flags: {isMethod} container: Menu (deprecated)
# initializer for MenuAccessible: gtk_menu_accessible_get_type
proc gtk_menu_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_menu_accessible_get_type".}
template gtype*(klass_parameter: typedesc[MenuAccessible]): GType = gtk_menu_accessible_get_type()
# initializer for MenuBar: gtk_menu_bar_get_type
proc gtk_menu_bar_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_menu_bar_get_type".}
template gtype*(klass_parameter: typedesc[MenuBar]): GType = gtk_menu_bar_get_type()
# gtk_menu_bar_new
# flags: {isConstructor} container: MenuBar
# need sugar: is static method
# return: INTERFACE 'MenuBar' 'TransferNone[TMenuBar]' (diff., need sugar)
proc gtk_menu_bar_new(): TransferNone[TMenuBar] {.cdecl, dynlib: lib, importc: "gtk_menu_bar_new".}
proc new_menubar*(): MenuBar {.inline.} =
  wrap(gtk_menu_bar_new())
# proc new_menubar*(): MenuBar {.inline.} =

# gtk_menu_bar_new_from_model
# flags: {isConstructor} container: MenuBar
# need sugar: is static method
# arg model: INTERFACE (OBJECT) 'Gio2.MenuModel' 'ptr Gio2.TMenuModel' IN (diff., need sugar)
# return: INTERFACE 'MenuBar' 'TransferNone[TMenuBar]' (diff., need sugar)
proc gtk_menu_bar_new_from_model(model: ptr Gio2.TMenuModel): TransferNone[TMenuBar] {.cdecl, dynlib: lib, importc: "gtk_menu_bar_new_from_model".}
proc new_menubar_from_model*(model: Gio2.MenuModel): MenuBar {.inline.} =
  wrap(gtk_menu_bar_new_from_model(model.getPointer))
# proc new_menubar_from_model*(model: Gio2.MenuModel): MenuBar {.inline.} =

# gtk_menu_bar_get_child_pack_direction
# flags: {isMethod} container: MenuBar
# need sugar: is method
# return: INTERFACE 'PackDirection' 'PackDirection'
proc gtk_menu_bar_get_child_pack_direction(self: ptr TMenuBar): PackDirection {.cdecl, dynlib: lib, importc: "gtk_menu_bar_get_child_pack_direction".}
proc get_child_pack_direction*(self: MenuBar): PackDirection {.inline.} =
  gtk_menu_bar_get_child_pack_direction(self)
# proc get_child_pack_direction*(self: MenuBar): PackDirection {.inline.} =

# gtk_menu_bar_get_pack_direction
# flags: {isMethod} container: MenuBar
# need sugar: is method
# return: INTERFACE 'PackDirection' 'PackDirection'
proc gtk_menu_bar_get_pack_direction(self: ptr TMenuBar): PackDirection {.cdecl, dynlib: lib, importc: "gtk_menu_bar_get_pack_direction".}
proc get_pack_direction*(self: MenuBar): PackDirection {.inline.} =
  gtk_menu_bar_get_pack_direction(self)
# proc get_pack_direction*(self: MenuBar): PackDirection {.inline.} =

# gtk_menu_bar_set_child_pack_direction
# flags: {isMethod} container: MenuBar
# need sugar: is method
# arg child_pack_dir: INTERFACE (ENUM) 'PackDirection' 'PackDirection' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_bar_set_child_pack_direction(self: ptr TMenuBar, child_pack_dir: PackDirection) {.cdecl, dynlib: lib, importc: "gtk_menu_bar_set_child_pack_direction".}
proc set_child_pack_direction*(self: MenuBar, child_pack_dir: PackDirection) {.inline.} =
  gtk_menu_bar_set_child_pack_direction(self, child_pack_dir)
# proc set_child_pack_direction*(self: MenuBar, child_pack_dir: PackDirection) {.inline.} =

# gtk_menu_bar_set_pack_direction
# flags: {isMethod} container: MenuBar
# need sugar: is method
# arg pack_dir: INTERFACE (ENUM) 'PackDirection' 'PackDirection' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_bar_set_pack_direction(self: ptr TMenuBar, pack_dir: PackDirection) {.cdecl, dynlib: lib, importc: "gtk_menu_bar_set_pack_direction".}
proc set_pack_direction*(self: MenuBar, pack_dir: PackDirection) {.inline.} =
  gtk_menu_bar_set_pack_direction(self, pack_dir)
# proc set_pack_direction*(self: MenuBar, pack_dir: PackDirection) {.inline.} =

# initializer for MenuButton: gtk_menu_button_get_type
proc gtk_menu_button_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_menu_button_get_type".}
template gtype*(klass_parameter: typedesc[MenuButton]): GType = gtk_menu_button_get_type()
# gtk_menu_button_new
# flags: {isConstructor} container: MenuButton
# need sugar: is static method
# return: INTERFACE 'MenuButton' 'TransferNone[TMenuButton]' (diff., need sugar)
proc gtk_menu_button_new(): TransferNone[TMenuButton] {.cdecl, dynlib: lib, importc: "gtk_menu_button_new".}
proc new_menubutton*(): MenuButton {.inline.} =
  wrap(gtk_menu_button_new())
# proc new_menubutton*(): MenuButton {.inline.} =

# gtk_menu_button_get_align_widget
# flags: {isMethod} container: MenuButton
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_menu_button_get_align_widget(self: ptr TMenuButton): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_menu_button_get_align_widget".}
proc get_align_widget*(self: MenuButton): Widget {.inline.} =
  wrap(gtk_menu_button_get_align_widget(self))
# proc get_align_widget*(self: MenuButton): Widget {.inline.} =

# gtk_menu_button_get_direction
# flags: {isMethod} container: MenuButton
# need sugar: is method
# return: INTERFACE 'ArrowType' 'ArrowType'
proc gtk_menu_button_get_direction(self: ptr TMenuButton): ArrowType {.cdecl, dynlib: lib, importc: "gtk_menu_button_get_direction".}
proc get_direction*(self: MenuButton): ArrowType {.inline.} =
  gtk_menu_button_get_direction(self)
# proc get_direction*(self: MenuButton): ArrowType {.inline.} =

# gtk_menu_button_get_menu_model
# flags: {isMethod} container: MenuButton
# need sugar: is method
# return: INTERFACE 'Gio2.MenuModel' 'TransferNone[Gio2.TMenuModel]' (diff., need sugar)
proc gtk_menu_button_get_menu_model(self: ptr TMenuButton): TransferNone[Gio2.TMenuModel] {.cdecl, dynlib: lib, importc: "gtk_menu_button_get_menu_model".}
proc get_menu_model*(self: MenuButton): Gio2.MenuModel {.inline.} =
  wrap(gtk_menu_button_get_menu_model(self))
# proc get_menu_model*(self: MenuButton): Gio2.MenuModel {.inline.} =

# gtk_menu_button_get_popover
# flags: {isMethod} container: MenuButton
# need sugar: is method
# return: INTERFACE 'Popover' 'TransferNone[TPopover]' (diff., need sugar)
proc gtk_menu_button_get_popover(self: ptr TMenuButton): TransferNone[TPopover] {.cdecl, dynlib: lib, importc: "gtk_menu_button_get_popover".}
proc get_popover*(self: MenuButton): Popover {.inline.} =
  wrap(gtk_menu_button_get_popover(self))
# proc get_popover*(self: MenuButton): Popover {.inline.} =

# gtk_menu_button_get_popup
# flags: {isMethod} container: MenuButton
# need sugar: is method
# return: INTERFACE 'Menu' 'TransferNone[TMenu]' (diff., need sugar)
proc gtk_menu_button_get_popup(self: ptr TMenuButton): TransferNone[TMenu] {.cdecl, dynlib: lib, importc: "gtk_menu_button_get_popup".}
proc get_popup*(self: MenuButton): Menu {.inline.} =
  wrap(gtk_menu_button_get_popup(self))
# proc get_popup*(self: MenuButton): Menu {.inline.} =

# gtk_menu_button_get_use_popover
# flags: {isMethod} container: MenuButton
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_menu_button_get_use_popover(self: ptr TMenuButton): bool {.cdecl, dynlib: lib, importc: "gtk_menu_button_get_use_popover".}
proc get_use_popover*(self: MenuButton): bool {.inline.} =
  gtk_menu_button_get_use_popover(self)
# proc get_use_popover*(self: MenuButton): bool {.inline.} =

# gtk_menu_button_set_align_widget
# flags: {isMethod} container: MenuButton
# need sugar: is method
# arg align_widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_button_set_align_widget(self: ptr TMenuButton, align_widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_menu_button_set_align_widget".}
proc set_align_widget*(self: MenuButton, align_widget: Widget) {.inline.} =
  gtk_menu_button_set_align_widget(self, align_widget.getPointer)
# proc set_align_widget*(self: MenuButton, align_widget: Widget) {.inline.} =

# gtk_menu_button_set_direction
# flags: {isMethod} container: MenuButton
# need sugar: is method
# arg direction: INTERFACE (ENUM) 'ArrowType' 'ArrowType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_button_set_direction(self: ptr TMenuButton, direction: ArrowType) {.cdecl, dynlib: lib, importc: "gtk_menu_button_set_direction".}
proc set_direction*(self: MenuButton, direction: ArrowType) {.inline.} =
  gtk_menu_button_set_direction(self, direction)
# proc set_direction*(self: MenuButton, direction: ArrowType) {.inline.} =

# gtk_menu_button_set_menu_model
# flags: {isMethod} container: MenuButton
# need sugar: is method
# arg menu_model: INTERFACE (OBJECT) 'Gio2.MenuModel' 'ptr Gio2.TMenuModel' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_button_set_menu_model(self: ptr TMenuButton, menu_model: ptr Gio2.TMenuModel) {.cdecl, dynlib: lib, importc: "gtk_menu_button_set_menu_model".}
proc set_menu_model*(self: MenuButton, menu_model: Gio2.MenuModel) {.inline.} =
  gtk_menu_button_set_menu_model(self, menu_model.getPointer)
# proc set_menu_model*(self: MenuButton, menu_model: Gio2.MenuModel) {.inline.} =

# gtk_menu_button_set_popover
# flags: {isMethod} container: MenuButton
# need sugar: is method
# arg popover: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_button_set_popover(self: ptr TMenuButton, popover: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_menu_button_set_popover".}
proc set_popover*(self: MenuButton, popover: Widget) {.inline.} =
  gtk_menu_button_set_popover(self, popover.getPointer)
# proc set_popover*(self: MenuButton, popover: Widget) {.inline.} =

# gtk_menu_button_set_popup
# flags: {isMethod} container: MenuButton
# need sugar: is method
# arg menu: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_button_set_popup(self: ptr TMenuButton, menu: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_menu_button_set_popup".}
proc set_popup*(self: MenuButton, menu: Widget) {.inline.} =
  gtk_menu_button_set_popup(self, menu.getPointer)
# proc set_popup*(self: MenuButton, menu: Widget) {.inline.} =

# gtk_menu_button_set_use_popover
# flags: {isMethod} container: MenuButton
# need sugar: is method
# arg use_popover: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_button_set_use_popover(self: ptr TMenuButton, use_popover: bool) {.cdecl, dynlib: lib, importc: "gtk_menu_button_set_use_popover".}
proc set_use_popover*(self: MenuButton, use_popover: bool) {.inline.} =
  gtk_menu_button_set_use_popover(self, use_popover)
# proc set_use_popover*(self: MenuButton, use_popover: bool) {.inline.} =

# initializer for MenuButtonAccessible: gtk_menu_button_accessible_get_type
proc gtk_menu_button_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_menu_button_accessible_get_type".}
template gtype*(klass_parameter: typedesc[MenuButtonAccessible]): GType = gtk_menu_button_accessible_get_type()
# initializer for MenuItem: gtk_menu_item_get_type
proc gtk_menu_item_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_menu_item_get_type".}
template gtype*(klass_parameter: typedesc[MenuItem]): GType = gtk_menu_item_get_type()
# gtk_menu_item_new
# flags: {isConstructor} container: MenuItem
# need sugar: is static method
# return: INTERFACE 'MenuItem' 'TransferNone[TMenuItem]' (diff., need sugar)
proc gtk_menu_item_new(): TransferNone[TMenuItem] {.cdecl, dynlib: lib, importc: "gtk_menu_item_new".}
proc new_menuitem*(): MenuItem {.inline.} =
  wrap(gtk_menu_item_new())
# proc new_menuitem*(): MenuItem {.inline.} =

# gtk_menu_item_new_with_label
# flags: {isConstructor} container: MenuItem
# need sugar: is static method
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'MenuItem' 'TransferNone[TMenuItem]' (diff., need sugar)
proc gtk_menu_item_new_with_label(label: ucstring): TransferNone[TMenuItem] {.cdecl, dynlib: lib, importc: "gtk_menu_item_new_with_label".}
proc new_menuitem_with_label*(label: ustring): MenuItem {.inline.} =
  wrap(gtk_menu_item_new_with_label(ucstring(label)))
# proc new_menuitem_with_label*(label: ustring): MenuItem {.inline.} =

# gtk_menu_item_new_with_mnemonic
# flags: {isConstructor} container: MenuItem
# need sugar: is static method
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'MenuItem' 'TransferNone[TMenuItem]' (diff., need sugar)
proc gtk_menu_item_new_with_mnemonic(label: ucstring): TransferNone[TMenuItem] {.cdecl, dynlib: lib, importc: "gtk_menu_item_new_with_mnemonic".}
proc new_menuitem_with_mnemonic*(label: ustring): MenuItem {.inline.} =
  wrap(gtk_menu_item_new_with_mnemonic(ucstring(label)))
# proc new_menuitem_with_mnemonic*(label: ustring): MenuItem {.inline.} =

# gtk_menu_item_activate
# flags: {isMethod} container: MenuItem
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_item_activate(self: ptr TMenuItem) {.cdecl, dynlib: lib, importc: "gtk_menu_item_activate".}
proc activate*(self: MenuItem) {.inline.} =
  gtk_menu_item_activate(self)
# proc activate*(self: MenuItem) {.inline.} =

# gtk_menu_item_deselect
# flags: {isMethod} container: MenuItem
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_item_deselect(self: ptr TMenuItem) {.cdecl, dynlib: lib, importc: "gtk_menu_item_deselect".}
proc deselect*(self: MenuItem) {.inline.} =
  gtk_menu_item_deselect(self)
# proc deselect*(self: MenuItem) {.inline.} =

# gtk_menu_item_get_accel_path
# flags: {isMethod} container: MenuItem
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_menu_item_get_accel_path(self: ptr TMenuItem): ucstring {.cdecl, dynlib: lib, importc: "gtk_menu_item_get_accel_path".}
proc get_accel_path*(self: MenuItem): ucstring {.inline.} =
  gtk_menu_item_get_accel_path(self)
# proc get_accel_path*(self: MenuItem): ucstring {.inline.} =

# gtk_menu_item_get_label
# flags: {isMethod} container: MenuItem
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_menu_item_get_label(self: ptr TMenuItem): ucstring {.cdecl, dynlib: lib, importc: "gtk_menu_item_get_label".}
proc get_label*(self: MenuItem): ucstring {.inline.} =
  gtk_menu_item_get_label(self)
# proc get_label*(self: MenuItem): ucstring {.inline.} =

# gtk_menu_item_get_reserve_indicator
# flags: {isMethod} container: MenuItem
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_menu_item_get_reserve_indicator(self: ptr TMenuItem): bool {.cdecl, dynlib: lib, importc: "gtk_menu_item_get_reserve_indicator".}
proc get_reserve_indicator*(self: MenuItem): bool {.inline.} =
  gtk_menu_item_get_reserve_indicator(self)
# proc get_reserve_indicator*(self: MenuItem): bool {.inline.} =

# gtk_menu_item_get_right_justified
# flags: {isMethod} container: MenuItem (deprecated)
# gtk_menu_item_get_submenu
# flags: {isMethod} container: MenuItem
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_menu_item_get_submenu(self: ptr TMenuItem): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_menu_item_get_submenu".}
proc get_submenu*(self: MenuItem): Widget {.inline.} =
  wrap(gtk_menu_item_get_submenu(self))
# proc get_submenu*(self: MenuItem): Widget {.inline.} =

# gtk_menu_item_get_use_underline
# flags: {isMethod} container: MenuItem
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_menu_item_get_use_underline(self: ptr TMenuItem): bool {.cdecl, dynlib: lib, importc: "gtk_menu_item_get_use_underline".}
proc get_use_underline*(self: MenuItem): bool {.inline.} =
  gtk_menu_item_get_use_underline(self)
# proc get_use_underline*(self: MenuItem): bool {.inline.} =

# gtk_menu_item_select
# flags: {isMethod} container: MenuItem
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_item_select(self: ptr TMenuItem) {.cdecl, dynlib: lib, importc: "gtk_menu_item_select".}
proc select*(self: MenuItem) {.inline.} =
  gtk_menu_item_select(self)
# proc select*(self: MenuItem) {.inline.} =

# gtk_menu_item_set_accel_path
# flags: {isMethod} container: MenuItem
# need sugar: is method
# arg accel_path: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_item_set_accel_path(self: ptr TMenuItem, accel_path: ucstring) {.cdecl, dynlib: lib, importc: "gtk_menu_item_set_accel_path".}
proc set_accel_path*(self: MenuItem, accel_path: ustring) {.inline.} =
  gtk_menu_item_set_accel_path(self, ucstring(accel_path))
# proc set_accel_path*(self: MenuItem, accel_path: ustring) {.inline.} =

# gtk_menu_item_set_label
# flags: {isMethod} container: MenuItem
# need sugar: is method
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_item_set_label(self: ptr TMenuItem, label: ucstring) {.cdecl, dynlib: lib, importc: "gtk_menu_item_set_label".}
proc set_label*(self: MenuItem, label: ustring) {.inline.} =
  gtk_menu_item_set_label(self, ucstring(label))
# proc set_label*(self: MenuItem, label: ustring) {.inline.} =

# gtk_menu_item_set_reserve_indicator
# flags: {isMethod} container: MenuItem
# need sugar: is method
# arg reserve: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_item_set_reserve_indicator(self: ptr TMenuItem, reserve: bool) {.cdecl, dynlib: lib, importc: "gtk_menu_item_set_reserve_indicator".}
proc set_reserve_indicator*(self: MenuItem, reserve: bool) {.inline.} =
  gtk_menu_item_set_reserve_indicator(self, reserve)
# proc set_reserve_indicator*(self: MenuItem, reserve: bool) {.inline.} =

# gtk_menu_item_set_right_justified
# flags: {isMethod} container: MenuItem (deprecated)
# gtk_menu_item_set_submenu
# flags: {isMethod} container: MenuItem
# need sugar: is method
# arg submenu: INTERFACE (OBJECT) 'Menu' 'ptr TMenu' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_item_set_submenu(self: ptr TMenuItem, submenu: ptr TMenu) {.cdecl, dynlib: lib, importc: "gtk_menu_item_set_submenu".}
proc set_submenu*(self: MenuItem, submenu: Menu) {.inline.} =
  gtk_menu_item_set_submenu(self, submenu.getPointer)
# proc set_submenu*(self: MenuItem, submenu: Menu) {.inline.} =

# gtk_menu_item_set_use_underline
# flags: {isMethod} container: MenuItem
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_item_set_use_underline(self: ptr TMenuItem, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_menu_item_set_use_underline".}
proc set_use_underline*(self: MenuItem, setting: bool) {.inline.} =
  gtk_menu_item_set_use_underline(self, setting)
# proc set_use_underline*(self: MenuItem, setting: bool) {.inline.} =

# gtk_menu_item_toggle_size_allocate
# flags: {isMethod} container: MenuItem
# need sugar: is method
# arg allocation: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_item_toggle_size_allocate(self: ptr TMenuItem, allocation: int32) {.cdecl, dynlib: lib, importc: "gtk_menu_item_toggle_size_allocate".}
proc toggle_size_allocate*(self: MenuItem, allocation: int32) {.inline.} =
  gtk_menu_item_toggle_size_allocate(self, allocation)
# proc toggle_size_allocate*(self: MenuItem, allocation: int32) {.inline.} =

# gtk_menu_item_toggle_size_request
# flags: {isMethod} container: MenuItem
# need sugar: is method
# arg requisition: INT32 'var int32' 'ptr int32' INOUT (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_item_toggle_size_request(self: ptr TMenuItem, requisition: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_menu_item_toggle_size_request".}
proc toggle_size_request*(self: MenuItem, requisition: var int32) {.inline.} =
  gtk_menu_item_toggle_size_request(self, addr(requisition))
# proc toggle_size_request*(self: MenuItem, requisition: var int32) {.inline.} =

# initializer for MenuItemAccessible: gtk_menu_item_accessible_get_type
proc gtk_menu_item_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_menu_item_accessible_get_type".}
template gtype*(klass_parameter: typedesc[MenuItemAccessible]): GType = gtk_menu_item_accessible_get_type()
# initializer for MenuShell: gtk_menu_shell_get_type
proc gtk_menu_shell_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_menu_shell_get_type".}
template gtype*(klass_parameter: typedesc[MenuShell]): GType = gtk_menu_shell_get_type()
# gtk_menu_shell_activate_item
# flags: {isMethod} container: MenuShell
# need sugar: is method
# arg menu_item: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg force_deactivate: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_shell_activate_item(self: ptr TMenuShell, menu_item: ptr TWidget, force_deactivate: bool) {.cdecl, dynlib: lib, importc: "gtk_menu_shell_activate_item".}
proc activate_item*(self: MenuShell, menu_item: Widget, force_deactivate: bool) {.inline.} =
  gtk_menu_shell_activate_item(self, menu_item.getPointer, force_deactivate)
# proc activate_item*(self: MenuShell, menu_item: Widget, force_deactivate: bool) {.inline.} =

# gtk_menu_shell_append
# flags: {isMethod} container: MenuShell
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'MenuItem' 'ptr TMenuItem' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_shell_append(self: ptr TMenuShell, child: ptr TMenuItem) {.cdecl, dynlib: lib, importc: "gtk_menu_shell_append".}
proc append*(self: MenuShell, child: MenuItem) {.inline.} =
  gtk_menu_shell_append(self, child.getPointer)
# proc append*(self: MenuShell, child: MenuItem) {.inline.} =

# gtk_menu_shell_bind_model
# flags: {isMethod} container: MenuShell
# need sugar: is method
# arg model: INTERFACE (OBJECT) 'Gio2.MenuModel' 'ptr Gio2.TMenuModel' IN (diff., need sugar)
# arg action_namespace: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg with_separators: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_shell_bind_model(self: ptr TMenuShell, model: ptr Gio2.TMenuModel, action_namespace: ucstring, with_separators: bool) {.cdecl, dynlib: lib, importc: "gtk_menu_shell_bind_model".}
proc bind_model*(self: MenuShell, model: Gio2.MenuModel, action_namespace: ustring, with_separators: bool) {.inline.} =
  gtk_menu_shell_bind_model(self, model.getPointer, ucstring(action_namespace), with_separators)
# proc bind_model*(self: MenuShell, model: Gio2.MenuModel, action_namespace: ustring, with_separators: bool) {.inline.} =

# gtk_menu_shell_cancel
# flags: {isMethod} container: MenuShell
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_shell_cancel(self: ptr TMenuShell) {.cdecl, dynlib: lib, importc: "gtk_menu_shell_cancel".}
proc cancel*(self: MenuShell) {.inline.} =
  gtk_menu_shell_cancel(self)
# proc cancel*(self: MenuShell) {.inline.} =

# gtk_menu_shell_deactivate
# flags: {isMethod} container: MenuShell
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_shell_deactivate(self: ptr TMenuShell) {.cdecl, dynlib: lib, importc: "gtk_menu_shell_deactivate".}
proc deactivate*(self: MenuShell) {.inline.} =
  gtk_menu_shell_deactivate(self)
# proc deactivate*(self: MenuShell) {.inline.} =

# gtk_menu_shell_deselect
# flags: {isMethod} container: MenuShell
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_shell_deselect(self: ptr TMenuShell) {.cdecl, dynlib: lib, importc: "gtk_menu_shell_deselect".}
proc deselect*(self: MenuShell) {.inline.} =
  gtk_menu_shell_deselect(self)
# proc deselect*(self: MenuShell) {.inline.} =

# gtk_menu_shell_get_parent_shell
# flags: {isMethod} container: MenuShell
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_menu_shell_get_parent_shell(self: ptr TMenuShell): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_menu_shell_get_parent_shell".}
proc get_parent_shell*(self: MenuShell): Widget {.inline.} =
  wrap(gtk_menu_shell_get_parent_shell(self))
# proc get_parent_shell*(self: MenuShell): Widget {.inline.} =

# gtk_menu_shell_get_selected_item
# flags: {isMethod} container: MenuShell
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_menu_shell_get_selected_item(self: ptr TMenuShell): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_menu_shell_get_selected_item".}
proc get_selected_item*(self: MenuShell): Widget {.inline.} =
  wrap(gtk_menu_shell_get_selected_item(self))
# proc get_selected_item*(self: MenuShell): Widget {.inline.} =

# gtk_menu_shell_get_take_focus
# flags: {isMethod} container: MenuShell
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_menu_shell_get_take_focus(self: ptr TMenuShell): bool {.cdecl, dynlib: lib, importc: "gtk_menu_shell_get_take_focus".}
proc get_take_focus*(self: MenuShell): bool {.inline.} =
  gtk_menu_shell_get_take_focus(self)
# proc get_take_focus*(self: MenuShell): bool {.inline.} =

# gtk_menu_shell_insert
# flags: {isMethod} container: MenuShell
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg position: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_shell_insert(self: ptr TMenuShell, child: ptr TWidget, position: int32) {.cdecl, dynlib: lib, importc: "gtk_menu_shell_insert".}
proc insert*(self: MenuShell, child: Widget, position: int32) {.inline.} =
  gtk_menu_shell_insert(self, child.getPointer, position)
# proc insert*(self: MenuShell, child: Widget, position: int32) {.inline.} =

# gtk_menu_shell_prepend
# flags: {isMethod} container: MenuShell
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_shell_prepend(self: ptr TMenuShell, child: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_menu_shell_prepend".}
proc prepend*(self: MenuShell, child: Widget) {.inline.} =
  gtk_menu_shell_prepend(self, child.getPointer)
# proc prepend*(self: MenuShell, child: Widget) {.inline.} =

# gtk_menu_shell_select_first
# flags: {isMethod} container: MenuShell
# need sugar: is method
# arg search_sensitive: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_shell_select_first(self: ptr TMenuShell, search_sensitive: bool) {.cdecl, dynlib: lib, importc: "gtk_menu_shell_select_first".}
proc select_first*(self: MenuShell, search_sensitive: bool) {.inline.} =
  gtk_menu_shell_select_first(self, search_sensitive)
# proc select_first*(self: MenuShell, search_sensitive: bool) {.inline.} =

# gtk_menu_shell_select_item
# flags: {isMethod} container: MenuShell
# need sugar: is method
# arg menu_item: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_shell_select_item(self: ptr TMenuShell, menu_item: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_menu_shell_select_item".}
proc select_item*(self: MenuShell, menu_item: Widget) {.inline.} =
  gtk_menu_shell_select_item(self, menu_item.getPointer)
# proc select_item*(self: MenuShell, menu_item: Widget) {.inline.} =

# gtk_menu_shell_set_take_focus
# flags: {isMethod} container: MenuShell
# need sugar: is method
# arg take_focus: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_shell_set_take_focus(self: ptr TMenuShell, take_focus: bool) {.cdecl, dynlib: lib, importc: "gtk_menu_shell_set_take_focus".}
proc set_take_focus*(self: MenuShell, take_focus: bool) {.inline.} =
  gtk_menu_shell_set_take_focus(self, take_focus)
# proc set_take_focus*(self: MenuShell, take_focus: bool) {.inline.} =

# initializer for MenuShellAccessible: gtk_menu_shell_accessible_get_type
proc gtk_menu_shell_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_menu_shell_accessible_get_type".}
template gtype*(klass_parameter: typedesc[MenuShellAccessible]): GType = gtk_menu_shell_accessible_get_type()
# initializer for MenuToolButton: gtk_menu_tool_button_get_type
proc gtk_menu_tool_button_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_menu_tool_button_get_type".}
template gtype*(klass_parameter: typedesc[MenuToolButton]): GType = gtk_menu_tool_button_get_type()
# gtk_menu_tool_button_new
# flags: {isConstructor} container: MenuToolButton
# need sugar: is static method
# arg icon_widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'MenuToolButton' 'TransferNone[TMenuToolButton]' (diff., need sugar)
proc gtk_menu_tool_button_new(icon_widget: ptr TWidget, label: ucstring): TransferNone[TMenuToolButton] {.cdecl, dynlib: lib, importc: "gtk_menu_tool_button_new".}
proc new_menutoolbutton*(icon_widget: Widget, label: ustring): MenuToolButton {.inline.} =
  wrap(gtk_menu_tool_button_new(icon_widget.getPointer, ucstring(label)))
# proc new_menutoolbutton*(icon_widget: Widget, label: ustring): MenuToolButton {.inline.} =

# gtk_menu_tool_button_new_from_stock
# flags: {isConstructor} container: MenuToolButton (deprecated)
# gtk_menu_tool_button_get_menu
# flags: {isMethod} container: MenuToolButton
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_menu_tool_button_get_menu(self: ptr TMenuToolButton): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_menu_tool_button_get_menu".}
proc get_menu*(self: MenuToolButton): Widget {.inline.} =
  wrap(gtk_menu_tool_button_get_menu(self))
# proc get_menu*(self: MenuToolButton): Widget {.inline.} =

# gtk_menu_tool_button_set_arrow_tooltip_markup
# flags: {isMethod} container: MenuToolButton
# need sugar: is method
# arg markup: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_tool_button_set_arrow_tooltip_markup(self: ptr TMenuToolButton, markup: ucstring) {.cdecl, dynlib: lib, importc: "gtk_menu_tool_button_set_arrow_tooltip_markup".}
proc set_arrow_tooltip_markup*(self: MenuToolButton, markup: ustring) {.inline.} =
  gtk_menu_tool_button_set_arrow_tooltip_markup(self, ucstring(markup))
# proc set_arrow_tooltip_markup*(self: MenuToolButton, markup: ustring) {.inline.} =

# gtk_menu_tool_button_set_arrow_tooltip_text
# flags: {isMethod} container: MenuToolButton
# need sugar: is method
# arg text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_tool_button_set_arrow_tooltip_text(self: ptr TMenuToolButton, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_menu_tool_button_set_arrow_tooltip_text".}
proc set_arrow_tooltip_text*(self: MenuToolButton, text: ustring) {.inline.} =
  gtk_menu_tool_button_set_arrow_tooltip_text(self, ucstring(text))
# proc set_arrow_tooltip_text*(self: MenuToolButton, text: ustring) {.inline.} =

# gtk_menu_tool_button_set_menu
# flags: {isMethod} container: MenuToolButton
# need sugar: is method
# arg menu: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_menu_tool_button_set_menu(self: ptr TMenuToolButton, menu: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_menu_tool_button_set_menu".}
proc set_menu*(self: MenuToolButton, menu: Widget) {.inline.} =
  gtk_menu_tool_button_set_menu(self, menu.getPointer)
# proc set_menu*(self: MenuToolButton, menu: Widget) {.inline.} =

# initializer for MessageDialog: gtk_message_dialog_get_type
proc gtk_message_dialog_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_message_dialog_get_type".}
template gtype*(klass_parameter: typedesc[MessageDialog]): GType = gtk_message_dialog_get_type()
# gtk_message_dialog_get_image
# flags: {isMethod} container: MessageDialog (deprecated)
# gtk_message_dialog_get_message_area
# flags: {isMethod} container: MessageDialog
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_message_dialog_get_message_area(self: ptr TMessageDialog): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_message_dialog_get_message_area".}
proc get_message_area*(self: MessageDialog): Widget {.inline.} =
  wrap(gtk_message_dialog_get_message_area(self))
# proc get_message_area*(self: MessageDialog): Widget {.inline.} =

# gtk_message_dialog_set_image
# flags: {isMethod} container: MessageDialog (deprecated)
# gtk_message_dialog_set_markup
# flags: {isMethod} container: MessageDialog
# need sugar: is method
# arg str: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_message_dialog_set_markup(self: ptr TMessageDialog, str: ucstring) {.cdecl, dynlib: lib, importc: "gtk_message_dialog_set_markup".}
proc set_markup*(self: MessageDialog, str: ustring) {.inline.} =
  gtk_message_dialog_set_markup(self, ucstring(str))
# proc set_markup*(self: MessageDialog, str: ustring) {.inline.} =

# initializer for Misc: gtk_misc_get_type
proc gtk_misc_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_misc_get_type".}
template gtype*(klass_parameter: typedesc[Misc]): GType = gtk_misc_get_type()
# gtk_misc_get_alignment
# flags: {isMethod} container: Misc (deprecated)
# gtk_misc_get_padding
# flags: {isMethod} container: Misc (deprecated)
# gtk_misc_set_alignment
# flags: {isMethod} container: Misc (deprecated)
# gtk_misc_set_padding
# flags: {isMethod} container: Misc (deprecated)
# initializer for ModelButton: gtk_model_button_get_type
proc gtk_model_button_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_model_button_get_type".}
template gtype*(klass_parameter: typedesc[ModelButton]): GType = gtk_model_button_get_type()
# gtk_model_button_new
# flags: {isConstructor} container: ModelButton
# need sugar: is static method
# return: INTERFACE 'ModelButton' 'TransferNone[TModelButton]' (diff., need sugar)
proc gtk_model_button_new(): TransferNone[TModelButton] {.cdecl, dynlib: lib, importc: "gtk_model_button_new".}
proc new_modelbutton*(): ModelButton {.inline.} =
  wrap(gtk_model_button_new())
# proc new_modelbutton*(): ModelButton {.inline.} =

# initializer for MountOperation: gtk_mount_operation_get_type
proc gtk_mount_operation_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_mount_operation_get_type".}
template gtype*(klass_parameter: typedesc[MountOperation]): GType = gtk_mount_operation_get_type()
# gtk_mount_operation_new
# flags: {isConstructor} container: MountOperation
# need sugar: is static method
# arg parent: INTERFACE (OBJECT) 'Window' 'ptr TWindow' IN (diff., need sugar)
# return: INTERFACE 'MountOperation' 'TransferFull[TMountOperation]' (diff., need sugar)
proc gtk_mount_operation_new(parent: ptr TWindow): TransferFull[TMountOperation] {.cdecl, dynlib: lib, importc: "gtk_mount_operation_new".}
proc new_mountoperation*(parent: Window): MountOperation {.inline.} =
  wrap(gtk_mount_operation_new(parent.getPointer))
# proc new_mountoperation*(parent: Window): MountOperation {.inline.} =

# gtk_mount_operation_get_parent
# flags: {isMethod} container: MountOperation
# need sugar: is method
# return: INTERFACE 'Window' 'TransferNone[TWindow]' (diff., need sugar)
proc gtk_mount_operation_get_parent(self: ptr TMountOperation): TransferNone[TWindow] {.cdecl, dynlib: lib, importc: "gtk_mount_operation_get_parent".}
proc get_parent*(self: MountOperation): Window {.inline.} =
  wrap(gtk_mount_operation_get_parent(self))
# proc get_parent*(self: MountOperation): Window {.inline.} =

# gtk_mount_operation_get_screen
# flags: {isMethod} container: MountOperation
# need sugar: is method
# return: INTERFACE 'Gdk3.Screen' 'TransferNone[Gdk3.TScreen]' (diff., need sugar)
proc gtk_mount_operation_get_screen(self: ptr TMountOperation): TransferNone[Gdk3.TScreen] {.cdecl, dynlib: lib, importc: "gtk_mount_operation_get_screen".}
proc get_screen*(self: MountOperation): Gdk3.Screen {.inline.} =
  wrap(gtk_mount_operation_get_screen(self))
# proc get_screen*(self: MountOperation): Gdk3.Screen {.inline.} =

# gtk_mount_operation_is_showing
# flags: {isMethod} container: MountOperation
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_mount_operation_is_showing(self: ptr TMountOperation): bool {.cdecl, dynlib: lib, importc: "gtk_mount_operation_is_showing".}
proc is_showing*(self: MountOperation): bool {.inline.} =
  gtk_mount_operation_is_showing(self)
# proc is_showing*(self: MountOperation): bool {.inline.} =

# gtk_mount_operation_set_parent
# flags: {isMethod} container: MountOperation
# need sugar: is method
# arg parent: INTERFACE (OBJECT) 'Window' 'ptr TWindow' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_mount_operation_set_parent(self: ptr TMountOperation, parent: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_mount_operation_set_parent".}
proc set_parent*(self: MountOperation, parent: Window) {.inline.} =
  gtk_mount_operation_set_parent(self, parent.getPointer)
# proc set_parent*(self: MountOperation, parent: Window) {.inline.} =

# gtk_mount_operation_set_screen
# flags: {isMethod} container: MountOperation
# need sugar: is method
# arg screen: INTERFACE (OBJECT) 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_mount_operation_set_screen(self: ptr TMountOperation, screen: ptr Gdk3.TScreen) {.cdecl, dynlib: lib, importc: "gtk_mount_operation_set_screen".}
proc set_screen*(self: MountOperation, screen: Gdk3.Screen) {.inline.} =
  gtk_mount_operation_set_screen(self, screen.getPointer)
# proc set_screen*(self: MountOperation, screen: Gdk3.Screen) {.inline.} =

# initializer for Notebook: gtk_notebook_get_type
proc gtk_notebook_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_notebook_get_type".}
template gtype*(klass_parameter: typedesc[Notebook]): GType = gtk_notebook_get_type()
# gtk_notebook_new
# flags: {isConstructor} container: Notebook
# need sugar: is static method
# return: INTERFACE 'Notebook' 'TransferNone[TNotebook]' (diff., need sugar)
proc gtk_notebook_new(): TransferNone[TNotebook] {.cdecl, dynlib: lib, importc: "gtk_notebook_new".}
proc new_notebook*(): Notebook {.inline.} =
  wrap(gtk_notebook_new())
# proc new_notebook*(): Notebook {.inline.} =

# gtk_notebook_append_page
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg tab_label: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: INT32 'int32' 'int32'
proc gtk_notebook_append_page(self: ptr TNotebook, child: ptr TWidget, tab_label: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_notebook_append_page".}
proc append_page*(self: Notebook, child: Widget, tab_label: Widget): int32 {.inline.} =
  gtk_notebook_append_page(self, child.getPointer, tab_label.getPointer)
# proc append_page*(self: Notebook, child: Widget, tab_label: Widget): int32 {.inline.} =

# gtk_notebook_append_page_menu
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg tab_label: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg menu_label: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: INT32 'int32' 'int32'
proc gtk_notebook_append_page_menu(self: ptr TNotebook, child: ptr TWidget, tab_label: ptr TWidget, menu_label: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_notebook_append_page_menu".}
proc append_page_menu*(self: Notebook, child: Widget, tab_label: Widget, menu_label: Widget): int32 {.inline.} =
  gtk_notebook_append_page_menu(self, child.getPointer, tab_label.getPointer, menu_label.getPointer)
# proc append_page_menu*(self: Notebook, child: Widget, tab_label: Widget, menu_label: Widget): int32 {.inline.} =

# gtk_notebook_detach_tab
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_detach_tab(self: ptr TNotebook, child: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_notebook_detach_tab".}
proc detach_tab*(self: Notebook, child: Widget) {.inline.} =
  gtk_notebook_detach_tab(self, child.getPointer)
# proc detach_tab*(self: Notebook, child: Widget) {.inline.} =

# gtk_notebook_get_action_widget
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg pack_type: INTERFACE (ENUM) 'PackType' 'PackType' IN
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_notebook_get_action_widget(self: ptr TNotebook, pack_type: PackType): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_notebook_get_action_widget".}
proc get_action_widget*(self: Notebook, pack_type: PackType): Widget {.inline.} =
  wrap(gtk_notebook_get_action_widget(self, pack_type))
# proc get_action_widget*(self: Notebook, pack_type: PackType): Widget {.inline.} =

# gtk_notebook_get_current_page
# flags: {isMethod} container: Notebook
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_notebook_get_current_page(self: ptr TNotebook): int32 {.cdecl, dynlib: lib, importc: "gtk_notebook_get_current_page".}
proc get_current_page*(self: Notebook): int32 {.inline.} =
  gtk_notebook_get_current_page(self)
# proc get_current_page*(self: Notebook): int32 {.inline.} =

# gtk_notebook_get_group_name
# flags: {isMethod} container: Notebook
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_notebook_get_group_name(self: ptr TNotebook): ucstring {.cdecl, dynlib: lib, importc: "gtk_notebook_get_group_name".}
proc get_group_name*(self: Notebook): ucstring {.inline.} =
  gtk_notebook_get_group_name(self)
# proc get_group_name*(self: Notebook): ucstring {.inline.} =

# gtk_notebook_get_menu_label
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_notebook_get_menu_label(self: ptr TNotebook, child: ptr TWidget): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_notebook_get_menu_label".}
proc get_menu_label*(self: Notebook, child: Widget): Widget {.inline.} =
  wrap(gtk_notebook_get_menu_label(self, child.getPointer))
# proc get_menu_label*(self: Notebook, child: Widget): Widget {.inline.} =

# gtk_notebook_get_menu_label_text
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: UTF8 'ucstring' 'ucstring'
proc gtk_notebook_get_menu_label_text(self: ptr TNotebook, child: ptr TWidget): ucstring {.cdecl, dynlib: lib, importc: "gtk_notebook_get_menu_label_text".}
proc get_menu_label_text*(self: Notebook, child: Widget): ucstring {.inline.} =
  gtk_notebook_get_menu_label_text(self, child.getPointer)
# proc get_menu_label_text*(self: Notebook, child: Widget): ucstring {.inline.} =

# gtk_notebook_get_n_pages
# flags: {isMethod} container: Notebook
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_notebook_get_n_pages(self: ptr TNotebook): int32 {.cdecl, dynlib: lib, importc: "gtk_notebook_get_n_pages".}
proc get_n_pages*(self: Notebook): int32 {.inline.} =
  gtk_notebook_get_n_pages(self)
# proc get_n_pages*(self: Notebook): int32 {.inline.} =

# gtk_notebook_get_nth_page
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg page_num: INT32 'int32' 'int32' IN
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_notebook_get_nth_page(self: ptr TNotebook, page_num: int32): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_notebook_get_nth_page".}
proc get_nth_page*(self: Notebook, page_num: int32): Widget {.inline.} =
  wrap(gtk_notebook_get_nth_page(self, page_num))
# proc get_nth_page*(self: Notebook, page_num: int32): Widget {.inline.} =

# gtk_notebook_get_scrollable
# flags: {isMethod} container: Notebook
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_notebook_get_scrollable(self: ptr TNotebook): bool {.cdecl, dynlib: lib, importc: "gtk_notebook_get_scrollable".}
proc get_scrollable*(self: Notebook): bool {.inline.} =
  gtk_notebook_get_scrollable(self)
# proc get_scrollable*(self: Notebook): bool {.inline.} =

# gtk_notebook_get_show_border
# flags: {isMethod} container: Notebook
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_notebook_get_show_border(self: ptr TNotebook): bool {.cdecl, dynlib: lib, importc: "gtk_notebook_get_show_border".}
proc get_show_border*(self: Notebook): bool {.inline.} =
  gtk_notebook_get_show_border(self)
# proc get_show_border*(self: Notebook): bool {.inline.} =

# gtk_notebook_get_show_tabs
# flags: {isMethod} container: Notebook
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_notebook_get_show_tabs(self: ptr TNotebook): bool {.cdecl, dynlib: lib, importc: "gtk_notebook_get_show_tabs".}
proc get_show_tabs*(self: Notebook): bool {.inline.} =
  gtk_notebook_get_show_tabs(self)
# proc get_show_tabs*(self: Notebook): bool {.inline.} =

# gtk_notebook_get_tab_detachable
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_notebook_get_tab_detachable(self: ptr TNotebook, child: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_notebook_get_tab_detachable".}
proc get_tab_detachable*(self: Notebook, child: Widget): bool {.inline.} =
  gtk_notebook_get_tab_detachable(self, child.getPointer)
# proc get_tab_detachable*(self: Notebook, child: Widget): bool {.inline.} =

# gtk_notebook_get_tab_hborder
# flags: {isMethod} container: Notebook (deprecated)
# gtk_notebook_get_tab_label
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_notebook_get_tab_label(self: ptr TNotebook, child: ptr TWidget): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_notebook_get_tab_label".}
proc get_tab_label*(self: Notebook, child: Widget): Widget {.inline.} =
  wrap(gtk_notebook_get_tab_label(self, child.getPointer))
# proc get_tab_label*(self: Notebook, child: Widget): Widget {.inline.} =

# gtk_notebook_get_tab_label_text
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: UTF8 'ucstring' 'ucstring'
proc gtk_notebook_get_tab_label_text(self: ptr TNotebook, child: ptr TWidget): ucstring {.cdecl, dynlib: lib, importc: "gtk_notebook_get_tab_label_text".}
proc get_tab_label_text*(self: Notebook, child: Widget): ucstring {.inline.} =
  gtk_notebook_get_tab_label_text(self, child.getPointer)
# proc get_tab_label_text*(self: Notebook, child: Widget): ucstring {.inline.} =

# gtk_notebook_get_tab_pos
# flags: {isMethod} container: Notebook
# need sugar: is method
# return: INTERFACE 'PositionType' 'PositionType'
proc gtk_notebook_get_tab_pos(self: ptr TNotebook): PositionType {.cdecl, dynlib: lib, importc: "gtk_notebook_get_tab_pos".}
proc get_tab_pos*(self: Notebook): PositionType {.inline.} =
  gtk_notebook_get_tab_pos(self)
# proc get_tab_pos*(self: Notebook): PositionType {.inline.} =

# gtk_notebook_get_tab_reorderable
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_notebook_get_tab_reorderable(self: ptr TNotebook, child: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_notebook_get_tab_reorderable".}
proc get_tab_reorderable*(self: Notebook, child: Widget): bool {.inline.} =
  gtk_notebook_get_tab_reorderable(self, child.getPointer)
# proc get_tab_reorderable*(self: Notebook, child: Widget): bool {.inline.} =

# gtk_notebook_get_tab_vborder
# flags: {isMethod} container: Notebook (deprecated)
# gtk_notebook_insert_page
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg tab_label: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg position: INT32 'int32' 'int32' IN
# return: INT32 'int32' 'int32'
proc gtk_notebook_insert_page(self: ptr TNotebook, child: ptr TWidget, tab_label: ptr TWidget, position: int32): int32 {.cdecl, dynlib: lib, importc: "gtk_notebook_insert_page".}
proc insert_page*(self: Notebook, child: Widget, tab_label: Widget, position: int32): int32 {.inline.} =
  gtk_notebook_insert_page(self, child.getPointer, tab_label.getPointer, position)
# proc insert_page*(self: Notebook, child: Widget, tab_label: Widget, position: int32): int32 {.inline.} =

# gtk_notebook_insert_page_menu
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg tab_label: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg menu_label: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg position: INT32 'int32' 'int32' IN
# return: INT32 'int32' 'int32'
proc gtk_notebook_insert_page_menu(self: ptr TNotebook, child: ptr TWidget, tab_label: ptr TWidget, menu_label: ptr TWidget, position: int32): int32 {.cdecl, dynlib: lib, importc: "gtk_notebook_insert_page_menu".}
proc insert_page_menu*(self: Notebook, child: Widget, tab_label: Widget, menu_label: Widget, position: int32): int32 {.inline.} =
  gtk_notebook_insert_page_menu(self, child.getPointer, tab_label.getPointer, menu_label.getPointer, position)
# proc insert_page_menu*(self: Notebook, child: Widget, tab_label: Widget, menu_label: Widget, position: int32): int32 {.inline.} =

# gtk_notebook_next_page
# flags: {isMethod} container: Notebook
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_next_page(self: ptr TNotebook) {.cdecl, dynlib: lib, importc: "gtk_notebook_next_page".}
proc next_page*(self: Notebook) {.inline.} =
  gtk_notebook_next_page(self)
# proc next_page*(self: Notebook) {.inline.} =

# gtk_notebook_page_num
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: INT32 'int32' 'int32'
proc gtk_notebook_page_num(self: ptr TNotebook, child: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_notebook_page_num".}
proc page_num*(self: Notebook, child: Widget): int32 {.inline.} =
  gtk_notebook_page_num(self, child.getPointer)
# proc page_num*(self: Notebook, child: Widget): int32 {.inline.} =

# gtk_notebook_popup_disable
# flags: {isMethod} container: Notebook
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_popup_disable(self: ptr TNotebook) {.cdecl, dynlib: lib, importc: "gtk_notebook_popup_disable".}
proc popup_disable*(self: Notebook) {.inline.} =
  gtk_notebook_popup_disable(self)
# proc popup_disable*(self: Notebook) {.inline.} =

# gtk_notebook_popup_enable
# flags: {isMethod} container: Notebook
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_popup_enable(self: ptr TNotebook) {.cdecl, dynlib: lib, importc: "gtk_notebook_popup_enable".}
proc popup_enable*(self: Notebook) {.inline.} =
  gtk_notebook_popup_enable(self)
# proc popup_enable*(self: Notebook) {.inline.} =

# gtk_notebook_prepend_page
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg tab_label: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: INT32 'int32' 'int32'
proc gtk_notebook_prepend_page(self: ptr TNotebook, child: ptr TWidget, tab_label: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_notebook_prepend_page".}
proc prepend_page*(self: Notebook, child: Widget, tab_label: Widget): int32 {.inline.} =
  gtk_notebook_prepend_page(self, child.getPointer, tab_label.getPointer)
# proc prepend_page*(self: Notebook, child: Widget, tab_label: Widget): int32 {.inline.} =

# gtk_notebook_prepend_page_menu
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg tab_label: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg menu_label: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: INT32 'int32' 'int32'
proc gtk_notebook_prepend_page_menu(self: ptr TNotebook, child: ptr TWidget, tab_label: ptr TWidget, menu_label: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_notebook_prepend_page_menu".}
proc prepend_page_menu*(self: Notebook, child: Widget, tab_label: Widget, menu_label: Widget): int32 {.inline.} =
  gtk_notebook_prepend_page_menu(self, child.getPointer, tab_label.getPointer, menu_label.getPointer)
# proc prepend_page_menu*(self: Notebook, child: Widget, tab_label: Widget, menu_label: Widget): int32 {.inline.} =

# gtk_notebook_prev_page
# flags: {isMethod} container: Notebook
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_prev_page(self: ptr TNotebook) {.cdecl, dynlib: lib, importc: "gtk_notebook_prev_page".}
proc prev_page*(self: Notebook) {.inline.} =
  gtk_notebook_prev_page(self)
# proc prev_page*(self: Notebook) {.inline.} =

# gtk_notebook_remove_page
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg page_num: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_remove_page(self: ptr TNotebook, page_num: int32) {.cdecl, dynlib: lib, importc: "gtk_notebook_remove_page".}
proc remove_page*(self: Notebook, page_num: int32) {.inline.} =
  gtk_notebook_remove_page(self, page_num)
# proc remove_page*(self: Notebook, page_num: int32) {.inline.} =

# gtk_notebook_reorder_child
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg position: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_reorder_child(self: ptr TNotebook, child: ptr TWidget, position: int32) {.cdecl, dynlib: lib, importc: "gtk_notebook_reorder_child".}
proc reorder_child*(self: Notebook, child: Widget, position: int32) {.inline.} =
  gtk_notebook_reorder_child(self, child.getPointer, position)
# proc reorder_child*(self: Notebook, child: Widget, position: int32) {.inline.} =

# gtk_notebook_set_action_widget
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg pack_type: INTERFACE (ENUM) 'PackType' 'PackType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_set_action_widget(self: ptr TNotebook, widget: ptr TWidget, pack_type: PackType) {.cdecl, dynlib: lib, importc: "gtk_notebook_set_action_widget".}
proc set_action_widget*(self: Notebook, widget: Widget, pack_type: PackType) {.inline.} =
  gtk_notebook_set_action_widget(self, widget.getPointer, pack_type)
# proc set_action_widget*(self: Notebook, widget: Widget, pack_type: PackType) {.inline.} =

# gtk_notebook_set_current_page
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg page_num: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_set_current_page(self: ptr TNotebook, page_num: int32) {.cdecl, dynlib: lib, importc: "gtk_notebook_set_current_page".}
proc set_current_page*(self: Notebook, page_num: int32) {.inline.} =
  gtk_notebook_set_current_page(self, page_num)
# proc set_current_page*(self: Notebook, page_num: int32) {.inline.} =

# gtk_notebook_set_group_name
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg group_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_set_group_name(self: ptr TNotebook, group_name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_notebook_set_group_name".}
proc set_group_name*(self: Notebook, group_name: ustring) {.inline.} =
  gtk_notebook_set_group_name(self, ucstring(group_name))
# proc set_group_name*(self: Notebook, group_name: ustring) {.inline.} =

# gtk_notebook_set_menu_label
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg menu_label: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_set_menu_label(self: ptr TNotebook, child: ptr TWidget, menu_label: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_notebook_set_menu_label".}
proc set_menu_label*(self: Notebook, child: Widget, menu_label: Widget) {.inline.} =
  gtk_notebook_set_menu_label(self, child.getPointer, menu_label.getPointer)
# proc set_menu_label*(self: Notebook, child: Widget, menu_label: Widget) {.inline.} =

# gtk_notebook_set_menu_label_text
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg menu_text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_set_menu_label_text(self: ptr TNotebook, child: ptr TWidget, menu_text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_notebook_set_menu_label_text".}
proc set_menu_label_text*(self: Notebook, child: Widget, menu_text: ustring) {.inline.} =
  gtk_notebook_set_menu_label_text(self, child.getPointer, ucstring(menu_text))
# proc set_menu_label_text*(self: Notebook, child: Widget, menu_text: ustring) {.inline.} =

# gtk_notebook_set_scrollable
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg scrollable: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_set_scrollable(self: ptr TNotebook, scrollable: bool) {.cdecl, dynlib: lib, importc: "gtk_notebook_set_scrollable".}
proc set_scrollable*(self: Notebook, scrollable: bool) {.inline.} =
  gtk_notebook_set_scrollable(self, scrollable)
# proc set_scrollable*(self: Notebook, scrollable: bool) {.inline.} =

# gtk_notebook_set_show_border
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg show_border: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_set_show_border(self: ptr TNotebook, show_border: bool) {.cdecl, dynlib: lib, importc: "gtk_notebook_set_show_border".}
proc set_show_border*(self: Notebook, show_border: bool) {.inline.} =
  gtk_notebook_set_show_border(self, show_border)
# proc set_show_border*(self: Notebook, show_border: bool) {.inline.} =

# gtk_notebook_set_show_tabs
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg show_tabs: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_set_show_tabs(self: ptr TNotebook, show_tabs: bool) {.cdecl, dynlib: lib, importc: "gtk_notebook_set_show_tabs".}
proc set_show_tabs*(self: Notebook, show_tabs: bool) {.inline.} =
  gtk_notebook_set_show_tabs(self, show_tabs)
# proc set_show_tabs*(self: Notebook, show_tabs: bool) {.inline.} =

# gtk_notebook_set_tab_detachable
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg detachable: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_set_tab_detachable(self: ptr TNotebook, child: ptr TWidget, detachable: bool) {.cdecl, dynlib: lib, importc: "gtk_notebook_set_tab_detachable".}
proc set_tab_detachable*(self: Notebook, child: Widget, detachable: bool) {.inline.} =
  gtk_notebook_set_tab_detachable(self, child.getPointer, detachable)
# proc set_tab_detachable*(self: Notebook, child: Widget, detachable: bool) {.inline.} =

# gtk_notebook_set_tab_label
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg tab_label: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_set_tab_label(self: ptr TNotebook, child: ptr TWidget, tab_label: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_notebook_set_tab_label".}
proc set_tab_label*(self: Notebook, child: Widget, tab_label: Widget) {.inline.} =
  gtk_notebook_set_tab_label(self, child.getPointer, tab_label.getPointer)
# proc set_tab_label*(self: Notebook, child: Widget, tab_label: Widget) {.inline.} =

# gtk_notebook_set_tab_label_text
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg tab_text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_set_tab_label_text(self: ptr TNotebook, child: ptr TWidget, tab_text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_notebook_set_tab_label_text".}
proc set_tab_label_text*(self: Notebook, child: Widget, tab_text: ustring) {.inline.} =
  gtk_notebook_set_tab_label_text(self, child.getPointer, ucstring(tab_text))
# proc set_tab_label_text*(self: Notebook, child: Widget, tab_text: ustring) {.inline.} =

# gtk_notebook_set_tab_pos
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg pos: INTERFACE (ENUM) 'PositionType' 'PositionType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_set_tab_pos(self: ptr TNotebook, pos: PositionType) {.cdecl, dynlib: lib, importc: "gtk_notebook_set_tab_pos".}
proc set_tab_pos*(self: Notebook, pos: PositionType) {.inline.} =
  gtk_notebook_set_tab_pos(self, pos)
# proc set_tab_pos*(self: Notebook, pos: PositionType) {.inline.} =

# gtk_notebook_set_tab_reorderable
# flags: {isMethod} container: Notebook
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg reorderable: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_set_tab_reorderable(self: ptr TNotebook, child: ptr TWidget, reorderable: bool) {.cdecl, dynlib: lib, importc: "gtk_notebook_set_tab_reorderable".}
proc set_tab_reorderable*(self: Notebook, child: Widget, reorderable: bool) {.inline.} =
  gtk_notebook_set_tab_reorderable(self, child.getPointer, reorderable)
# proc set_tab_reorderable*(self: Notebook, child: Widget, reorderable: bool) {.inline.} =

# initializer for NotebookAccessible: gtk_notebook_accessible_get_type
proc gtk_notebook_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_notebook_accessible_get_type".}
template gtype*(klass_parameter: typedesc[NotebookAccessible]): GType = gtk_notebook_accessible_get_type()
# initializer for NotebookPageAccessible: gtk_notebook_page_accessible_get_type
proc gtk_notebook_page_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_notebook_page_accessible_get_type".}
template gtype*(klass_parameter: typedesc[NotebookPageAccessible]): GType = gtk_notebook_page_accessible_get_type()
# gtk_notebook_page_accessible_new
# flags: {isConstructor} container: NotebookPageAccessible
# need sugar: is static method
# arg notebook: INTERFACE (OBJECT) 'NotebookAccessible' 'ptr TNotebookAccessible' IN (diff., need sugar)
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: INTERFACE 'NotebookPageAccessible' 'TransferFull[TNotebookPageAccessible]' (diff., need sugar)
proc gtk_notebook_page_accessible_new(notebook: ptr TNotebookAccessible, child: ptr TWidget): TransferFull[TNotebookPageAccessible] {.cdecl, dynlib: lib, importc: "gtk_notebook_page_accessible_new".}
proc new_notebookpageaccessible*(notebook: NotebookAccessible, child: Widget): NotebookPageAccessible {.inline.} =
  wrap(gtk_notebook_page_accessible_new(notebook.getPointer, child.getPointer))
# proc new_notebookpageaccessible*(notebook: NotebookAccessible, child: Widget): NotebookPageAccessible {.inline.} =

# gtk_notebook_page_accessible_invalidate
# flags: {isMethod} container: NotebookPageAccessible
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_notebook_page_accessible_invalidate(self: ptr TNotebookPageAccessible) {.cdecl, dynlib: lib, importc: "gtk_notebook_page_accessible_invalidate".}
proc invalidate*(self: NotebookPageAccessible) {.inline.} =
  gtk_notebook_page_accessible_invalidate(self)
# proc invalidate*(self: NotebookPageAccessible) {.inline.} =

# initializer for NumerableIcon: gtk_numerable_icon_get_type
proc gtk_numerable_icon_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_numerable_icon_get_type".}
template gtype*(klass_parameter: typedesc[NumerableIcon]): GType = gtk_numerable_icon_get_type()
# gtk_numerable_icon_new
# flags: {} container: NumerableIcon (deprecated)
# gtk_numerable_icon_new_with_style_context
# flags: {} container: NumerableIcon (deprecated)
# gtk_numerable_icon_get_background_gicon
# flags: {isMethod} container: NumerableIcon (deprecated)
# gtk_numerable_icon_get_background_icon_name
# flags: {isMethod} container: NumerableIcon (deprecated)
# gtk_numerable_icon_get_count
# flags: {isMethod} container: NumerableIcon (deprecated)
# gtk_numerable_icon_get_label
# flags: {isMethod} container: NumerableIcon (deprecated)
# gtk_numerable_icon_get_style_context
# flags: {isMethod} container: NumerableIcon (deprecated)
# gtk_numerable_icon_set_background_gicon
# flags: {isMethod} container: NumerableIcon (deprecated)
# gtk_numerable_icon_set_background_icon_name
# flags: {isMethod} container: NumerableIcon (deprecated)
# gtk_numerable_icon_set_count
# flags: {isMethod} container: NumerableIcon (deprecated)
# gtk_numerable_icon_set_label
# flags: {isMethod} container: NumerableIcon (deprecated)
# gtk_numerable_icon_set_style_context
# flags: {isMethod} container: NumerableIcon (deprecated)
# initializer for OffscreenWindow: gtk_offscreen_window_get_type
proc gtk_offscreen_window_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_offscreen_window_get_type".}
template gtype*(klass_parameter: typedesc[OffscreenWindow]): GType = gtk_offscreen_window_get_type()
# gtk_offscreen_window_new
# flags: {isConstructor} container: OffscreenWindow
# need sugar: is static method
# return: INTERFACE 'OffscreenWindow' 'TransferNone[TOffscreenWindow]' (diff., need sugar)
proc gtk_offscreen_window_new(): TransferNone[TOffscreenWindow] {.cdecl, dynlib: lib, importc: "gtk_offscreen_window_new".}
proc new_offscreenwindow*(): OffscreenWindow {.inline.} =
  wrap(gtk_offscreen_window_new())
# proc new_offscreenwindow*(): OffscreenWindow {.inline.} =

# gtk_offscreen_window_get_pixbuf
# flags: {isMethod} container: OffscreenWindow
# need sugar: is method
# return: INTERFACE 'GdkPixbuf2.Pixbuf' 'TransferFull[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_offscreen_window_get_pixbuf(self: ptr TOffscreenWindow): TransferFull[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_offscreen_window_get_pixbuf".}
proc get_pixbuf*(self: OffscreenWindow): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_offscreen_window_get_pixbuf(self))
# proc get_pixbuf*(self: OffscreenWindow): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_offscreen_window_get_surface
# flags: {isMethod} container: OffscreenWindow
# need sugar: is method
# return: INTERFACE 'ptr cairo1.TSurface' 'ptr cairo1.TSurface'
proc gtk_offscreen_window_get_surface(self: ptr TOffscreenWindow): ptr cairo1.TSurface {.cdecl, dynlib: lib, importc: "gtk_offscreen_window_get_surface".}
proc get_surface*(self: OffscreenWindow): ptr cairo1.TSurface {.inline.} =
  gtk_offscreen_window_get_surface(self)
# proc get_surface*(self: OffscreenWindow): ptr cairo1.TSurface {.inline.} =

# initializer for Overlay: gtk_overlay_get_type
proc gtk_overlay_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_overlay_get_type".}
template gtype*(klass_parameter: typedesc[Overlay]): GType = gtk_overlay_get_type()
# gtk_overlay_new
# flags: {isConstructor} container: Overlay
# need sugar: is static method
# return: INTERFACE 'Overlay' 'TransferNone[TOverlay]' (diff., need sugar)
proc gtk_overlay_new(): TransferNone[TOverlay] {.cdecl, dynlib: lib, importc: "gtk_overlay_new".}
proc new_overlay*(): Overlay {.inline.} =
  wrap(gtk_overlay_new())
# proc new_overlay*(): Overlay {.inline.} =

# gtk_overlay_add_overlay
# flags: {isMethod} container: Overlay
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_overlay_add_overlay(self: ptr TOverlay, widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_overlay_add_overlay".}
proc add_overlay*(self: Overlay, widget: Widget) {.inline.} =
  gtk_overlay_add_overlay(self, widget.getPointer)
# proc add_overlay*(self: Overlay, widget: Widget) {.inline.} =

# gtk_overlay_get_overlay_pass_through
# flags: {isMethod} container: Overlay
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_overlay_get_overlay_pass_through(self: ptr TOverlay, widget: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_overlay_get_overlay_pass_through".}
proc get_overlay_pass_through*(self: Overlay, widget: Widget): bool {.inline.} =
  gtk_overlay_get_overlay_pass_through(self, widget.getPointer)
# proc get_overlay_pass_through*(self: Overlay, widget: Widget): bool {.inline.} =

# gtk_overlay_reorder_overlay
# flags: {isMethod} container: Overlay
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg position: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_overlay_reorder_overlay(self: ptr TOverlay, child: ptr TWidget, position: int32) {.cdecl, dynlib: lib, importc: "gtk_overlay_reorder_overlay".}
proc reorder_overlay*(self: Overlay, child: Widget, position: int32) {.inline.} =
  gtk_overlay_reorder_overlay(self, child.getPointer, position)
# proc reorder_overlay*(self: Overlay, child: Widget, position: int32) {.inline.} =

# gtk_overlay_set_overlay_pass_through
# flags: {isMethod} container: Overlay
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg pass_through: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_overlay_set_overlay_pass_through(self: ptr TOverlay, widget: ptr TWidget, pass_through: bool) {.cdecl, dynlib: lib, importc: "gtk_overlay_set_overlay_pass_through".}
proc set_overlay_pass_through*(self: Overlay, widget: Widget, pass_through: bool) {.inline.} =
  gtk_overlay_set_overlay_pass_through(self, widget.getPointer, pass_through)
# proc set_overlay_pass_through*(self: Overlay, widget: Widget, pass_through: bool) {.inline.} =

# initializer for PageSetup: gtk_page_setup_get_type
proc gtk_page_setup_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_page_setup_get_type".}
template gtype*(klass_parameter: typedesc[PageSetup]): GType = gtk_page_setup_get_type()
# gtk_page_setup_new
# flags: {isConstructor} container: PageSetup
# need sugar: is static method
# return: INTERFACE 'PageSetup' 'TransferFull[TPageSetup]' (diff., need sugar)
proc gtk_page_setup_new(): TransferFull[TPageSetup] {.cdecl, dynlib: lib, importc: "gtk_page_setup_new".}
proc new_pagesetup*(): PageSetup {.inline.} =
  wrap(gtk_page_setup_new())
# proc new_pagesetup*(): PageSetup {.inline.} =

# gtk_page_setup_new_from_file
# flags: {isConstructor, throws} container: PageSetup
# can throw
# need sugar: is static method
# arg file_name: FILENAME 'string' 'cstring' IN (diff., need sugar)
# return: INTERFACE 'PageSetup' 'TransferFull[TPageSetup]' (diff., need sugar)
proc gtk_page_setup_new_from_file(file_name: cstring, error: ptr PGError=nil): TransferFull[TPageSetup] {.cdecl, dynlib: lib, importc: "gtk_page_setup_new_from_file".}
proc new_pagesetup_from_file*(file_name: string): PageSetup {.inline.} =
  wrap(gtk_page_setup_new_from_file(cstring(file_name)))
# proc new_pagesetup_from_file*(file_name: string): PageSetup {.inline.} =

# gtk_page_setup_new_from_key_file
# flags: {isConstructor, throws} container: PageSetup
# can throw
# need sugar: is static method
# arg key_file: INTERFACE (STRUCT) 'ptr GLib2.TKeyFile' 'ptr GLib2.TKeyFile' IN
# arg group_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'PageSetup' 'TransferFull[TPageSetup]' (diff., need sugar)
proc gtk_page_setup_new_from_key_file(key_file: ptr GLib2.TKeyFile, group_name: ucstring, error: ptr PGError=nil): TransferFull[TPageSetup] {.cdecl, dynlib: lib, importc: "gtk_page_setup_new_from_key_file".}
proc new_pagesetup_from_key_file*(key_file: ptr GLib2.TKeyFile, group_name: ustring): PageSetup {.inline.} =
  wrap(gtk_page_setup_new_from_key_file(key_file, ucstring(group_name)))
# proc new_pagesetup_from_key_file*(key_file: ptr GLib2.TKeyFile, group_name: ustring): PageSetup {.inline.} =

# gtk_page_setup_copy
# flags: {isMethod} container: PageSetup
# need sugar: is method
# return: INTERFACE 'PageSetup' 'TransferFull[TPageSetup]' (diff., need sugar)
proc gtk_page_setup_copy(self: ptr TPageSetup): TransferFull[TPageSetup] {.cdecl, dynlib: lib, importc: "gtk_page_setup_copy".}
proc copy*(self: PageSetup): PageSetup {.inline.} =
  wrap(gtk_page_setup_copy(self))
# proc copy*(self: PageSetup): PageSetup {.inline.} =

# gtk_page_setup_get_bottom_margin
# flags: {isMethod} container: PageSetup
# need sugar: is method
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: DOUBLE 'float64' 'float64'
proc gtk_page_setup_get_bottom_margin(self: ptr TPageSetup, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_page_setup_get_bottom_margin".}
proc get_bottom_margin*(self: PageSetup, unit: Unit): float64 {.inline.} =
  gtk_page_setup_get_bottom_margin(self, unit)
# proc get_bottom_margin*(self: PageSetup, unit: Unit): float64 {.inline.} =

# gtk_page_setup_get_left_margin
# flags: {isMethod} container: PageSetup
# need sugar: is method
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: DOUBLE 'float64' 'float64'
proc gtk_page_setup_get_left_margin(self: ptr TPageSetup, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_page_setup_get_left_margin".}
proc get_left_margin*(self: PageSetup, unit: Unit): float64 {.inline.} =
  gtk_page_setup_get_left_margin(self, unit)
# proc get_left_margin*(self: PageSetup, unit: Unit): float64 {.inline.} =

# gtk_page_setup_get_orientation
# flags: {isMethod} container: PageSetup
# need sugar: is method
# return: INTERFACE 'PageOrientation' 'PageOrientation'
proc gtk_page_setup_get_orientation(self: ptr TPageSetup): PageOrientation {.cdecl, dynlib: lib, importc: "gtk_page_setup_get_orientation".}
proc get_orientation*(self: PageSetup): PageOrientation {.inline.} =
  gtk_page_setup_get_orientation(self)
# proc get_orientation*(self: PageSetup): PageOrientation {.inline.} =

# gtk_page_setup_get_page_height
# flags: {isMethod} container: PageSetup
# need sugar: is method
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: DOUBLE 'float64' 'float64'
proc gtk_page_setup_get_page_height(self: ptr TPageSetup, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_page_setup_get_page_height".}
proc get_page_height*(self: PageSetup, unit: Unit): float64 {.inline.} =
  gtk_page_setup_get_page_height(self, unit)
# proc get_page_height*(self: PageSetup, unit: Unit): float64 {.inline.} =

# gtk_page_setup_get_page_width
# flags: {isMethod} container: PageSetup
# need sugar: is method
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: DOUBLE 'float64' 'float64'
proc gtk_page_setup_get_page_width(self: ptr TPageSetup, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_page_setup_get_page_width".}
proc get_page_width*(self: PageSetup, unit: Unit): float64 {.inline.} =
  gtk_page_setup_get_page_width(self, unit)
# proc get_page_width*(self: PageSetup, unit: Unit): float64 {.inline.} =

# gtk_page_setup_get_paper_height
# flags: {isMethod} container: PageSetup
# need sugar: is method
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: DOUBLE 'float64' 'float64'
proc gtk_page_setup_get_paper_height(self: ptr TPageSetup, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_page_setup_get_paper_height".}
proc get_paper_height*(self: PageSetup, unit: Unit): float64 {.inline.} =
  gtk_page_setup_get_paper_height(self, unit)
# proc get_paper_height*(self: PageSetup, unit: Unit): float64 {.inline.} =

# gtk_page_setup_get_paper_size
# flags: {isMethod} container: PageSetup
# need sugar: is method
# return: INTERFACE 'ptr TPaperSize' 'ptr TPaperSize'
proc gtk_page_setup_get_paper_size(self: ptr TPageSetup): ptr TPaperSize {.cdecl, dynlib: lib, importc: "gtk_page_setup_get_paper_size".}
proc get_paper_size*(self: PageSetup): ptr TPaperSize {.inline.} =
  gtk_page_setup_get_paper_size(self)
# proc get_paper_size*(self: PageSetup): ptr TPaperSize {.inline.} =

# gtk_page_setup_get_paper_width
# flags: {isMethod} container: PageSetup
# need sugar: is method
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: DOUBLE 'float64' 'float64'
proc gtk_page_setup_get_paper_width(self: ptr TPageSetup, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_page_setup_get_paper_width".}
proc get_paper_width*(self: PageSetup, unit: Unit): float64 {.inline.} =
  gtk_page_setup_get_paper_width(self, unit)
# proc get_paper_width*(self: PageSetup, unit: Unit): float64 {.inline.} =

# gtk_page_setup_get_right_margin
# flags: {isMethod} container: PageSetup
# need sugar: is method
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: DOUBLE 'float64' 'float64'
proc gtk_page_setup_get_right_margin(self: ptr TPageSetup, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_page_setup_get_right_margin".}
proc get_right_margin*(self: PageSetup, unit: Unit): float64 {.inline.} =
  gtk_page_setup_get_right_margin(self, unit)
# proc get_right_margin*(self: PageSetup, unit: Unit): float64 {.inline.} =

# gtk_page_setup_get_top_margin
# flags: {isMethod} container: PageSetup
# need sugar: is method
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: DOUBLE 'float64' 'float64'
proc gtk_page_setup_get_top_margin(self: ptr TPageSetup, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_page_setup_get_top_margin".}
proc get_top_margin*(self: PageSetup, unit: Unit): float64 {.inline.} =
  gtk_page_setup_get_top_margin(self, unit)
# proc get_top_margin*(self: PageSetup, unit: Unit): float64 {.inline.} =

# gtk_page_setup_load_file
# flags: {isMethod, throws} container: PageSetup
# can throw
# need sugar: is method
# arg file_name: FILENAME 'string' 'cstring' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_page_setup_load_file(self: ptr TPageSetup, file_name: cstring, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_page_setup_load_file".}
proc load_file*(self: PageSetup, file_name: string): bool {.inline.} =
  gtk_page_setup_load_file(self, cstring(file_name))
# proc load_file*(self: PageSetup, file_name: string): bool {.inline.} =

# gtk_page_setup_load_key_file
# flags: {isMethod, throws} container: PageSetup
# can throw
# need sugar: is method
# arg key_file: INTERFACE (STRUCT) 'ptr GLib2.TKeyFile' 'ptr GLib2.TKeyFile' IN
# arg group_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_page_setup_load_key_file(self: ptr TPageSetup, key_file: ptr GLib2.TKeyFile, group_name: ucstring, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_page_setup_load_key_file".}
proc load_key_file*(self: PageSetup, key_file: ptr GLib2.TKeyFile, group_name: ustring): bool {.inline.} =
  gtk_page_setup_load_key_file(self, key_file, ucstring(group_name))
# proc load_key_file*(self: PageSetup, key_file: ptr GLib2.TKeyFile, group_name: ustring): bool {.inline.} =

# gtk_page_setup_set_bottom_margin
# flags: {isMethod} container: PageSetup
# need sugar: is method
# arg margin: DOUBLE 'float64' 'float64' IN
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_page_setup_set_bottom_margin(self: ptr TPageSetup, margin: float64, unit: Unit) {.cdecl, dynlib: lib, importc: "gtk_page_setup_set_bottom_margin".}
proc set_bottom_margin*(self: PageSetup, margin: float64, unit: Unit) {.inline.} =
  gtk_page_setup_set_bottom_margin(self, margin, unit)
# proc set_bottom_margin*(self: PageSetup, margin: float64, unit: Unit) {.inline.} =

# gtk_page_setup_set_left_margin
# flags: {isMethod} container: PageSetup
# need sugar: is method
# arg margin: DOUBLE 'float64' 'float64' IN
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_page_setup_set_left_margin(self: ptr TPageSetup, margin: float64, unit: Unit) {.cdecl, dynlib: lib, importc: "gtk_page_setup_set_left_margin".}
proc set_left_margin*(self: PageSetup, margin: float64, unit: Unit) {.inline.} =
  gtk_page_setup_set_left_margin(self, margin, unit)
# proc set_left_margin*(self: PageSetup, margin: float64, unit: Unit) {.inline.} =

# gtk_page_setup_set_orientation
# flags: {isMethod} container: PageSetup
# need sugar: is method
# arg orientation: INTERFACE (ENUM) 'PageOrientation' 'PageOrientation' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_page_setup_set_orientation(self: ptr TPageSetup, orientation: PageOrientation) {.cdecl, dynlib: lib, importc: "gtk_page_setup_set_orientation".}
proc set_orientation*(self: PageSetup, orientation: PageOrientation) {.inline.} =
  gtk_page_setup_set_orientation(self, orientation)
# proc set_orientation*(self: PageSetup, orientation: PageOrientation) {.inline.} =

# gtk_page_setup_set_paper_size
# flags: {isMethod} container: PageSetup
# need sugar: is method
# arg size: INTERFACE (STRUCT) 'ptr TPaperSize' 'ptr TPaperSize' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_page_setup_set_paper_size(self: ptr TPageSetup, size: ptr TPaperSize) {.cdecl, dynlib: lib, importc: "gtk_page_setup_set_paper_size".}
proc set_paper_size*(self: PageSetup, size: ptr TPaperSize) {.inline.} =
  gtk_page_setup_set_paper_size(self, size)
# proc set_paper_size*(self: PageSetup, size: ptr TPaperSize) {.inline.} =

# gtk_page_setup_set_paper_size_and_default_margins
# flags: {isMethod} container: PageSetup
# need sugar: is method
# arg size: INTERFACE (STRUCT) 'ptr TPaperSize' 'ptr TPaperSize' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_page_setup_set_paper_size_and_default_margins(self: ptr TPageSetup, size: ptr TPaperSize) {.cdecl, dynlib: lib, importc: "gtk_page_setup_set_paper_size_and_default_margins".}
proc set_paper_size_and_default_margins*(self: PageSetup, size: ptr TPaperSize) {.inline.} =
  gtk_page_setup_set_paper_size_and_default_margins(self, size)
# proc set_paper_size_and_default_margins*(self: PageSetup, size: ptr TPaperSize) {.inline.} =

# gtk_page_setup_set_right_margin
# flags: {isMethod} container: PageSetup
# need sugar: is method
# arg margin: DOUBLE 'float64' 'float64' IN
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_page_setup_set_right_margin(self: ptr TPageSetup, margin: float64, unit: Unit) {.cdecl, dynlib: lib, importc: "gtk_page_setup_set_right_margin".}
proc set_right_margin*(self: PageSetup, margin: float64, unit: Unit) {.inline.} =
  gtk_page_setup_set_right_margin(self, margin, unit)
# proc set_right_margin*(self: PageSetup, margin: float64, unit: Unit) {.inline.} =

# gtk_page_setup_set_top_margin
# flags: {isMethod} container: PageSetup
# need sugar: is method
# arg margin: DOUBLE 'float64' 'float64' IN
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_page_setup_set_top_margin(self: ptr TPageSetup, margin: float64, unit: Unit) {.cdecl, dynlib: lib, importc: "gtk_page_setup_set_top_margin".}
proc set_top_margin*(self: PageSetup, margin: float64, unit: Unit) {.inline.} =
  gtk_page_setup_set_top_margin(self, margin, unit)
# proc set_top_margin*(self: PageSetup, margin: float64, unit: Unit) {.inline.} =

# gtk_page_setup_to_file
# flags: {isMethod, throws} container: PageSetup
# can throw
# need sugar: is method
# arg file_name: FILENAME 'string' 'cstring' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_page_setup_to_file(self: ptr TPageSetup, file_name: cstring, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_page_setup_to_file".}
proc to_file*(self: PageSetup, file_name: string): bool {.inline.} =
  gtk_page_setup_to_file(self, cstring(file_name))
# proc to_file*(self: PageSetup, file_name: string): bool {.inline.} =

# gtk_page_setup_to_key_file
# flags: {isMethod} container: PageSetup
# need sugar: is method
# arg key_file: INTERFACE (STRUCT) 'ptr GLib2.TKeyFile' 'ptr GLib2.TKeyFile' IN
# arg group_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_page_setup_to_key_file(self: ptr TPageSetup, key_file: ptr GLib2.TKeyFile, group_name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_page_setup_to_key_file".}
proc to_key_file*(self: PageSetup, key_file: ptr GLib2.TKeyFile, group_name: ustring) {.inline.} =
  gtk_page_setup_to_key_file(self, key_file, ucstring(group_name))
# proc to_key_file*(self: PageSetup, key_file: ptr GLib2.TKeyFile, group_name: ustring) {.inline.} =

# initializer for Paned: gtk_paned_get_type
proc gtk_paned_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_paned_get_type".}
template gtype*(klass_parameter: typedesc[Paned]): GType = gtk_paned_get_type()
# gtk_paned_new
# flags: {isConstructor} container: Paned
# need sugar: is static method
# arg orientation: INTERFACE (ENUM) 'Orientation' 'Orientation' IN
# return: INTERFACE 'Paned' 'TransferNone[TPaned]' (diff., need sugar)
proc gtk_paned_new(orientation: Orientation): TransferNone[TPaned] {.cdecl, dynlib: lib, importc: "gtk_paned_new".}
proc new_paned*(orientation: Orientation): Paned {.inline.} =
  wrap(gtk_paned_new(orientation))
# proc new_paned*(orientation: Orientation): Paned {.inline.} =

# gtk_paned_add1
# flags: {isMethod} container: Paned
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_paned_add1(self: ptr TPaned, child: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_paned_add1".}
proc add1*(self: Paned, child: Widget) {.inline.} =
  gtk_paned_add1(self, child.getPointer)
# proc add1*(self: Paned, child: Widget) {.inline.} =

# gtk_paned_add2
# flags: {isMethod} container: Paned
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_paned_add2(self: ptr TPaned, child: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_paned_add2".}
proc add2*(self: Paned, child: Widget) {.inline.} =
  gtk_paned_add2(self, child.getPointer)
# proc add2*(self: Paned, child: Widget) {.inline.} =

# gtk_paned_get_child1
# flags: {isMethod} container: Paned
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_paned_get_child1(self: ptr TPaned): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_paned_get_child1".}
proc get_child1*(self: Paned): Widget {.inline.} =
  wrap(gtk_paned_get_child1(self))
# proc get_child1*(self: Paned): Widget {.inline.} =

# gtk_paned_get_child2
# flags: {isMethod} container: Paned
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_paned_get_child2(self: ptr TPaned): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_paned_get_child2".}
proc get_child2*(self: Paned): Widget {.inline.} =
  wrap(gtk_paned_get_child2(self))
# proc get_child2*(self: Paned): Widget {.inline.} =

# gtk_paned_get_handle_window
# flags: {isMethod} container: Paned
# need sugar: is method
# return: INTERFACE 'Gdk3.Window' 'TransferNone[Gdk3.TWindow]' (diff., need sugar)
proc gtk_paned_get_handle_window(self: ptr TPaned): TransferNone[Gdk3.TWindow] {.cdecl, dynlib: lib, importc: "gtk_paned_get_handle_window".}
proc get_handle_window*(self: Paned): Gdk3.Window {.inline.} =
  wrap(gtk_paned_get_handle_window(self))
# proc get_handle_window*(self: Paned): Gdk3.Window {.inline.} =

# gtk_paned_get_position
# flags: {isMethod} container: Paned
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_paned_get_position(self: ptr TPaned): int32 {.cdecl, dynlib: lib, importc: "gtk_paned_get_position".}
proc get_position*(self: Paned): int32 {.inline.} =
  gtk_paned_get_position(self)
# proc get_position*(self: Paned): int32 {.inline.} =

# gtk_paned_get_wide_handle
# flags: {isMethod} container: Paned
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_paned_get_wide_handle(self: ptr TPaned): bool {.cdecl, dynlib: lib, importc: "gtk_paned_get_wide_handle".}
proc get_wide_handle*(self: Paned): bool {.inline.} =
  gtk_paned_get_wide_handle(self)
# proc get_wide_handle*(self: Paned): bool {.inline.} =

# gtk_paned_pack1
# flags: {isMethod} container: Paned
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg resize: BOOLEAN 'bool' 'bool' IN
# arg shrink: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_paned_pack1(self: ptr TPaned, child: ptr TWidget, resize: bool, shrink: bool) {.cdecl, dynlib: lib, importc: "gtk_paned_pack1".}
proc pack1*(self: Paned, child: Widget, resize: bool, shrink: bool) {.inline.} =
  gtk_paned_pack1(self, child.getPointer, resize, shrink)
# proc pack1*(self: Paned, child: Widget, resize: bool, shrink: bool) {.inline.} =

# gtk_paned_pack2
# flags: {isMethod} container: Paned
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg resize: BOOLEAN 'bool' 'bool' IN
# arg shrink: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_paned_pack2(self: ptr TPaned, child: ptr TWidget, resize: bool, shrink: bool) {.cdecl, dynlib: lib, importc: "gtk_paned_pack2".}
proc pack2*(self: Paned, child: Widget, resize: bool, shrink: bool) {.inline.} =
  gtk_paned_pack2(self, child.getPointer, resize, shrink)
# proc pack2*(self: Paned, child: Widget, resize: bool, shrink: bool) {.inline.} =

# gtk_paned_set_position
# flags: {isMethod} container: Paned
# need sugar: is method
# arg position: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_paned_set_position(self: ptr TPaned, position: int32) {.cdecl, dynlib: lib, importc: "gtk_paned_set_position".}
proc set_position*(self: Paned, position: int32) {.inline.} =
  gtk_paned_set_position(self, position)
# proc set_position*(self: Paned, position: int32) {.inline.} =

# gtk_paned_set_wide_handle
# flags: {isMethod} container: Paned
# need sugar: is method
# arg wide: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_paned_set_wide_handle(self: ptr TPaned, wide: bool) {.cdecl, dynlib: lib, importc: "gtk_paned_set_wide_handle".}
proc set_wide_handle*(self: Paned, wide: bool) {.inline.} =
  gtk_paned_set_wide_handle(self, wide)
# proc set_wide_handle*(self: Paned, wide: bool) {.inline.} =

# initializer for PanedAccessible: gtk_paned_accessible_get_type
proc gtk_paned_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_paned_accessible_get_type".}
template gtype*(klass_parameter: typedesc[PanedAccessible]): GType = gtk_paned_accessible_get_type()
# initializer for PlacesSidebar: gtk_places_sidebar_get_type
proc gtk_places_sidebar_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_get_type".}
template gtype*(klass_parameter: typedesc[PlacesSidebar]): GType = gtk_places_sidebar_get_type()
# gtk_places_sidebar_new
# flags: {isConstructor} container: PlacesSidebar
# need sugar: is static method
# return: INTERFACE 'PlacesSidebar' 'TransferNone[TPlacesSidebar]' (diff., need sugar)
proc gtk_places_sidebar_new(): TransferNone[TPlacesSidebar] {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_new".}
proc new_placessidebar*(): PlacesSidebar {.inline.} =
  wrap(gtk_places_sidebar_new())
# proc new_placessidebar*(): PlacesSidebar {.inline.} =

# gtk_places_sidebar_add_shortcut
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# arg location: INTERFACE (INTERFACE) 'ptr Gio2.TFile' 'ptr Gio2.TFile' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_places_sidebar_add_shortcut(self: ptr TPlacesSidebar, location: ptr Gio2.TFile) {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_add_shortcut".}
proc add_shortcut*(self: PlacesSidebar, location: ptr Gio2.TFile) {.inline.} =
  gtk_places_sidebar_add_shortcut(self, location)
# proc add_shortcut*(self: PlacesSidebar, location: ptr Gio2.TFile) {.inline.} =

# gtk_places_sidebar_get_local_only
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_places_sidebar_get_local_only(self: ptr TPlacesSidebar): bool {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_get_local_only".}
proc get_local_only*(self: PlacesSidebar): bool {.inline.} =
  gtk_places_sidebar_get_local_only(self)
# proc get_local_only*(self: PlacesSidebar): bool {.inline.} =

# gtk_places_sidebar_get_location
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# return: INTERFACE 'ptr Gio2.TFile' 'TransferFull[Gio2.TFile]' (diff., need sugar)
proc gtk_places_sidebar_get_location(self: ptr TPlacesSidebar): TransferFull[Gio2.TFile] {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_get_location".}
proc get_location*(self: PlacesSidebar): ptr Gio2.TFile {.inline.} =
  wrap(gtk_places_sidebar_get_location(self))
# proc get_location*(self: PlacesSidebar): ptr Gio2.TFile {.inline.} =

# gtk_places_sidebar_get_nth_bookmark
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# arg n: INT32 'int32' 'int32' IN
# return: INTERFACE 'ptr Gio2.TFile' 'TransferFull[Gio2.TFile]' (diff., need sugar)
proc gtk_places_sidebar_get_nth_bookmark(self: ptr TPlacesSidebar, n: int32): TransferFull[Gio2.TFile] {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_get_nth_bookmark".}
proc get_nth_bookmark*(self: PlacesSidebar, n: int32): ptr Gio2.TFile {.inline.} =
  wrap(gtk_places_sidebar_get_nth_bookmark(self, n))
# proc get_nth_bookmark*(self: PlacesSidebar, n: int32): ptr Gio2.TFile {.inline.} =

# gtk_places_sidebar_get_open_flags
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# return: INTERFACE 'SPlacesOpenFlags' 'SPlacesOpenFlags'
proc gtk_places_sidebar_get_open_flags(self: ptr TPlacesSidebar): SPlacesOpenFlags {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_get_open_flags".}
proc get_open_flags*(self: PlacesSidebar): SPlacesOpenFlags {.inline.} =
  gtk_places_sidebar_get_open_flags(self)
# proc get_open_flags*(self: PlacesSidebar): SPlacesOpenFlags {.inline.} =

# gtk_places_sidebar_get_show_connect_to_server
# flags: {isMethod} container: PlacesSidebar (deprecated)
# gtk_places_sidebar_get_show_desktop
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_places_sidebar_get_show_desktop(self: ptr TPlacesSidebar): bool {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_get_show_desktop".}
proc get_show_desktop*(self: PlacesSidebar): bool {.inline.} =
  gtk_places_sidebar_get_show_desktop(self)
# proc get_show_desktop*(self: PlacesSidebar): bool {.inline.} =

# gtk_places_sidebar_get_show_enter_location
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_places_sidebar_get_show_enter_location(self: ptr TPlacesSidebar): bool {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_get_show_enter_location".}
proc get_show_enter_location*(self: PlacesSidebar): bool {.inline.} =
  gtk_places_sidebar_get_show_enter_location(self)
# proc get_show_enter_location*(self: PlacesSidebar): bool {.inline.} =

# gtk_places_sidebar_get_show_other_locations
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_places_sidebar_get_show_other_locations(self: ptr TPlacesSidebar): bool {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_get_show_other_locations".}
proc get_show_other_locations*(self: PlacesSidebar): bool {.inline.} =
  gtk_places_sidebar_get_show_other_locations(self)
# proc get_show_other_locations*(self: PlacesSidebar): bool {.inline.} =

# gtk_places_sidebar_get_show_recent
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_places_sidebar_get_show_recent(self: ptr TPlacesSidebar): bool {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_get_show_recent".}
proc get_show_recent*(self: PlacesSidebar): bool {.inline.} =
  gtk_places_sidebar_get_show_recent(self)
# proc get_show_recent*(self: PlacesSidebar): bool {.inline.} =

# gtk_places_sidebar_get_show_trash
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_places_sidebar_get_show_trash(self: ptr TPlacesSidebar): bool {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_get_show_trash".}
proc get_show_trash*(self: PlacesSidebar): bool {.inline.} =
  gtk_places_sidebar_get_show_trash(self)
# proc get_show_trash*(self: PlacesSidebar): bool {.inline.} =

# gtk_places_sidebar_list_shortcuts
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# return: GSLIST 'ptr GSLIST_TODO' 'ptr GSLIST_TODO'
proc gtk_places_sidebar_list_shortcuts(self: ptr TPlacesSidebar): ptr GSLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_list_shortcuts".}
proc list_shortcuts*(self: PlacesSidebar): ptr GSLIST_TODO {.inline.} =
  gtk_places_sidebar_list_shortcuts(self)
# proc list_shortcuts*(self: PlacesSidebar): ptr GSLIST_TODO {.inline.} =

# gtk_places_sidebar_remove_shortcut
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# arg location: INTERFACE (INTERFACE) 'ptr Gio2.TFile' 'ptr Gio2.TFile' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_places_sidebar_remove_shortcut(self: ptr TPlacesSidebar, location: ptr Gio2.TFile) {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_remove_shortcut".}
proc remove_shortcut*(self: PlacesSidebar, location: ptr Gio2.TFile) {.inline.} =
  gtk_places_sidebar_remove_shortcut(self, location)
# proc remove_shortcut*(self: PlacesSidebar, location: ptr Gio2.TFile) {.inline.} =

# gtk_places_sidebar_set_drop_targets_visible
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# arg visible: BOOLEAN 'bool' 'bool' IN
# arg context: INTERFACE (OBJECT) 'Gdk3.DragContext' 'ptr Gdk3.TDragContext' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_places_sidebar_set_drop_targets_visible(self: ptr TPlacesSidebar, visible: bool, context: ptr Gdk3.TDragContext) {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_set_drop_targets_visible".}
proc set_drop_targets_visible*(self: PlacesSidebar, visible: bool, context: Gdk3.DragContext) {.inline.} =
  gtk_places_sidebar_set_drop_targets_visible(self, visible, context.getPointer)
# proc set_drop_targets_visible*(self: PlacesSidebar, visible: bool, context: Gdk3.DragContext) {.inline.} =

# gtk_places_sidebar_set_local_only
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# arg local_only: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_places_sidebar_set_local_only(self: ptr TPlacesSidebar, local_only: bool) {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_set_local_only".}
proc set_local_only*(self: PlacesSidebar, local_only: bool) {.inline.} =
  gtk_places_sidebar_set_local_only(self, local_only)
# proc set_local_only*(self: PlacesSidebar, local_only: bool) {.inline.} =

# gtk_places_sidebar_set_location
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# arg location: INTERFACE (INTERFACE) 'ptr Gio2.TFile' 'ptr Gio2.TFile' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_places_sidebar_set_location(self: ptr TPlacesSidebar, location: ptr Gio2.TFile) {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_set_location".}
proc set_location*(self: PlacesSidebar, location: ptr Gio2.TFile) {.inline.} =
  gtk_places_sidebar_set_location(self, location)
# proc set_location*(self: PlacesSidebar, location: ptr Gio2.TFile) {.inline.} =

# gtk_places_sidebar_set_open_flags
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# arg flags: INTERFACE (FLAGS) 'SPlacesOpenFlags' 'SPlacesOpenFlags' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_places_sidebar_set_open_flags(self: ptr TPlacesSidebar, flags: SPlacesOpenFlags) {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_set_open_flags".}
proc set_open_flags*(self: PlacesSidebar, flags: SPlacesOpenFlags) {.inline.} =
  gtk_places_sidebar_set_open_flags(self, flags)
# proc set_open_flags*(self: PlacesSidebar, flags: SPlacesOpenFlags) {.inline.} =

# gtk_places_sidebar_set_show_connect_to_server
# flags: {isMethod} container: PlacesSidebar (deprecated)
# gtk_places_sidebar_set_show_desktop
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# arg show_desktop: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_places_sidebar_set_show_desktop(self: ptr TPlacesSidebar, show_desktop: bool) {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_set_show_desktop".}
proc set_show_desktop*(self: PlacesSidebar, show_desktop: bool) {.inline.} =
  gtk_places_sidebar_set_show_desktop(self, show_desktop)
# proc set_show_desktop*(self: PlacesSidebar, show_desktop: bool) {.inline.} =

# gtk_places_sidebar_set_show_enter_location
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# arg show_enter_location: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_places_sidebar_set_show_enter_location(self: ptr TPlacesSidebar, show_enter_location: bool) {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_set_show_enter_location".}
proc set_show_enter_location*(self: PlacesSidebar, show_enter_location: bool) {.inline.} =
  gtk_places_sidebar_set_show_enter_location(self, show_enter_location)
# proc set_show_enter_location*(self: PlacesSidebar, show_enter_location: bool) {.inline.} =

# gtk_places_sidebar_set_show_other_locations
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# arg show_other_locations: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_places_sidebar_set_show_other_locations(self: ptr TPlacesSidebar, show_other_locations: bool) {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_set_show_other_locations".}
proc set_show_other_locations*(self: PlacesSidebar, show_other_locations: bool) {.inline.} =
  gtk_places_sidebar_set_show_other_locations(self, show_other_locations)
# proc set_show_other_locations*(self: PlacesSidebar, show_other_locations: bool) {.inline.} =

# gtk_places_sidebar_set_show_recent
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# arg show_recent: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_places_sidebar_set_show_recent(self: ptr TPlacesSidebar, show_recent: bool) {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_set_show_recent".}
proc set_show_recent*(self: PlacesSidebar, show_recent: bool) {.inline.} =
  gtk_places_sidebar_set_show_recent(self, show_recent)
# proc set_show_recent*(self: PlacesSidebar, show_recent: bool) {.inline.} =

# gtk_places_sidebar_set_show_trash
# flags: {isMethod} container: PlacesSidebar
# need sugar: is method
# arg show_trash: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_places_sidebar_set_show_trash(self: ptr TPlacesSidebar, show_trash: bool) {.cdecl, dynlib: lib, importc: "gtk_places_sidebar_set_show_trash".}
proc set_show_trash*(self: PlacesSidebar, show_trash: bool) {.inline.} =
  gtk_places_sidebar_set_show_trash(self, show_trash)
# proc set_show_trash*(self: PlacesSidebar, show_trash: bool) {.inline.} =

# initializer for Popover: gtk_popover_get_type
proc gtk_popover_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_popover_get_type".}
template gtype*(klass_parameter: typedesc[Popover]): GType = gtk_popover_get_type()
# gtk_popover_new
# flags: {isConstructor} container: Popover
# need sugar: is static method
# arg relative_to: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: INTERFACE 'Popover' 'TransferNone[TPopover]' (diff., need sugar)
proc gtk_popover_new(relative_to: ptr TWidget): TransferNone[TPopover] {.cdecl, dynlib: lib, importc: "gtk_popover_new".}
proc new_popover*(relative_to: Widget): Popover {.inline.} =
  wrap(gtk_popover_new(relative_to.getPointer))
# proc new_popover*(relative_to: Widget): Popover {.inline.} =

# gtk_popover_new_from_model
# flags: {isConstructor} container: Popover
# need sugar: is static method
# arg relative_to: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg model: INTERFACE (OBJECT) 'Gio2.MenuModel' 'ptr Gio2.TMenuModel' IN (diff., need sugar)
# return: INTERFACE 'Popover' 'TransferNone[TPopover]' (diff., need sugar)
proc gtk_popover_new_from_model(relative_to: ptr TWidget, model: ptr Gio2.TMenuModel): TransferNone[TPopover] {.cdecl, dynlib: lib, importc: "gtk_popover_new_from_model".}
proc new_popover_from_model*(relative_to: Widget, model: Gio2.MenuModel): Popover {.inline.} =
  wrap(gtk_popover_new_from_model(relative_to.getPointer, model.getPointer))
# proc new_popover_from_model*(relative_to: Widget, model: Gio2.MenuModel): Popover {.inline.} =

# gtk_popover_bind_model
# flags: {isMethod} container: Popover
# need sugar: is method
# arg model: INTERFACE (OBJECT) 'Gio2.MenuModel' 'ptr Gio2.TMenuModel' IN (diff., need sugar)
# arg action_namespace: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_popover_bind_model(self: ptr TPopover, model: ptr Gio2.TMenuModel, action_namespace: ucstring) {.cdecl, dynlib: lib, importc: "gtk_popover_bind_model".}
proc bind_model*(self: Popover, model: Gio2.MenuModel, action_namespace: ustring) {.inline.} =
  gtk_popover_bind_model(self, model.getPointer, ucstring(action_namespace))
# proc bind_model*(self: Popover, model: Gio2.MenuModel, action_namespace: ustring) {.inline.} =

# gtk_popover_get_default_widget
# flags: {isMethod} container: Popover
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_popover_get_default_widget(self: ptr TPopover): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_popover_get_default_widget".}
proc get_default_widget*(self: Popover): Widget {.inline.} =
  wrap(gtk_popover_get_default_widget(self))
# proc get_default_widget*(self: Popover): Widget {.inline.} =

# gtk_popover_get_modal
# flags: {isMethod} container: Popover
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_popover_get_modal(self: ptr TPopover): bool {.cdecl, dynlib: lib, importc: "gtk_popover_get_modal".}
proc get_modal*(self: Popover): bool {.inline.} =
  gtk_popover_get_modal(self)
# proc get_modal*(self: Popover): bool {.inline.} =

# gtk_popover_get_pointing_to
# flags: {isMethod} container: Popover
# need sugar: is method
# arg rect: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' OUT caller-allocates
# return: BOOLEAN 'bool' 'bool'
proc gtk_popover_get_pointing_to(self: ptr TPopover, rect: ptr Gdk3.TRectangle): bool {.cdecl, dynlib: lib, importc: "gtk_popover_get_pointing_to".}
proc get_pointing_to*(self: Popover, rect: ptr Gdk3.TRectangle): bool {.inline.} =
  gtk_popover_get_pointing_to(self, rect)
# tuple-return
# rect: ptr Gdk3.TRectangle
# proc get_pointing_to*(self: Popover): bool {.inline.} =

# gtk_popover_get_position
# flags: {isMethod} container: Popover
# need sugar: is method
# return: INTERFACE 'PositionType' 'PositionType'
proc gtk_popover_get_position(self: ptr TPopover): PositionType {.cdecl, dynlib: lib, importc: "gtk_popover_get_position".}
proc get_position*(self: Popover): PositionType {.inline.} =
  gtk_popover_get_position(self)
# proc get_position*(self: Popover): PositionType {.inline.} =

# gtk_popover_get_relative_to
# flags: {isMethod} container: Popover
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_popover_get_relative_to(self: ptr TPopover): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_popover_get_relative_to".}
proc get_relative_to*(self: Popover): Widget {.inline.} =
  wrap(gtk_popover_get_relative_to(self))
# proc get_relative_to*(self: Popover): Widget {.inline.} =

# gtk_popover_get_transitions_enabled
# flags: {isMethod} container: Popover
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_popover_get_transitions_enabled(self: ptr TPopover): bool {.cdecl, dynlib: lib, importc: "gtk_popover_get_transitions_enabled".}
proc get_transitions_enabled*(self: Popover): bool {.inline.} =
  gtk_popover_get_transitions_enabled(self)
# proc get_transitions_enabled*(self: Popover): bool {.inline.} =

# gtk_popover_set_default_widget
# flags: {isMethod} container: Popover
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_popover_set_default_widget(self: ptr TPopover, widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_popover_set_default_widget".}
proc set_default_widget*(self: Popover, widget: Widget) {.inline.} =
  gtk_popover_set_default_widget(self, widget.getPointer)
# proc set_default_widget*(self: Popover, widget: Widget) {.inline.} =

# gtk_popover_set_modal
# flags: {isMethod} container: Popover
# need sugar: is method
# arg modal: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_popover_set_modal(self: ptr TPopover, modal: bool) {.cdecl, dynlib: lib, importc: "gtk_popover_set_modal".}
proc set_modal*(self: Popover, modal: bool) {.inline.} =
  gtk_popover_set_modal(self, modal)
# proc set_modal*(self: Popover, modal: bool) {.inline.} =

# gtk_popover_set_pointing_to
# flags: {isMethod} container: Popover
# need sugar: is method
# arg rect: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_popover_set_pointing_to(self: ptr TPopover, rect: ptr Gdk3.TRectangle) {.cdecl, dynlib: lib, importc: "gtk_popover_set_pointing_to".}
proc set_pointing_to*(self: Popover, rect: ptr Gdk3.TRectangle) {.inline.} =
  gtk_popover_set_pointing_to(self, rect)
# proc set_pointing_to*(self: Popover, rect: ptr Gdk3.TRectangle) {.inline.} =

# gtk_popover_set_position
# flags: {isMethod} container: Popover
# need sugar: is method
# arg position: INTERFACE (ENUM) 'PositionType' 'PositionType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_popover_set_position(self: ptr TPopover, position: PositionType) {.cdecl, dynlib: lib, importc: "gtk_popover_set_position".}
proc set_position*(self: Popover, position: PositionType) {.inline.} =
  gtk_popover_set_position(self, position)
# proc set_position*(self: Popover, position: PositionType) {.inline.} =

# gtk_popover_set_relative_to
# flags: {isMethod} container: Popover
# need sugar: is method
# arg relative_to: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_popover_set_relative_to(self: ptr TPopover, relative_to: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_popover_set_relative_to".}
proc set_relative_to*(self: Popover, relative_to: Widget) {.inline.} =
  gtk_popover_set_relative_to(self, relative_to.getPointer)
# proc set_relative_to*(self: Popover, relative_to: Widget) {.inline.} =

# gtk_popover_set_transitions_enabled
# flags: {isMethod} container: Popover
# need sugar: is method
# arg transitions_enabled: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_popover_set_transitions_enabled(self: ptr TPopover, transitions_enabled: bool) {.cdecl, dynlib: lib, importc: "gtk_popover_set_transitions_enabled".}
proc set_transitions_enabled*(self: Popover, transitions_enabled: bool) {.inline.} =
  gtk_popover_set_transitions_enabled(self, transitions_enabled)
# proc set_transitions_enabled*(self: Popover, transitions_enabled: bool) {.inline.} =

# initializer for PopoverAccessible: gtk_popover_accessible_get_type
proc gtk_popover_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_popover_accessible_get_type".}
template gtype*(klass_parameter: typedesc[PopoverAccessible]): GType = gtk_popover_accessible_get_type()
# initializer for PopoverMenu: gtk_popover_menu_get_type
proc gtk_popover_menu_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_popover_menu_get_type".}
template gtype*(klass_parameter: typedesc[PopoverMenu]): GType = gtk_popover_menu_get_type()
# gtk_popover_menu_new
# flags: {isConstructor} container: PopoverMenu
# need sugar: is static method
# return: INTERFACE 'PopoverMenu' 'TransferNone[TPopoverMenu]' (diff., need sugar)
proc gtk_popover_menu_new(): TransferNone[TPopoverMenu] {.cdecl, dynlib: lib, importc: "gtk_popover_menu_new".}
proc new_popovermenu*(): PopoverMenu {.inline.} =
  wrap(gtk_popover_menu_new())
# proc new_popovermenu*(): PopoverMenu {.inline.} =

# gtk_popover_menu_open_submenu
# flags: {isMethod} container: PopoverMenu
# need sugar: is method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_popover_menu_open_submenu(self: ptr TPopoverMenu, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_popover_menu_open_submenu".}
proc open_submenu*(self: PopoverMenu, name: ustring) {.inline.} =
  gtk_popover_menu_open_submenu(self, ucstring(name))
# proc open_submenu*(self: PopoverMenu, name: ustring) {.inline.} =

# initializer for PrintContext: gtk_print_context_get_type
proc gtk_print_context_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_print_context_get_type".}
template gtype*(klass_parameter: typedesc[PrintContext]): GType = gtk_print_context_get_type()
# gtk_print_context_create_pango_context
# flags: {isMethod} container: PrintContext
# need sugar: is method
# return: INTERFACE 'Pango1.Context' 'TransferFull[Pango1.TContext]' (diff., need sugar)
proc gtk_print_context_create_pango_context(self: ptr TPrintContext): TransferFull[Pango1.TContext] {.cdecl, dynlib: lib, importc: "gtk_print_context_create_pango_context".}
proc create_pango_context*(self: PrintContext): Pango1.Context {.inline.} =
  wrap(gtk_print_context_create_pango_context(self))
# proc create_pango_context*(self: PrintContext): Pango1.Context {.inline.} =

# gtk_print_context_create_pango_layout
# flags: {isMethod} container: PrintContext
# need sugar: is method
# return: INTERFACE 'Pango1.Layout' 'TransferFull[Pango1.TLayout]' (diff., need sugar)
proc gtk_print_context_create_pango_layout(self: ptr TPrintContext): TransferFull[Pango1.TLayout] {.cdecl, dynlib: lib, importc: "gtk_print_context_create_pango_layout".}
proc create_pango_layout*(self: PrintContext): Pango1.Layout {.inline.} =
  wrap(gtk_print_context_create_pango_layout(self))
# proc create_pango_layout*(self: PrintContext): Pango1.Layout {.inline.} =

# gtk_print_context_get_cairo_context
# flags: {isMethod} container: PrintContext
# need sugar: is method
# return: INTERFACE 'ptr cairo1.TContext' 'ptr cairo1.TContext'
proc gtk_print_context_get_cairo_context(self: ptr TPrintContext): ptr cairo1.TContext {.cdecl, dynlib: lib, importc: "gtk_print_context_get_cairo_context".}
proc get_cairo_context*(self: PrintContext): ptr cairo1.TContext {.inline.} =
  gtk_print_context_get_cairo_context(self)
# proc get_cairo_context*(self: PrintContext): ptr cairo1.TContext {.inline.} =

# gtk_print_context_get_dpi_x
# flags: {isMethod} container: PrintContext
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_print_context_get_dpi_x(self: ptr TPrintContext): float64 {.cdecl, dynlib: lib, importc: "gtk_print_context_get_dpi_x".}
proc get_dpi_x*(self: PrintContext): float64 {.inline.} =
  gtk_print_context_get_dpi_x(self)
# proc get_dpi_x*(self: PrintContext): float64 {.inline.} =

# gtk_print_context_get_dpi_y
# flags: {isMethod} container: PrintContext
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_print_context_get_dpi_y(self: ptr TPrintContext): float64 {.cdecl, dynlib: lib, importc: "gtk_print_context_get_dpi_y".}
proc get_dpi_y*(self: PrintContext): float64 {.inline.} =
  gtk_print_context_get_dpi_y(self)
# proc get_dpi_y*(self: PrintContext): float64 {.inline.} =

# gtk_print_context_get_hard_margins
# flags: {isMethod} container: PrintContext
# need sugar: is method
# arg top: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar)
# arg bottom: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar)
# arg left: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar)
# arg right: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_print_context_get_hard_margins(self: ptr TPrintContext, top: ptr float64, bottom: ptr float64, left: ptr float64, right: ptr float64): bool {.cdecl, dynlib: lib, importc: "gtk_print_context_get_hard_margins".}
proc get_hard_margins*(self: PrintContext, top: var float64, bottom: var float64, left: var float64, right: var float64): bool {.inline.} =
  gtk_print_context_get_hard_margins(self, addr(top), addr(bottom), addr(left), addr(right))
# tuple-return
# top: var float64
# bottom: var float64
# left: var float64
# right: var float64
# proc get_hard_margins*(self: PrintContext): bool {.inline.} =

# gtk_print_context_get_height
# flags: {isMethod} container: PrintContext
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_print_context_get_height(self: ptr TPrintContext): float64 {.cdecl, dynlib: lib, importc: "gtk_print_context_get_height".}
proc get_height*(self: PrintContext): float64 {.inline.} =
  gtk_print_context_get_height(self)
# proc get_height*(self: PrintContext): float64 {.inline.} =

# gtk_print_context_get_page_setup
# flags: {isMethod} container: PrintContext
# need sugar: is method
# return: INTERFACE 'PageSetup' 'TransferNone[TPageSetup]' (diff., need sugar)
proc gtk_print_context_get_page_setup(self: ptr TPrintContext): TransferNone[TPageSetup] {.cdecl, dynlib: lib, importc: "gtk_print_context_get_page_setup".}
proc get_page_setup*(self: PrintContext): PageSetup {.inline.} =
  wrap(gtk_print_context_get_page_setup(self))
# proc get_page_setup*(self: PrintContext): PageSetup {.inline.} =

# gtk_print_context_get_pango_fontmap
# flags: {isMethod} container: PrintContext
# need sugar: is method
# return: INTERFACE 'Pango1.FontMap' 'TransferNone[Pango1.TFontMap]' (diff., need sugar)
proc gtk_print_context_get_pango_fontmap(self: ptr TPrintContext): TransferNone[Pango1.TFontMap] {.cdecl, dynlib: lib, importc: "gtk_print_context_get_pango_fontmap".}
proc get_pango_fontmap*(self: PrintContext): Pango1.FontMap {.inline.} =
  wrap(gtk_print_context_get_pango_fontmap(self))
# proc get_pango_fontmap*(self: PrintContext): Pango1.FontMap {.inline.} =

# gtk_print_context_get_width
# flags: {isMethod} container: PrintContext
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_print_context_get_width(self: ptr TPrintContext): float64 {.cdecl, dynlib: lib, importc: "gtk_print_context_get_width".}
proc get_width*(self: PrintContext): float64 {.inline.} =
  gtk_print_context_get_width(self)
# proc get_width*(self: PrintContext): float64 {.inline.} =

# gtk_print_context_set_cairo_context
# flags: {isMethod} container: PrintContext
# need sugar: is method
# arg cr: INTERFACE (STRUCT) 'ptr cairo1.TContext' 'ptr cairo1.TContext' IN
# arg dpi_x: DOUBLE 'float64' 'float64' IN
# arg dpi_y: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_context_set_cairo_context(self: ptr TPrintContext, cr: ptr cairo1.TContext, dpi_x: float64, dpi_y: float64) {.cdecl, dynlib: lib, importc: "gtk_print_context_set_cairo_context".}
proc set_cairo_context*(self: PrintContext, cr: ptr cairo1.TContext, dpi_x: float64, dpi_y: float64) {.inline.} =
  gtk_print_context_set_cairo_context(self, cr, dpi_x, dpi_y)
# proc set_cairo_context*(self: PrintContext, cr: ptr cairo1.TContext, dpi_x: float64, dpi_y: float64) {.inline.} =

# initializer for PrintOperation: gtk_print_operation_get_type
proc gtk_print_operation_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_print_operation_get_type".}
template gtype*(klass_parameter: typedesc[PrintOperation]): GType = gtk_print_operation_get_type()
# gtk_print_operation_new
# flags: {isConstructor} container: PrintOperation
# need sugar: is static method
# return: INTERFACE 'PrintOperation' 'TransferFull[TPrintOperation]' (diff., need sugar)
proc gtk_print_operation_new(): TransferFull[TPrintOperation] {.cdecl, dynlib: lib, importc: "gtk_print_operation_new".}
proc new_printoperation*(): PrintOperation {.inline.} =
  wrap(gtk_print_operation_new())
# proc new_printoperation*(): PrintOperation {.inline.} =

# gtk_print_operation_cancel
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_cancel(self: ptr TPrintOperation) {.cdecl, dynlib: lib, importc: "gtk_print_operation_cancel".}
proc cancel*(self: PrintOperation) {.inline.} =
  gtk_print_operation_cancel(self)
# proc cancel*(self: PrintOperation) {.inline.} =

# gtk_print_operation_draw_page_finish
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_draw_page_finish(self: ptr TPrintOperation) {.cdecl, dynlib: lib, importc: "gtk_print_operation_draw_page_finish".}
proc draw_page_finish*(self: PrintOperation) {.inline.} =
  gtk_print_operation_draw_page_finish(self)
# proc draw_page_finish*(self: PrintOperation) {.inline.} =

# gtk_print_operation_get_default_page_setup
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# return: INTERFACE 'PageSetup' 'TransferNone[TPageSetup]' (diff., need sugar)
proc gtk_print_operation_get_default_page_setup(self: ptr TPrintOperation): TransferNone[TPageSetup] {.cdecl, dynlib: lib, importc: "gtk_print_operation_get_default_page_setup".}
proc get_default_page_setup*(self: PrintOperation): PageSetup {.inline.} =
  wrap(gtk_print_operation_get_default_page_setup(self))
# proc get_default_page_setup*(self: PrintOperation): PageSetup {.inline.} =

# gtk_print_operation_get_embed_page_setup
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_print_operation_get_embed_page_setup(self: ptr TPrintOperation): bool {.cdecl, dynlib: lib, importc: "gtk_print_operation_get_embed_page_setup".}
proc get_embed_page_setup*(self: PrintOperation): bool {.inline.} =
  gtk_print_operation_get_embed_page_setup(self)
# proc get_embed_page_setup*(self: PrintOperation): bool {.inline.} =

# gtk_print_operation_get_error
# flags: {isMethod, throws} container: PrintOperation
# can throw
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_get_error(self: ptr TPrintOperation, error: ptr PGError=nil) {.cdecl, dynlib: lib, importc: "gtk_print_operation_get_error".}
proc get_error*(self: PrintOperation) {.inline.} =
  gtk_print_operation_get_error(self)
# proc get_error*(self: PrintOperation) {.inline.} =

# gtk_print_operation_get_has_selection
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_print_operation_get_has_selection(self: ptr TPrintOperation): bool {.cdecl, dynlib: lib, importc: "gtk_print_operation_get_has_selection".}
proc get_has_selection*(self: PrintOperation): bool {.inline.} =
  gtk_print_operation_get_has_selection(self)
# proc get_has_selection*(self: PrintOperation): bool {.inline.} =

# gtk_print_operation_get_n_pages_to_print
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_print_operation_get_n_pages_to_print(self: ptr TPrintOperation): int32 {.cdecl, dynlib: lib, importc: "gtk_print_operation_get_n_pages_to_print".}
proc get_n_pages_to_print*(self: PrintOperation): int32 {.inline.} =
  gtk_print_operation_get_n_pages_to_print(self)
# proc get_n_pages_to_print*(self: PrintOperation): int32 {.inline.} =

# gtk_print_operation_get_print_settings
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# return: INTERFACE 'PrintSettings' 'TransferNone[TPrintSettings]' (diff., need sugar)
proc gtk_print_operation_get_print_settings(self: ptr TPrintOperation): TransferNone[TPrintSettings] {.cdecl, dynlib: lib, importc: "gtk_print_operation_get_print_settings".}
proc get_print_settings*(self: PrintOperation): PrintSettings {.inline.} =
  wrap(gtk_print_operation_get_print_settings(self))
# proc get_print_settings*(self: PrintOperation): PrintSettings {.inline.} =

# gtk_print_operation_get_status
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# return: INTERFACE 'PrintStatus' 'PrintStatus'
proc gtk_print_operation_get_status(self: ptr TPrintOperation): PrintStatus {.cdecl, dynlib: lib, importc: "gtk_print_operation_get_status".}
proc get_status*(self: PrintOperation): PrintStatus {.inline.} =
  gtk_print_operation_get_status(self)
# proc get_status*(self: PrintOperation): PrintStatus {.inline.} =

# gtk_print_operation_get_status_string
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_print_operation_get_status_string(self: ptr TPrintOperation): ucstring {.cdecl, dynlib: lib, importc: "gtk_print_operation_get_status_string".}
proc get_status_string*(self: PrintOperation): ucstring {.inline.} =
  gtk_print_operation_get_status_string(self)
# proc get_status_string*(self: PrintOperation): ucstring {.inline.} =

# gtk_print_operation_get_support_selection
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_print_operation_get_support_selection(self: ptr TPrintOperation): bool {.cdecl, dynlib: lib, importc: "gtk_print_operation_get_support_selection".}
proc get_support_selection*(self: PrintOperation): bool {.inline.} =
  gtk_print_operation_get_support_selection(self)
# proc get_support_selection*(self: PrintOperation): bool {.inline.} =

# gtk_print_operation_is_finished
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_print_operation_is_finished(self: ptr TPrintOperation): bool {.cdecl, dynlib: lib, importc: "gtk_print_operation_is_finished".}
proc is_finished*(self: PrintOperation): bool {.inline.} =
  gtk_print_operation_is_finished(self)
# proc is_finished*(self: PrintOperation): bool {.inline.} =

# gtk_print_operation_run
# flags: {isMethod, throws} container: PrintOperation
# can throw
# need sugar: is method
# arg action: INTERFACE (ENUM) 'PrintOperationAction' 'PrintOperationAction' IN
# arg parent: INTERFACE (OBJECT) 'Window' 'ptr TWindow' IN (diff., need sugar)
# return: INTERFACE 'PrintOperationResult' 'PrintOperationResult'
proc gtk_print_operation_run(self: ptr TPrintOperation, action: PrintOperationAction, parent: ptr TWindow, error: ptr PGError=nil): PrintOperationResult {.cdecl, dynlib: lib, importc: "gtk_print_operation_run".}
proc run*(self: PrintOperation, action: PrintOperationAction, parent: Window): PrintOperationResult {.inline.} =
  gtk_print_operation_run(self, action, parent.getPointer)
# proc run*(self: PrintOperation, action: PrintOperationAction, parent: Window): PrintOperationResult {.inline.} =

# gtk_print_operation_set_allow_async
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# arg allow_async: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_allow_async(self: ptr TPrintOperation, allow_async: bool) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_allow_async".}
proc set_allow_async*(self: PrintOperation, allow_async: bool) {.inline.} =
  gtk_print_operation_set_allow_async(self, allow_async)
# proc set_allow_async*(self: PrintOperation, allow_async: bool) {.inline.} =

# gtk_print_operation_set_current_page
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# arg current_page: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_current_page(self: ptr TPrintOperation, current_page: int32) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_current_page".}
proc set_current_page*(self: PrintOperation, current_page: int32) {.inline.} =
  gtk_print_operation_set_current_page(self, current_page)
# proc set_current_page*(self: PrintOperation, current_page: int32) {.inline.} =

# gtk_print_operation_set_custom_tab_label
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_custom_tab_label(self: ptr TPrintOperation, label: ucstring) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_custom_tab_label".}
proc set_custom_tab_label*(self: PrintOperation, label: ustring) {.inline.} =
  gtk_print_operation_set_custom_tab_label(self, ucstring(label))
# proc set_custom_tab_label*(self: PrintOperation, label: ustring) {.inline.} =

# gtk_print_operation_set_default_page_setup
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# arg default_page_setup: INTERFACE (OBJECT) 'PageSetup' 'ptr TPageSetup' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_default_page_setup(self: ptr TPrintOperation, default_page_setup: ptr TPageSetup) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_default_page_setup".}
proc set_default_page_setup*(self: PrintOperation, default_page_setup: PageSetup) {.inline.} =
  gtk_print_operation_set_default_page_setup(self, default_page_setup.getPointer)
# proc set_default_page_setup*(self: PrintOperation, default_page_setup: PageSetup) {.inline.} =

# gtk_print_operation_set_defer_drawing
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_defer_drawing(self: ptr TPrintOperation) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_defer_drawing".}
proc set_defer_drawing*(self: PrintOperation) {.inline.} =
  gtk_print_operation_set_defer_drawing(self)
# proc set_defer_drawing*(self: PrintOperation) {.inline.} =

# gtk_print_operation_set_embed_page_setup
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# arg embed: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_embed_page_setup(self: ptr TPrintOperation, embed: bool) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_embed_page_setup".}
proc set_embed_page_setup*(self: PrintOperation, embed: bool) {.inline.} =
  gtk_print_operation_set_embed_page_setup(self, embed)
# proc set_embed_page_setup*(self: PrintOperation, embed: bool) {.inline.} =

# gtk_print_operation_set_export_filename
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# arg filename: FILENAME 'string' 'cstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_export_filename(self: ptr TPrintOperation, filename: cstring) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_export_filename".}
proc set_export_filename*(self: PrintOperation, filename: string) {.inline.} =
  gtk_print_operation_set_export_filename(self, cstring(filename))
# proc set_export_filename*(self: PrintOperation, filename: string) {.inline.} =

# gtk_print_operation_set_has_selection
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# arg has_selection: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_has_selection(self: ptr TPrintOperation, has_selection: bool) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_has_selection".}
proc set_has_selection*(self: PrintOperation, has_selection: bool) {.inline.} =
  gtk_print_operation_set_has_selection(self, has_selection)
# proc set_has_selection*(self: PrintOperation, has_selection: bool) {.inline.} =

# gtk_print_operation_set_job_name
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# arg job_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_job_name(self: ptr TPrintOperation, job_name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_job_name".}
proc set_job_name*(self: PrintOperation, job_name: ustring) {.inline.} =
  gtk_print_operation_set_job_name(self, ucstring(job_name))
# proc set_job_name*(self: PrintOperation, job_name: ustring) {.inline.} =

# gtk_print_operation_set_n_pages
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# arg n_pages: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_n_pages(self: ptr TPrintOperation, n_pages: int32) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_n_pages".}
proc set_n_pages*(self: PrintOperation, n_pages: int32) {.inline.} =
  gtk_print_operation_set_n_pages(self, n_pages)
# proc set_n_pages*(self: PrintOperation, n_pages: int32) {.inline.} =

# gtk_print_operation_set_print_settings
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# arg print_settings: INTERFACE (OBJECT) 'PrintSettings' 'ptr TPrintSettings' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_print_settings(self: ptr TPrintOperation, print_settings: ptr TPrintSettings) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_print_settings".}
proc set_print_settings*(self: PrintOperation, print_settings: PrintSettings) {.inline.} =
  gtk_print_operation_set_print_settings(self, print_settings.getPointer)
# proc set_print_settings*(self: PrintOperation, print_settings: PrintSettings) {.inline.} =

# gtk_print_operation_set_show_progress
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# arg show_progress: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_show_progress(self: ptr TPrintOperation, show_progress: bool) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_show_progress".}
proc set_show_progress*(self: PrintOperation, show_progress: bool) {.inline.} =
  gtk_print_operation_set_show_progress(self, show_progress)
# proc set_show_progress*(self: PrintOperation, show_progress: bool) {.inline.} =

# gtk_print_operation_set_support_selection
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# arg support_selection: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_support_selection(self: ptr TPrintOperation, support_selection: bool) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_support_selection".}
proc set_support_selection*(self: PrintOperation, support_selection: bool) {.inline.} =
  gtk_print_operation_set_support_selection(self, support_selection)
# proc set_support_selection*(self: PrintOperation, support_selection: bool) {.inline.} =

# gtk_print_operation_set_track_print_status
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# arg track_status: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_track_print_status(self: ptr TPrintOperation, track_status: bool) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_track_print_status".}
proc set_track_print_status*(self: PrintOperation, track_status: bool) {.inline.} =
  gtk_print_operation_set_track_print_status(self, track_status)
# proc set_track_print_status*(self: PrintOperation, track_status: bool) {.inline.} =

# gtk_print_operation_set_unit
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_unit(self: ptr TPrintOperation, unit: Unit) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_unit".}
proc set_unit*(self: PrintOperation, unit: Unit) {.inline.} =
  gtk_print_operation_set_unit(self, unit)
# proc set_unit*(self: PrintOperation, unit: Unit) {.inline.} =

# gtk_print_operation_set_use_full_page
# flags: {isMethod} container: PrintOperation
# need sugar: is method
# arg full_page: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_operation_set_use_full_page(self: ptr TPrintOperation, full_page: bool) {.cdecl, dynlib: lib, importc: "gtk_print_operation_set_use_full_page".}
proc set_use_full_page*(self: PrintOperation, full_page: bool) {.inline.} =
  gtk_print_operation_set_use_full_page(self, full_page)
# proc set_use_full_page*(self: PrintOperation, full_page: bool) {.inline.} =

# initializer for PrintSettings: gtk_print_settings_get_type
proc gtk_print_settings_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_type".}
template gtype*(klass_parameter: typedesc[PrintSettings]): GType = gtk_print_settings_get_type()
# gtk_print_settings_new
# flags: {isConstructor} container: PrintSettings
# need sugar: is static method
# return: INTERFACE 'PrintSettings' 'TransferFull[TPrintSettings]' (diff., need sugar)
proc gtk_print_settings_new(): TransferFull[TPrintSettings] {.cdecl, dynlib: lib, importc: "gtk_print_settings_new".}
proc new_printsettings*(): PrintSettings {.inline.} =
  wrap(gtk_print_settings_new())
# proc new_printsettings*(): PrintSettings {.inline.} =

# gtk_print_settings_new_from_file
# flags: {isConstructor, throws} container: PrintSettings
# can throw
# need sugar: is static method
# arg file_name: FILENAME 'string' 'cstring' IN (diff., need sugar)
# return: INTERFACE 'PrintSettings' 'TransferFull[TPrintSettings]' (diff., need sugar)
proc gtk_print_settings_new_from_file(file_name: cstring, error: ptr PGError=nil): TransferFull[TPrintSettings] {.cdecl, dynlib: lib, importc: "gtk_print_settings_new_from_file".}
proc new_printsettings_from_file*(file_name: string): PrintSettings {.inline.} =
  wrap(gtk_print_settings_new_from_file(cstring(file_name)))
# proc new_printsettings_from_file*(file_name: string): PrintSettings {.inline.} =

# gtk_print_settings_new_from_key_file
# flags: {isConstructor, throws} container: PrintSettings
# can throw
# need sugar: is static method
# arg key_file: INTERFACE (STRUCT) 'ptr GLib2.TKeyFile' 'ptr GLib2.TKeyFile' IN
# arg group_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'PrintSettings' 'TransferFull[TPrintSettings]' (diff., need sugar)
proc gtk_print_settings_new_from_key_file(key_file: ptr GLib2.TKeyFile, group_name: ucstring, error: ptr PGError=nil): TransferFull[TPrintSettings] {.cdecl, dynlib: lib, importc: "gtk_print_settings_new_from_key_file".}
proc new_printsettings_from_key_file*(key_file: ptr GLib2.TKeyFile, group_name: ustring): PrintSettings {.inline.} =
  wrap(gtk_print_settings_new_from_key_file(key_file, ucstring(group_name)))
# proc new_printsettings_from_key_file*(key_file: ptr GLib2.TKeyFile, group_name: ustring): PrintSettings {.inline.} =

# gtk_print_settings_copy
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# return: INTERFACE 'PrintSettings' 'TransferFull[TPrintSettings]' (diff., need sugar)
proc gtk_print_settings_copy(self: ptr TPrintSettings): TransferFull[TPrintSettings] {.cdecl, dynlib: lib, importc: "gtk_print_settings_copy".}
proc copy*(self: PrintSettings): PrintSettings {.inline.} =
  wrap(gtk_print_settings_copy(self))
# proc copy*(self: PrintSettings): PrintSettings {.inline.} =

# gtk_print_settings_foreach
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg user_data: VOID 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_foreach(self: ptr TPrintSettings, func_x: pointer, user_data: pointer) {.cdecl, dynlib: lib, importc: "gtk_print_settings_foreach".}
proc foreach*(self: PrintSettings, func_x: pointer, user_data: pointer) {.inline.} =
  gtk_print_settings_foreach(self, func_x, user_data)
# proc foreach*(self: PrintSettings, func_x: pointer, user_data: pointer) {.inline.} =

# gtk_print_settings_get
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg key: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: UTF8 'ucstring' 'ucstring'
proc gtk_print_settings_get(self: ptr TPrintSettings, key: ucstring): ucstring {.cdecl, dynlib: lib, importc: "gtk_print_settings_get".}
proc get*(self: PrintSettings, key: ustring): ucstring {.inline.} =
  gtk_print_settings_get(self, ucstring(key))
# proc get*(self: PrintSettings, key: ustring): ucstring {.inline.} =

# gtk_print_settings_get_bool
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg key: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_print_settings_get_bool(self: ptr TPrintSettings, key: ucstring): bool {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_bool".}
proc get_bool*(self: PrintSettings, key: ustring): bool {.inline.} =
  gtk_print_settings_get_bool(self, ucstring(key))
# proc get_bool*(self: PrintSettings, key: ustring): bool {.inline.} =

# gtk_print_settings_get_collate
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_print_settings_get_collate(self: ptr TPrintSettings): bool {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_collate".}
proc get_collate*(self: PrintSettings): bool {.inline.} =
  gtk_print_settings_get_collate(self)
# proc get_collate*(self: PrintSettings): bool {.inline.} =

# gtk_print_settings_get_default_source
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_print_settings_get_default_source(self: ptr TPrintSettings): ucstring {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_default_source".}
proc get_default_source*(self: PrintSettings): ucstring {.inline.} =
  gtk_print_settings_get_default_source(self)
# proc get_default_source*(self: PrintSettings): ucstring {.inline.} =

# gtk_print_settings_get_dither
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_print_settings_get_dither(self: ptr TPrintSettings): ucstring {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_dither".}
proc get_dither*(self: PrintSettings): ucstring {.inline.} =
  gtk_print_settings_get_dither(self)
# proc get_dither*(self: PrintSettings): ucstring {.inline.} =

# gtk_print_settings_get_double
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg key: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: DOUBLE 'float64' 'float64'
proc gtk_print_settings_get_double(self: ptr TPrintSettings, key: ucstring): float64 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_double".}
proc get_double*(self: PrintSettings, key: ustring): float64 {.inline.} =
  gtk_print_settings_get_double(self, ucstring(key))
# proc get_double*(self: PrintSettings, key: ustring): float64 {.inline.} =

# gtk_print_settings_get_double_with_default
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg key: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg def: DOUBLE 'float64' 'float64' IN
# return: DOUBLE 'float64' 'float64'
proc gtk_print_settings_get_double_with_default(self: ptr TPrintSettings, key: ucstring, def: float64): float64 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_double_with_default".}
proc get_double_with_default*(self: PrintSettings, key: ustring, def: float64): float64 {.inline.} =
  gtk_print_settings_get_double_with_default(self, ucstring(key), def)
# proc get_double_with_default*(self: PrintSettings, key: ustring, def: float64): float64 {.inline.} =

# gtk_print_settings_get_duplex
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# return: INTERFACE 'PrintDuplex' 'PrintDuplex'
proc gtk_print_settings_get_duplex(self: ptr TPrintSettings): PrintDuplex {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_duplex".}
proc get_duplex*(self: PrintSettings): PrintDuplex {.inline.} =
  gtk_print_settings_get_duplex(self)
# proc get_duplex*(self: PrintSettings): PrintDuplex {.inline.} =

# gtk_print_settings_get_finishings
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_print_settings_get_finishings(self: ptr TPrintSettings): ucstring {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_finishings".}
proc get_finishings*(self: PrintSettings): ucstring {.inline.} =
  gtk_print_settings_get_finishings(self)
# proc get_finishings*(self: PrintSettings): ucstring {.inline.} =

# gtk_print_settings_get_int
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg key: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INT32 'int32' 'int32'
proc gtk_print_settings_get_int(self: ptr TPrintSettings, key: ucstring): int32 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_int".}
proc get_int*(self: PrintSettings, key: ustring): int32 {.inline.} =
  gtk_print_settings_get_int(self, ucstring(key))
# proc get_int*(self: PrintSettings, key: ustring): int32 {.inline.} =

# gtk_print_settings_get_int_with_default
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg key: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg def: INT32 'int32' 'int32' IN
# return: INT32 'int32' 'int32'
proc gtk_print_settings_get_int_with_default(self: ptr TPrintSettings, key: ucstring, def: int32): int32 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_int_with_default".}
proc get_int_with_default*(self: PrintSettings, key: ustring, def: int32): int32 {.inline.} =
  gtk_print_settings_get_int_with_default(self, ucstring(key), def)
# proc get_int_with_default*(self: PrintSettings, key: ustring, def: int32): int32 {.inline.} =

# gtk_print_settings_get_length
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg key: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: DOUBLE 'float64' 'float64'
proc gtk_print_settings_get_length(self: ptr TPrintSettings, key: ucstring, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_length".}
proc get_length*(self: PrintSettings, key: ustring, unit: Unit): float64 {.inline.} =
  gtk_print_settings_get_length(self, ucstring(key), unit)
# proc get_length*(self: PrintSettings, key: ustring, unit: Unit): float64 {.inline.} =

# gtk_print_settings_get_media_type
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_print_settings_get_media_type(self: ptr TPrintSettings): ucstring {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_media_type".}
proc get_media_type*(self: PrintSettings): ucstring {.inline.} =
  gtk_print_settings_get_media_type(self)
# proc get_media_type*(self: PrintSettings): ucstring {.inline.} =

# gtk_print_settings_get_n_copies
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_print_settings_get_n_copies(self: ptr TPrintSettings): int32 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_n_copies".}
proc get_n_copies*(self: PrintSettings): int32 {.inline.} =
  gtk_print_settings_get_n_copies(self)
# proc get_n_copies*(self: PrintSettings): int32 {.inline.} =

# gtk_print_settings_get_number_up
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_print_settings_get_number_up(self: ptr TPrintSettings): int32 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_number_up".}
proc get_number_up*(self: PrintSettings): int32 {.inline.} =
  gtk_print_settings_get_number_up(self)
# proc get_number_up*(self: PrintSettings): int32 {.inline.} =

# gtk_print_settings_get_number_up_layout
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# return: INTERFACE 'NumberUpLayout' 'NumberUpLayout'
proc gtk_print_settings_get_number_up_layout(self: ptr TPrintSettings): NumberUpLayout {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_number_up_layout".}
proc get_number_up_layout*(self: PrintSettings): NumberUpLayout {.inline.} =
  gtk_print_settings_get_number_up_layout(self)
# proc get_number_up_layout*(self: PrintSettings): NumberUpLayout {.inline.} =

# gtk_print_settings_get_orientation
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# return: INTERFACE 'PageOrientation' 'PageOrientation'
proc gtk_print_settings_get_orientation(self: ptr TPrintSettings): PageOrientation {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_orientation".}
proc get_orientation*(self: PrintSettings): PageOrientation {.inline.} =
  gtk_print_settings_get_orientation(self)
# proc get_orientation*(self: PrintSettings): PageOrientation {.inline.} =

# gtk_print_settings_get_output_bin
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_print_settings_get_output_bin(self: ptr TPrintSettings): ucstring {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_output_bin".}
proc get_output_bin*(self: PrintSettings): ucstring {.inline.} =
  gtk_print_settings_get_output_bin(self)
# proc get_output_bin*(self: PrintSettings): ucstring {.inline.} =

# gtk_print_settings_get_page_ranges
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg num_ranges: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# return: ARRAY 'zeroTerminatedArray[TPageRange]' 'zeroTerminatedArray[TPageRange]'
proc gtk_print_settings_get_page_ranges(self: ptr TPrintSettings, num_ranges: ptr int32): zeroTerminatedArray[TPageRange] {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_page_ranges".}
proc get_page_ranges*(self: PrintSettings, num_ranges: var int32): zeroTerminatedArray[TPageRange] {.inline.} =
  gtk_print_settings_get_page_ranges(self, addr(num_ranges))
# tuple-return
# num_ranges: var int32
# proc get_page_ranges*(self: PrintSettings): zeroTerminatedArray[TPageRange] {.inline.} =

# gtk_print_settings_get_page_set
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# return: INTERFACE 'PageSet' 'PageSet'
proc gtk_print_settings_get_page_set(self: ptr TPrintSettings): PageSet {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_page_set".}
proc get_page_set*(self: PrintSettings): PageSet {.inline.} =
  gtk_print_settings_get_page_set(self)
# proc get_page_set*(self: PrintSettings): PageSet {.inline.} =

# gtk_print_settings_get_paper_height
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: DOUBLE 'float64' 'float64'
proc gtk_print_settings_get_paper_height(self: ptr TPrintSettings, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_paper_height".}
proc get_paper_height*(self: PrintSettings, unit: Unit): float64 {.inline.} =
  gtk_print_settings_get_paper_height(self, unit)
# proc get_paper_height*(self: PrintSettings, unit: Unit): float64 {.inline.} =

# gtk_print_settings_get_paper_size
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# return: INTERFACE 'ptr TPaperSize' 'ptr TPaperSize'
proc gtk_print_settings_get_paper_size(self: ptr TPrintSettings): ptr TPaperSize {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_paper_size".}
proc get_paper_size*(self: PrintSettings): ptr TPaperSize {.inline.} =
  gtk_print_settings_get_paper_size(self)
# proc get_paper_size*(self: PrintSettings): ptr TPaperSize {.inline.} =

# gtk_print_settings_get_paper_width
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: DOUBLE 'float64' 'float64'
proc gtk_print_settings_get_paper_width(self: ptr TPrintSettings, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_paper_width".}
proc get_paper_width*(self: PrintSettings, unit: Unit): float64 {.inline.} =
  gtk_print_settings_get_paper_width(self, unit)
# proc get_paper_width*(self: PrintSettings, unit: Unit): float64 {.inline.} =

# gtk_print_settings_get_print_pages
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# return: INTERFACE 'PrintPages' 'PrintPages'
proc gtk_print_settings_get_print_pages(self: ptr TPrintSettings): PrintPages {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_print_pages".}
proc get_print_pages*(self: PrintSettings): PrintPages {.inline.} =
  gtk_print_settings_get_print_pages(self)
# proc get_print_pages*(self: PrintSettings): PrintPages {.inline.} =

# gtk_print_settings_get_printer
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_print_settings_get_printer(self: ptr TPrintSettings): ucstring {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_printer".}
proc get_printer*(self: PrintSettings): ucstring {.inline.} =
  gtk_print_settings_get_printer(self)
# proc get_printer*(self: PrintSettings): ucstring {.inline.} =

# gtk_print_settings_get_printer_lpi
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_print_settings_get_printer_lpi(self: ptr TPrintSettings): float64 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_printer_lpi".}
proc get_printer_lpi*(self: PrintSettings): float64 {.inline.} =
  gtk_print_settings_get_printer_lpi(self)
# proc get_printer_lpi*(self: PrintSettings): float64 {.inline.} =

# gtk_print_settings_get_quality
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# return: INTERFACE 'PrintQuality' 'PrintQuality'
proc gtk_print_settings_get_quality(self: ptr TPrintSettings): PrintQuality {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_quality".}
proc get_quality*(self: PrintSettings): PrintQuality {.inline.} =
  gtk_print_settings_get_quality(self)
# proc get_quality*(self: PrintSettings): PrintQuality {.inline.} =

# gtk_print_settings_get_resolution
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_print_settings_get_resolution(self: ptr TPrintSettings): int32 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_resolution".}
proc get_resolution*(self: PrintSettings): int32 {.inline.} =
  gtk_print_settings_get_resolution(self)
# proc get_resolution*(self: PrintSettings): int32 {.inline.} =

# gtk_print_settings_get_resolution_x
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_print_settings_get_resolution_x(self: ptr TPrintSettings): int32 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_resolution_x".}
proc get_resolution_x*(self: PrintSettings): int32 {.inline.} =
  gtk_print_settings_get_resolution_x(self)
# proc get_resolution_x*(self: PrintSettings): int32 {.inline.} =

# gtk_print_settings_get_resolution_y
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_print_settings_get_resolution_y(self: ptr TPrintSettings): int32 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_resolution_y".}
proc get_resolution_y*(self: PrintSettings): int32 {.inline.} =
  gtk_print_settings_get_resolution_y(self)
# proc get_resolution_y*(self: PrintSettings): int32 {.inline.} =

# gtk_print_settings_get_reverse
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_print_settings_get_reverse(self: ptr TPrintSettings): bool {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_reverse".}
proc get_reverse*(self: PrintSettings): bool {.inline.} =
  gtk_print_settings_get_reverse(self)
# proc get_reverse*(self: PrintSettings): bool {.inline.} =

# gtk_print_settings_get_scale
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_print_settings_get_scale(self: ptr TPrintSettings): float64 {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_scale".}
proc get_scale*(self: PrintSettings): float64 {.inline.} =
  gtk_print_settings_get_scale(self)
# proc get_scale*(self: PrintSettings): float64 {.inline.} =

# gtk_print_settings_get_use_color
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_print_settings_get_use_color(self: ptr TPrintSettings): bool {.cdecl, dynlib: lib, importc: "gtk_print_settings_get_use_color".}
proc get_use_color*(self: PrintSettings): bool {.inline.} =
  gtk_print_settings_get_use_color(self)
# proc get_use_color*(self: PrintSettings): bool {.inline.} =

# gtk_print_settings_has_key
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg key: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_print_settings_has_key(self: ptr TPrintSettings, key: ucstring): bool {.cdecl, dynlib: lib, importc: "gtk_print_settings_has_key".}
proc has_key*(self: PrintSettings, key: ustring): bool {.inline.} =
  gtk_print_settings_has_key(self, ucstring(key))
# proc has_key*(self: PrintSettings, key: ustring): bool {.inline.} =

# gtk_print_settings_load_file
# flags: {isMethod, throws} container: PrintSettings
# can throw
# need sugar: is method
# arg file_name: FILENAME 'string' 'cstring' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_print_settings_load_file(self: ptr TPrintSettings, file_name: cstring, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_print_settings_load_file".}
proc load_file*(self: PrintSettings, file_name: string): bool {.inline.} =
  gtk_print_settings_load_file(self, cstring(file_name))
# proc load_file*(self: PrintSettings, file_name: string): bool {.inline.} =

# gtk_print_settings_load_key_file
# flags: {isMethod, throws} container: PrintSettings
# can throw
# need sugar: is method
# arg key_file: INTERFACE (STRUCT) 'ptr GLib2.TKeyFile' 'ptr GLib2.TKeyFile' IN
# arg group_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_print_settings_load_key_file(self: ptr TPrintSettings, key_file: ptr GLib2.TKeyFile, group_name: ucstring, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_print_settings_load_key_file".}
proc load_key_file*(self: PrintSettings, key_file: ptr GLib2.TKeyFile, group_name: ustring): bool {.inline.} =
  gtk_print_settings_load_key_file(self, key_file, ucstring(group_name))
# proc load_key_file*(self: PrintSettings, key_file: ptr GLib2.TKeyFile, group_name: ustring): bool {.inline.} =

# gtk_print_settings_set
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg key: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg value: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set(self: ptr TPrintSettings, key: ucstring, value: ucstring) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set".}
proc set*(self: PrintSettings, key: ustring, value: ustring) {.inline.} =
  gtk_print_settings_set(self, ucstring(key), ucstring(value))
# proc set*(self: PrintSettings, key: ustring, value: ustring) {.inline.} =

# gtk_print_settings_set_bool
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg key: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg value: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_bool(self: ptr TPrintSettings, key: ucstring, value: bool) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_bool".}
proc set_bool*(self: PrintSettings, key: ustring, value: bool) {.inline.} =
  gtk_print_settings_set_bool(self, ucstring(key), value)
# proc set_bool*(self: PrintSettings, key: ustring, value: bool) {.inline.} =

# gtk_print_settings_set_collate
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg collate: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_collate(self: ptr TPrintSettings, collate: bool) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_collate".}
proc set_collate*(self: PrintSettings, collate: bool) {.inline.} =
  gtk_print_settings_set_collate(self, collate)
# proc set_collate*(self: PrintSettings, collate: bool) {.inline.} =

# gtk_print_settings_set_default_source
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg default_source: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_default_source(self: ptr TPrintSettings, default_source: ucstring) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_default_source".}
proc set_default_source*(self: PrintSettings, default_source: ustring) {.inline.} =
  gtk_print_settings_set_default_source(self, ucstring(default_source))
# proc set_default_source*(self: PrintSettings, default_source: ustring) {.inline.} =

# gtk_print_settings_set_dither
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg dither: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_dither(self: ptr TPrintSettings, dither: ucstring) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_dither".}
proc set_dither*(self: PrintSettings, dither: ustring) {.inline.} =
  gtk_print_settings_set_dither(self, ucstring(dither))
# proc set_dither*(self: PrintSettings, dither: ustring) {.inline.} =

# gtk_print_settings_set_double
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg key: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg value: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_double(self: ptr TPrintSettings, key: ucstring, value: float64) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_double".}
proc set_double*(self: PrintSettings, key: ustring, value: float64) {.inline.} =
  gtk_print_settings_set_double(self, ucstring(key), value)
# proc set_double*(self: PrintSettings, key: ustring, value: float64) {.inline.} =

# gtk_print_settings_set_duplex
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg duplex: INTERFACE (ENUM) 'PrintDuplex' 'PrintDuplex' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_duplex(self: ptr TPrintSettings, duplex: PrintDuplex) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_duplex".}
proc set_duplex*(self: PrintSettings, duplex: PrintDuplex) {.inline.} =
  gtk_print_settings_set_duplex(self, duplex)
# proc set_duplex*(self: PrintSettings, duplex: PrintDuplex) {.inline.} =

# gtk_print_settings_set_finishings
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg finishings: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_finishings(self: ptr TPrintSettings, finishings: ucstring) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_finishings".}
proc set_finishings*(self: PrintSettings, finishings: ustring) {.inline.} =
  gtk_print_settings_set_finishings(self, ucstring(finishings))
# proc set_finishings*(self: PrintSettings, finishings: ustring) {.inline.} =

# gtk_print_settings_set_int
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg key: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg value: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_int(self: ptr TPrintSettings, key: ucstring, value: int32) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_int".}
proc set_int*(self: PrintSettings, key: ustring, value: int32) {.inline.} =
  gtk_print_settings_set_int(self, ucstring(key), value)
# proc set_int*(self: PrintSettings, key: ustring, value: int32) {.inline.} =

# gtk_print_settings_set_length
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg key: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg value: DOUBLE 'float64' 'float64' IN
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_length(self: ptr TPrintSettings, key: ucstring, value: float64, unit: Unit) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_length".}
proc set_length*(self: PrintSettings, key: ustring, value: float64, unit: Unit) {.inline.} =
  gtk_print_settings_set_length(self, ucstring(key), value, unit)
# proc set_length*(self: PrintSettings, key: ustring, value: float64, unit: Unit) {.inline.} =

# gtk_print_settings_set_media_type
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg media_type: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_media_type(self: ptr TPrintSettings, media_type: ucstring) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_media_type".}
proc set_media_type*(self: PrintSettings, media_type: ustring) {.inline.} =
  gtk_print_settings_set_media_type(self, ucstring(media_type))
# proc set_media_type*(self: PrintSettings, media_type: ustring) {.inline.} =

# gtk_print_settings_set_n_copies
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg num_copies: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_n_copies(self: ptr TPrintSettings, num_copies: int32) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_n_copies".}
proc set_n_copies*(self: PrintSettings, num_copies: int32) {.inline.} =
  gtk_print_settings_set_n_copies(self, num_copies)
# proc set_n_copies*(self: PrintSettings, num_copies: int32) {.inline.} =

# gtk_print_settings_set_number_up
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg number_up: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_number_up(self: ptr TPrintSettings, number_up: int32) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_number_up".}
proc set_number_up*(self: PrintSettings, number_up: int32) {.inline.} =
  gtk_print_settings_set_number_up(self, number_up)
# proc set_number_up*(self: PrintSettings, number_up: int32) {.inline.} =

# gtk_print_settings_set_number_up_layout
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg number_up_layout: INTERFACE (ENUM) 'NumberUpLayout' 'NumberUpLayout' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_number_up_layout(self: ptr TPrintSettings, number_up_layout: NumberUpLayout) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_number_up_layout".}
proc set_number_up_layout*(self: PrintSettings, number_up_layout: NumberUpLayout) {.inline.} =
  gtk_print_settings_set_number_up_layout(self, number_up_layout)
# proc set_number_up_layout*(self: PrintSettings, number_up_layout: NumberUpLayout) {.inline.} =

# gtk_print_settings_set_orientation
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg orientation: INTERFACE (ENUM) 'PageOrientation' 'PageOrientation' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_orientation(self: ptr TPrintSettings, orientation: PageOrientation) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_orientation".}
proc set_orientation*(self: PrintSettings, orientation: PageOrientation) {.inline.} =
  gtk_print_settings_set_orientation(self, orientation)
# proc set_orientation*(self: PrintSettings, orientation: PageOrientation) {.inline.} =

# gtk_print_settings_set_output_bin
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg output_bin: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_output_bin(self: ptr TPrintSettings, output_bin: ucstring) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_output_bin".}
proc set_output_bin*(self: PrintSettings, output_bin: ustring) {.inline.} =
  gtk_print_settings_set_output_bin(self, ucstring(output_bin))
# proc set_output_bin*(self: PrintSettings, output_bin: ustring) {.inline.} =

# gtk_print_settings_set_page_ranges
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg page_ranges: ARRAY 'var openarray[TPageRange]' 'openarray[TPageRange]' IN (diff., need sugar) array lengthArg: 1
# arg num_ranges: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_page_ranges(self: ptr TPrintSettings, page_ranges: openarray[TPageRange], num_ranges: int32) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_page_ranges".}
proc set_page_ranges*(self: PrintSettings, page_ranges: var openarray[TPageRange]) {.inline.} =
  gtk_print_settings_set_page_ranges(self, page_ranges, page_ranges.len.int32)
# proc set_page_ranges*(self: PrintSettings, page_ranges: var openarray[TPageRange]) {.inline.} =

# gtk_print_settings_set_page_set
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg page_set: INTERFACE (ENUM) 'PageSet' 'PageSet' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_page_set(self: ptr TPrintSettings, page_set: PageSet) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_page_set".}
proc set_page_set*(self: PrintSettings, page_set: PageSet) {.inline.} =
  gtk_print_settings_set_page_set(self, page_set)
# proc set_page_set*(self: PrintSettings, page_set: PageSet) {.inline.} =

# gtk_print_settings_set_paper_height
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg height: DOUBLE 'float64' 'float64' IN
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_paper_height(self: ptr TPrintSettings, height: float64, unit: Unit) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_paper_height".}
proc set_paper_height*(self: PrintSettings, height: float64, unit: Unit) {.inline.} =
  gtk_print_settings_set_paper_height(self, height, unit)
# proc set_paper_height*(self: PrintSettings, height: float64, unit: Unit) {.inline.} =

# gtk_print_settings_set_paper_size
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg paper_size: INTERFACE (STRUCT) 'ptr TPaperSize' 'ptr TPaperSize' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_paper_size(self: ptr TPrintSettings, paper_size: ptr TPaperSize) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_paper_size".}
proc set_paper_size*(self: PrintSettings, paper_size: ptr TPaperSize) {.inline.} =
  gtk_print_settings_set_paper_size(self, paper_size)
# proc set_paper_size*(self: PrintSettings, paper_size: ptr TPaperSize) {.inline.} =

# gtk_print_settings_set_paper_width
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg width: DOUBLE 'float64' 'float64' IN
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_paper_width(self: ptr TPrintSettings, width: float64, unit: Unit) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_paper_width".}
proc set_paper_width*(self: PrintSettings, width: float64, unit: Unit) {.inline.} =
  gtk_print_settings_set_paper_width(self, width, unit)
# proc set_paper_width*(self: PrintSettings, width: float64, unit: Unit) {.inline.} =

# gtk_print_settings_set_print_pages
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg pages: INTERFACE (ENUM) 'PrintPages' 'PrintPages' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_print_pages(self: ptr TPrintSettings, pages: PrintPages) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_print_pages".}
proc set_print_pages*(self: PrintSettings, pages: PrintPages) {.inline.} =
  gtk_print_settings_set_print_pages(self, pages)
# proc set_print_pages*(self: PrintSettings, pages: PrintPages) {.inline.} =

# gtk_print_settings_set_printer
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg printer: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_printer(self: ptr TPrintSettings, printer: ucstring) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_printer".}
proc set_printer*(self: PrintSettings, printer: ustring) {.inline.} =
  gtk_print_settings_set_printer(self, ucstring(printer))
# proc set_printer*(self: PrintSettings, printer: ustring) {.inline.} =

# gtk_print_settings_set_printer_lpi
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg lpi: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_printer_lpi(self: ptr TPrintSettings, lpi: float64) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_printer_lpi".}
proc set_printer_lpi*(self: PrintSettings, lpi: float64) {.inline.} =
  gtk_print_settings_set_printer_lpi(self, lpi)
# proc set_printer_lpi*(self: PrintSettings, lpi: float64) {.inline.} =

# gtk_print_settings_set_quality
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg quality: INTERFACE (ENUM) 'PrintQuality' 'PrintQuality' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_quality(self: ptr TPrintSettings, quality: PrintQuality) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_quality".}
proc set_quality*(self: PrintSettings, quality: PrintQuality) {.inline.} =
  gtk_print_settings_set_quality(self, quality)
# proc set_quality*(self: PrintSettings, quality: PrintQuality) {.inline.} =

# gtk_print_settings_set_resolution
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg resolution: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_resolution(self: ptr TPrintSettings, resolution: int32) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_resolution".}
proc set_resolution*(self: PrintSettings, resolution: int32) {.inline.} =
  gtk_print_settings_set_resolution(self, resolution)
# proc set_resolution*(self: PrintSettings, resolution: int32) {.inline.} =

# gtk_print_settings_set_resolution_xy
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg resolution_x: INT32 'int32' 'int32' IN
# arg resolution_y: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_resolution_xy(self: ptr TPrintSettings, resolution_x: int32, resolution_y: int32) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_resolution_xy".}
proc set_resolution_xy*(self: PrintSettings, resolution_x: int32, resolution_y: int32) {.inline.} =
  gtk_print_settings_set_resolution_xy(self, resolution_x, resolution_y)
# proc set_resolution_xy*(self: PrintSettings, resolution_x: int32, resolution_y: int32) {.inline.} =

# gtk_print_settings_set_reverse
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg reverse: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_reverse(self: ptr TPrintSettings, reverse: bool) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_reverse".}
proc set_reverse*(self: PrintSettings, reverse: bool) {.inline.} =
  gtk_print_settings_set_reverse(self, reverse)
# proc set_reverse*(self: PrintSettings, reverse: bool) {.inline.} =

# gtk_print_settings_set_scale
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg scale: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_scale(self: ptr TPrintSettings, scale: float64) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_scale".}
proc set_scale*(self: PrintSettings, scale: float64) {.inline.} =
  gtk_print_settings_set_scale(self, scale)
# proc set_scale*(self: PrintSettings, scale: float64) {.inline.} =

# gtk_print_settings_set_use_color
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg use_color: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_set_use_color(self: ptr TPrintSettings, use_color: bool) {.cdecl, dynlib: lib, importc: "gtk_print_settings_set_use_color".}
proc set_use_color*(self: PrintSettings, use_color: bool) {.inline.} =
  gtk_print_settings_set_use_color(self, use_color)
# proc set_use_color*(self: PrintSettings, use_color: bool) {.inline.} =

# gtk_print_settings_to_file
# flags: {isMethod, throws} container: PrintSettings
# can throw
# need sugar: is method
# arg file_name: FILENAME 'string' 'cstring' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_print_settings_to_file(self: ptr TPrintSettings, file_name: cstring, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_print_settings_to_file".}
proc to_file*(self: PrintSettings, file_name: string): bool {.inline.} =
  gtk_print_settings_to_file(self, cstring(file_name))
# proc to_file*(self: PrintSettings, file_name: string): bool {.inline.} =

# gtk_print_settings_to_key_file
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg key_file: INTERFACE (STRUCT) 'ptr GLib2.TKeyFile' 'ptr GLib2.TKeyFile' IN
# arg group_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_to_key_file(self: ptr TPrintSettings, key_file: ptr GLib2.TKeyFile, group_name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_print_settings_to_key_file".}
proc to_key_file*(self: PrintSettings, key_file: ptr GLib2.TKeyFile, group_name: ustring) {.inline.} =
  gtk_print_settings_to_key_file(self, key_file, ucstring(group_name))
# proc to_key_file*(self: PrintSettings, key_file: ptr GLib2.TKeyFile, group_name: ustring) {.inline.} =

# gtk_print_settings_unset
# flags: {isMethod} container: PrintSettings
# need sugar: is method
# arg key: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_print_settings_unset(self: ptr TPrintSettings, key: ucstring) {.cdecl, dynlib: lib, importc: "gtk_print_settings_unset".}
proc unset*(self: PrintSettings, key: ustring) {.inline.} =
  gtk_print_settings_unset(self, ucstring(key))
# proc unset*(self: PrintSettings, key: ustring) {.inline.} =

# initializer for ProgressBar: gtk_progress_bar_get_type
proc gtk_progress_bar_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_progress_bar_get_type".}
template gtype*(klass_parameter: typedesc[ProgressBar]): GType = gtk_progress_bar_get_type()
# gtk_progress_bar_new
# flags: {isConstructor} container: ProgressBar
# need sugar: is static method
# return: INTERFACE 'ProgressBar' 'TransferNone[TProgressBar]' (diff., need sugar)
proc gtk_progress_bar_new(): TransferNone[TProgressBar] {.cdecl, dynlib: lib, importc: "gtk_progress_bar_new".}
proc new_progressbar*(): ProgressBar {.inline.} =
  wrap(gtk_progress_bar_new())
# proc new_progressbar*(): ProgressBar {.inline.} =

# gtk_progress_bar_get_ellipsize
# flags: {isMethod} container: ProgressBar
# need sugar: is method
# return: INTERFACE 'Pango1.EllipsizeMode' 'Pango1.EllipsizeMode'
proc gtk_progress_bar_get_ellipsize(self: ptr TProgressBar): Pango1.EllipsizeMode {.cdecl, dynlib: lib, importc: "gtk_progress_bar_get_ellipsize".}
proc get_ellipsize*(self: ProgressBar): Pango1.EllipsizeMode {.inline.} =
  gtk_progress_bar_get_ellipsize(self)
# proc get_ellipsize*(self: ProgressBar): Pango1.EllipsizeMode {.inline.} =

# gtk_progress_bar_get_fraction
# flags: {isMethod} container: ProgressBar
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_progress_bar_get_fraction(self: ptr TProgressBar): float64 {.cdecl, dynlib: lib, importc: "gtk_progress_bar_get_fraction".}
proc get_fraction*(self: ProgressBar): float64 {.inline.} =
  gtk_progress_bar_get_fraction(self)
# proc get_fraction*(self: ProgressBar): float64 {.inline.} =

# gtk_progress_bar_get_inverted
# flags: {isMethod} container: ProgressBar
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_progress_bar_get_inverted(self: ptr TProgressBar): bool {.cdecl, dynlib: lib, importc: "gtk_progress_bar_get_inverted".}
proc get_inverted*(self: ProgressBar): bool {.inline.} =
  gtk_progress_bar_get_inverted(self)
# proc get_inverted*(self: ProgressBar): bool {.inline.} =

# gtk_progress_bar_get_pulse_step
# flags: {isMethod} container: ProgressBar
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_progress_bar_get_pulse_step(self: ptr TProgressBar): float64 {.cdecl, dynlib: lib, importc: "gtk_progress_bar_get_pulse_step".}
proc get_pulse_step*(self: ProgressBar): float64 {.inline.} =
  gtk_progress_bar_get_pulse_step(self)
# proc get_pulse_step*(self: ProgressBar): float64 {.inline.} =

# gtk_progress_bar_get_show_text
# flags: {isMethod} container: ProgressBar
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_progress_bar_get_show_text(self: ptr TProgressBar): bool {.cdecl, dynlib: lib, importc: "gtk_progress_bar_get_show_text".}
proc get_show_text*(self: ProgressBar): bool {.inline.} =
  gtk_progress_bar_get_show_text(self)
# proc get_show_text*(self: ProgressBar): bool {.inline.} =

# gtk_progress_bar_get_text
# flags: {isMethod} container: ProgressBar
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_progress_bar_get_text(self: ptr TProgressBar): ucstring {.cdecl, dynlib: lib, importc: "gtk_progress_bar_get_text".}
proc get_text*(self: ProgressBar): ucstring {.inline.} =
  gtk_progress_bar_get_text(self)
# proc get_text*(self: ProgressBar): ucstring {.inline.} =

# gtk_progress_bar_pulse
# flags: {isMethod} container: ProgressBar
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_progress_bar_pulse(self: ptr TProgressBar) {.cdecl, dynlib: lib, importc: "gtk_progress_bar_pulse".}
proc pulse*(self: ProgressBar) {.inline.} =
  gtk_progress_bar_pulse(self)
# proc pulse*(self: ProgressBar) {.inline.} =

# gtk_progress_bar_set_ellipsize
# flags: {isMethod} container: ProgressBar
# need sugar: is method
# arg mode: INTERFACE (ENUM) 'Pango1.EllipsizeMode' 'Pango1.EllipsizeMode' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_progress_bar_set_ellipsize(self: ptr TProgressBar, mode: Pango1.EllipsizeMode) {.cdecl, dynlib: lib, importc: "gtk_progress_bar_set_ellipsize".}
proc set_ellipsize*(self: ProgressBar, mode: Pango1.EllipsizeMode) {.inline.} =
  gtk_progress_bar_set_ellipsize(self, mode)
# proc set_ellipsize*(self: ProgressBar, mode: Pango1.EllipsizeMode) {.inline.} =

# gtk_progress_bar_set_fraction
# flags: {isMethod} container: ProgressBar
# need sugar: is method
# arg fraction: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_progress_bar_set_fraction(self: ptr TProgressBar, fraction: float64) {.cdecl, dynlib: lib, importc: "gtk_progress_bar_set_fraction".}
proc set_fraction*(self: ProgressBar, fraction: float64) {.inline.} =
  gtk_progress_bar_set_fraction(self, fraction)
# proc set_fraction*(self: ProgressBar, fraction: float64) {.inline.} =

# gtk_progress_bar_set_inverted
# flags: {isMethod} container: ProgressBar
# need sugar: is method
# arg inverted: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_progress_bar_set_inverted(self: ptr TProgressBar, inverted: bool) {.cdecl, dynlib: lib, importc: "gtk_progress_bar_set_inverted".}
proc set_inverted*(self: ProgressBar, inverted: bool) {.inline.} =
  gtk_progress_bar_set_inverted(self, inverted)
# proc set_inverted*(self: ProgressBar, inverted: bool) {.inline.} =

# gtk_progress_bar_set_pulse_step
# flags: {isMethod} container: ProgressBar
# need sugar: is method
# arg fraction: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_progress_bar_set_pulse_step(self: ptr TProgressBar, fraction: float64) {.cdecl, dynlib: lib, importc: "gtk_progress_bar_set_pulse_step".}
proc set_pulse_step*(self: ProgressBar, fraction: float64) {.inline.} =
  gtk_progress_bar_set_pulse_step(self, fraction)
# proc set_pulse_step*(self: ProgressBar, fraction: float64) {.inline.} =

# gtk_progress_bar_set_show_text
# flags: {isMethod} container: ProgressBar
# need sugar: is method
# arg show_text: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_progress_bar_set_show_text(self: ptr TProgressBar, show_text: bool) {.cdecl, dynlib: lib, importc: "gtk_progress_bar_set_show_text".}
proc set_show_text*(self: ProgressBar, show_text: bool) {.inline.} =
  gtk_progress_bar_set_show_text(self, show_text)
# proc set_show_text*(self: ProgressBar, show_text: bool) {.inline.} =

# gtk_progress_bar_set_text
# flags: {isMethod} container: ProgressBar
# need sugar: is method
# arg text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_progress_bar_set_text(self: ptr TProgressBar, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_progress_bar_set_text".}
proc set_text*(self: ProgressBar, text: ustring) {.inline.} =
  gtk_progress_bar_set_text(self, ucstring(text))
# proc set_text*(self: ProgressBar, text: ustring) {.inline.} =

# initializer for ProgressBarAccessible: gtk_progress_bar_accessible_get_type
proc gtk_progress_bar_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_progress_bar_accessible_get_type".}
template gtype*(klass_parameter: typedesc[ProgressBarAccessible]): GType = gtk_progress_bar_accessible_get_type()
# initializer for RadioAction: gtk_radio_action_get_type
proc gtk_radio_action_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_radio_action_get_type".}
template gtype*(klass_parameter: typedesc[RadioAction]): GType = gtk_radio_action_get_type()
# gtk_radio_action_new
# flags: {isConstructor} container: RadioAction (deprecated)
# gtk_radio_action_get_current_value
# flags: {isMethod} container: RadioAction (deprecated)
# gtk_radio_action_get_group
# flags: {isMethod} container: RadioAction (deprecated)
# gtk_radio_action_join_group
# flags: {isMethod} container: RadioAction (deprecated)
# gtk_radio_action_set_current_value
# flags: {isMethod} container: RadioAction (deprecated)
# gtk_radio_action_set_group
# flags: {isMethod} container: RadioAction (deprecated)
# initializer for RadioButton: gtk_radio_button_get_type
proc gtk_radio_button_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_radio_button_get_type".}
template gtype*(klass_parameter: typedesc[RadioButton]): GType = gtk_radio_button_get_type()
# gtk_radio_button_new
# flags: {isConstructor} container: RadioButton
# need sugar: is static method
# arg group: GSLIST 'ptr GSLIST_TODO' 'ptr GSLIST_TODO' IN
# return: INTERFACE 'RadioButton' 'TransferNone[TRadioButton]' (diff., need sugar)
proc gtk_radio_button_new(group: ptr GSLIST_TODO): TransferNone[TRadioButton] {.cdecl, dynlib: lib, importc: "gtk_radio_button_new".}
proc new_radiobutton*(group: ptr GSLIST_TODO): RadioButton {.inline.} =
  wrap(gtk_radio_button_new(group))
# proc new_radiobutton*(group: ptr GSLIST_TODO): RadioButton {.inline.} =

# gtk_radio_button_new_from_widget
# flags: {isConstructor} container: RadioButton
# need sugar: is static method
# arg radio_group_member: INTERFACE (OBJECT) 'RadioButton' 'ptr TRadioButton' IN (diff., need sugar)
# return: INTERFACE 'RadioButton' 'TransferNone[TRadioButton]' (diff., need sugar)
proc gtk_radio_button_new_from_widget(radio_group_member: ptr TRadioButton): TransferNone[TRadioButton] {.cdecl, dynlib: lib, importc: "gtk_radio_button_new_from_widget".}
proc new_radiobutton_from_widget*(radio_group_member: RadioButton): RadioButton {.inline.} =
  wrap(gtk_radio_button_new_from_widget(radio_group_member.getPointer))
# proc new_radiobutton_from_widget*(radio_group_member: RadioButton): RadioButton {.inline.} =

# gtk_radio_button_new_with_label
# flags: {isConstructor} container: RadioButton
# need sugar: is static method
# arg group: GSLIST 'ptr GSLIST_TODO' 'ptr GSLIST_TODO' IN
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'RadioButton' 'TransferNone[TRadioButton]' (diff., need sugar)
proc gtk_radio_button_new_with_label(group: ptr GSLIST_TODO, label: ucstring): TransferNone[TRadioButton] {.cdecl, dynlib: lib, importc: "gtk_radio_button_new_with_label".}
proc new_radiobutton_with_label*(group: ptr GSLIST_TODO, label: ustring): RadioButton {.inline.} =
  wrap(gtk_radio_button_new_with_label(group, ucstring(label)))
# proc new_radiobutton_with_label*(group: ptr GSLIST_TODO, label: ustring): RadioButton {.inline.} =

# gtk_radio_button_new_with_label_from_widget
# flags: {isConstructor} container: RadioButton
# need sugar: is static method
# arg radio_group_member: INTERFACE (OBJECT) 'RadioButton' 'ptr TRadioButton' IN (diff., need sugar)
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'RadioButton' 'TransferNone[TRadioButton]' (diff., need sugar)
proc gtk_radio_button_new_with_label_from_widget(radio_group_member: ptr TRadioButton, label: ucstring): TransferNone[TRadioButton] {.cdecl, dynlib: lib, importc: "gtk_radio_button_new_with_label_from_widget".}
proc new_radiobutton_with_label_from_widget*(radio_group_member: RadioButton, label: ustring): RadioButton {.inline.} =
  wrap(gtk_radio_button_new_with_label_from_widget(radio_group_member.getPointer, ucstring(label)))
# proc new_radiobutton_with_label_from_widget*(radio_group_member: RadioButton, label: ustring): RadioButton {.inline.} =

# gtk_radio_button_new_with_mnemonic
# flags: {isConstructor} container: RadioButton
# need sugar: is static method
# arg group: GSLIST 'ptr GSLIST_TODO' 'ptr GSLIST_TODO' IN
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'RadioButton' 'TransferNone[TRadioButton]' (diff., need sugar)
proc gtk_radio_button_new_with_mnemonic(group: ptr GSLIST_TODO, label: ucstring): TransferNone[TRadioButton] {.cdecl, dynlib: lib, importc: "gtk_radio_button_new_with_mnemonic".}
proc new_radiobutton_with_mnemonic*(group: ptr GSLIST_TODO, label: ustring): RadioButton {.inline.} =
  wrap(gtk_radio_button_new_with_mnemonic(group, ucstring(label)))
# proc new_radiobutton_with_mnemonic*(group: ptr GSLIST_TODO, label: ustring): RadioButton {.inline.} =

# gtk_radio_button_new_with_mnemonic_from_widget
# flags: {isConstructor} container: RadioButton
# need sugar: is static method
# arg radio_group_member: INTERFACE (OBJECT) 'RadioButton' 'ptr TRadioButton' IN (diff., need sugar)
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'RadioButton' 'TransferNone[TRadioButton]' (diff., need sugar)
proc gtk_radio_button_new_with_mnemonic_from_widget(radio_group_member: ptr TRadioButton, label: ucstring): TransferNone[TRadioButton] {.cdecl, dynlib: lib, importc: "gtk_radio_button_new_with_mnemonic_from_widget".}
proc new_radiobutton_with_mnemonic_from_widget*(radio_group_member: RadioButton, label: ustring): RadioButton {.inline.} =
  wrap(gtk_radio_button_new_with_mnemonic_from_widget(radio_group_member.getPointer, ucstring(label)))
# proc new_radiobutton_with_mnemonic_from_widget*(radio_group_member: RadioButton, label: ustring): RadioButton {.inline.} =

# gtk_radio_button_get_group
# flags: {isMethod} container: RadioButton
# need sugar: is method
# return: GSLIST 'ptr GSLIST_TODO' 'ptr GSLIST_TODO'
proc gtk_radio_button_get_group(self: ptr TRadioButton): ptr GSLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_radio_button_get_group".}
proc get_group*(self: RadioButton): ptr GSLIST_TODO {.inline.} =
  gtk_radio_button_get_group(self)
# proc get_group*(self: RadioButton): ptr GSLIST_TODO {.inline.} =

# gtk_radio_button_join_group
# flags: {isMethod} container: RadioButton
# need sugar: is method
# arg group_source: INTERFACE (OBJECT) 'RadioButton' 'ptr TRadioButton' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_radio_button_join_group(self: ptr TRadioButton, group_source: ptr TRadioButton) {.cdecl, dynlib: lib, importc: "gtk_radio_button_join_group".}
proc join_group*(self: RadioButton, group_source: RadioButton) {.inline.} =
  gtk_radio_button_join_group(self, group_source.getPointer)
# proc join_group*(self: RadioButton, group_source: RadioButton) {.inline.} =

# gtk_radio_button_set_group
# flags: {isMethod} container: RadioButton
# need sugar: is method
# arg group: GSLIST 'ptr GSLIST_TODO' 'ptr GSLIST_TODO' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_radio_button_set_group(self: ptr TRadioButton, group: ptr GSLIST_TODO) {.cdecl, dynlib: lib, importc: "gtk_radio_button_set_group".}
proc set_group*(self: RadioButton, group: ptr GSLIST_TODO) {.inline.} =
  gtk_radio_button_set_group(self, group)
# proc set_group*(self: RadioButton, group: ptr GSLIST_TODO) {.inline.} =

# initializer for RadioButtonAccessible: gtk_radio_button_accessible_get_type
proc gtk_radio_button_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_radio_button_accessible_get_type".}
template gtype*(klass_parameter: typedesc[RadioButtonAccessible]): GType = gtk_radio_button_accessible_get_type()
# initializer for RadioMenuItem: gtk_radio_menu_item_get_type
proc gtk_radio_menu_item_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_radio_menu_item_get_type".}
template gtype*(klass_parameter: typedesc[RadioMenuItem]): GType = gtk_radio_menu_item_get_type()
# gtk_radio_menu_item_new
# flags: {isConstructor} container: RadioMenuItem
# need sugar: is static method
# arg group: GSLIST 'ptr GSLIST_TODO' 'ptr GSLIST_TODO' IN
# return: INTERFACE 'RadioMenuItem' 'TransferNone[TRadioMenuItem]' (diff., need sugar)
proc gtk_radio_menu_item_new(group: ptr GSLIST_TODO): TransferNone[TRadioMenuItem] {.cdecl, dynlib: lib, importc: "gtk_radio_menu_item_new".}
proc new_radiomenuitem*(group: ptr GSLIST_TODO): RadioMenuItem {.inline.} =
  wrap(gtk_radio_menu_item_new(group))
# proc new_radiomenuitem*(group: ptr GSLIST_TODO): RadioMenuItem {.inline.} =

# gtk_radio_menu_item_new_from_widget
# flags: {isConstructor} container: RadioMenuItem
# need sugar: is static method
# arg group: INTERFACE (OBJECT) 'RadioMenuItem' 'ptr TRadioMenuItem' IN (diff., need sugar)
# return: INTERFACE 'RadioMenuItem' 'TransferNone[TRadioMenuItem]' (diff., need sugar)
proc gtk_radio_menu_item_new_from_widget(group: ptr TRadioMenuItem): TransferNone[TRadioMenuItem] {.cdecl, dynlib: lib, importc: "gtk_radio_menu_item_new_from_widget".}
proc new_radiomenuitem_from_widget*(group: RadioMenuItem): RadioMenuItem {.inline.} =
  wrap(gtk_radio_menu_item_new_from_widget(group.getPointer))
# proc new_radiomenuitem_from_widget*(group: RadioMenuItem): RadioMenuItem {.inline.} =

# gtk_radio_menu_item_new_with_label
# flags: {isConstructor} container: RadioMenuItem
# need sugar: is static method
# arg group: GSLIST 'ptr GSLIST_TODO' 'ptr GSLIST_TODO' IN
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'RadioMenuItem' 'TransferNone[TRadioMenuItem]' (diff., need sugar)
proc gtk_radio_menu_item_new_with_label(group: ptr GSLIST_TODO, label: ucstring): TransferNone[TRadioMenuItem] {.cdecl, dynlib: lib, importc: "gtk_radio_menu_item_new_with_label".}
proc new_radiomenuitem_with_label*(group: ptr GSLIST_TODO, label: ustring): RadioMenuItem {.inline.} =
  wrap(gtk_radio_menu_item_new_with_label(group, ucstring(label)))
# proc new_radiomenuitem_with_label*(group: ptr GSLIST_TODO, label: ustring): RadioMenuItem {.inline.} =

# gtk_radio_menu_item_new_with_label_from_widget
# flags: {isConstructor} container: RadioMenuItem
# need sugar: is static method
# arg group: INTERFACE (OBJECT) 'RadioMenuItem' 'ptr TRadioMenuItem' IN (diff., need sugar)
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'RadioMenuItem' 'TransferNone[TRadioMenuItem]' (diff., need sugar)
proc gtk_radio_menu_item_new_with_label_from_widget(group: ptr TRadioMenuItem, label: ucstring): TransferNone[TRadioMenuItem] {.cdecl, dynlib: lib, importc: "gtk_radio_menu_item_new_with_label_from_widget".}
proc new_radiomenuitem_with_label_from_widget*(group: RadioMenuItem, label: ustring): RadioMenuItem {.inline.} =
  wrap(gtk_radio_menu_item_new_with_label_from_widget(group.getPointer, ucstring(label)))
# proc new_radiomenuitem_with_label_from_widget*(group: RadioMenuItem, label: ustring): RadioMenuItem {.inline.} =

# gtk_radio_menu_item_new_with_mnemonic
# flags: {isConstructor} container: RadioMenuItem
# need sugar: is static method
# arg group: GSLIST 'ptr GSLIST_TODO' 'ptr GSLIST_TODO' IN
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'RadioMenuItem' 'TransferNone[TRadioMenuItem]' (diff., need sugar)
proc gtk_radio_menu_item_new_with_mnemonic(group: ptr GSLIST_TODO, label: ucstring): TransferNone[TRadioMenuItem] {.cdecl, dynlib: lib, importc: "gtk_radio_menu_item_new_with_mnemonic".}
proc new_radiomenuitem_with_mnemonic*(group: ptr GSLIST_TODO, label: ustring): RadioMenuItem {.inline.} =
  wrap(gtk_radio_menu_item_new_with_mnemonic(group, ucstring(label)))
# proc new_radiomenuitem_with_mnemonic*(group: ptr GSLIST_TODO, label: ustring): RadioMenuItem {.inline.} =

# gtk_radio_menu_item_new_with_mnemonic_from_widget
# flags: {isConstructor} container: RadioMenuItem
# need sugar: is static method
# arg group: INTERFACE (OBJECT) 'RadioMenuItem' 'ptr TRadioMenuItem' IN (diff., need sugar)
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'RadioMenuItem' 'TransferNone[TRadioMenuItem]' (diff., need sugar)
proc gtk_radio_menu_item_new_with_mnemonic_from_widget(group: ptr TRadioMenuItem, label: ucstring): TransferNone[TRadioMenuItem] {.cdecl, dynlib: lib, importc: "gtk_radio_menu_item_new_with_mnemonic_from_widget".}
proc new_radiomenuitem_with_mnemonic_from_widget*(group: RadioMenuItem, label: ustring): RadioMenuItem {.inline.} =
  wrap(gtk_radio_menu_item_new_with_mnemonic_from_widget(group.getPointer, ucstring(label)))
# proc new_radiomenuitem_with_mnemonic_from_widget*(group: RadioMenuItem, label: ustring): RadioMenuItem {.inline.} =

# gtk_radio_menu_item_get_group
# flags: {isMethod} container: RadioMenuItem
# need sugar: is method
# return: GSLIST 'ptr GSLIST_TODO' 'ptr GSLIST_TODO'
proc gtk_radio_menu_item_get_group(self: ptr TRadioMenuItem): ptr GSLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_radio_menu_item_get_group".}
proc get_group*(self: RadioMenuItem): ptr GSLIST_TODO {.inline.} =
  gtk_radio_menu_item_get_group(self)
# proc get_group*(self: RadioMenuItem): ptr GSLIST_TODO {.inline.} =

# gtk_radio_menu_item_join_group
# flags: {isMethod} container: RadioMenuItem
# need sugar: is method
# arg group_source: INTERFACE (OBJECT) 'RadioMenuItem' 'ptr TRadioMenuItem' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_radio_menu_item_join_group(self: ptr TRadioMenuItem, group_source: ptr TRadioMenuItem) {.cdecl, dynlib: lib, importc: "gtk_radio_menu_item_join_group".}
proc join_group*(self: RadioMenuItem, group_source: RadioMenuItem) {.inline.} =
  gtk_radio_menu_item_join_group(self, group_source.getPointer)
# proc join_group*(self: RadioMenuItem, group_source: RadioMenuItem) {.inline.} =

# gtk_radio_menu_item_set_group
# flags: {isMethod} container: RadioMenuItem
# need sugar: is method
# arg group: GSLIST 'ptr GSLIST_TODO' 'ptr GSLIST_TODO' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_radio_menu_item_set_group(self: ptr TRadioMenuItem, group: ptr GSLIST_TODO) {.cdecl, dynlib: lib, importc: "gtk_radio_menu_item_set_group".}
proc set_group*(self: RadioMenuItem, group: ptr GSLIST_TODO) {.inline.} =
  gtk_radio_menu_item_set_group(self, group)
# proc set_group*(self: RadioMenuItem, group: ptr GSLIST_TODO) {.inline.} =

# initializer for RadioMenuItemAccessible: gtk_radio_menu_item_accessible_get_type
proc gtk_radio_menu_item_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_radio_menu_item_accessible_get_type".}
template gtype*(klass_parameter: typedesc[RadioMenuItemAccessible]): GType = gtk_radio_menu_item_accessible_get_type()
# initializer for RadioToolButton: gtk_radio_tool_button_get_type
proc gtk_radio_tool_button_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_radio_tool_button_get_type".}
template gtype*(klass_parameter: typedesc[RadioToolButton]): GType = gtk_radio_tool_button_get_type()
# gtk_radio_tool_button_new
# flags: {isConstructor} container: RadioToolButton
# need sugar: is static method
# arg group: GSLIST 'ptr GSLIST_TODO' 'ptr GSLIST_TODO' IN
# return: INTERFACE 'RadioToolButton' 'TransferNone[TRadioToolButton]' (diff., need sugar)
proc gtk_radio_tool_button_new(group: ptr GSLIST_TODO): TransferNone[TRadioToolButton] {.cdecl, dynlib: lib, importc: "gtk_radio_tool_button_new".}
proc new_radiotoolbutton*(group: ptr GSLIST_TODO): RadioToolButton {.inline.} =
  wrap(gtk_radio_tool_button_new(group))
# proc new_radiotoolbutton*(group: ptr GSLIST_TODO): RadioToolButton {.inline.} =

# gtk_radio_tool_button_new_from_stock
# flags: {isConstructor} container: RadioToolButton (deprecated)
# gtk_radio_tool_button_new_from_widget
# flags: {isConstructor} container: RadioToolButton
# need sugar: is static method
# arg group: INTERFACE (OBJECT) 'RadioToolButton' 'ptr TRadioToolButton' IN (diff., need sugar)
# return: INTERFACE 'RadioToolButton' 'TransferNone[TRadioToolButton]' (diff., need sugar)
proc gtk_radio_tool_button_new_from_widget(group: ptr TRadioToolButton): TransferNone[TRadioToolButton] {.cdecl, dynlib: lib, importc: "gtk_radio_tool_button_new_from_widget".}
proc new_radiotoolbutton_from_widget*(group: RadioToolButton): RadioToolButton {.inline.} =
  wrap(gtk_radio_tool_button_new_from_widget(group.getPointer))
# proc new_radiotoolbutton_from_widget*(group: RadioToolButton): RadioToolButton {.inline.} =

# gtk_radio_tool_button_new_with_stock_from_widget
# flags: {isConstructor} container: RadioToolButton (deprecated)
# gtk_radio_tool_button_get_group
# flags: {isMethod} container: RadioToolButton
# need sugar: is method
# return: GSLIST 'ptr GSLIST_TODO' 'ptr GSLIST_TODO'
proc gtk_radio_tool_button_get_group(self: ptr TRadioToolButton): ptr GSLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_radio_tool_button_get_group".}
proc get_group*(self: RadioToolButton): ptr GSLIST_TODO {.inline.} =
  gtk_radio_tool_button_get_group(self)
# proc get_group*(self: RadioToolButton): ptr GSLIST_TODO {.inline.} =

# gtk_radio_tool_button_set_group
# flags: {isMethod} container: RadioToolButton
# need sugar: is method
# arg group: GSLIST 'ptr GSLIST_TODO' 'ptr GSLIST_TODO' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_radio_tool_button_set_group(self: ptr TRadioToolButton, group: ptr GSLIST_TODO) {.cdecl, dynlib: lib, importc: "gtk_radio_tool_button_set_group".}
proc set_group*(self: RadioToolButton, group: ptr GSLIST_TODO) {.inline.} =
  gtk_radio_tool_button_set_group(self, group)
# proc set_group*(self: RadioToolButton, group: ptr GSLIST_TODO) {.inline.} =

# initializer for Range: gtk_range_get_type
proc gtk_range_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_range_get_type".}
template gtype*(klass_parameter: typedesc[Range]): GType = gtk_range_get_type()
# gtk_range_get_adjustment
# flags: {isMethod} container: Range
# need sugar: is method
# return: INTERFACE 'Adjustment' 'TransferNone[TAdjustment]' (diff., need sugar)
proc gtk_range_get_adjustment(self: ptr TRange): TransferNone[TAdjustment] {.cdecl, dynlib: lib, importc: "gtk_range_get_adjustment".}
proc get_adjustment*(self: Range): Adjustment {.inline.} =
  wrap(gtk_range_get_adjustment(self))
# proc get_adjustment*(self: Range): Adjustment {.inline.} =

# gtk_range_get_fill_level
# flags: {isMethod} container: Range
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_range_get_fill_level(self: ptr TRange): float64 {.cdecl, dynlib: lib, importc: "gtk_range_get_fill_level".}
proc get_fill_level*(self: Range): float64 {.inline.} =
  gtk_range_get_fill_level(self)
# proc get_fill_level*(self: Range): float64 {.inline.} =

# gtk_range_get_flippable
# flags: {isMethod} container: Range
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_range_get_flippable(self: ptr TRange): bool {.cdecl, dynlib: lib, importc: "gtk_range_get_flippable".}
proc get_flippable*(self: Range): bool {.inline.} =
  gtk_range_get_flippable(self)
# proc get_flippable*(self: Range): bool {.inline.} =

# gtk_range_get_inverted
# flags: {isMethod} container: Range
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_range_get_inverted(self: ptr TRange): bool {.cdecl, dynlib: lib, importc: "gtk_range_get_inverted".}
proc get_inverted*(self: Range): bool {.inline.} =
  gtk_range_get_inverted(self)
# proc get_inverted*(self: Range): bool {.inline.} =

# gtk_range_get_lower_stepper_sensitivity
# flags: {isMethod} container: Range
# need sugar: is method
# return: INTERFACE 'SensitivityType' 'SensitivityType'
proc gtk_range_get_lower_stepper_sensitivity(self: ptr TRange): SensitivityType {.cdecl, dynlib: lib, importc: "gtk_range_get_lower_stepper_sensitivity".}
proc get_lower_stepper_sensitivity*(self: Range): SensitivityType {.inline.} =
  gtk_range_get_lower_stepper_sensitivity(self)
# proc get_lower_stepper_sensitivity*(self: Range): SensitivityType {.inline.} =

# gtk_range_get_min_slider_size
# flags: {isMethod} container: Range
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_range_get_min_slider_size(self: ptr TRange): int32 {.cdecl, dynlib: lib, importc: "gtk_range_get_min_slider_size".}
proc get_min_slider_size*(self: Range): int32 {.inline.} =
  gtk_range_get_min_slider_size(self)
# proc get_min_slider_size*(self: Range): int32 {.inline.} =

# gtk_range_get_range_rect
# flags: {isMethod} container: Range
# need sugar: is method
# arg range_rect: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' OUT caller-allocates
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_range_get_range_rect(self: ptr TRange, range_rect: ptr Gdk3.TRectangle) {.cdecl, dynlib: lib, importc: "gtk_range_get_range_rect".}
proc get_range_rect*(self: Range, range_rect: ptr Gdk3.TRectangle) {.inline.} =
  gtk_range_get_range_rect(self, range_rect)
# tuple-return
# range_rect: ptr Gdk3.TRectangle
# proc get_range_rect*(self: Range) {.inline.} =

# gtk_range_get_restrict_to_fill_level
# flags: {isMethod} container: Range
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_range_get_restrict_to_fill_level(self: ptr TRange): bool {.cdecl, dynlib: lib, importc: "gtk_range_get_restrict_to_fill_level".}
proc get_restrict_to_fill_level*(self: Range): bool {.inline.} =
  gtk_range_get_restrict_to_fill_level(self)
# proc get_restrict_to_fill_level*(self: Range): bool {.inline.} =

# gtk_range_get_round_digits
# flags: {isMethod} container: Range
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_range_get_round_digits(self: ptr TRange): int32 {.cdecl, dynlib: lib, importc: "gtk_range_get_round_digits".}
proc get_round_digits*(self: Range): int32 {.inline.} =
  gtk_range_get_round_digits(self)
# proc get_round_digits*(self: Range): int32 {.inline.} =

# gtk_range_get_show_fill_level
# flags: {isMethod} container: Range
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_range_get_show_fill_level(self: ptr TRange): bool {.cdecl, dynlib: lib, importc: "gtk_range_get_show_fill_level".}
proc get_show_fill_level*(self: Range): bool {.inline.} =
  gtk_range_get_show_fill_level(self)
# proc get_show_fill_level*(self: Range): bool {.inline.} =

# gtk_range_get_slider_range
# flags: {isMethod} container: Range
# need sugar: is method
# arg slider_start: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg slider_end: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_range_get_slider_range(self: ptr TRange, slider_start: ptr int32, slider_end: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_range_get_slider_range".}
proc get_slider_range*(self: Range, slider_start: var int32, slider_end: var int32) {.inline.} =
  gtk_range_get_slider_range(self, addr(slider_start), addr(slider_end))
# tuple-return
# slider_start: var int32
# slider_end: var int32
# proc get_slider_range*(self: Range) {.inline.} =

# gtk_range_get_slider_size_fixed
# flags: {isMethod} container: Range
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_range_get_slider_size_fixed(self: ptr TRange): bool {.cdecl, dynlib: lib, importc: "gtk_range_get_slider_size_fixed".}
proc get_slider_size_fixed*(self: Range): bool {.inline.} =
  gtk_range_get_slider_size_fixed(self)
# proc get_slider_size_fixed*(self: Range): bool {.inline.} =

# gtk_range_get_upper_stepper_sensitivity
# flags: {isMethod} container: Range
# need sugar: is method
# return: INTERFACE 'SensitivityType' 'SensitivityType'
proc gtk_range_get_upper_stepper_sensitivity(self: ptr TRange): SensitivityType {.cdecl, dynlib: lib, importc: "gtk_range_get_upper_stepper_sensitivity".}
proc get_upper_stepper_sensitivity*(self: Range): SensitivityType {.inline.} =
  gtk_range_get_upper_stepper_sensitivity(self)
# proc get_upper_stepper_sensitivity*(self: Range): SensitivityType {.inline.} =

# gtk_range_get_value
# flags: {isMethod} container: Range
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_range_get_value(self: ptr TRange): float64 {.cdecl, dynlib: lib, importc: "gtk_range_get_value".}
proc get_value*(self: Range): float64 {.inline.} =
  gtk_range_get_value(self)
# proc get_value*(self: Range): float64 {.inline.} =

# gtk_range_set_adjustment
# flags: {isMethod} container: Range
# need sugar: is method
# arg adjustment: INTERFACE (OBJECT) 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_adjustment(self: ptr TRange, adjustment: ptr TAdjustment) {.cdecl, dynlib: lib, importc: "gtk_range_set_adjustment".}
proc set_adjustment*(self: Range, adjustment: Adjustment) {.inline.} =
  gtk_range_set_adjustment(self, adjustment.getPointer)
# proc set_adjustment*(self: Range, adjustment: Adjustment) {.inline.} =

# gtk_range_set_fill_level
# flags: {isMethod} container: Range
# need sugar: is method
# arg fill_level: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_fill_level(self: ptr TRange, fill_level: float64) {.cdecl, dynlib: lib, importc: "gtk_range_set_fill_level".}
proc set_fill_level*(self: Range, fill_level: float64) {.inline.} =
  gtk_range_set_fill_level(self, fill_level)
# proc set_fill_level*(self: Range, fill_level: float64) {.inline.} =

# gtk_range_set_flippable
# flags: {isMethod} container: Range
# need sugar: is method
# arg flippable: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_flippable(self: ptr TRange, flippable: bool) {.cdecl, dynlib: lib, importc: "gtk_range_set_flippable".}
proc set_flippable*(self: Range, flippable: bool) {.inline.} =
  gtk_range_set_flippable(self, flippable)
# proc set_flippable*(self: Range, flippable: bool) {.inline.} =

# gtk_range_set_increments
# flags: {isMethod} container: Range
# need sugar: is method
# arg step: DOUBLE 'float64' 'float64' IN
# arg page: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_increments(self: ptr TRange, step: float64, page: float64) {.cdecl, dynlib: lib, importc: "gtk_range_set_increments".}
proc set_increments*(self: Range, step: float64, page: float64) {.inline.} =
  gtk_range_set_increments(self, step, page)
# proc set_increments*(self: Range, step: float64, page: float64) {.inline.} =

# gtk_range_set_inverted
# flags: {isMethod} container: Range
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_inverted(self: ptr TRange, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_range_set_inverted".}
proc set_inverted*(self: Range, setting: bool) {.inline.} =
  gtk_range_set_inverted(self, setting)
# proc set_inverted*(self: Range, setting: bool) {.inline.} =

# gtk_range_set_lower_stepper_sensitivity
# flags: {isMethod} container: Range
# need sugar: is method
# arg sensitivity: INTERFACE (ENUM) 'SensitivityType' 'SensitivityType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_lower_stepper_sensitivity(self: ptr TRange, sensitivity: SensitivityType) {.cdecl, dynlib: lib, importc: "gtk_range_set_lower_stepper_sensitivity".}
proc set_lower_stepper_sensitivity*(self: Range, sensitivity: SensitivityType) {.inline.} =
  gtk_range_set_lower_stepper_sensitivity(self, sensitivity)
# proc set_lower_stepper_sensitivity*(self: Range, sensitivity: SensitivityType) {.inline.} =

# gtk_range_set_min_slider_size
# flags: {isMethod} container: Range
# need sugar: is method
# arg min_size: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_min_slider_size(self: ptr TRange, min_size: int32) {.cdecl, dynlib: lib, importc: "gtk_range_set_min_slider_size".}
proc set_min_slider_size*(self: Range, min_size: int32) {.inline.} =
  gtk_range_set_min_slider_size(self, min_size)
# proc set_min_slider_size*(self: Range, min_size: int32) {.inline.} =

# gtk_range_set_range
# flags: {isMethod} container: Range
# need sugar: is method
# arg min: DOUBLE 'float64' 'float64' IN
# arg max: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_range(self: ptr TRange, min: float64, max: float64) {.cdecl, dynlib: lib, importc: "gtk_range_set_range".}
proc set_range*(self: Range, min: float64, max: float64) {.inline.} =
  gtk_range_set_range(self, min, max)
# proc set_range*(self: Range, min: float64, max: float64) {.inline.} =

# gtk_range_set_restrict_to_fill_level
# flags: {isMethod} container: Range
# need sugar: is method
# arg restrict_to_fill_level: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_restrict_to_fill_level(self: ptr TRange, restrict_to_fill_level: bool) {.cdecl, dynlib: lib, importc: "gtk_range_set_restrict_to_fill_level".}
proc set_restrict_to_fill_level*(self: Range, restrict_to_fill_level: bool) {.inline.} =
  gtk_range_set_restrict_to_fill_level(self, restrict_to_fill_level)
# proc set_restrict_to_fill_level*(self: Range, restrict_to_fill_level: bool) {.inline.} =

# gtk_range_set_round_digits
# flags: {isMethod} container: Range
# need sugar: is method
# arg round_digits: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_round_digits(self: ptr TRange, round_digits: int32) {.cdecl, dynlib: lib, importc: "gtk_range_set_round_digits".}
proc set_round_digits*(self: Range, round_digits: int32) {.inline.} =
  gtk_range_set_round_digits(self, round_digits)
# proc set_round_digits*(self: Range, round_digits: int32) {.inline.} =

# gtk_range_set_show_fill_level
# flags: {isMethod} container: Range
# need sugar: is method
# arg show_fill_level: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_show_fill_level(self: ptr TRange, show_fill_level: bool) {.cdecl, dynlib: lib, importc: "gtk_range_set_show_fill_level".}
proc set_show_fill_level*(self: Range, show_fill_level: bool) {.inline.} =
  gtk_range_set_show_fill_level(self, show_fill_level)
# proc set_show_fill_level*(self: Range, show_fill_level: bool) {.inline.} =

# gtk_range_set_slider_size_fixed
# flags: {isMethod} container: Range
# need sugar: is method
# arg size_fixed: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_slider_size_fixed(self: ptr TRange, size_fixed: bool) {.cdecl, dynlib: lib, importc: "gtk_range_set_slider_size_fixed".}
proc set_slider_size_fixed*(self: Range, size_fixed: bool) {.inline.} =
  gtk_range_set_slider_size_fixed(self, size_fixed)
# proc set_slider_size_fixed*(self: Range, size_fixed: bool) {.inline.} =

# gtk_range_set_upper_stepper_sensitivity
# flags: {isMethod} container: Range
# need sugar: is method
# arg sensitivity: INTERFACE (ENUM) 'SensitivityType' 'SensitivityType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_upper_stepper_sensitivity(self: ptr TRange, sensitivity: SensitivityType) {.cdecl, dynlib: lib, importc: "gtk_range_set_upper_stepper_sensitivity".}
proc set_upper_stepper_sensitivity*(self: Range, sensitivity: SensitivityType) {.inline.} =
  gtk_range_set_upper_stepper_sensitivity(self, sensitivity)
# proc set_upper_stepper_sensitivity*(self: Range, sensitivity: SensitivityType) {.inline.} =

# gtk_range_set_value
# flags: {isMethod} container: Range
# need sugar: is method
# arg value: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_range_set_value(self: ptr TRange, value: float64) {.cdecl, dynlib: lib, importc: "gtk_range_set_value".}
proc set_value*(self: Range, value: float64) {.inline.} =
  gtk_range_set_value(self, value)
# proc set_value*(self: Range, value: float64) {.inline.} =

# initializer for RangeAccessible: gtk_range_accessible_get_type
proc gtk_range_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_range_accessible_get_type".}
template gtype*(klass_parameter: typedesc[RangeAccessible]): GType = gtk_range_accessible_get_type()
# initializer for RcStyle: gtk_rc_style_get_type
proc gtk_rc_style_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_rc_style_get_type".}
template gtype*(klass_parameter: typedesc[RcStyle]): GType = gtk_rc_style_get_type()
# gtk_rc_style_new
# flags: {isConstructor} container: RcStyle (deprecated)
# gtk_rc_style_copy
# flags: {isMethod} container: RcStyle (deprecated)
# initializer for RecentAction: gtk_recent_action_get_type
proc gtk_recent_action_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_recent_action_get_type".}
template gtype*(klass_parameter: typedesc[RecentAction]): GType = gtk_recent_action_get_type()
# gtk_recent_action_new
# flags: {isConstructor} container: RecentAction (deprecated)
# gtk_recent_action_new_for_manager
# flags: {isConstructor} container: RecentAction (deprecated)
# gtk_recent_action_get_show_numbers
# flags: {isMethod} container: RecentAction (deprecated)
# gtk_recent_action_set_show_numbers
# flags: {isMethod} container: RecentAction (deprecated)
# initializer for RecentChooserDialog: gtk_recent_chooser_dialog_get_type
proc gtk_recent_chooser_dialog_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_recent_chooser_dialog_get_type".}
template gtype*(klass_parameter: typedesc[RecentChooserDialog]): GType = gtk_recent_chooser_dialog_get_type()
# initializer for RecentChooserMenu: gtk_recent_chooser_menu_get_type
proc gtk_recent_chooser_menu_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_recent_chooser_menu_get_type".}
template gtype*(klass_parameter: typedesc[RecentChooserMenu]): GType = gtk_recent_chooser_menu_get_type()
# gtk_recent_chooser_menu_new
# flags: {isConstructor} container: RecentChooserMenu
# need sugar: is static method
# return: INTERFACE 'RecentChooserMenu' 'TransferNone[TRecentChooserMenu]' (diff., need sugar)
proc gtk_recent_chooser_menu_new(): TransferNone[TRecentChooserMenu] {.cdecl, dynlib: lib, importc: "gtk_recent_chooser_menu_new".}
proc new_recentchoosermenu*(): RecentChooserMenu {.inline.} =
  wrap(gtk_recent_chooser_menu_new())
# proc new_recentchoosermenu*(): RecentChooserMenu {.inline.} =

# gtk_recent_chooser_menu_new_for_manager
# flags: {isConstructor} container: RecentChooserMenu
# need sugar: is static method
# arg manager: INTERFACE (OBJECT) 'RecentManager' 'ptr TRecentManager' IN (diff., need sugar)
# return: INTERFACE 'RecentChooserMenu' 'TransferNone[TRecentChooserMenu]' (diff., need sugar)
proc gtk_recent_chooser_menu_new_for_manager(manager: ptr TRecentManager): TransferNone[TRecentChooserMenu] {.cdecl, dynlib: lib, importc: "gtk_recent_chooser_menu_new_for_manager".}
proc new_recentchoosermenu_for_manager*(manager: RecentManager): RecentChooserMenu {.inline.} =
  wrap(gtk_recent_chooser_menu_new_for_manager(manager.getPointer))
# proc new_recentchoosermenu_for_manager*(manager: RecentManager): RecentChooserMenu {.inline.} =

# gtk_recent_chooser_menu_get_show_numbers
# flags: {isMethod} container: RecentChooserMenu
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_recent_chooser_menu_get_show_numbers(self: ptr TRecentChooserMenu): bool {.cdecl, dynlib: lib, importc: "gtk_recent_chooser_menu_get_show_numbers".}
proc get_show_numbers*(self: RecentChooserMenu): bool {.inline.} =
  gtk_recent_chooser_menu_get_show_numbers(self)
# proc get_show_numbers*(self: RecentChooserMenu): bool {.inline.} =

# gtk_recent_chooser_menu_set_show_numbers
# flags: {isMethod} container: RecentChooserMenu
# need sugar: is method
# arg show_numbers: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_recent_chooser_menu_set_show_numbers(self: ptr TRecentChooserMenu, show_numbers: bool) {.cdecl, dynlib: lib, importc: "gtk_recent_chooser_menu_set_show_numbers".}
proc set_show_numbers*(self: RecentChooserMenu, show_numbers: bool) {.inline.} =
  gtk_recent_chooser_menu_set_show_numbers(self, show_numbers)
# proc set_show_numbers*(self: RecentChooserMenu, show_numbers: bool) {.inline.} =

# initializer for RecentChooserWidget: gtk_recent_chooser_widget_get_type
proc gtk_recent_chooser_widget_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_recent_chooser_widget_get_type".}
template gtype*(klass_parameter: typedesc[RecentChooserWidget]): GType = gtk_recent_chooser_widget_get_type()
# gtk_recent_chooser_widget_new
# flags: {isConstructor} container: RecentChooserWidget
# need sugar: is static method
# return: INTERFACE 'RecentChooserWidget' 'TransferNone[TRecentChooserWidget]' (diff., need sugar)
proc gtk_recent_chooser_widget_new(): TransferNone[TRecentChooserWidget] {.cdecl, dynlib: lib, importc: "gtk_recent_chooser_widget_new".}
proc new_recentchooserwidget*(): RecentChooserWidget {.inline.} =
  wrap(gtk_recent_chooser_widget_new())
# proc new_recentchooserwidget*(): RecentChooserWidget {.inline.} =

# gtk_recent_chooser_widget_new_for_manager
# flags: {isConstructor} container: RecentChooserWidget
# need sugar: is static method
# arg manager: INTERFACE (OBJECT) 'RecentManager' 'ptr TRecentManager' IN (diff., need sugar)
# return: INTERFACE 'RecentChooserWidget' 'TransferNone[TRecentChooserWidget]' (diff., need sugar)
proc gtk_recent_chooser_widget_new_for_manager(manager: ptr TRecentManager): TransferNone[TRecentChooserWidget] {.cdecl, dynlib: lib, importc: "gtk_recent_chooser_widget_new_for_manager".}
proc new_recentchooserwidget_for_manager*(manager: RecentManager): RecentChooserWidget {.inline.} =
  wrap(gtk_recent_chooser_widget_new_for_manager(manager.getPointer))
# proc new_recentchooserwidget_for_manager*(manager: RecentManager): RecentChooserWidget {.inline.} =

# initializer for RecentFilter: gtk_recent_filter_get_type
proc gtk_recent_filter_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_recent_filter_get_type".}
template gtype*(klass_parameter: typedesc[RecentFilter]): GType = gtk_recent_filter_get_type()
# gtk_recent_filter_new
# flags: {isConstructor} container: RecentFilter
# need sugar: is static method
# return: INTERFACE 'RecentFilter' 'TransferNone[TRecentFilter]' (diff., need sugar)
proc gtk_recent_filter_new(): TransferNone[TRecentFilter] {.cdecl, dynlib: lib, importc: "gtk_recent_filter_new".}
proc new_recentfilter*(): RecentFilter {.inline.} =
  wrap(gtk_recent_filter_new())
# proc new_recentfilter*(): RecentFilter {.inline.} =

# gtk_recent_filter_add_age
# flags: {isMethod} container: RecentFilter
# need sugar: is method
# arg days: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_recent_filter_add_age(self: ptr TRecentFilter, days: int32) {.cdecl, dynlib: lib, importc: "gtk_recent_filter_add_age".}
proc add_age*(self: RecentFilter, days: int32) {.inline.} =
  gtk_recent_filter_add_age(self, days)
# proc add_age*(self: RecentFilter, days: int32) {.inline.} =

# gtk_recent_filter_add_application
# flags: {isMethod} container: RecentFilter
# need sugar: is method
# arg application: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_recent_filter_add_application(self: ptr TRecentFilter, application: ucstring) {.cdecl, dynlib: lib, importc: "gtk_recent_filter_add_application".}
proc add_application*(self: RecentFilter, application: ustring) {.inline.} =
  gtk_recent_filter_add_application(self, ucstring(application))
# proc add_application*(self: RecentFilter, application: ustring) {.inline.} =

# gtk_recent_filter_add_custom
# flags: {isMethod} container: RecentFilter
# need sugar: is method
# arg needed: INTERFACE (FLAGS) 'SRecentFilterFlags' 'SRecentFilterFlags' IN
# arg func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg data: VOID 'pointer' 'pointer' IN
# arg data_destroy: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_recent_filter_add_custom(self: ptr TRecentFilter, needed: SRecentFilterFlags, func_x: pointer, data: pointer, data_destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_recent_filter_add_custom".}
proc add_custom*(self: RecentFilter, needed: SRecentFilterFlags, func_x: pointer, data: pointer, data_destroy: pointer) {.inline.} =
  gtk_recent_filter_add_custom(self, needed, func_x, data, data_destroy)
# proc add_custom*(self: RecentFilter, needed: SRecentFilterFlags, func_x: pointer, data: pointer, data_destroy: pointer) {.inline.} =

# gtk_recent_filter_add_group
# flags: {isMethod} container: RecentFilter
# need sugar: is method
# arg group: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_recent_filter_add_group(self: ptr TRecentFilter, group: ucstring) {.cdecl, dynlib: lib, importc: "gtk_recent_filter_add_group".}
proc add_group*(self: RecentFilter, group: ustring) {.inline.} =
  gtk_recent_filter_add_group(self, ucstring(group))
# proc add_group*(self: RecentFilter, group: ustring) {.inline.} =

# gtk_recent_filter_add_mime_type
# flags: {isMethod} container: RecentFilter
# need sugar: is method
# arg mime_type: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_recent_filter_add_mime_type(self: ptr TRecentFilter, mime_type: ucstring) {.cdecl, dynlib: lib, importc: "gtk_recent_filter_add_mime_type".}
proc add_mime_type*(self: RecentFilter, mime_type: ustring) {.inline.} =
  gtk_recent_filter_add_mime_type(self, ucstring(mime_type))
# proc add_mime_type*(self: RecentFilter, mime_type: ustring) {.inline.} =

# gtk_recent_filter_add_pattern
# flags: {isMethod} container: RecentFilter
# need sugar: is method
# arg pattern: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_recent_filter_add_pattern(self: ptr TRecentFilter, pattern: ucstring) {.cdecl, dynlib: lib, importc: "gtk_recent_filter_add_pattern".}
proc add_pattern*(self: RecentFilter, pattern: ustring) {.inline.} =
  gtk_recent_filter_add_pattern(self, ucstring(pattern))
# proc add_pattern*(self: RecentFilter, pattern: ustring) {.inline.} =

# gtk_recent_filter_add_pixbuf_formats
# flags: {isMethod} container: RecentFilter
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_recent_filter_add_pixbuf_formats(self: ptr TRecentFilter) {.cdecl, dynlib: lib, importc: "gtk_recent_filter_add_pixbuf_formats".}
proc add_pixbuf_formats*(self: RecentFilter) {.inline.} =
  gtk_recent_filter_add_pixbuf_formats(self)
# proc add_pixbuf_formats*(self: RecentFilter) {.inline.} =

# gtk_recent_filter_filter
# flags: {isMethod} container: RecentFilter
# need sugar: is method
# arg filter_info: INTERFACE (STRUCT) 'ptr TRecentFilterInfo' 'ptr TRecentFilterInfo' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_recent_filter_filter(self: ptr TRecentFilter, filter_info: ptr TRecentFilterInfo): bool {.cdecl, dynlib: lib, importc: "gtk_recent_filter_filter".}
proc filter*(self: RecentFilter, filter_info: ptr TRecentFilterInfo): bool {.inline.} =
  gtk_recent_filter_filter(self, filter_info)
# proc filter*(self: RecentFilter, filter_info: ptr TRecentFilterInfo): bool {.inline.} =

# gtk_recent_filter_get_name
# flags: {isMethod} container: RecentFilter
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_recent_filter_get_name(self: ptr TRecentFilter): ucstring {.cdecl, dynlib: lib, importc: "gtk_recent_filter_get_name".}
proc get_name*(self: RecentFilter): ucstring {.inline.} =
  gtk_recent_filter_get_name(self)
# proc get_name*(self: RecentFilter): ucstring {.inline.} =

# gtk_recent_filter_get_needed
# flags: {isMethod} container: RecentFilter
# need sugar: is method
# return: INTERFACE 'SRecentFilterFlags' 'SRecentFilterFlags'
proc gtk_recent_filter_get_needed(self: ptr TRecentFilter): SRecentFilterFlags {.cdecl, dynlib: lib, importc: "gtk_recent_filter_get_needed".}
proc get_needed*(self: RecentFilter): SRecentFilterFlags {.inline.} =
  gtk_recent_filter_get_needed(self)
# proc get_needed*(self: RecentFilter): SRecentFilterFlags {.inline.} =

# gtk_recent_filter_set_name
# flags: {isMethod} container: RecentFilter
# need sugar: is method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_recent_filter_set_name(self: ptr TRecentFilter, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_recent_filter_set_name".}
proc set_name*(self: RecentFilter, name: ustring) {.inline.} =
  gtk_recent_filter_set_name(self, ucstring(name))
# proc set_name*(self: RecentFilter, name: ustring) {.inline.} =

# initializer for RecentManager: gtk_recent_manager_get_type
proc gtk_recent_manager_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_recent_manager_get_type".}
template gtype*(klass_parameter: typedesc[RecentManager]): GType = gtk_recent_manager_get_type()
# gtk_recent_manager_new
# flags: {isConstructor} container: RecentManager
# need sugar: is static method
# return: INTERFACE 'RecentManager' 'TransferFull[TRecentManager]' (diff., need sugar)
proc gtk_recent_manager_new(): TransferFull[TRecentManager] {.cdecl, dynlib: lib, importc: "gtk_recent_manager_new".}
proc new_recentmanager*(): RecentManager {.inline.} =
  wrap(gtk_recent_manager_new())
# proc new_recentmanager*(): RecentManager {.inline.} =

# gtk_recent_manager_get_default
# flags: {} container: RecentManager
# need sugar: is static method
# return: INTERFACE 'RecentManager' 'TransferNone[TRecentManager]' (diff., need sugar)
proc gtk_recent_manager_get_default(): TransferNone[TRecentManager] {.cdecl, dynlib: lib, importc: "gtk_recent_manager_get_default".}
template get_default*(klass_parameter: typedesc[RecentManager]): RecentManager =
  wrap(gtk_recent_manager_get_default())
# template get_default*(klass_parameter: typedesc[RecentManager]): RecentManager =

# gtk_recent_manager_add_full
# flags: {isMethod} container: RecentManager
# need sugar: is method
# arg uri: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg recent_data: INTERFACE (STRUCT) 'ptr TRecentData' 'ptr TRecentData' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_recent_manager_add_full(self: ptr TRecentManager, uri: ucstring, recent_data: ptr TRecentData): bool {.cdecl, dynlib: lib, importc: "gtk_recent_manager_add_full".}
proc add_full*(self: RecentManager, uri: ustring, recent_data: ptr TRecentData): bool {.inline.} =
  gtk_recent_manager_add_full(self, ucstring(uri), recent_data)
# proc add_full*(self: RecentManager, uri: ustring, recent_data: ptr TRecentData): bool {.inline.} =

# gtk_recent_manager_add_item
# flags: {isMethod} container: RecentManager
# need sugar: is method
# arg uri: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_recent_manager_add_item(self: ptr TRecentManager, uri: ucstring): bool {.cdecl, dynlib: lib, importc: "gtk_recent_manager_add_item".}
proc add_item*(self: RecentManager, uri: ustring): bool {.inline.} =
  gtk_recent_manager_add_item(self, ucstring(uri))
# proc add_item*(self: RecentManager, uri: ustring): bool {.inline.} =

# gtk_recent_manager_get_items
# flags: {isMethod} container: RecentManager
# need sugar: is method
# return: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_recent_manager_get_items(self: ptr TRecentManager): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_recent_manager_get_items".}
proc get_items*(self: RecentManager): ptr GLIST_TODO {.inline.} =
  gtk_recent_manager_get_items(self)
# proc get_items*(self: RecentManager): ptr GLIST_TODO {.inline.} =

# gtk_recent_manager_has_item
# flags: {isMethod} container: RecentManager
# need sugar: is method
# arg uri: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_recent_manager_has_item(self: ptr TRecentManager, uri: ucstring): bool {.cdecl, dynlib: lib, importc: "gtk_recent_manager_has_item".}
proc has_item*(self: RecentManager, uri: ustring): bool {.inline.} =
  gtk_recent_manager_has_item(self, ucstring(uri))
# proc has_item*(self: RecentManager, uri: ustring): bool {.inline.} =

# gtk_recent_manager_lookup_item
# flags: {isMethod, throws} container: RecentManager
# can throw
# need sugar: is method
# arg uri: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'ptr TRecentInfo' 'ptr TRecentInfo'
proc gtk_recent_manager_lookup_item(self: ptr TRecentManager, uri: ucstring, error: ptr PGError=nil): ptr TRecentInfo {.cdecl, dynlib: lib, importc: "gtk_recent_manager_lookup_item".}
proc lookup_item*(self: RecentManager, uri: ustring): ptr TRecentInfo {.inline.} =
  gtk_recent_manager_lookup_item(self, ucstring(uri))
# proc lookup_item*(self: RecentManager, uri: ustring): ptr TRecentInfo {.inline.} =

# gtk_recent_manager_move_item
# flags: {isMethod, throws} container: RecentManager
# can throw
# need sugar: is method
# arg uri: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg new_uri: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_recent_manager_move_item(self: ptr TRecentManager, uri: ucstring, new_uri: ucstring, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_recent_manager_move_item".}
proc move_item*(self: RecentManager, uri: ustring, new_uri: ustring): bool {.inline.} =
  gtk_recent_manager_move_item(self, ucstring(uri), ucstring(new_uri))
# proc move_item*(self: RecentManager, uri: ustring, new_uri: ustring): bool {.inline.} =

# gtk_recent_manager_purge_items
# flags: {isMethod, throws} container: RecentManager
# can throw
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_recent_manager_purge_items(self: ptr TRecentManager, error: ptr PGError=nil): int32 {.cdecl, dynlib: lib, importc: "gtk_recent_manager_purge_items".}
proc purge_items*(self: RecentManager): int32 {.inline.} =
  gtk_recent_manager_purge_items(self)
# proc purge_items*(self: RecentManager): int32 {.inline.} =

# gtk_recent_manager_remove_item
# flags: {isMethod, throws} container: RecentManager
# can throw
# need sugar: is method
# arg uri: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_recent_manager_remove_item(self: ptr TRecentManager, uri: ucstring, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_recent_manager_remove_item".}
proc remove_item*(self: RecentManager, uri: ustring): bool {.inline.} =
  gtk_recent_manager_remove_item(self, ucstring(uri))
# proc remove_item*(self: RecentManager, uri: ustring): bool {.inline.} =

# initializer for RendererCellAccessible: gtk_renderer_cell_accessible_get_type
proc gtk_renderer_cell_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_renderer_cell_accessible_get_type".}
template gtype*(klass_parameter: typedesc[RendererCellAccessible]): GType = gtk_renderer_cell_accessible_get_type()
# gtk_renderer_cell_accessible_new
# flags: {isConstructor} container: RendererCellAccessible
# need sugar: is static method
# arg renderer: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# return: INTERFACE 'RendererCellAccessible' 'TransferFull[TRendererCellAccessible]' (diff., need sugar)
proc gtk_renderer_cell_accessible_new(renderer: ptr TCellRenderer): TransferFull[TRendererCellAccessible] {.cdecl, dynlib: lib, importc: "gtk_renderer_cell_accessible_new".}
proc new_renderercellaccessible*(renderer: CellRenderer): RendererCellAccessible {.inline.} =
  wrap(gtk_renderer_cell_accessible_new(renderer.getPointer))
# proc new_renderercellaccessible*(renderer: CellRenderer): RendererCellAccessible {.inline.} =

# initializer for Revealer: gtk_revealer_get_type
proc gtk_revealer_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_revealer_get_type".}
template gtype*(klass_parameter: typedesc[Revealer]): GType = gtk_revealer_get_type()
# gtk_revealer_new
# flags: {isConstructor} container: Revealer
# need sugar: is static method
# return: INTERFACE 'Revealer' 'TransferNone[TRevealer]' (diff., need sugar)
proc gtk_revealer_new(): TransferNone[TRevealer] {.cdecl, dynlib: lib, importc: "gtk_revealer_new".}
proc new_revealer*(): Revealer {.inline.} =
  wrap(gtk_revealer_new())
# proc new_revealer*(): Revealer {.inline.} =

# gtk_revealer_get_child_revealed
# flags: {isMethod} container: Revealer
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_revealer_get_child_revealed(self: ptr TRevealer): bool {.cdecl, dynlib: lib, importc: "gtk_revealer_get_child_revealed".}
proc get_child_revealed*(self: Revealer): bool {.inline.} =
  gtk_revealer_get_child_revealed(self)
# proc get_child_revealed*(self: Revealer): bool {.inline.} =

# gtk_revealer_get_reveal_child
# flags: {isMethod} container: Revealer
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_revealer_get_reveal_child(self: ptr TRevealer): bool {.cdecl, dynlib: lib, importc: "gtk_revealer_get_reveal_child".}
proc get_reveal_child*(self: Revealer): bool {.inline.} =
  gtk_revealer_get_reveal_child(self)
# proc get_reveal_child*(self: Revealer): bool {.inline.} =

# gtk_revealer_get_transition_duration
# flags: {isMethod} container: Revealer
# need sugar: is method
# return: UINT32 'uint32' 'uint32'
proc gtk_revealer_get_transition_duration(self: ptr TRevealer): uint32 {.cdecl, dynlib: lib, importc: "gtk_revealer_get_transition_duration".}
proc get_transition_duration*(self: Revealer): uint32 {.inline.} =
  gtk_revealer_get_transition_duration(self)
# proc get_transition_duration*(self: Revealer): uint32 {.inline.} =

# gtk_revealer_get_transition_type
# flags: {isMethod} container: Revealer
# need sugar: is method
# return: INTERFACE 'RevealerTransitionType' 'RevealerTransitionType'
proc gtk_revealer_get_transition_type(self: ptr TRevealer): RevealerTransitionType {.cdecl, dynlib: lib, importc: "gtk_revealer_get_transition_type".}
proc get_transition_type*(self: Revealer): RevealerTransitionType {.inline.} =
  gtk_revealer_get_transition_type(self)
# proc get_transition_type*(self: Revealer): RevealerTransitionType {.inline.} =

# gtk_revealer_set_reveal_child
# flags: {isMethod} container: Revealer
# need sugar: is method
# arg reveal_child: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_revealer_set_reveal_child(self: ptr TRevealer, reveal_child: bool) {.cdecl, dynlib: lib, importc: "gtk_revealer_set_reveal_child".}
proc set_reveal_child*(self: Revealer, reveal_child: bool) {.inline.} =
  gtk_revealer_set_reveal_child(self, reveal_child)
# proc set_reveal_child*(self: Revealer, reveal_child: bool) {.inline.} =

# gtk_revealer_set_transition_duration
# flags: {isMethod} container: Revealer
# need sugar: is method
# arg duration: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_revealer_set_transition_duration(self: ptr TRevealer, duration: uint32) {.cdecl, dynlib: lib, importc: "gtk_revealer_set_transition_duration".}
proc set_transition_duration*(self: Revealer, duration: uint32) {.inline.} =
  gtk_revealer_set_transition_duration(self, duration)
# proc set_transition_duration*(self: Revealer, duration: uint32) {.inline.} =

# gtk_revealer_set_transition_type
# flags: {isMethod} container: Revealer
# need sugar: is method
# arg transition: INTERFACE (ENUM) 'RevealerTransitionType' 'RevealerTransitionType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_revealer_set_transition_type(self: ptr TRevealer, transition: RevealerTransitionType) {.cdecl, dynlib: lib, importc: "gtk_revealer_set_transition_type".}
proc set_transition_type*(self: Revealer, transition: RevealerTransitionType) {.inline.} =
  gtk_revealer_set_transition_type(self, transition)
# proc set_transition_type*(self: Revealer, transition: RevealerTransitionType) {.inline.} =

# initializer for Scale: gtk_scale_get_type
proc gtk_scale_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_scale_get_type".}
template gtype*(klass_parameter: typedesc[Scale]): GType = gtk_scale_get_type()
# gtk_scale_new
# flags: {isConstructor} container: Scale
# need sugar: is static method
# arg orientation: INTERFACE (ENUM) 'Orientation' 'Orientation' IN
# arg adjustment: INTERFACE (OBJECT) 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# return: INTERFACE 'Scale' 'TransferNone[TScale]' (diff., need sugar)
proc gtk_scale_new(orientation: Orientation, adjustment: ptr TAdjustment): TransferNone[TScale] {.cdecl, dynlib: lib, importc: "gtk_scale_new".}
proc new_scale*(orientation: Orientation, adjustment: Adjustment): Scale {.inline.} =
  wrap(gtk_scale_new(orientation, adjustment.getPointer))
# proc new_scale*(orientation: Orientation, adjustment: Adjustment): Scale {.inline.} =

# gtk_scale_new_with_range
# flags: {isConstructor} container: Scale
# need sugar: is static method
# arg orientation: INTERFACE (ENUM) 'Orientation' 'Orientation' IN
# arg min: DOUBLE 'float64' 'float64' IN
# arg max: DOUBLE 'float64' 'float64' IN
# arg step: DOUBLE 'float64' 'float64' IN
# return: INTERFACE 'Scale' 'TransferNone[TScale]' (diff., need sugar)
proc gtk_scale_new_with_range(orientation: Orientation, min: float64, max: float64, step: float64): TransferNone[TScale] {.cdecl, dynlib: lib, importc: "gtk_scale_new_with_range".}
proc new_scale_with_range*(orientation: Orientation, min: float64, max: float64, step: float64): Scale {.inline.} =
  wrap(gtk_scale_new_with_range(orientation, min, max, step))
# proc new_scale_with_range*(orientation: Orientation, min: float64, max: float64, step: float64): Scale {.inline.} =

# gtk_scale_add_mark
# flags: {isMethod} container: Scale
# need sugar: is method
# arg value: DOUBLE 'float64' 'float64' IN
# arg position: INTERFACE (ENUM) 'PositionType' 'PositionType' IN
# arg markup: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_scale_add_mark(self: ptr TScale, value: float64, position: PositionType, markup: ucstring) {.cdecl, dynlib: lib, importc: "gtk_scale_add_mark".}
proc add_mark*(self: Scale, value: float64, position: PositionType, markup: ustring) {.inline.} =
  gtk_scale_add_mark(self, value, position, ucstring(markup))
# proc add_mark*(self: Scale, value: float64, position: PositionType, markup: ustring) {.inline.} =

# gtk_scale_clear_marks
# flags: {isMethod} container: Scale
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_scale_clear_marks(self: ptr TScale) {.cdecl, dynlib: lib, importc: "gtk_scale_clear_marks".}
proc clear_marks*(self: Scale) {.inline.} =
  gtk_scale_clear_marks(self)
# proc clear_marks*(self: Scale) {.inline.} =

# gtk_scale_get_digits
# flags: {isMethod} container: Scale
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_scale_get_digits(self: ptr TScale): int32 {.cdecl, dynlib: lib, importc: "gtk_scale_get_digits".}
proc get_digits*(self: Scale): int32 {.inline.} =
  gtk_scale_get_digits(self)
# proc get_digits*(self: Scale): int32 {.inline.} =

# gtk_scale_get_draw_value
# flags: {isMethod} container: Scale
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_scale_get_draw_value(self: ptr TScale): bool {.cdecl, dynlib: lib, importc: "gtk_scale_get_draw_value".}
proc get_draw_value*(self: Scale): bool {.inline.} =
  gtk_scale_get_draw_value(self)
# proc get_draw_value*(self: Scale): bool {.inline.} =

# gtk_scale_get_has_origin
# flags: {isMethod} container: Scale
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_scale_get_has_origin(self: ptr TScale): bool {.cdecl, dynlib: lib, importc: "gtk_scale_get_has_origin".}
proc get_has_origin*(self: Scale): bool {.inline.} =
  gtk_scale_get_has_origin(self)
# proc get_has_origin*(self: Scale): bool {.inline.} =

# gtk_scale_get_layout
# flags: {isMethod} container: Scale
# need sugar: is method
# return: INTERFACE 'Pango1.Layout' 'TransferNone[Pango1.TLayout]' (diff., need sugar)
proc gtk_scale_get_layout(self: ptr TScale): TransferNone[Pango1.TLayout] {.cdecl, dynlib: lib, importc: "gtk_scale_get_layout".}
proc get_layout*(self: Scale): Pango1.Layout {.inline.} =
  wrap(gtk_scale_get_layout(self))
# proc get_layout*(self: Scale): Pango1.Layout {.inline.} =

# gtk_scale_get_layout_offsets
# flags: {isMethod} container: Scale
# need sugar: is method
# arg x: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg y: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_scale_get_layout_offsets(self: ptr TScale, x: ptr int32, y: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_scale_get_layout_offsets".}
proc get_layout_offsets*(self: Scale, x: var int32, y: var int32) {.inline.} =
  gtk_scale_get_layout_offsets(self, addr(x), addr(y))
# tuple-return
# x: var int32
# y: var int32
# proc get_layout_offsets*(self: Scale) {.inline.} =

# gtk_scale_get_value_pos
# flags: {isMethod} container: Scale
# need sugar: is method
# return: INTERFACE 'PositionType' 'PositionType'
proc gtk_scale_get_value_pos(self: ptr TScale): PositionType {.cdecl, dynlib: lib, importc: "gtk_scale_get_value_pos".}
proc get_value_pos*(self: Scale): PositionType {.inline.} =
  gtk_scale_get_value_pos(self)
# proc get_value_pos*(self: Scale): PositionType {.inline.} =

# gtk_scale_set_digits
# flags: {isMethod} container: Scale
# need sugar: is method
# arg digits: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_scale_set_digits(self: ptr TScale, digits: int32) {.cdecl, dynlib: lib, importc: "gtk_scale_set_digits".}
proc set_digits*(self: Scale, digits: int32) {.inline.} =
  gtk_scale_set_digits(self, digits)
# proc set_digits*(self: Scale, digits: int32) {.inline.} =

# gtk_scale_set_draw_value
# flags: {isMethod} container: Scale
# need sugar: is method
# arg draw_value: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_scale_set_draw_value(self: ptr TScale, draw_value: bool) {.cdecl, dynlib: lib, importc: "gtk_scale_set_draw_value".}
proc set_draw_value*(self: Scale, draw_value: bool) {.inline.} =
  gtk_scale_set_draw_value(self, draw_value)
# proc set_draw_value*(self: Scale, draw_value: bool) {.inline.} =

# gtk_scale_set_has_origin
# flags: {isMethod} container: Scale
# need sugar: is method
# arg has_origin: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_scale_set_has_origin(self: ptr TScale, has_origin: bool) {.cdecl, dynlib: lib, importc: "gtk_scale_set_has_origin".}
proc set_has_origin*(self: Scale, has_origin: bool) {.inline.} =
  gtk_scale_set_has_origin(self, has_origin)
# proc set_has_origin*(self: Scale, has_origin: bool) {.inline.} =

# gtk_scale_set_value_pos
# flags: {isMethod} container: Scale
# need sugar: is method
# arg pos: INTERFACE (ENUM) 'PositionType' 'PositionType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_scale_set_value_pos(self: ptr TScale, pos: PositionType) {.cdecl, dynlib: lib, importc: "gtk_scale_set_value_pos".}
proc set_value_pos*(self: Scale, pos: PositionType) {.inline.} =
  gtk_scale_set_value_pos(self, pos)
# proc set_value_pos*(self: Scale, pos: PositionType) {.inline.} =

# initializer for ScaleAccessible: gtk_scale_accessible_get_type
proc gtk_scale_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_scale_accessible_get_type".}
template gtype*(klass_parameter: typedesc[ScaleAccessible]): GType = gtk_scale_accessible_get_type()
# initializer for ScaleButton: gtk_scale_button_get_type
proc gtk_scale_button_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_scale_button_get_type".}
template gtype*(klass_parameter: typedesc[ScaleButton]): GType = gtk_scale_button_get_type()
# gtk_scale_button_new
# flags: {isConstructor} container: ScaleButton
# need sugar: is static method
# arg size: INT32 'int32' 'int32' IN
# arg min: DOUBLE 'float64' 'float64' IN
# arg max: DOUBLE 'float64' 'float64' IN
# arg step: DOUBLE 'float64' 'float64' IN
# arg icons: ARRAY 'uncheckedArray[ucstring]' 'uncheckedArray[ucstring]' IN array zero-terminated
# return: INTERFACE 'ScaleButton' 'TransferNone[TScaleButton]' (diff., need sugar)
proc gtk_scale_button_new(size: int32, min: float64, max: float64, step: float64, icons: uncheckedArray[ucstring]): TransferNone[TScaleButton] {.cdecl, dynlib: lib, importc: "gtk_scale_button_new".}
proc new_scalebutton*(size: int32, min: float64, max: float64, step: float64, icons: uncheckedArray[ucstring]): ScaleButton {.inline.} =
  wrap(gtk_scale_button_new(size, min, max, step, icons))
# proc new_scalebutton*(size: int32, min: float64, max: float64, step: float64, icons: uncheckedArray[ucstring]): ScaleButton {.inline.} =

# gtk_scale_button_get_adjustment
# flags: {isMethod} container: ScaleButton
# need sugar: is method
# return: INTERFACE 'Adjustment' 'TransferNone[TAdjustment]' (diff., need sugar)
proc gtk_scale_button_get_adjustment(self: ptr TScaleButton): TransferNone[TAdjustment] {.cdecl, dynlib: lib, importc: "gtk_scale_button_get_adjustment".}
proc get_adjustment*(self: ScaleButton): Adjustment {.inline.} =
  wrap(gtk_scale_button_get_adjustment(self))
# proc get_adjustment*(self: ScaleButton): Adjustment {.inline.} =

# gtk_scale_button_get_minus_button
# flags: {isMethod} container: ScaleButton
# need sugar: is method
# return: INTERFACE 'Button' 'TransferNone[TButton]' (diff., need sugar)
proc gtk_scale_button_get_minus_button(self: ptr TScaleButton): TransferNone[TButton] {.cdecl, dynlib: lib, importc: "gtk_scale_button_get_minus_button".}
proc get_minus_button*(self: ScaleButton): Button {.inline.} =
  wrap(gtk_scale_button_get_minus_button(self))
# proc get_minus_button*(self: ScaleButton): Button {.inline.} =

# gtk_scale_button_get_plus_button
# flags: {isMethod} container: ScaleButton
# need sugar: is method
# return: INTERFACE 'Button' 'TransferNone[TButton]' (diff., need sugar)
proc gtk_scale_button_get_plus_button(self: ptr TScaleButton): TransferNone[TButton] {.cdecl, dynlib: lib, importc: "gtk_scale_button_get_plus_button".}
proc get_plus_button*(self: ScaleButton): Button {.inline.} =
  wrap(gtk_scale_button_get_plus_button(self))
# proc get_plus_button*(self: ScaleButton): Button {.inline.} =

# gtk_scale_button_get_popup
# flags: {isMethod} container: ScaleButton
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_scale_button_get_popup(self: ptr TScaleButton): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_scale_button_get_popup".}
proc get_popup*(self: ScaleButton): Widget {.inline.} =
  wrap(gtk_scale_button_get_popup(self))
# proc get_popup*(self: ScaleButton): Widget {.inline.} =

# gtk_scale_button_get_value
# flags: {isMethod} container: ScaleButton
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_scale_button_get_value(self: ptr TScaleButton): float64 {.cdecl, dynlib: lib, importc: "gtk_scale_button_get_value".}
proc get_value*(self: ScaleButton): float64 {.inline.} =
  gtk_scale_button_get_value(self)
# proc get_value*(self: ScaleButton): float64 {.inline.} =

# gtk_scale_button_set_adjustment
# flags: {isMethod} container: ScaleButton
# need sugar: is method
# arg adjustment: INTERFACE (OBJECT) 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_scale_button_set_adjustment(self: ptr TScaleButton, adjustment: ptr TAdjustment) {.cdecl, dynlib: lib, importc: "gtk_scale_button_set_adjustment".}
proc set_adjustment*(self: ScaleButton, adjustment: Adjustment) {.inline.} =
  gtk_scale_button_set_adjustment(self, adjustment.getPointer)
# proc set_adjustment*(self: ScaleButton, adjustment: Adjustment) {.inline.} =

# gtk_scale_button_set_icons
# flags: {isMethod} container: ScaleButton
# need sugar: is method
# arg icons: ARRAY 'uncheckedArray[ucstring]' 'uncheckedArray[ucstring]' IN array zero-terminated
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_scale_button_set_icons(self: ptr TScaleButton, icons: uncheckedArray[ucstring]) {.cdecl, dynlib: lib, importc: "gtk_scale_button_set_icons".}
proc set_icons*(self: ScaleButton, icons: uncheckedArray[ucstring]) {.inline.} =
  gtk_scale_button_set_icons(self, icons)
# proc set_icons*(self: ScaleButton, icons: uncheckedArray[ucstring]) {.inline.} =

# gtk_scale_button_set_value
# flags: {isMethod} container: ScaleButton
# need sugar: is method
# arg value: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_scale_button_set_value(self: ptr TScaleButton, value: float64) {.cdecl, dynlib: lib, importc: "gtk_scale_button_set_value".}
proc set_value*(self: ScaleButton, value: float64) {.inline.} =
  gtk_scale_button_set_value(self, value)
# proc set_value*(self: ScaleButton, value: float64) {.inline.} =

# initializer for ScaleButtonAccessible: gtk_scale_button_accessible_get_type
proc gtk_scale_button_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_scale_button_accessible_get_type".}
template gtype*(klass_parameter: typedesc[ScaleButtonAccessible]): GType = gtk_scale_button_accessible_get_type()
# initializer for Scrollbar: gtk_scrollbar_get_type
proc gtk_scrollbar_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_scrollbar_get_type".}
template gtype*(klass_parameter: typedesc[Scrollbar]): GType = gtk_scrollbar_get_type()
# gtk_scrollbar_new
# flags: {isConstructor} container: Scrollbar
# need sugar: is static method
# arg orientation: INTERFACE (ENUM) 'Orientation' 'Orientation' IN
# arg adjustment: INTERFACE (OBJECT) 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# return: INTERFACE 'Scrollbar' 'TransferNone[TScrollbar]' (diff., need sugar)
proc gtk_scrollbar_new(orientation: Orientation, adjustment: ptr TAdjustment): TransferNone[TScrollbar] {.cdecl, dynlib: lib, importc: "gtk_scrollbar_new".}
proc new_scrollbar*(orientation: Orientation, adjustment: Adjustment): Scrollbar {.inline.} =
  wrap(gtk_scrollbar_new(orientation, adjustment.getPointer))
# proc new_scrollbar*(orientation: Orientation, adjustment: Adjustment): Scrollbar {.inline.} =

# initializer for ScrolledWindow: gtk_scrolled_window_get_type
proc gtk_scrolled_window_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_get_type".}
template gtype*(klass_parameter: typedesc[ScrolledWindow]): GType = gtk_scrolled_window_get_type()
# gtk_scrolled_window_new
# flags: {isConstructor} container: ScrolledWindow
# need sugar: is static method
# arg hadjustment: INTERFACE (OBJECT) 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# arg vadjustment: INTERFACE (OBJECT) 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# return: INTERFACE 'ScrolledWindow' 'TransferNone[TScrolledWindow]' (diff., need sugar)
proc gtk_scrolled_window_new(hadjustment: ptr TAdjustment, vadjustment: ptr TAdjustment): TransferNone[TScrolledWindow] {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_new".}
proc new_scrolledwindow*(hadjustment: Adjustment, vadjustment: Adjustment): ScrolledWindow {.inline.} =
  wrap(gtk_scrolled_window_new(hadjustment.getPointer, vadjustment.getPointer))
# proc new_scrolledwindow*(hadjustment: Adjustment, vadjustment: Adjustment): ScrolledWindow {.inline.} =

# gtk_scrolled_window_add_with_viewport
# flags: {isMethod} container: ScrolledWindow (deprecated)
# gtk_scrolled_window_get_capture_button_press
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_scrolled_window_get_capture_button_press(self: ptr TScrolledWindow): bool {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_get_capture_button_press".}
proc get_capture_button_press*(self: ScrolledWindow): bool {.inline.} =
  gtk_scrolled_window_get_capture_button_press(self)
# proc get_capture_button_press*(self: ScrolledWindow): bool {.inline.} =

# gtk_scrolled_window_get_hadjustment
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# return: INTERFACE 'Adjustment' 'TransferNone[TAdjustment]' (diff., need sugar)
proc gtk_scrolled_window_get_hadjustment(self: ptr TScrolledWindow): TransferNone[TAdjustment] {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_get_hadjustment".}
proc get_hadjustment*(self: ScrolledWindow): Adjustment {.inline.} =
  wrap(gtk_scrolled_window_get_hadjustment(self))
# proc get_hadjustment*(self: ScrolledWindow): Adjustment {.inline.} =

# gtk_scrolled_window_get_hscrollbar
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_scrolled_window_get_hscrollbar(self: ptr TScrolledWindow): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_get_hscrollbar".}
proc get_hscrollbar*(self: ScrolledWindow): Widget {.inline.} =
  wrap(gtk_scrolled_window_get_hscrollbar(self))
# proc get_hscrollbar*(self: ScrolledWindow): Widget {.inline.} =

# gtk_scrolled_window_get_kinetic_scrolling
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_scrolled_window_get_kinetic_scrolling(self: ptr TScrolledWindow): bool {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_get_kinetic_scrolling".}
proc get_kinetic_scrolling*(self: ScrolledWindow): bool {.inline.} =
  gtk_scrolled_window_get_kinetic_scrolling(self)
# proc get_kinetic_scrolling*(self: ScrolledWindow): bool {.inline.} =

# gtk_scrolled_window_get_min_content_height
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_scrolled_window_get_min_content_height(self: ptr TScrolledWindow): int32 {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_get_min_content_height".}
proc get_min_content_height*(self: ScrolledWindow): int32 {.inline.} =
  gtk_scrolled_window_get_min_content_height(self)
# proc get_min_content_height*(self: ScrolledWindow): int32 {.inline.} =

# gtk_scrolled_window_get_min_content_width
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_scrolled_window_get_min_content_width(self: ptr TScrolledWindow): int32 {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_get_min_content_width".}
proc get_min_content_width*(self: ScrolledWindow): int32 {.inline.} =
  gtk_scrolled_window_get_min_content_width(self)
# proc get_min_content_width*(self: ScrolledWindow): int32 {.inline.} =

# gtk_scrolled_window_get_overlay_scrolling
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_scrolled_window_get_overlay_scrolling(self: ptr TScrolledWindow): bool {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_get_overlay_scrolling".}
proc get_overlay_scrolling*(self: ScrolledWindow): bool {.inline.} =
  gtk_scrolled_window_get_overlay_scrolling(self)
# proc get_overlay_scrolling*(self: ScrolledWindow): bool {.inline.} =

# gtk_scrolled_window_get_placement
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# return: INTERFACE 'CornerType' 'CornerType'
proc gtk_scrolled_window_get_placement(self: ptr TScrolledWindow): CornerType {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_get_placement".}
proc get_placement*(self: ScrolledWindow): CornerType {.inline.} =
  gtk_scrolled_window_get_placement(self)
# proc get_placement*(self: ScrolledWindow): CornerType {.inline.} =

# gtk_scrolled_window_get_policy
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# arg hscrollbar_policy: INTERFACE (ENUM) 'PolicyType' 'PolicyType' OUT optional
# arg vscrollbar_policy: INTERFACE (ENUM) 'PolicyType' 'PolicyType' OUT optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_scrolled_window_get_policy(self: ptr TScrolledWindow, hscrollbar_policy: PolicyType, vscrollbar_policy: PolicyType) {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_get_policy".}
proc get_policy*(self: ScrolledWindow, hscrollbar_policy: PolicyType, vscrollbar_policy: PolicyType) {.inline.} =
  gtk_scrolled_window_get_policy(self, hscrollbar_policy, vscrollbar_policy)
# tuple-return
# hscrollbar_policy: PolicyType
# vscrollbar_policy: PolicyType
# proc get_policy*(self: ScrolledWindow) {.inline.} =

# gtk_scrolled_window_get_shadow_type
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# return: INTERFACE 'ShadowType' 'ShadowType'
proc gtk_scrolled_window_get_shadow_type(self: ptr TScrolledWindow): ShadowType {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_get_shadow_type".}
proc get_shadow_type*(self: ScrolledWindow): ShadowType {.inline.} =
  gtk_scrolled_window_get_shadow_type(self)
# proc get_shadow_type*(self: ScrolledWindow): ShadowType {.inline.} =

# gtk_scrolled_window_get_vadjustment
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# return: INTERFACE 'Adjustment' 'TransferNone[TAdjustment]' (diff., need sugar)
proc gtk_scrolled_window_get_vadjustment(self: ptr TScrolledWindow): TransferNone[TAdjustment] {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_get_vadjustment".}
proc get_vadjustment*(self: ScrolledWindow): Adjustment {.inline.} =
  wrap(gtk_scrolled_window_get_vadjustment(self))
# proc get_vadjustment*(self: ScrolledWindow): Adjustment {.inline.} =

# gtk_scrolled_window_get_vscrollbar
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_scrolled_window_get_vscrollbar(self: ptr TScrolledWindow): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_get_vscrollbar".}
proc get_vscrollbar*(self: ScrolledWindow): Widget {.inline.} =
  wrap(gtk_scrolled_window_get_vscrollbar(self))
# proc get_vscrollbar*(self: ScrolledWindow): Widget {.inline.} =

# gtk_scrolled_window_set_capture_button_press
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# arg capture_button_press: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_scrolled_window_set_capture_button_press(self: ptr TScrolledWindow, capture_button_press: bool) {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_set_capture_button_press".}
proc set_capture_button_press*(self: ScrolledWindow, capture_button_press: bool) {.inline.} =
  gtk_scrolled_window_set_capture_button_press(self, capture_button_press)
# proc set_capture_button_press*(self: ScrolledWindow, capture_button_press: bool) {.inline.} =

# gtk_scrolled_window_set_hadjustment
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# arg hadjustment: INTERFACE (OBJECT) 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_scrolled_window_set_hadjustment(self: ptr TScrolledWindow, hadjustment: ptr TAdjustment) {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_set_hadjustment".}
proc set_hadjustment*(self: ScrolledWindow, hadjustment: Adjustment) {.inline.} =
  gtk_scrolled_window_set_hadjustment(self, hadjustment.getPointer)
# proc set_hadjustment*(self: ScrolledWindow, hadjustment: Adjustment) {.inline.} =

# gtk_scrolled_window_set_kinetic_scrolling
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# arg kinetic_scrolling: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_scrolled_window_set_kinetic_scrolling(self: ptr TScrolledWindow, kinetic_scrolling: bool) {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_set_kinetic_scrolling".}
proc set_kinetic_scrolling*(self: ScrolledWindow, kinetic_scrolling: bool) {.inline.} =
  gtk_scrolled_window_set_kinetic_scrolling(self, kinetic_scrolling)
# proc set_kinetic_scrolling*(self: ScrolledWindow, kinetic_scrolling: bool) {.inline.} =

# gtk_scrolled_window_set_min_content_height
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# arg height: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_scrolled_window_set_min_content_height(self: ptr TScrolledWindow, height: int32) {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_set_min_content_height".}
proc set_min_content_height*(self: ScrolledWindow, height: int32) {.inline.} =
  gtk_scrolled_window_set_min_content_height(self, height)
# proc set_min_content_height*(self: ScrolledWindow, height: int32) {.inline.} =

# gtk_scrolled_window_set_min_content_width
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# arg width: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_scrolled_window_set_min_content_width(self: ptr TScrolledWindow, width: int32) {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_set_min_content_width".}
proc set_min_content_width*(self: ScrolledWindow, width: int32) {.inline.} =
  gtk_scrolled_window_set_min_content_width(self, width)
# proc set_min_content_width*(self: ScrolledWindow, width: int32) {.inline.} =

# gtk_scrolled_window_set_overlay_scrolling
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# arg overlay_scrolling: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_scrolled_window_set_overlay_scrolling(self: ptr TScrolledWindow, overlay_scrolling: bool) {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_set_overlay_scrolling".}
proc set_overlay_scrolling*(self: ScrolledWindow, overlay_scrolling: bool) {.inline.} =
  gtk_scrolled_window_set_overlay_scrolling(self, overlay_scrolling)
# proc set_overlay_scrolling*(self: ScrolledWindow, overlay_scrolling: bool) {.inline.} =

# gtk_scrolled_window_set_placement
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# arg window_placement: INTERFACE (ENUM) 'CornerType' 'CornerType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_scrolled_window_set_placement(self: ptr TScrolledWindow, window_placement: CornerType) {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_set_placement".}
proc set_placement*(self: ScrolledWindow, window_placement: CornerType) {.inline.} =
  gtk_scrolled_window_set_placement(self, window_placement)
# proc set_placement*(self: ScrolledWindow, window_placement: CornerType) {.inline.} =

# gtk_scrolled_window_set_policy
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# arg hscrollbar_policy: INTERFACE (ENUM) 'PolicyType' 'PolicyType' IN
# arg vscrollbar_policy: INTERFACE (ENUM) 'PolicyType' 'PolicyType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_scrolled_window_set_policy(self: ptr TScrolledWindow, hscrollbar_policy: PolicyType, vscrollbar_policy: PolicyType) {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_set_policy".}
proc set_policy*(self: ScrolledWindow, hscrollbar_policy: PolicyType, vscrollbar_policy: PolicyType) {.inline.} =
  gtk_scrolled_window_set_policy(self, hscrollbar_policy, vscrollbar_policy)
# proc set_policy*(self: ScrolledWindow, hscrollbar_policy: PolicyType, vscrollbar_policy: PolicyType) {.inline.} =

# gtk_scrolled_window_set_shadow_type
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# arg type: INTERFACE (ENUM) 'ShadowType' 'ShadowType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_scrolled_window_set_shadow_type(self: ptr TScrolledWindow, type_x: ShadowType) {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_set_shadow_type".}
proc set_shadow_type*(self: ScrolledWindow, type_x: ShadowType) {.inline.} =
  gtk_scrolled_window_set_shadow_type(self, type_x)
# proc set_shadow_type*(self: ScrolledWindow, type_x: ShadowType) {.inline.} =

# gtk_scrolled_window_set_vadjustment
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# arg vadjustment: INTERFACE (OBJECT) 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_scrolled_window_set_vadjustment(self: ptr TScrolledWindow, vadjustment: ptr TAdjustment) {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_set_vadjustment".}
proc set_vadjustment*(self: ScrolledWindow, vadjustment: Adjustment) {.inline.} =
  gtk_scrolled_window_set_vadjustment(self, vadjustment.getPointer)
# proc set_vadjustment*(self: ScrolledWindow, vadjustment: Adjustment) {.inline.} =

# gtk_scrolled_window_unset_placement
# flags: {isMethod} container: ScrolledWindow
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_scrolled_window_unset_placement(self: ptr TScrolledWindow) {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_unset_placement".}
proc unset_placement*(self: ScrolledWindow) {.inline.} =
  gtk_scrolled_window_unset_placement(self)
# proc unset_placement*(self: ScrolledWindow) {.inline.} =

# initializer for ScrolledWindowAccessible: gtk_scrolled_window_accessible_get_type
proc gtk_scrolled_window_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_scrolled_window_accessible_get_type".}
template gtype*(klass_parameter: typedesc[ScrolledWindowAccessible]): GType = gtk_scrolled_window_accessible_get_type()
# initializer for SearchBar: gtk_search_bar_get_type
proc gtk_search_bar_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_search_bar_get_type".}
template gtype*(klass_parameter: typedesc[SearchBar]): GType = gtk_search_bar_get_type()
# gtk_search_bar_new
# flags: {isConstructor} container: SearchBar
# need sugar: is static method
# return: INTERFACE 'SearchBar' 'TransferNone[TSearchBar]' (diff., need sugar)
proc gtk_search_bar_new(): TransferNone[TSearchBar] {.cdecl, dynlib: lib, importc: "gtk_search_bar_new".}
proc new_searchbar*(): SearchBar {.inline.} =
  wrap(gtk_search_bar_new())
# proc new_searchbar*(): SearchBar {.inline.} =

# gtk_search_bar_connect_entry
# flags: {isMethod} container: SearchBar
# need sugar: is method
# arg entry: INTERFACE (OBJECT) 'Entry' 'ptr TEntry' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_search_bar_connect_entry(self: ptr TSearchBar, entry: ptr TEntry) {.cdecl, dynlib: lib, importc: "gtk_search_bar_connect_entry".}
proc connect_entry*(self: SearchBar, entry: Entry) {.inline.} =
  gtk_search_bar_connect_entry(self, entry.getPointer)
# proc connect_entry*(self: SearchBar, entry: Entry) {.inline.} =

# gtk_search_bar_get_search_mode
# flags: {isMethod} container: SearchBar
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_search_bar_get_search_mode(self: ptr TSearchBar): bool {.cdecl, dynlib: lib, importc: "gtk_search_bar_get_search_mode".}
proc get_search_mode*(self: SearchBar): bool {.inline.} =
  gtk_search_bar_get_search_mode(self)
# proc get_search_mode*(self: SearchBar): bool {.inline.} =

# gtk_search_bar_get_show_close_button
# flags: {isMethod} container: SearchBar
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_search_bar_get_show_close_button(self: ptr TSearchBar): bool {.cdecl, dynlib: lib, importc: "gtk_search_bar_get_show_close_button".}
proc get_show_close_button*(self: SearchBar): bool {.inline.} =
  gtk_search_bar_get_show_close_button(self)
# proc get_show_close_button*(self: SearchBar): bool {.inline.} =

# gtk_search_bar_handle_event
# flags: {isMethod} container: SearchBar
# need sugar: is method
# arg event: INTERFACE (UNION) 'ptr Gdk3.TEvent' 'ptr Gdk3.TEvent' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_search_bar_handle_event(self: ptr TSearchBar, event: ptr Gdk3.TEvent): bool {.cdecl, dynlib: lib, importc: "gtk_search_bar_handle_event".}
proc handle_event*(self: SearchBar, event: ptr Gdk3.TEvent): bool {.inline.} =
  gtk_search_bar_handle_event(self, event)
# proc handle_event*(self: SearchBar, event: ptr Gdk3.TEvent): bool {.inline.} =

# gtk_search_bar_set_search_mode
# flags: {isMethod} container: SearchBar
# need sugar: is method
# arg search_mode: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_search_bar_set_search_mode(self: ptr TSearchBar, search_mode: bool) {.cdecl, dynlib: lib, importc: "gtk_search_bar_set_search_mode".}
proc set_search_mode*(self: SearchBar, search_mode: bool) {.inline.} =
  gtk_search_bar_set_search_mode(self, search_mode)
# proc set_search_mode*(self: SearchBar, search_mode: bool) {.inline.} =

# gtk_search_bar_set_show_close_button
# flags: {isMethod} container: SearchBar
# need sugar: is method
# arg visible: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_search_bar_set_show_close_button(self: ptr TSearchBar, visible: bool) {.cdecl, dynlib: lib, importc: "gtk_search_bar_set_show_close_button".}
proc set_show_close_button*(self: SearchBar, visible: bool) {.inline.} =
  gtk_search_bar_set_show_close_button(self, visible)
# proc set_show_close_button*(self: SearchBar, visible: bool) {.inline.} =

# initializer for SearchEntry: gtk_search_entry_get_type
proc gtk_search_entry_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_search_entry_get_type".}
template gtype*(klass_parameter: typedesc[SearchEntry]): GType = gtk_search_entry_get_type()
# gtk_search_entry_new
# flags: {isConstructor} container: SearchEntry
# need sugar: is static method
# return: INTERFACE 'SearchEntry' 'TransferNone[TSearchEntry]' (diff., need sugar)
proc gtk_search_entry_new(): TransferNone[TSearchEntry] {.cdecl, dynlib: lib, importc: "gtk_search_entry_new".}
proc new_searchentry*(): SearchEntry {.inline.} =
  wrap(gtk_search_entry_new())
# proc new_searchentry*(): SearchEntry {.inline.} =

# gtk_search_entry_handle_event
# flags: {isMethod} container: SearchEntry
# need sugar: is method
# arg event: INTERFACE (UNION) 'ptr Gdk3.TEvent' 'ptr Gdk3.TEvent' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_search_entry_handle_event(self: ptr TSearchEntry, event: ptr Gdk3.TEvent): bool {.cdecl, dynlib: lib, importc: "gtk_search_entry_handle_event".}
proc handle_event*(self: SearchEntry, event: ptr Gdk3.TEvent): bool {.inline.} =
  gtk_search_entry_handle_event(self, event)
# proc handle_event*(self: SearchEntry, event: ptr Gdk3.TEvent): bool {.inline.} =

# initializer for Separator: gtk_separator_get_type
proc gtk_separator_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_separator_get_type".}
template gtype*(klass_parameter: typedesc[Separator]): GType = gtk_separator_get_type()
# gtk_separator_new
# flags: {isConstructor} container: Separator
# need sugar: is static method
# arg orientation: INTERFACE (ENUM) 'Orientation' 'Orientation' IN
# return: INTERFACE 'Separator' 'TransferNone[TSeparator]' (diff., need sugar)
proc gtk_separator_new(orientation: Orientation): TransferNone[TSeparator] {.cdecl, dynlib: lib, importc: "gtk_separator_new".}
proc new_separator*(orientation: Orientation): Separator {.inline.} =
  wrap(gtk_separator_new(orientation))
# proc new_separator*(orientation: Orientation): Separator {.inline.} =

# initializer for SeparatorMenuItem: gtk_separator_menu_item_get_type
proc gtk_separator_menu_item_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_separator_menu_item_get_type".}
template gtype*(klass_parameter: typedesc[SeparatorMenuItem]): GType = gtk_separator_menu_item_get_type()
# gtk_separator_menu_item_new
# flags: {isConstructor} container: SeparatorMenuItem
# need sugar: is static method
# return: INTERFACE 'SeparatorMenuItem' 'TransferNone[TSeparatorMenuItem]' (diff., need sugar)
proc gtk_separator_menu_item_new(): TransferNone[TSeparatorMenuItem] {.cdecl, dynlib: lib, importc: "gtk_separator_menu_item_new".}
proc new_separatormenuitem*(): SeparatorMenuItem {.inline.} =
  wrap(gtk_separator_menu_item_new())
# proc new_separatormenuitem*(): SeparatorMenuItem {.inline.} =

# initializer for SeparatorToolItem: gtk_separator_tool_item_get_type
proc gtk_separator_tool_item_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_separator_tool_item_get_type".}
template gtype*(klass_parameter: typedesc[SeparatorToolItem]): GType = gtk_separator_tool_item_get_type()
# gtk_separator_tool_item_new
# flags: {isConstructor} container: SeparatorToolItem
# need sugar: is static method
# return: INTERFACE 'SeparatorToolItem' 'TransferNone[TSeparatorToolItem]' (diff., need sugar)
proc gtk_separator_tool_item_new(): TransferNone[TSeparatorToolItem] {.cdecl, dynlib: lib, importc: "gtk_separator_tool_item_new".}
proc new_separatortoolitem*(): SeparatorToolItem {.inline.} =
  wrap(gtk_separator_tool_item_new())
# proc new_separatortoolitem*(): SeparatorToolItem {.inline.} =

# gtk_separator_tool_item_get_draw
# flags: {isMethod} container: SeparatorToolItem
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_separator_tool_item_get_draw(self: ptr TSeparatorToolItem): bool {.cdecl, dynlib: lib, importc: "gtk_separator_tool_item_get_draw".}
proc get_draw*(self: SeparatorToolItem): bool {.inline.} =
  gtk_separator_tool_item_get_draw(self)
# proc get_draw*(self: SeparatorToolItem): bool {.inline.} =

# gtk_separator_tool_item_set_draw
# flags: {isMethod} container: SeparatorToolItem
# need sugar: is method
# arg draw: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_separator_tool_item_set_draw(self: ptr TSeparatorToolItem, draw: bool) {.cdecl, dynlib: lib, importc: "gtk_separator_tool_item_set_draw".}
proc set_draw*(self: SeparatorToolItem, draw: bool) {.inline.} =
  gtk_separator_tool_item_set_draw(self, draw)
# proc set_draw*(self: SeparatorToolItem, draw: bool) {.inline.} =

# initializer for Settings: gtk_settings_get_type
proc gtk_settings_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_settings_get_type".}
template gtype*(klass_parameter: typedesc[Settings]): GType = gtk_settings_get_type()
# gtk_settings_get_default
# flags: {} container: Settings
# need sugar: is static method
# return: INTERFACE 'Settings' 'TransferNone[TSettings]' (diff., need sugar)
proc gtk_settings_get_default(): TransferNone[TSettings] {.cdecl, dynlib: lib, importc: "gtk_settings_get_default".}
template get_default*(klass_parameter: typedesc[Settings]): Settings =
  wrap(gtk_settings_get_default())
# template get_default*(klass_parameter: typedesc[Settings]): Settings =

# gtk_settings_get_for_screen
# flags: {} container: Settings
# need sugar: is static method
# arg screen: INTERFACE (OBJECT) 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# return: INTERFACE 'Settings' 'TransferNone[TSettings]' (diff., need sugar)
proc gtk_settings_get_for_screen(screen: ptr Gdk3.TScreen): TransferNone[TSettings] {.cdecl, dynlib: lib, importc: "gtk_settings_get_for_screen".}
template get_for_screen*(klass_parameter: typedesc[Settings], screen: Gdk3.Screen): Settings =
  wrap(gtk_settings_get_for_screen(screen.getPointer))
# template get_for_screen*(klass_parameter: typedesc[Settings], screen: Gdk3.Screen): Settings =

# gtk_settings_install_property
# flags: {} container: Settings (deprecated)
# gtk_settings_install_property_parser
# flags: {} container: Settings (deprecated)
# gtk_settings_set_double_property
# flags: {isMethod} container: Settings (deprecated)
# gtk_settings_set_long_property
# flags: {isMethod} container: Settings (deprecated)
# gtk_settings_set_property_value
# flags: {isMethod} container: Settings (deprecated)
# gtk_settings_set_string_property
# flags: {isMethod} container: Settings (deprecated)
# initializer for SizeGroup: gtk_size_group_get_type
proc gtk_size_group_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_size_group_get_type".}
template gtype*(klass_parameter: typedesc[SizeGroup]): GType = gtk_size_group_get_type()
# gtk_size_group_new
# flags: {isConstructor} container: SizeGroup
# need sugar: is static method
# arg mode: INTERFACE (ENUM) 'SizeGroupMode' 'SizeGroupMode' IN
# return: INTERFACE 'SizeGroup' 'TransferFull[TSizeGroup]' (diff., need sugar)
proc gtk_size_group_new(mode: SizeGroupMode): TransferFull[TSizeGroup] {.cdecl, dynlib: lib, importc: "gtk_size_group_new".}
proc new_sizegroup*(mode: SizeGroupMode): SizeGroup {.inline.} =
  wrap(gtk_size_group_new(mode))
# proc new_sizegroup*(mode: SizeGroupMode): SizeGroup {.inline.} =

# gtk_size_group_add_widget
# flags: {isMethod} container: SizeGroup
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_size_group_add_widget(self: ptr TSizeGroup, widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_size_group_add_widget".}
proc add_widget*(self: SizeGroup, widget: Widget) {.inline.} =
  gtk_size_group_add_widget(self, widget.getPointer)
# proc add_widget*(self: SizeGroup, widget: Widget) {.inline.} =

# gtk_size_group_get_ignore_hidden
# flags: {isMethod} container: SizeGroup
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_size_group_get_ignore_hidden(self: ptr TSizeGroup): bool {.cdecl, dynlib: lib, importc: "gtk_size_group_get_ignore_hidden".}
proc get_ignore_hidden*(self: SizeGroup): bool {.inline.} =
  gtk_size_group_get_ignore_hidden(self)
# proc get_ignore_hidden*(self: SizeGroup): bool {.inline.} =

# gtk_size_group_get_mode
# flags: {isMethod} container: SizeGroup
# need sugar: is method
# return: INTERFACE 'SizeGroupMode' 'SizeGroupMode'
proc gtk_size_group_get_mode(self: ptr TSizeGroup): SizeGroupMode {.cdecl, dynlib: lib, importc: "gtk_size_group_get_mode".}
proc get_mode*(self: SizeGroup): SizeGroupMode {.inline.} =
  gtk_size_group_get_mode(self)
# proc get_mode*(self: SizeGroup): SizeGroupMode {.inline.} =

# gtk_size_group_get_widgets
# flags: {isMethod} container: SizeGroup
# need sugar: is method
# return: GSLIST 'ptr GSLIST_TODO' 'ptr GSLIST_TODO'
proc gtk_size_group_get_widgets(self: ptr TSizeGroup): ptr GSLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_size_group_get_widgets".}
proc get_widgets*(self: SizeGroup): ptr GSLIST_TODO {.inline.} =
  gtk_size_group_get_widgets(self)
# proc get_widgets*(self: SizeGroup): ptr GSLIST_TODO {.inline.} =

# gtk_size_group_remove_widget
# flags: {isMethod} container: SizeGroup
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_size_group_remove_widget(self: ptr TSizeGroup, widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_size_group_remove_widget".}
proc remove_widget*(self: SizeGroup, widget: Widget) {.inline.} =
  gtk_size_group_remove_widget(self, widget.getPointer)
# proc remove_widget*(self: SizeGroup, widget: Widget) {.inline.} =

# gtk_size_group_set_ignore_hidden
# flags: {isMethod} container: SizeGroup
# need sugar: is method
# arg ignore_hidden: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_size_group_set_ignore_hidden(self: ptr TSizeGroup, ignore_hidden: bool) {.cdecl, dynlib: lib, importc: "gtk_size_group_set_ignore_hidden".}
proc set_ignore_hidden*(self: SizeGroup, ignore_hidden: bool) {.inline.} =
  gtk_size_group_set_ignore_hidden(self, ignore_hidden)
# proc set_ignore_hidden*(self: SizeGroup, ignore_hidden: bool) {.inline.} =

# gtk_size_group_set_mode
# flags: {isMethod} container: SizeGroup
# need sugar: is method
# arg mode: INTERFACE (ENUM) 'SizeGroupMode' 'SizeGroupMode' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_size_group_set_mode(self: ptr TSizeGroup, mode: SizeGroupMode) {.cdecl, dynlib: lib, importc: "gtk_size_group_set_mode".}
proc set_mode*(self: SizeGroup, mode: SizeGroupMode) {.inline.} =
  gtk_size_group_set_mode(self, mode)
# proc set_mode*(self: SizeGroup, mode: SizeGroupMode) {.inline.} =

# initializer for SpinButton: gtk_spin_button_get_type
proc gtk_spin_button_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_spin_button_get_type".}
template gtype*(klass_parameter: typedesc[SpinButton]): GType = gtk_spin_button_get_type()
# gtk_spin_button_new
# flags: {isConstructor} container: SpinButton
# need sugar: is static method
# arg adjustment: INTERFACE (OBJECT) 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# arg climb_rate: DOUBLE 'float64' 'float64' IN
# arg digits: UINT32 'uint32' 'uint32' IN
# return: INTERFACE 'SpinButton' 'TransferNone[TSpinButton]' (diff., need sugar)
proc gtk_spin_button_new(adjustment: ptr TAdjustment, climb_rate: float64, digits: uint32): TransferNone[TSpinButton] {.cdecl, dynlib: lib, importc: "gtk_spin_button_new".}
proc new_spinbutton*(adjustment: Adjustment, climb_rate: float64, digits: uint32): SpinButton {.inline.} =
  wrap(gtk_spin_button_new(adjustment.getPointer, climb_rate, digits))
# proc new_spinbutton*(adjustment: Adjustment, climb_rate: float64, digits: uint32): SpinButton {.inline.} =

# gtk_spin_button_new_with_range
# flags: {isConstructor} container: SpinButton
# need sugar: is static method
# arg min: DOUBLE 'float64' 'float64' IN
# arg max: DOUBLE 'float64' 'float64' IN
# arg step: DOUBLE 'float64' 'float64' IN
# return: INTERFACE 'SpinButton' 'TransferNone[TSpinButton]' (diff., need sugar)
proc gtk_spin_button_new_with_range(min: float64, max: float64, step: float64): TransferNone[TSpinButton] {.cdecl, dynlib: lib, importc: "gtk_spin_button_new_with_range".}
proc new_spinbutton_with_range*(min: float64, max: float64, step: float64): SpinButton {.inline.} =
  wrap(gtk_spin_button_new_with_range(min, max, step))
# proc new_spinbutton_with_range*(min: float64, max: float64, step: float64): SpinButton {.inline.} =

# gtk_spin_button_configure
# flags: {isMethod} container: SpinButton
# need sugar: is method
# arg adjustment: INTERFACE (OBJECT) 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# arg climb_rate: DOUBLE 'float64' 'float64' IN
# arg digits: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_configure(self: ptr TSpinButton, adjustment: ptr TAdjustment, climb_rate: float64, digits: uint32) {.cdecl, dynlib: lib, importc: "gtk_spin_button_configure".}
proc configure*(self: SpinButton, adjustment: Adjustment, climb_rate: float64, digits: uint32) {.inline.} =
  gtk_spin_button_configure(self, adjustment.getPointer, climb_rate, digits)
# proc configure*(self: SpinButton, adjustment: Adjustment, climb_rate: float64, digits: uint32) {.inline.} =

# gtk_spin_button_get_adjustment
# flags: {isMethod} container: SpinButton
# need sugar: is method
# return: INTERFACE 'Adjustment' 'TransferNone[TAdjustment]' (diff., need sugar)
proc gtk_spin_button_get_adjustment(self: ptr TSpinButton): TransferNone[TAdjustment] {.cdecl, dynlib: lib, importc: "gtk_spin_button_get_adjustment".}
proc get_adjustment*(self: SpinButton): Adjustment {.inline.} =
  wrap(gtk_spin_button_get_adjustment(self))
# proc get_adjustment*(self: SpinButton): Adjustment {.inline.} =

# gtk_spin_button_get_digits
# flags: {isMethod} container: SpinButton
# need sugar: is method
# return: UINT32 'uint32' 'uint32'
proc gtk_spin_button_get_digits(self: ptr TSpinButton): uint32 {.cdecl, dynlib: lib, importc: "gtk_spin_button_get_digits".}
proc get_digits*(self: SpinButton): uint32 {.inline.} =
  gtk_spin_button_get_digits(self)
# proc get_digits*(self: SpinButton): uint32 {.inline.} =

# gtk_spin_button_get_increments
# flags: {isMethod} container: SpinButton
# need sugar: is method
# arg step: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar) optional
# arg page: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_get_increments(self: ptr TSpinButton, step: ptr float64, page: ptr float64) {.cdecl, dynlib: lib, importc: "gtk_spin_button_get_increments".}
proc get_increments*(self: SpinButton, step: var float64, page: var float64) {.inline.} =
  gtk_spin_button_get_increments(self, addr(step), addr(page))
# tuple-return
# step: var float64
# page: var float64
# proc get_increments*(self: SpinButton) {.inline.} =

# gtk_spin_button_get_numeric
# flags: {isMethod} container: SpinButton
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_spin_button_get_numeric(self: ptr TSpinButton): bool {.cdecl, dynlib: lib, importc: "gtk_spin_button_get_numeric".}
proc get_numeric*(self: SpinButton): bool {.inline.} =
  gtk_spin_button_get_numeric(self)
# proc get_numeric*(self: SpinButton): bool {.inline.} =

# gtk_spin_button_get_range
# flags: {isMethod} container: SpinButton
# need sugar: is method
# arg min: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar) optional
# arg max: DOUBLE 'var float64' 'ptr float64' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_get_range(self: ptr TSpinButton, min: ptr float64, max: ptr float64) {.cdecl, dynlib: lib, importc: "gtk_spin_button_get_range".}
proc get_range*(self: SpinButton, min: var float64, max: var float64) {.inline.} =
  gtk_spin_button_get_range(self, addr(min), addr(max))
# tuple-return
# min: var float64
# max: var float64
# proc get_range*(self: SpinButton) {.inline.} =

# gtk_spin_button_get_snap_to_ticks
# flags: {isMethod} container: SpinButton
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_spin_button_get_snap_to_ticks(self: ptr TSpinButton): bool {.cdecl, dynlib: lib, importc: "gtk_spin_button_get_snap_to_ticks".}
proc get_snap_to_ticks*(self: SpinButton): bool {.inline.} =
  gtk_spin_button_get_snap_to_ticks(self)
# proc get_snap_to_ticks*(self: SpinButton): bool {.inline.} =

# gtk_spin_button_get_update_policy
# flags: {isMethod} container: SpinButton
# need sugar: is method
# return: INTERFACE 'SpinButtonUpdatePolicy' 'SpinButtonUpdatePolicy'
proc gtk_spin_button_get_update_policy(self: ptr TSpinButton): SpinButtonUpdatePolicy {.cdecl, dynlib: lib, importc: "gtk_spin_button_get_update_policy".}
proc get_update_policy*(self: SpinButton): SpinButtonUpdatePolicy {.inline.} =
  gtk_spin_button_get_update_policy(self)
# proc get_update_policy*(self: SpinButton): SpinButtonUpdatePolicy {.inline.} =

# gtk_spin_button_get_value
# flags: {isMethod} container: SpinButton
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_spin_button_get_value(self: ptr TSpinButton): float64 {.cdecl, dynlib: lib, importc: "gtk_spin_button_get_value".}
proc get_value*(self: SpinButton): float64 {.inline.} =
  gtk_spin_button_get_value(self)
# proc get_value*(self: SpinButton): float64 {.inline.} =

# gtk_spin_button_get_value_as_int
# flags: {isMethod} container: SpinButton
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_spin_button_get_value_as_int(self: ptr TSpinButton): int32 {.cdecl, dynlib: lib, importc: "gtk_spin_button_get_value_as_int".}
proc get_value_as_int*(self: SpinButton): int32 {.inline.} =
  gtk_spin_button_get_value_as_int(self)
# proc get_value_as_int*(self: SpinButton): int32 {.inline.} =

# gtk_spin_button_get_wrap
# flags: {isMethod} container: SpinButton
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_spin_button_get_wrap(self: ptr TSpinButton): bool {.cdecl, dynlib: lib, importc: "gtk_spin_button_get_wrap".}
proc get_wrap*(self: SpinButton): bool {.inline.} =
  gtk_spin_button_get_wrap(self)
# proc get_wrap*(self: SpinButton): bool {.inline.} =

# gtk_spin_button_set_adjustment
# flags: {isMethod} container: SpinButton
# need sugar: is method
# arg adjustment: INTERFACE (OBJECT) 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_set_adjustment(self: ptr TSpinButton, adjustment: ptr TAdjustment) {.cdecl, dynlib: lib, importc: "gtk_spin_button_set_adjustment".}
proc set_adjustment*(self: SpinButton, adjustment: Adjustment) {.inline.} =
  gtk_spin_button_set_adjustment(self, adjustment.getPointer)
# proc set_adjustment*(self: SpinButton, adjustment: Adjustment) {.inline.} =

# gtk_spin_button_set_digits
# flags: {isMethod} container: SpinButton
# need sugar: is method
# arg digits: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_set_digits(self: ptr TSpinButton, digits: uint32) {.cdecl, dynlib: lib, importc: "gtk_spin_button_set_digits".}
proc set_digits*(self: SpinButton, digits: uint32) {.inline.} =
  gtk_spin_button_set_digits(self, digits)
# proc set_digits*(self: SpinButton, digits: uint32) {.inline.} =

# gtk_spin_button_set_increments
# flags: {isMethod} container: SpinButton
# need sugar: is method
# arg step: DOUBLE 'float64' 'float64' IN
# arg page: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_set_increments(self: ptr TSpinButton, step: float64, page: float64) {.cdecl, dynlib: lib, importc: "gtk_spin_button_set_increments".}
proc set_increments*(self: SpinButton, step: float64, page: float64) {.inline.} =
  gtk_spin_button_set_increments(self, step, page)
# proc set_increments*(self: SpinButton, step: float64, page: float64) {.inline.} =

# gtk_spin_button_set_numeric
# flags: {isMethod} container: SpinButton
# need sugar: is method
# arg numeric: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_set_numeric(self: ptr TSpinButton, numeric: bool) {.cdecl, dynlib: lib, importc: "gtk_spin_button_set_numeric".}
proc set_numeric*(self: SpinButton, numeric: bool) {.inline.} =
  gtk_spin_button_set_numeric(self, numeric)
# proc set_numeric*(self: SpinButton, numeric: bool) {.inline.} =

# gtk_spin_button_set_range
# flags: {isMethod} container: SpinButton
# need sugar: is method
# arg min: DOUBLE 'float64' 'float64' IN
# arg max: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_set_range(self: ptr TSpinButton, min: float64, max: float64) {.cdecl, dynlib: lib, importc: "gtk_spin_button_set_range".}
proc set_range*(self: SpinButton, min: float64, max: float64) {.inline.} =
  gtk_spin_button_set_range(self, min, max)
# proc set_range*(self: SpinButton, min: float64, max: float64) {.inline.} =

# gtk_spin_button_set_snap_to_ticks
# flags: {isMethod} container: SpinButton
# need sugar: is method
# arg snap_to_ticks: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_set_snap_to_ticks(self: ptr TSpinButton, snap_to_ticks: bool) {.cdecl, dynlib: lib, importc: "gtk_spin_button_set_snap_to_ticks".}
proc set_snap_to_ticks*(self: SpinButton, snap_to_ticks: bool) {.inline.} =
  gtk_spin_button_set_snap_to_ticks(self, snap_to_ticks)
# proc set_snap_to_ticks*(self: SpinButton, snap_to_ticks: bool) {.inline.} =

# gtk_spin_button_set_update_policy
# flags: {isMethod} container: SpinButton
# need sugar: is method
# arg policy: INTERFACE (ENUM) 'SpinButtonUpdatePolicy' 'SpinButtonUpdatePolicy' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_set_update_policy(self: ptr TSpinButton, policy: SpinButtonUpdatePolicy) {.cdecl, dynlib: lib, importc: "gtk_spin_button_set_update_policy".}
proc set_update_policy*(self: SpinButton, policy: SpinButtonUpdatePolicy) {.inline.} =
  gtk_spin_button_set_update_policy(self, policy)
# proc set_update_policy*(self: SpinButton, policy: SpinButtonUpdatePolicy) {.inline.} =

# gtk_spin_button_set_value
# flags: {isMethod} container: SpinButton
# need sugar: is method
# arg value: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_set_value(self: ptr TSpinButton, value: float64) {.cdecl, dynlib: lib, importc: "gtk_spin_button_set_value".}
proc set_value*(self: SpinButton, value: float64) {.inline.} =
  gtk_spin_button_set_value(self, value)
# proc set_value*(self: SpinButton, value: float64) {.inline.} =

# gtk_spin_button_set_wrap
# flags: {isMethod} container: SpinButton
# need sugar: is method
# arg wrap: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_set_wrap(self: ptr TSpinButton, wrap: bool) {.cdecl, dynlib: lib, importc: "gtk_spin_button_set_wrap".}
proc set_wrap*(self: SpinButton, wrap: bool) {.inline.} =
  gtk_spin_button_set_wrap(self, wrap)
# proc set_wrap*(self: SpinButton, wrap: bool) {.inline.} =

# gtk_spin_button_spin
# flags: {isMethod} container: SpinButton
# need sugar: is method
# arg direction: INTERFACE (ENUM) 'SpinType' 'SpinType' IN
# arg increment: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_spin(self: ptr TSpinButton, direction: SpinType, increment: float64) {.cdecl, dynlib: lib, importc: "gtk_spin_button_spin".}
proc spin*(self: SpinButton, direction: SpinType, increment: float64) {.inline.} =
  gtk_spin_button_spin(self, direction, increment)
# proc spin*(self: SpinButton, direction: SpinType, increment: float64) {.inline.} =

# gtk_spin_button_update
# flags: {isMethod} container: SpinButton
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_spin_button_update(self: ptr TSpinButton) {.cdecl, dynlib: lib, importc: "gtk_spin_button_update".}
proc update*(self: SpinButton) {.inline.} =
  gtk_spin_button_update(self)
# proc update*(self: SpinButton) {.inline.} =

# initializer for SpinButtonAccessible: gtk_spin_button_accessible_get_type
proc gtk_spin_button_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_spin_button_accessible_get_type".}
template gtype*(klass_parameter: typedesc[SpinButtonAccessible]): GType = gtk_spin_button_accessible_get_type()
# initializer for Spinner: gtk_spinner_get_type
proc gtk_spinner_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_spinner_get_type".}
template gtype*(klass_parameter: typedesc[Spinner]): GType = gtk_spinner_get_type()
# gtk_spinner_new
# flags: {isConstructor} container: Spinner
# need sugar: is static method
# return: INTERFACE 'Spinner' 'TransferNone[TSpinner]' (diff., need sugar)
proc gtk_spinner_new(): TransferNone[TSpinner] {.cdecl, dynlib: lib, importc: "gtk_spinner_new".}
proc new_spinner*(): Spinner {.inline.} =
  wrap(gtk_spinner_new())
# proc new_spinner*(): Spinner {.inline.} =

# gtk_spinner_start
# flags: {isMethod} container: Spinner
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_spinner_start(self: ptr TSpinner) {.cdecl, dynlib: lib, importc: "gtk_spinner_start".}
proc start*(self: Spinner) {.inline.} =
  gtk_spinner_start(self)
# proc start*(self: Spinner) {.inline.} =

# gtk_spinner_stop
# flags: {isMethod} container: Spinner
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_spinner_stop(self: ptr TSpinner) {.cdecl, dynlib: lib, importc: "gtk_spinner_stop".}
proc stop*(self: Spinner) {.inline.} =
  gtk_spinner_stop(self)
# proc stop*(self: Spinner) {.inline.} =

# initializer for SpinnerAccessible: gtk_spinner_accessible_get_type
proc gtk_spinner_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_spinner_accessible_get_type".}
template gtype*(klass_parameter: typedesc[SpinnerAccessible]): GType = gtk_spinner_accessible_get_type()
# initializer for Stack: gtk_stack_get_type
proc gtk_stack_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_stack_get_type".}
template gtype*(klass_parameter: typedesc[Stack]): GType = gtk_stack_get_type()
# gtk_stack_new
# flags: {isConstructor} container: Stack
# need sugar: is static method
# return: INTERFACE 'Stack' 'TransferNone[TStack]' (diff., need sugar)
proc gtk_stack_new(): TransferNone[TStack] {.cdecl, dynlib: lib, importc: "gtk_stack_new".}
proc new_stack*(): Stack {.inline.} =
  wrap(gtk_stack_new())
# proc new_stack*(): Stack {.inline.} =

# gtk_stack_add_named
# flags: {isMethod} container: Stack
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_stack_add_named(self: ptr TStack, child: ptr TWidget, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_stack_add_named".}
proc add_named*(self: Stack, child: Widget, name: ustring) {.inline.} =
  gtk_stack_add_named(self, child.getPointer, ucstring(name))
# proc add_named*(self: Stack, child: Widget, name: ustring) {.inline.} =

# gtk_stack_add_titled
# flags: {isMethod} container: Stack
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg title: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_stack_add_titled(self: ptr TStack, child: ptr TWidget, name: ucstring, title: ucstring) {.cdecl, dynlib: lib, importc: "gtk_stack_add_titled".}
proc add_titled*(self: Stack, child: Widget, name: ustring, title: ustring) {.inline.} =
  gtk_stack_add_titled(self, child.getPointer, ucstring(name), ucstring(title))
# proc add_titled*(self: Stack, child: Widget, name: ustring, title: ustring) {.inline.} =

# gtk_stack_get_child_by_name
# flags: {isMethod} container: Stack
# need sugar: is method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_stack_get_child_by_name(self: ptr TStack, name: ucstring): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_stack_get_child_by_name".}
proc get_child_by_name*(self: Stack, name: ustring): Widget {.inline.} =
  wrap(gtk_stack_get_child_by_name(self, ucstring(name)))
# proc get_child_by_name*(self: Stack, name: ustring): Widget {.inline.} =

# gtk_stack_get_hhomogeneous
# flags: {isMethod} container: Stack
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_stack_get_hhomogeneous(self: ptr TStack): bool {.cdecl, dynlib: lib, importc: "gtk_stack_get_hhomogeneous".}
proc get_hhomogeneous*(self: Stack): bool {.inline.} =
  gtk_stack_get_hhomogeneous(self)
# proc get_hhomogeneous*(self: Stack): bool {.inline.} =

# gtk_stack_get_homogeneous
# flags: {isMethod} container: Stack
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_stack_get_homogeneous(self: ptr TStack): bool {.cdecl, dynlib: lib, importc: "gtk_stack_get_homogeneous".}
proc get_homogeneous*(self: Stack): bool {.inline.} =
  gtk_stack_get_homogeneous(self)
# proc get_homogeneous*(self: Stack): bool {.inline.} =

# gtk_stack_get_interpolate_size
# flags: {isMethod} container: Stack
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_stack_get_interpolate_size(self: ptr TStack): bool {.cdecl, dynlib: lib, importc: "gtk_stack_get_interpolate_size".}
proc get_interpolate_size*(self: Stack): bool {.inline.} =
  gtk_stack_get_interpolate_size(self)
# proc get_interpolate_size*(self: Stack): bool {.inline.} =

# gtk_stack_get_transition_duration
# flags: {isMethod} container: Stack
# need sugar: is method
# return: UINT32 'uint32' 'uint32'
proc gtk_stack_get_transition_duration(self: ptr TStack): uint32 {.cdecl, dynlib: lib, importc: "gtk_stack_get_transition_duration".}
proc get_transition_duration*(self: Stack): uint32 {.inline.} =
  gtk_stack_get_transition_duration(self)
# proc get_transition_duration*(self: Stack): uint32 {.inline.} =

# gtk_stack_get_transition_running
# flags: {isMethod} container: Stack
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_stack_get_transition_running(self: ptr TStack): bool {.cdecl, dynlib: lib, importc: "gtk_stack_get_transition_running".}
proc get_transition_running*(self: Stack): bool {.inline.} =
  gtk_stack_get_transition_running(self)
# proc get_transition_running*(self: Stack): bool {.inline.} =

# gtk_stack_get_transition_type
# flags: {isMethod} container: Stack
# need sugar: is method
# return: INTERFACE 'StackTransitionType' 'StackTransitionType'
proc gtk_stack_get_transition_type(self: ptr TStack): StackTransitionType {.cdecl, dynlib: lib, importc: "gtk_stack_get_transition_type".}
proc get_transition_type*(self: Stack): StackTransitionType {.inline.} =
  gtk_stack_get_transition_type(self)
# proc get_transition_type*(self: Stack): StackTransitionType {.inline.} =

# gtk_stack_get_vhomogeneous
# flags: {isMethod} container: Stack
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_stack_get_vhomogeneous(self: ptr TStack): bool {.cdecl, dynlib: lib, importc: "gtk_stack_get_vhomogeneous".}
proc get_vhomogeneous*(self: Stack): bool {.inline.} =
  gtk_stack_get_vhomogeneous(self)
# proc get_vhomogeneous*(self: Stack): bool {.inline.} =

# gtk_stack_get_visible_child
# flags: {isMethod} container: Stack
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_stack_get_visible_child(self: ptr TStack): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_stack_get_visible_child".}
proc get_visible_child*(self: Stack): Widget {.inline.} =
  wrap(gtk_stack_get_visible_child(self))
# proc get_visible_child*(self: Stack): Widget {.inline.} =

# gtk_stack_get_visible_child_name
# flags: {isMethod} container: Stack
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_stack_get_visible_child_name(self: ptr TStack): ucstring {.cdecl, dynlib: lib, importc: "gtk_stack_get_visible_child_name".}
proc get_visible_child_name*(self: Stack): ucstring {.inline.} =
  gtk_stack_get_visible_child_name(self)
# proc get_visible_child_name*(self: Stack): ucstring {.inline.} =

# gtk_stack_set_hhomogeneous
# flags: {isMethod} container: Stack
# need sugar: is method
# arg hhomogeneous: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_stack_set_hhomogeneous(self: ptr TStack, hhomogeneous: bool) {.cdecl, dynlib: lib, importc: "gtk_stack_set_hhomogeneous".}
proc set_hhomogeneous*(self: Stack, hhomogeneous: bool) {.inline.} =
  gtk_stack_set_hhomogeneous(self, hhomogeneous)
# proc set_hhomogeneous*(self: Stack, hhomogeneous: bool) {.inline.} =

# gtk_stack_set_homogeneous
# flags: {isMethod} container: Stack
# need sugar: is method
# arg homogeneous: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_stack_set_homogeneous(self: ptr TStack, homogeneous: bool) {.cdecl, dynlib: lib, importc: "gtk_stack_set_homogeneous".}
proc set_homogeneous*(self: Stack, homogeneous: bool) {.inline.} =
  gtk_stack_set_homogeneous(self, homogeneous)
# proc set_homogeneous*(self: Stack, homogeneous: bool) {.inline.} =

# gtk_stack_set_interpolate_size
# flags: {isMethod} container: Stack
# need sugar: is method
# arg interpolate_size: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_stack_set_interpolate_size(self: ptr TStack, interpolate_size: bool) {.cdecl, dynlib: lib, importc: "gtk_stack_set_interpolate_size".}
proc set_interpolate_size*(self: Stack, interpolate_size: bool) {.inline.} =
  gtk_stack_set_interpolate_size(self, interpolate_size)
# proc set_interpolate_size*(self: Stack, interpolate_size: bool) {.inline.} =

# gtk_stack_set_transition_duration
# flags: {isMethod} container: Stack
# need sugar: is method
# arg duration: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_stack_set_transition_duration(self: ptr TStack, duration: uint32) {.cdecl, dynlib: lib, importc: "gtk_stack_set_transition_duration".}
proc set_transition_duration*(self: Stack, duration: uint32) {.inline.} =
  gtk_stack_set_transition_duration(self, duration)
# proc set_transition_duration*(self: Stack, duration: uint32) {.inline.} =

# gtk_stack_set_transition_type
# flags: {isMethod} container: Stack
# need sugar: is method
# arg transition: INTERFACE (ENUM) 'StackTransitionType' 'StackTransitionType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_stack_set_transition_type(self: ptr TStack, transition: StackTransitionType) {.cdecl, dynlib: lib, importc: "gtk_stack_set_transition_type".}
proc set_transition_type*(self: Stack, transition: StackTransitionType) {.inline.} =
  gtk_stack_set_transition_type(self, transition)
# proc set_transition_type*(self: Stack, transition: StackTransitionType) {.inline.} =

# gtk_stack_set_vhomogeneous
# flags: {isMethod} container: Stack
# need sugar: is method
# arg vhomogeneous: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_stack_set_vhomogeneous(self: ptr TStack, vhomogeneous: bool) {.cdecl, dynlib: lib, importc: "gtk_stack_set_vhomogeneous".}
proc set_vhomogeneous*(self: Stack, vhomogeneous: bool) {.inline.} =
  gtk_stack_set_vhomogeneous(self, vhomogeneous)
# proc set_vhomogeneous*(self: Stack, vhomogeneous: bool) {.inline.} =

# gtk_stack_set_visible_child
# flags: {isMethod} container: Stack
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_stack_set_visible_child(self: ptr TStack, child: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_stack_set_visible_child".}
proc set_visible_child*(self: Stack, child: Widget) {.inline.} =
  gtk_stack_set_visible_child(self, child.getPointer)
# proc set_visible_child*(self: Stack, child: Widget) {.inline.} =

# gtk_stack_set_visible_child_full
# flags: {isMethod} container: Stack
# need sugar: is method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg transition: INTERFACE (ENUM) 'StackTransitionType' 'StackTransitionType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_stack_set_visible_child_full(self: ptr TStack, name: ucstring, transition: StackTransitionType) {.cdecl, dynlib: lib, importc: "gtk_stack_set_visible_child_full".}
proc set_visible_child_full*(self: Stack, name: ustring, transition: StackTransitionType) {.inline.} =
  gtk_stack_set_visible_child_full(self, ucstring(name), transition)
# proc set_visible_child_full*(self: Stack, name: ustring, transition: StackTransitionType) {.inline.} =

# gtk_stack_set_visible_child_name
# flags: {isMethod} container: Stack
# need sugar: is method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_stack_set_visible_child_name(self: ptr TStack, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_stack_set_visible_child_name".}
proc set_visible_child_name*(self: Stack, name: ustring) {.inline.} =
  gtk_stack_set_visible_child_name(self, ucstring(name))
# proc set_visible_child_name*(self: Stack, name: ustring) {.inline.} =

# initializer for StackSidebar: gtk_stack_sidebar_get_type
proc gtk_stack_sidebar_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_stack_sidebar_get_type".}
template gtype*(klass_parameter: typedesc[StackSidebar]): GType = gtk_stack_sidebar_get_type()
# gtk_stack_sidebar_new
# flags: {isConstructor} container: StackSidebar
# need sugar: is static method
# return: INTERFACE 'StackSidebar' 'TransferNone[TStackSidebar]' (diff., need sugar)
proc gtk_stack_sidebar_new(): TransferNone[TStackSidebar] {.cdecl, dynlib: lib, importc: "gtk_stack_sidebar_new".}
proc new_stacksidebar*(): StackSidebar {.inline.} =
  wrap(gtk_stack_sidebar_new())
# proc new_stacksidebar*(): StackSidebar {.inline.} =

# gtk_stack_sidebar_get_stack
# flags: {isMethod} container: StackSidebar
# need sugar: is method
# return: INTERFACE 'Stack' 'TransferFull[TStack]' (diff., need sugar)
proc gtk_stack_sidebar_get_stack(self: ptr TStackSidebar): TransferFull[TStack] {.cdecl, dynlib: lib, importc: "gtk_stack_sidebar_get_stack".}
proc get_stack*(self: StackSidebar): Stack {.inline.} =
  wrap(gtk_stack_sidebar_get_stack(self))
# proc get_stack*(self: StackSidebar): Stack {.inline.} =

# gtk_stack_sidebar_set_stack
# flags: {isMethod} container: StackSidebar
# need sugar: is method
# arg stack: INTERFACE (OBJECT) 'Stack' 'ptr TStack' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_stack_sidebar_set_stack(self: ptr TStackSidebar, stack: ptr TStack) {.cdecl, dynlib: lib, importc: "gtk_stack_sidebar_set_stack".}
proc set_stack*(self: StackSidebar, stack: Stack) {.inline.} =
  gtk_stack_sidebar_set_stack(self, stack.getPointer)
# proc set_stack*(self: StackSidebar, stack: Stack) {.inline.} =

# initializer for StackSwitcher: gtk_stack_switcher_get_type
proc gtk_stack_switcher_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_stack_switcher_get_type".}
template gtype*(klass_parameter: typedesc[StackSwitcher]): GType = gtk_stack_switcher_get_type()
# gtk_stack_switcher_new
# flags: {isConstructor} container: StackSwitcher
# need sugar: is static method
# return: INTERFACE 'StackSwitcher' 'TransferNone[TStackSwitcher]' (diff., need sugar)
proc gtk_stack_switcher_new(): TransferNone[TStackSwitcher] {.cdecl, dynlib: lib, importc: "gtk_stack_switcher_new".}
proc new_stackswitcher*(): StackSwitcher {.inline.} =
  wrap(gtk_stack_switcher_new())
# proc new_stackswitcher*(): StackSwitcher {.inline.} =

# gtk_stack_switcher_get_stack
# flags: {isMethod} container: StackSwitcher
# need sugar: is method
# return: INTERFACE 'Stack' 'TransferNone[TStack]' (diff., need sugar)
proc gtk_stack_switcher_get_stack(self: ptr TStackSwitcher): TransferNone[TStack] {.cdecl, dynlib: lib, importc: "gtk_stack_switcher_get_stack".}
proc get_stack*(self: StackSwitcher): Stack {.inline.} =
  wrap(gtk_stack_switcher_get_stack(self))
# proc get_stack*(self: StackSwitcher): Stack {.inline.} =

# gtk_stack_switcher_set_stack
# flags: {isMethod} container: StackSwitcher
# need sugar: is method
# arg stack: INTERFACE (OBJECT) 'Stack' 'ptr TStack' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_stack_switcher_set_stack(self: ptr TStackSwitcher, stack: ptr TStack) {.cdecl, dynlib: lib, importc: "gtk_stack_switcher_set_stack".}
proc set_stack*(self: StackSwitcher, stack: Stack) {.inline.} =
  gtk_stack_switcher_set_stack(self, stack.getPointer)
# proc set_stack*(self: StackSwitcher, stack: Stack) {.inline.} =

# initializer for StatusIcon: gtk_status_icon_get_type
proc gtk_status_icon_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_status_icon_get_type".}
template gtype*(klass_parameter: typedesc[StatusIcon]): GType = gtk_status_icon_get_type()
# gtk_status_icon_new
# flags: {isConstructor} container: StatusIcon (deprecated)
# gtk_status_icon_new_from_file
# flags: {isConstructor} container: StatusIcon (deprecated)
# gtk_status_icon_new_from_gicon
# flags: {isConstructor} container: StatusIcon (deprecated)
# gtk_status_icon_new_from_icon_name
# flags: {isConstructor} container: StatusIcon (deprecated)
# gtk_status_icon_new_from_pixbuf
# flags: {isConstructor} container: StatusIcon (deprecated)
# gtk_status_icon_new_from_stock
# flags: {isConstructor} container: StatusIcon (deprecated)
# gtk_status_icon_position_menu
# flags: {} container: StatusIcon (deprecated)
# gtk_status_icon_get_geometry
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_get_gicon
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_get_has_tooltip
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_get_icon_name
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_get_pixbuf
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_get_screen
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_get_size
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_get_stock
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_get_storage_type
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_get_title
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_get_tooltip_markup
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_get_tooltip_text
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_get_visible
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_get_x11_window_id
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_is_embedded
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_set_from_file
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_set_from_gicon
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_set_from_icon_name
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_set_from_pixbuf
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_set_from_stock
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_set_has_tooltip
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_set_name
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_set_screen
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_set_title
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_set_tooltip_markup
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_set_tooltip_text
# flags: {isMethod} container: StatusIcon (deprecated)
# gtk_status_icon_set_visible
# flags: {isMethod} container: StatusIcon (deprecated)
# initializer for Statusbar: gtk_statusbar_get_type
proc gtk_statusbar_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_statusbar_get_type".}
template gtype*(klass_parameter: typedesc[Statusbar]): GType = gtk_statusbar_get_type()
# gtk_statusbar_new
# flags: {isConstructor} container: Statusbar
# need sugar: is static method
# return: INTERFACE 'Statusbar' 'TransferNone[TStatusbar]' (diff., need sugar)
proc gtk_statusbar_new(): TransferNone[TStatusbar] {.cdecl, dynlib: lib, importc: "gtk_statusbar_new".}
proc new_statusbar*(): Statusbar {.inline.} =
  wrap(gtk_statusbar_new())
# proc new_statusbar*(): Statusbar {.inline.} =

# gtk_statusbar_get_context_id
# flags: {isMethod} container: Statusbar
# need sugar: is method
# arg context_description: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: UINT32 'uint32' 'uint32'
proc gtk_statusbar_get_context_id(self: ptr TStatusbar, context_description: ucstring): uint32 {.cdecl, dynlib: lib, importc: "gtk_statusbar_get_context_id".}
proc get_context_id*(self: Statusbar, context_description: ustring): uint32 {.inline.} =
  gtk_statusbar_get_context_id(self, ucstring(context_description))
# proc get_context_id*(self: Statusbar, context_description: ustring): uint32 {.inline.} =

# gtk_statusbar_get_message_area
# flags: {isMethod} container: Statusbar
# need sugar: is method
# return: INTERFACE 'Box' 'TransferNone[TBox]' (diff., need sugar)
proc gtk_statusbar_get_message_area(self: ptr TStatusbar): TransferNone[TBox] {.cdecl, dynlib: lib, importc: "gtk_statusbar_get_message_area".}
proc get_message_area*(self: Statusbar): Box {.inline.} =
  wrap(gtk_statusbar_get_message_area(self))
# proc get_message_area*(self: Statusbar): Box {.inline.} =

# gtk_statusbar_pop
# flags: {isMethod} container: Statusbar
# need sugar: is method
# arg context_id: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_statusbar_pop(self: ptr TStatusbar, context_id: uint32) {.cdecl, dynlib: lib, importc: "gtk_statusbar_pop".}
proc pop*(self: Statusbar, context_id: uint32) {.inline.} =
  gtk_statusbar_pop(self, context_id)
# proc pop*(self: Statusbar, context_id: uint32) {.inline.} =

# gtk_statusbar_push
# flags: {isMethod} container: Statusbar
# need sugar: is method
# arg context_id: UINT32 'uint32' 'uint32' IN
# arg text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: UINT32 'uint32' 'uint32'
proc gtk_statusbar_push(self: ptr TStatusbar, context_id: uint32, text: ucstring): uint32 {.cdecl, dynlib: lib, importc: "gtk_statusbar_push".}
proc push*(self: Statusbar, context_id: uint32, text: ustring): uint32 {.inline.} =
  gtk_statusbar_push(self, context_id, ucstring(text))
# proc push*(self: Statusbar, context_id: uint32, text: ustring): uint32 {.inline.} =

# gtk_statusbar_remove
# flags: {isMethod} container: Statusbar
# need sugar: is method
# arg context_id: UINT32 'uint32' 'uint32' IN
# arg message_id: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_statusbar_remove(self: ptr TStatusbar, context_id: uint32, message_id: uint32) {.cdecl, dynlib: lib, importc: "gtk_statusbar_remove".}
proc remove*(self: Statusbar, context_id: uint32, message_id: uint32) {.inline.} =
  gtk_statusbar_remove(self, context_id, message_id)
# proc remove*(self: Statusbar, context_id: uint32, message_id: uint32) {.inline.} =

# gtk_statusbar_remove_all
# flags: {isMethod} container: Statusbar
# need sugar: is method
# arg context_id: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_statusbar_remove_all(self: ptr TStatusbar, context_id: uint32) {.cdecl, dynlib: lib, importc: "gtk_statusbar_remove_all".}
proc remove_all*(self: Statusbar, context_id: uint32) {.inline.} =
  gtk_statusbar_remove_all(self, context_id)
# proc remove_all*(self: Statusbar, context_id: uint32) {.inline.} =

# initializer for StatusbarAccessible: gtk_statusbar_accessible_get_type
proc gtk_statusbar_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_statusbar_accessible_get_type".}
template gtype*(klass_parameter: typedesc[StatusbarAccessible]): GType = gtk_statusbar_accessible_get_type()
# initializer for Style: gtk_style_get_type
proc gtk_style_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_style_get_type".}
template gtype*(klass_parameter: typedesc[Style]): GType = gtk_style_get_type()
# gtk_style_new
# flags: {isConstructor} container: Style (deprecated)
# gtk_style_apply_default_background
# flags: {isMethod} container: Style (deprecated)
# gtk_style_copy
# flags: {isMethod} container: Style (deprecated)
# gtk_style_detach
# flags: {isMethod} container: Style (deprecated)
# gtk_style_get_style_property
# flags: {isMethod} container: Style
# need sugar: is method
# arg widget_type: GTYPE 'GType' 'GType' IN
# arg property_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg value: INTERFACE (STRUCT) 'ptr GObject2.TValue' 'ptr GObject2.TValue' OUT caller-allocates
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_style_get_style_property(self: ptr TStyle, widget_type: GType, property_name: ucstring, value: ptr GObject2.TValue) {.cdecl, dynlib: lib, importc: "gtk_style_get_style_property".}
proc get_style_property*(self: Style, widget_type: GType, property_name: ustring, value: ptr GObject2.TValue) {.inline.} =
  gtk_style_get_style_property(self, widget_type, ucstring(property_name), value)
# tuple-return
# value: ptr GObject2.TValue
# proc get_style_property*(self: Style, widget_type: GType, property_name: ustring) {.inline.} =

# gtk_style_has_context
# flags: {isMethod} container: Style
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_style_has_context(self: ptr TStyle): bool {.cdecl, dynlib: lib, importc: "gtk_style_has_context".}
proc has_context*(self: Style): bool {.inline.} =
  gtk_style_has_context(self)
# proc has_context*(self: Style): bool {.inline.} =

# gtk_style_lookup_color
# flags: {isMethod} container: Style (deprecated)
# gtk_style_lookup_icon_set
# flags: {isMethod} container: Style (deprecated)
# gtk_style_render_icon
# flags: {isMethod} container: Style (deprecated)
# gtk_style_set_background
# flags: {isMethod} container: Style (deprecated)
# initializer for StyleContext: gtk_style_context_get_type
proc gtk_style_context_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_style_context_get_type".}
template gtype*(klass_parameter: typedesc[StyleContext]): GType = gtk_style_context_get_type()
# gtk_style_context_new
# flags: {isConstructor} container: StyleContext
# need sugar: is static method
# return: INTERFACE 'StyleContext' 'TransferFull[TStyleContext]' (diff., need sugar)
proc gtk_style_context_new(): TransferFull[TStyleContext] {.cdecl, dynlib: lib, importc: "gtk_style_context_new".}
proc new_stylecontext*(): StyleContext {.inline.} =
  wrap(gtk_style_context_new())
# proc new_stylecontext*(): StyleContext {.inline.} =

# gtk_style_context_add_provider_for_screen
# flags: {} container: StyleContext
# need sugar: is static method
# arg screen: INTERFACE (OBJECT) 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# arg provider: INTERFACE (INTERFACE) 'ptr TStyleProvider' 'ptr TStyleProvider' IN
# arg priority: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_add_provider_for_screen(screen: ptr Gdk3.TScreen, provider: ptr TStyleProvider, priority: uint32) {.cdecl, dynlib: lib, importc: "gtk_style_context_add_provider_for_screen".}
template add_provider_for_screen*(klass_parameter: typedesc[StyleContext], screen: Gdk3.Screen, provider: ptr TStyleProvider, priority: uint32) =
  gtk_style_context_add_provider_for_screen(screen.getPointer, provider, priority)
# template add_provider_for_screen*(klass_parameter: typedesc[StyleContext], screen: Gdk3.Screen, provider: ptr TStyleProvider, priority: uint32) =

# gtk_style_context_remove_provider_for_screen
# flags: {} container: StyleContext
# need sugar: is static method
# arg screen: INTERFACE (OBJECT) 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# arg provider: INTERFACE (INTERFACE) 'ptr TStyleProvider' 'ptr TStyleProvider' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_remove_provider_for_screen(screen: ptr Gdk3.TScreen, provider: ptr TStyleProvider) {.cdecl, dynlib: lib, importc: "gtk_style_context_remove_provider_for_screen".}
template remove_provider_for_screen*(klass_parameter: typedesc[StyleContext], screen: Gdk3.Screen, provider: ptr TStyleProvider) =
  gtk_style_context_remove_provider_for_screen(screen.getPointer, provider)
# template remove_provider_for_screen*(klass_parameter: typedesc[StyleContext], screen: Gdk3.Screen, provider: ptr TStyleProvider) =

# gtk_style_context_reset_widgets
# flags: {} container: StyleContext
# need sugar: is static method
# arg screen: INTERFACE (OBJECT) 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_reset_widgets(screen: ptr Gdk3.TScreen) {.cdecl, dynlib: lib, importc: "gtk_style_context_reset_widgets".}
template reset_widgets*(klass_parameter: typedesc[StyleContext], screen: Gdk3.Screen) =
  gtk_style_context_reset_widgets(screen.getPointer)
# template reset_widgets*(klass_parameter: typedesc[StyleContext], screen: Gdk3.Screen) =

# gtk_style_context_add_class
# flags: {isMethod} container: StyleContext
# need sugar: is method
# arg class_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_add_class(self: ptr TStyleContext, class_name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_style_context_add_class".}
proc add_class*(self: StyleContext, class_name: ustring) {.inline.} =
  gtk_style_context_add_class(self, ucstring(class_name))
# proc add_class*(self: StyleContext, class_name: ustring) {.inline.} =

# gtk_style_context_add_provider
# flags: {isMethod} container: StyleContext
# need sugar: is method
# arg provider: INTERFACE (INTERFACE) 'ptr TStyleProvider' 'ptr TStyleProvider' IN
# arg priority: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_add_provider(self: ptr TStyleContext, provider: ptr TStyleProvider, priority: uint32) {.cdecl, dynlib: lib, importc: "gtk_style_context_add_provider".}
proc add_provider*(self: StyleContext, provider: ptr TStyleProvider, priority: uint32) {.inline.} =
  gtk_style_context_add_provider(self, provider, priority)
# proc add_provider*(self: StyleContext, provider: ptr TStyleProvider, priority: uint32) {.inline.} =

# gtk_style_context_add_region
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_cancel_animations
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_get_background_color
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_get_border
# flags: {isMethod} container: StyleContext
# need sugar: is method
# arg state: INTERFACE (FLAGS) 'SStateFlags' 'SStateFlags' IN
# arg border: INTERFACE (STRUCT) 'ptr TBorder' 'ptr TBorder' OUT caller-allocates
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_get_border(self: ptr TStyleContext, state: SStateFlags, border: ptr TBorder) {.cdecl, dynlib: lib, importc: "gtk_style_context_get_border".}
proc get_border*(self: StyleContext, state: SStateFlags, border: ptr TBorder) {.inline.} =
  gtk_style_context_get_border(self, state, border)
# tuple-return
# border: ptr TBorder
# proc get_border*(self: StyleContext, state: SStateFlags) {.inline.} =

# gtk_style_context_get_border_color
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_get_color
# flags: {isMethod} container: StyleContext
# need sugar: is method
# arg state: INTERFACE (FLAGS) 'SStateFlags' 'SStateFlags' IN
# arg color: INTERFACE (STRUCT) 'ptr Gdk3.TRGBA' 'ptr Gdk3.TRGBA' OUT caller-allocates
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_get_color(self: ptr TStyleContext, state: SStateFlags, color: ptr Gdk3.TRGBA) {.cdecl, dynlib: lib, importc: "gtk_style_context_get_color".}
proc get_color*(self: StyleContext, state: SStateFlags, color: ptr Gdk3.TRGBA) {.inline.} =
  gtk_style_context_get_color(self, state, color)
# tuple-return
# color: ptr Gdk3.TRGBA
# proc get_color*(self: StyleContext, state: SStateFlags) {.inline.} =

# gtk_style_context_get_direction
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_get_font
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_get_frame_clock
# flags: {isMethod} container: StyleContext
# need sugar: is method
# return: INTERFACE 'Gdk3.FrameClock' 'TransferNone[Gdk3.TFrameClock]' (diff., need sugar)
proc gtk_style_context_get_frame_clock(self: ptr TStyleContext): TransferNone[Gdk3.TFrameClock] {.cdecl, dynlib: lib, importc: "gtk_style_context_get_frame_clock".}
proc get_frame_clock*(self: StyleContext): Gdk3.FrameClock {.inline.} =
  wrap(gtk_style_context_get_frame_clock(self))
# proc get_frame_clock*(self: StyleContext): Gdk3.FrameClock {.inline.} =

# gtk_style_context_get_junction_sides
# flags: {isMethod} container: StyleContext
# need sugar: is method
# return: INTERFACE 'SJunctionSides' 'SJunctionSides'
proc gtk_style_context_get_junction_sides(self: ptr TStyleContext): SJunctionSides {.cdecl, dynlib: lib, importc: "gtk_style_context_get_junction_sides".}
proc get_junction_sides*(self: StyleContext): SJunctionSides {.inline.} =
  gtk_style_context_get_junction_sides(self)
# proc get_junction_sides*(self: StyleContext): SJunctionSides {.inline.} =

# gtk_style_context_get_margin
# flags: {isMethod} container: StyleContext
# need sugar: is method
# arg state: INTERFACE (FLAGS) 'SStateFlags' 'SStateFlags' IN
# arg margin: INTERFACE (STRUCT) 'ptr TBorder' 'ptr TBorder' OUT caller-allocates
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_get_margin(self: ptr TStyleContext, state: SStateFlags, margin: ptr TBorder) {.cdecl, dynlib: lib, importc: "gtk_style_context_get_margin".}
proc get_margin*(self: StyleContext, state: SStateFlags, margin: ptr TBorder) {.inline.} =
  gtk_style_context_get_margin(self, state, margin)
# tuple-return
# margin: ptr TBorder
# proc get_margin*(self: StyleContext, state: SStateFlags) {.inline.} =

# gtk_style_context_get_padding
# flags: {isMethod} container: StyleContext
# need sugar: is method
# arg state: INTERFACE (FLAGS) 'SStateFlags' 'SStateFlags' IN
# arg padding: INTERFACE (STRUCT) 'ptr TBorder' 'ptr TBorder' OUT caller-allocates
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_get_padding(self: ptr TStyleContext, state: SStateFlags, padding: ptr TBorder) {.cdecl, dynlib: lib, importc: "gtk_style_context_get_padding".}
proc get_padding*(self: StyleContext, state: SStateFlags, padding: ptr TBorder) {.inline.} =
  gtk_style_context_get_padding(self, state, padding)
# tuple-return
# padding: ptr TBorder
# proc get_padding*(self: StyleContext, state: SStateFlags) {.inline.} =

# gtk_style_context_get_parent
# flags: {isMethod} container: StyleContext
# need sugar: is method
# return: INTERFACE 'StyleContext' 'TransferNone[TStyleContext]' (diff., need sugar)
proc gtk_style_context_get_parent(self: ptr TStyleContext): TransferNone[TStyleContext] {.cdecl, dynlib: lib, importc: "gtk_style_context_get_parent".}
proc get_parent*(self: StyleContext): StyleContext {.inline.} =
  wrap(gtk_style_context_get_parent(self))
# proc get_parent*(self: StyleContext): StyleContext {.inline.} =

# gtk_style_context_get_path
# flags: {isMethod} container: StyleContext
# need sugar: is method
# return: INTERFACE 'ptr TWidgetPath' 'ptr TWidgetPath'
proc gtk_style_context_get_path(self: ptr TStyleContext): ptr TWidgetPath {.cdecl, dynlib: lib, importc: "gtk_style_context_get_path".}
proc get_path*(self: StyleContext): ptr TWidgetPath {.inline.} =
  gtk_style_context_get_path(self)
# proc get_path*(self: StyleContext): ptr TWidgetPath {.inline.} =

# gtk_style_context_get_property
# flags: {isMethod} container: StyleContext
# need sugar: is method
# arg property: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg state: INTERFACE (FLAGS) 'SStateFlags' 'SStateFlags' IN
# arg value: INTERFACE (STRUCT) 'ptr GObject2.TValue' 'ptr GObject2.TValue' OUT caller-allocates
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_get_property(self: ptr TStyleContext, property: ucstring, state: SStateFlags, value: ptr GObject2.TValue) {.cdecl, dynlib: lib, importc: "gtk_style_context_get_property".}
proc get_property*(self: StyleContext, property: ustring, state: SStateFlags, value: ptr GObject2.TValue) {.inline.} =
  gtk_style_context_get_property(self, ucstring(property), state, value)
# tuple-return
# value: ptr GObject2.TValue
# proc get_property*(self: StyleContext, property: ustring, state: SStateFlags) {.inline.} =

# gtk_style_context_get_scale
# flags: {isMethod} container: StyleContext
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_style_context_get_scale(self: ptr TStyleContext): int32 {.cdecl, dynlib: lib, importc: "gtk_style_context_get_scale".}
proc get_scale*(self: StyleContext): int32 {.inline.} =
  gtk_style_context_get_scale(self)
# proc get_scale*(self: StyleContext): int32 {.inline.} =

# gtk_style_context_get_screen
# flags: {isMethod} container: StyleContext
# need sugar: is method
# return: INTERFACE 'Gdk3.Screen' 'TransferNone[Gdk3.TScreen]' (diff., need sugar)
proc gtk_style_context_get_screen(self: ptr TStyleContext): TransferNone[Gdk3.TScreen] {.cdecl, dynlib: lib, importc: "gtk_style_context_get_screen".}
proc get_screen*(self: StyleContext): Gdk3.Screen {.inline.} =
  wrap(gtk_style_context_get_screen(self))
# proc get_screen*(self: StyleContext): Gdk3.Screen {.inline.} =

# gtk_style_context_get_section
# flags: {isMethod} container: StyleContext
# need sugar: is method
# arg property: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'ptr TCssSection' 'ptr TCssSection'
proc gtk_style_context_get_section(self: ptr TStyleContext, property: ucstring): ptr TCssSection {.cdecl, dynlib: lib, importc: "gtk_style_context_get_section".}
proc get_section*(self: StyleContext, property: ustring): ptr TCssSection {.inline.} =
  gtk_style_context_get_section(self, ucstring(property))
# proc get_section*(self: StyleContext, property: ustring): ptr TCssSection {.inline.} =

# gtk_style_context_get_state
# flags: {isMethod} container: StyleContext
# need sugar: is method
# return: INTERFACE 'SStateFlags' 'SStateFlags'
proc gtk_style_context_get_state(self: ptr TStyleContext): SStateFlags {.cdecl, dynlib: lib, importc: "gtk_style_context_get_state".}
proc get_state*(self: StyleContext): SStateFlags {.inline.} =
  gtk_style_context_get_state(self)
# proc get_state*(self: StyleContext): SStateFlags {.inline.} =

# gtk_style_context_get_style_property
# flags: {isMethod} container: StyleContext
# need sugar: is method
# arg property_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg value: INTERFACE (STRUCT) 'ptr GObject2.TValue' 'ptr GObject2.TValue' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_get_style_property(self: ptr TStyleContext, property_name: ucstring, value: ptr GObject2.TValue) {.cdecl, dynlib: lib, importc: "gtk_style_context_get_style_property".}
proc get_style_property*(self: StyleContext, property_name: ustring, value: ptr GObject2.TValue) {.inline.} =
  gtk_style_context_get_style_property(self, ucstring(property_name), value)
# proc get_style_property*(self: StyleContext, property_name: ustring, value: ptr GObject2.TValue) {.inline.} =

# gtk_style_context_has_class
# flags: {isMethod} container: StyleContext
# need sugar: is method
# arg class_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_style_context_has_class(self: ptr TStyleContext, class_name: ucstring): bool {.cdecl, dynlib: lib, importc: "gtk_style_context_has_class".}
proc has_class*(self: StyleContext, class_name: ustring): bool {.inline.} =
  gtk_style_context_has_class(self, ucstring(class_name))
# proc has_class*(self: StyleContext, class_name: ustring): bool {.inline.} =

# gtk_style_context_has_region
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_invalidate
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_list_classes
# flags: {isMethod} container: StyleContext
# need sugar: is method
# return: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_style_context_list_classes(self: ptr TStyleContext): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_style_context_list_classes".}
proc list_classes*(self: StyleContext): ptr GLIST_TODO {.inline.} =
  gtk_style_context_list_classes(self)
# proc list_classes*(self: StyleContext): ptr GLIST_TODO {.inline.} =

# gtk_style_context_list_regions
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_lookup_color
# flags: {isMethod} container: StyleContext
# need sugar: is method
# arg color_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg color: INTERFACE (STRUCT) 'ptr Gdk3.TRGBA' 'ptr Gdk3.TRGBA' OUT caller-allocates
# return: BOOLEAN 'bool' 'bool'
proc gtk_style_context_lookup_color(self: ptr TStyleContext, color_name: ucstring, color: ptr Gdk3.TRGBA): bool {.cdecl, dynlib: lib, importc: "gtk_style_context_lookup_color".}
proc lookup_color*(self: StyleContext, color_name: ustring, color: ptr Gdk3.TRGBA): bool {.inline.} =
  gtk_style_context_lookup_color(self, ucstring(color_name), color)
# tuple-return
# color: ptr Gdk3.TRGBA
# proc lookup_color*(self: StyleContext, color_name: ustring): bool {.inline.} =

# gtk_style_context_lookup_icon_set
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_notify_state_change
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_pop_animatable_region
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_push_animatable_region
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_remove_class
# flags: {isMethod} container: StyleContext
# need sugar: is method
# arg class_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_remove_class(self: ptr TStyleContext, class_name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_style_context_remove_class".}
proc remove_class*(self: StyleContext, class_name: ustring) {.inline.} =
  gtk_style_context_remove_class(self, ucstring(class_name))
# proc remove_class*(self: StyleContext, class_name: ustring) {.inline.} =

# gtk_style_context_remove_provider
# flags: {isMethod} container: StyleContext
# need sugar: is method
# arg provider: INTERFACE (INTERFACE) 'ptr TStyleProvider' 'ptr TStyleProvider' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_remove_provider(self: ptr TStyleContext, provider: ptr TStyleProvider) {.cdecl, dynlib: lib, importc: "gtk_style_context_remove_provider".}
proc remove_provider*(self: StyleContext, provider: ptr TStyleProvider) {.inline.} =
  gtk_style_context_remove_provider(self, provider)
# proc remove_provider*(self: StyleContext, provider: ptr TStyleProvider) {.inline.} =

# gtk_style_context_remove_region
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_restore
# flags: {isMethod} container: StyleContext
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_restore(self: ptr TStyleContext) {.cdecl, dynlib: lib, importc: "gtk_style_context_restore".}
proc restore*(self: StyleContext) {.inline.} =
  gtk_style_context_restore(self)
# proc restore*(self: StyleContext) {.inline.} =

# gtk_style_context_save
# flags: {isMethod} container: StyleContext
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_save(self: ptr TStyleContext) {.cdecl, dynlib: lib, importc: "gtk_style_context_save".}
proc save*(self: StyleContext) {.inline.} =
  gtk_style_context_save(self)
# proc save*(self: StyleContext) {.inline.} =

# gtk_style_context_scroll_animations
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_set_background
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_set_direction
# flags: {isMethod} container: StyleContext (deprecated)
# gtk_style_context_set_frame_clock
# flags: {isMethod} container: StyleContext
# need sugar: is method
# arg frame_clock: INTERFACE (OBJECT) 'Gdk3.FrameClock' 'ptr Gdk3.TFrameClock' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_set_frame_clock(self: ptr TStyleContext, frame_clock: ptr Gdk3.TFrameClock) {.cdecl, dynlib: lib, importc: "gtk_style_context_set_frame_clock".}
proc set_frame_clock*(self: StyleContext, frame_clock: Gdk3.FrameClock) {.inline.} =
  gtk_style_context_set_frame_clock(self, frame_clock.getPointer)
# proc set_frame_clock*(self: StyleContext, frame_clock: Gdk3.FrameClock) {.inline.} =

# gtk_style_context_set_junction_sides
# flags: {isMethod} container: StyleContext
# need sugar: is method
# arg sides: INTERFACE (FLAGS) 'SJunctionSides' 'SJunctionSides' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_set_junction_sides(self: ptr TStyleContext, sides: SJunctionSides) {.cdecl, dynlib: lib, importc: "gtk_style_context_set_junction_sides".}
proc set_junction_sides*(self: StyleContext, sides: SJunctionSides) {.inline.} =
  gtk_style_context_set_junction_sides(self, sides)
# proc set_junction_sides*(self: StyleContext, sides: SJunctionSides) {.inline.} =

# gtk_style_context_set_parent
# flags: {isMethod} container: StyleContext
# need sugar: is method
# arg parent: INTERFACE (OBJECT) 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_set_parent(self: ptr TStyleContext, parent: ptr TStyleContext) {.cdecl, dynlib: lib, importc: "gtk_style_context_set_parent".}
proc set_parent*(self: StyleContext, parent: StyleContext) {.inline.} =
  gtk_style_context_set_parent(self, parent.getPointer)
# proc set_parent*(self: StyleContext, parent: StyleContext) {.inline.} =

# gtk_style_context_set_path
# flags: {isMethod} container: StyleContext
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TWidgetPath' 'ptr TWidgetPath' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_set_path(self: ptr TStyleContext, path: ptr TWidgetPath) {.cdecl, dynlib: lib, importc: "gtk_style_context_set_path".}
proc set_path*(self: StyleContext, path: ptr TWidgetPath) {.inline.} =
  gtk_style_context_set_path(self, path)
# proc set_path*(self: StyleContext, path: ptr TWidgetPath) {.inline.} =

# gtk_style_context_set_scale
# flags: {isMethod} container: StyleContext
# need sugar: is method
# arg scale: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_set_scale(self: ptr TStyleContext, scale: int32) {.cdecl, dynlib: lib, importc: "gtk_style_context_set_scale".}
proc set_scale*(self: StyleContext, scale: int32) {.inline.} =
  gtk_style_context_set_scale(self, scale)
# proc set_scale*(self: StyleContext, scale: int32) {.inline.} =

# gtk_style_context_set_screen
# flags: {isMethod} container: StyleContext
# need sugar: is method
# arg screen: INTERFACE (OBJECT) 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_set_screen(self: ptr TStyleContext, screen: ptr Gdk3.TScreen) {.cdecl, dynlib: lib, importc: "gtk_style_context_set_screen".}
proc set_screen*(self: StyleContext, screen: Gdk3.Screen) {.inline.} =
  gtk_style_context_set_screen(self, screen.getPointer)
# proc set_screen*(self: StyleContext, screen: Gdk3.Screen) {.inline.} =

# gtk_style_context_set_state
# flags: {isMethod} container: StyleContext
# need sugar: is method
# arg flags: INTERFACE (FLAGS) 'SStateFlags' 'SStateFlags' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_style_context_set_state(self: ptr TStyleContext, flags: SStateFlags) {.cdecl, dynlib: lib, importc: "gtk_style_context_set_state".}
proc set_state*(self: StyleContext, flags: SStateFlags) {.inline.} =
  gtk_style_context_set_state(self, flags)
# proc set_state*(self: StyleContext, flags: SStateFlags) {.inline.} =

# gtk_style_context_state_is_running
# flags: {isMethod} container: StyleContext (deprecated)
# initializer for StyleProperties: gtk_style_properties_get_type
proc gtk_style_properties_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_style_properties_get_type".}
template gtype*(klass_parameter: typedesc[StyleProperties]): GType = gtk_style_properties_get_type()
# gtk_style_properties_new
# flags: {isConstructor} container: StyleProperties (deprecated)
# gtk_style_properties_clear
# flags: {isMethod} container: StyleProperties (deprecated)
# gtk_style_properties_get_property
# flags: {isMethod} container: StyleProperties (deprecated)
# gtk_style_properties_lookup_color
# flags: {isMethod} container: StyleProperties (deprecated)
# gtk_style_properties_map_color
# flags: {isMethod} container: StyleProperties (deprecated)
# gtk_style_properties_merge
# flags: {isMethod} container: StyleProperties (deprecated)
# gtk_style_properties_set_property
# flags: {isMethod} container: StyleProperties (deprecated)
# gtk_style_properties_unset_property
# flags: {isMethod} container: StyleProperties (deprecated)
# initializer for Switch: gtk_switch_get_type
proc gtk_switch_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_switch_get_type".}
template gtype*(klass_parameter: typedesc[Switch]): GType = gtk_switch_get_type()
# gtk_switch_new
# flags: {isConstructor} container: Switch
# need sugar: is static method
# return: INTERFACE 'Switch' 'TransferNone[TSwitch]' (diff., need sugar)
proc gtk_switch_new(): TransferNone[TSwitch] {.cdecl, dynlib: lib, importc: "gtk_switch_new".}
proc new_switch*(): Switch {.inline.} =
  wrap(gtk_switch_new())
# proc new_switch*(): Switch {.inline.} =

# gtk_switch_get_active
# flags: {isMethod} container: Switch
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_switch_get_active(self: ptr TSwitch): bool {.cdecl, dynlib: lib, importc: "gtk_switch_get_active".}
proc get_active*(self: Switch): bool {.inline.} =
  gtk_switch_get_active(self)
# proc get_active*(self: Switch): bool {.inline.} =

# gtk_switch_get_state
# flags: {isMethod} container: Switch
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_switch_get_state(self: ptr TSwitch): bool {.cdecl, dynlib: lib, importc: "gtk_switch_get_state".}
proc get_state*(self: Switch): bool {.inline.} =
  gtk_switch_get_state(self)
# proc get_state*(self: Switch): bool {.inline.} =

# gtk_switch_set_active
# flags: {isMethod} container: Switch
# need sugar: is method
# arg is_active: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_switch_set_active(self: ptr TSwitch, is_active: bool) {.cdecl, dynlib: lib, importc: "gtk_switch_set_active".}
proc set_active*(self: Switch, is_active: bool) {.inline.} =
  gtk_switch_set_active(self, is_active)
# proc set_active*(self: Switch, is_active: bool) {.inline.} =

# gtk_switch_set_state
# flags: {isMethod} container: Switch
# need sugar: is method
# arg state: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_switch_set_state(self: ptr TSwitch, state: bool) {.cdecl, dynlib: lib, importc: "gtk_switch_set_state".}
proc set_state*(self: Switch, state: bool) {.inline.} =
  gtk_switch_set_state(self, state)
# proc set_state*(self: Switch, state: bool) {.inline.} =

# initializer for SwitchAccessible: gtk_switch_accessible_get_type
proc gtk_switch_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_switch_accessible_get_type".}
template gtype*(klass_parameter: typedesc[SwitchAccessible]): GType = gtk_switch_accessible_get_type()
# initializer for Table: gtk_table_get_type
proc gtk_table_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_table_get_type".}
template gtype*(klass_parameter: typedesc[Table]): GType = gtk_table_get_type()
# gtk_table_new
# flags: {isConstructor} container: Table (deprecated)
# gtk_table_attach
# flags: {isMethod} container: Table (deprecated)
# gtk_table_attach_defaults
# flags: {isMethod} container: Table (deprecated)
# gtk_table_get_col_spacing
# flags: {isMethod} container: Table (deprecated)
# gtk_table_get_default_col_spacing
# flags: {isMethod} container: Table (deprecated)
# gtk_table_get_default_row_spacing
# flags: {isMethod} container: Table (deprecated)
# gtk_table_get_homogeneous
# flags: {isMethod} container: Table (deprecated)
# gtk_table_get_row_spacing
# flags: {isMethod} container: Table (deprecated)
# gtk_table_get_size
# flags: {isMethod} container: Table (deprecated)
# gtk_table_resize
# flags: {isMethod} container: Table (deprecated)
# gtk_table_set_col_spacing
# flags: {isMethod} container: Table (deprecated)
# gtk_table_set_col_spacings
# flags: {isMethod} container: Table (deprecated)
# gtk_table_set_homogeneous
# flags: {isMethod} container: Table (deprecated)
# gtk_table_set_row_spacing
# flags: {isMethod} container: Table (deprecated)
# gtk_table_set_row_spacings
# flags: {isMethod} container: Table (deprecated)
# initializer for TearoffMenuItem: gtk_tearoff_menu_item_get_type
proc gtk_tearoff_menu_item_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_tearoff_menu_item_get_type".}
template gtype*(klass_parameter: typedesc[TearoffMenuItem]): GType = gtk_tearoff_menu_item_get_type()
# gtk_tearoff_menu_item_new
# flags: {isConstructor} container: TearoffMenuItem (deprecated)
# initializer for TextBuffer: gtk_text_buffer_get_type
proc gtk_text_buffer_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_type".}
template gtype*(klass_parameter: typedesc[TextBuffer]): GType = gtk_text_buffer_get_type()
# gtk_text_buffer_new
# flags: {isConstructor} container: TextBuffer
# need sugar: is static method
# arg table: INTERFACE (OBJECT) 'TextTagTable' 'ptr TTextTagTable' IN (diff., need sugar)
# return: INTERFACE 'TextBuffer' 'TransferFull[TTextBuffer]' (diff., need sugar)
proc gtk_text_buffer_new(table: ptr TTextTagTable): TransferFull[TTextBuffer] {.cdecl, dynlib: lib, importc: "gtk_text_buffer_new".}
proc new_textbuffer*(table: TextTagTable): TextBuffer {.inline.} =
  wrap(gtk_text_buffer_new(table.getPointer))
# proc new_textbuffer*(table: TextTagTable): TextBuffer {.inline.} =

# gtk_text_buffer_add_mark
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg mark: INTERFACE (OBJECT) 'TextMark' 'ptr TTextMark' IN (diff., need sugar)
# arg where: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_add_mark(self: ptr TTextBuffer, mark: ptr TTextMark, where: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_add_mark".}
proc add_mark*(self: TextBuffer, mark: TextMark, where: ptr TTextIter) {.inline.} =
  gtk_text_buffer_add_mark(self, mark.getPointer, where)
# proc add_mark*(self: TextBuffer, mark: TextMark, where: ptr TTextIter) {.inline.} =

# gtk_text_buffer_add_selection_clipboard
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg clipboard: INTERFACE (OBJECT) 'Clipboard' 'ptr TClipboard' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_add_selection_clipboard(self: ptr TTextBuffer, clipboard: ptr TClipboard) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_add_selection_clipboard".}
proc add_selection_clipboard*(self: TextBuffer, clipboard: Clipboard) {.inline.} =
  gtk_text_buffer_add_selection_clipboard(self, clipboard.getPointer)
# proc add_selection_clipboard*(self: TextBuffer, clipboard: Clipboard) {.inline.} =

# gtk_text_buffer_apply_tag
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg tag: INTERFACE (OBJECT) 'TextTag' 'ptr TTextTag' IN (diff., need sugar)
# arg start: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg end: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_apply_tag(self: ptr TTextBuffer, tag: ptr TTextTag, start: ptr TTextIter, end_x: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_apply_tag".}
proc apply_tag*(self: TextBuffer, tag: TextTag, start: ptr TTextIter, end_x: ptr TTextIter) {.inline.} =
  gtk_text_buffer_apply_tag(self, tag.getPointer, start, end_x)
# proc apply_tag*(self: TextBuffer, tag: TextTag, start: ptr TTextIter, end_x: ptr TTextIter) {.inline.} =

# gtk_text_buffer_apply_tag_by_name
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg start: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg end: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_apply_tag_by_name(self: ptr TTextBuffer, name: ucstring, start: ptr TTextIter, end_x: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_apply_tag_by_name".}
proc apply_tag_by_name*(self: TextBuffer, name: ustring, start: ptr TTextIter, end_x: ptr TTextIter) {.inline.} =
  gtk_text_buffer_apply_tag_by_name(self, ucstring(name), start, end_x)
# proc apply_tag_by_name*(self: TextBuffer, name: ustring, start: ptr TTextIter, end_x: ptr TTextIter) {.inline.} =

# gtk_text_buffer_backspace
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg interactive: BOOLEAN 'bool' 'bool' IN
# arg default_editable: BOOLEAN 'bool' 'bool' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_buffer_backspace(self: ptr TTextBuffer, iter: ptr TTextIter, interactive: bool, default_editable: bool): bool {.cdecl, dynlib: lib, importc: "gtk_text_buffer_backspace".}
proc backspace*(self: TextBuffer, iter: ptr TTextIter, interactive: bool, default_editable: bool): bool {.inline.} =
  gtk_text_buffer_backspace(self, iter, interactive, default_editable)
# proc backspace*(self: TextBuffer, iter: ptr TTextIter, interactive: bool, default_editable: bool): bool {.inline.} =

# gtk_text_buffer_begin_user_action
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_begin_user_action(self: ptr TTextBuffer) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_begin_user_action".}
proc begin_user_action*(self: TextBuffer) {.inline.} =
  gtk_text_buffer_begin_user_action(self)
# proc begin_user_action*(self: TextBuffer) {.inline.} =

# gtk_text_buffer_copy_clipboard
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg clipboard: INTERFACE (OBJECT) 'Clipboard' 'ptr TClipboard' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_copy_clipboard(self: ptr TTextBuffer, clipboard: ptr TClipboard) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_copy_clipboard".}
proc copy_clipboard*(self: TextBuffer, clipboard: Clipboard) {.inline.} =
  gtk_text_buffer_copy_clipboard(self, clipboard.getPointer)
# proc copy_clipboard*(self: TextBuffer, clipboard: Clipboard) {.inline.} =

# gtk_text_buffer_create_child_anchor
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: INTERFACE 'TextChildAnchor' 'TransferNone[TTextChildAnchor]' (diff., need sugar)
proc gtk_text_buffer_create_child_anchor(self: ptr TTextBuffer, iter: ptr TTextIter): TransferNone[TTextChildAnchor] {.cdecl, dynlib: lib, importc: "gtk_text_buffer_create_child_anchor".}
proc create_child_anchor*(self: TextBuffer, iter: ptr TTextIter): TextChildAnchor {.inline.} =
  wrap(gtk_text_buffer_create_child_anchor(self, iter))
# proc create_child_anchor*(self: TextBuffer, iter: ptr TTextIter): TextChildAnchor {.inline.} =

# gtk_text_buffer_create_mark
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg mark_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg where: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg left_gravity: BOOLEAN 'bool' 'bool' IN
# return: INTERFACE 'TextMark' 'TransferNone[TTextMark]' (diff., need sugar)
proc gtk_text_buffer_create_mark(self: ptr TTextBuffer, mark_name: ucstring, where: ptr TTextIter, left_gravity: bool): TransferNone[TTextMark] {.cdecl, dynlib: lib, importc: "gtk_text_buffer_create_mark".}
proc create_mark*(self: TextBuffer, mark_name: ustring, where: ptr TTextIter, left_gravity: bool): TextMark {.inline.} =
  wrap(gtk_text_buffer_create_mark(self, ucstring(mark_name), where, left_gravity))
# proc create_mark*(self: TextBuffer, mark_name: ustring, where: ptr TTextIter, left_gravity: bool): TextMark {.inline.} =

# gtk_text_buffer_cut_clipboard
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg clipboard: INTERFACE (OBJECT) 'Clipboard' 'ptr TClipboard' IN (diff., need sugar)
# arg default_editable: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_cut_clipboard(self: ptr TTextBuffer, clipboard: ptr TClipboard, default_editable: bool) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_cut_clipboard".}
proc cut_clipboard*(self: TextBuffer, clipboard: Clipboard, default_editable: bool) {.inline.} =
  gtk_text_buffer_cut_clipboard(self, clipboard.getPointer, default_editable)
# proc cut_clipboard*(self: TextBuffer, clipboard: Clipboard, default_editable: bool) {.inline.} =

# gtk_text_buffer_delete
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg start: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg end: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_delete(self: ptr TTextBuffer, start: ptr TTextIter, end_x: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_delete".}
proc delete*(self: TextBuffer, start: ptr TTextIter, end_x: ptr TTextIter) {.inline.} =
  gtk_text_buffer_delete(self, start, end_x)
# proc delete*(self: TextBuffer, start: ptr TTextIter, end_x: ptr TTextIter) {.inline.} =

# gtk_text_buffer_delete_interactive
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg start_iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg end_iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg default_editable: BOOLEAN 'bool' 'bool' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_buffer_delete_interactive(self: ptr TTextBuffer, start_iter: ptr TTextIter, end_iter: ptr TTextIter, default_editable: bool): bool {.cdecl, dynlib: lib, importc: "gtk_text_buffer_delete_interactive".}
proc delete_interactive*(self: TextBuffer, start_iter: ptr TTextIter, end_iter: ptr TTextIter, default_editable: bool): bool {.inline.} =
  gtk_text_buffer_delete_interactive(self, start_iter, end_iter, default_editable)
# proc delete_interactive*(self: TextBuffer, start_iter: ptr TTextIter, end_iter: ptr TTextIter, default_editable: bool): bool {.inline.} =

# gtk_text_buffer_delete_mark
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg mark: INTERFACE (OBJECT) 'TextMark' 'ptr TTextMark' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_delete_mark(self: ptr TTextBuffer, mark: ptr TTextMark) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_delete_mark".}
proc delete_mark*(self: TextBuffer, mark: TextMark) {.inline.} =
  gtk_text_buffer_delete_mark(self, mark.getPointer)
# proc delete_mark*(self: TextBuffer, mark: TextMark) {.inline.} =

# gtk_text_buffer_delete_mark_by_name
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_delete_mark_by_name(self: ptr TTextBuffer, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_delete_mark_by_name".}
proc delete_mark_by_name*(self: TextBuffer, name: ustring) {.inline.} =
  gtk_text_buffer_delete_mark_by_name(self, ucstring(name))
# proc delete_mark_by_name*(self: TextBuffer, name: ustring) {.inline.} =

# gtk_text_buffer_delete_selection
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg interactive: BOOLEAN 'bool' 'bool' IN
# arg default_editable: BOOLEAN 'bool' 'bool' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_buffer_delete_selection(self: ptr TTextBuffer, interactive: bool, default_editable: bool): bool {.cdecl, dynlib: lib, importc: "gtk_text_buffer_delete_selection".}
proc delete_selection*(self: TextBuffer, interactive: bool, default_editable: bool): bool {.inline.} =
  gtk_text_buffer_delete_selection(self, interactive, default_editable)
# proc delete_selection*(self: TextBuffer, interactive: bool, default_editable: bool): bool {.inline.} =

# gtk_text_buffer_deserialize
# flags: {isMethod, throws} container: TextBuffer
# can throw
# need sugar: is method
# arg content_buffer: INTERFACE (OBJECT) 'TextBuffer' 'ptr TTextBuffer' IN (diff., need sugar)
# arg format: INTERFACE (STRUCT) 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom' IN
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg data: ARRAY 'string' 'cstring' IN (diff., need sugar) array lengthArg: 4
# arg length: UINT32 'uint32' 'uint32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_buffer_deserialize(self: ptr TTextBuffer, content_buffer: ptr TTextBuffer, format: ptr Gdk3.TAtom, iter: ptr TTextIter, data: cstring, length: uint32, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_text_buffer_deserialize".}
proc deserialize*(self: TextBuffer, content_buffer: TextBuffer, format: ptr Gdk3.TAtom, iter: ptr TTextIter, data: string): bool {.inline.} =
  gtk_text_buffer_deserialize(self, content_buffer.getPointer, format, iter, cstring(data), data.len.uint32)
# proc deserialize*(self: TextBuffer, content_buffer: TextBuffer, format: ptr Gdk3.TAtom, iter: ptr TTextIter, data: string): bool {.inline.} =

# gtk_text_buffer_deserialize_get_can_create_tags
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg format: INTERFACE (STRUCT) 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_buffer_deserialize_get_can_create_tags(self: ptr TTextBuffer, format: ptr Gdk3.TAtom): bool {.cdecl, dynlib: lib, importc: "gtk_text_buffer_deserialize_get_can_create_tags".}
proc deserialize_get_can_create_tags*(self: TextBuffer, format: ptr Gdk3.TAtom): bool {.inline.} =
  gtk_text_buffer_deserialize_get_can_create_tags(self, format)
# proc deserialize_get_can_create_tags*(self: TextBuffer, format: ptr Gdk3.TAtom): bool {.inline.} =

# gtk_text_buffer_deserialize_set_can_create_tags
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg format: INTERFACE (STRUCT) 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom' IN
# arg can_create_tags: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_deserialize_set_can_create_tags(self: ptr TTextBuffer, format: ptr Gdk3.TAtom, can_create_tags: bool) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_deserialize_set_can_create_tags".}
proc deserialize_set_can_create_tags*(self: TextBuffer, format: ptr Gdk3.TAtom, can_create_tags: bool) {.inline.} =
  gtk_text_buffer_deserialize_set_can_create_tags(self, format, can_create_tags)
# proc deserialize_set_can_create_tags*(self: TextBuffer, format: ptr Gdk3.TAtom, can_create_tags: bool) {.inline.} =

# gtk_text_buffer_end_user_action
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_end_user_action(self: ptr TTextBuffer) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_end_user_action".}
proc end_user_action*(self: TextBuffer) {.inline.} =
  gtk_text_buffer_end_user_action(self)
# proc end_user_action*(self: TextBuffer) {.inline.} =

# gtk_text_buffer_get_bounds
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg start: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' OUT caller-allocates
# arg end: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' OUT caller-allocates
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_get_bounds(self: ptr TTextBuffer, start: ptr TTextIter, end_x: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_bounds".}
proc get_bounds*(self: TextBuffer, start: ptr TTextIter, end_x: ptr TTextIter) {.inline.} =
  gtk_text_buffer_get_bounds(self, start, end_x)
# tuple-return
# start: ptr TTextIter
# end: ptr TTextIter
# proc get_bounds*(self: TextBuffer) {.inline.} =

# gtk_text_buffer_get_char_count
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_text_buffer_get_char_count(self: ptr TTextBuffer): int32 {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_char_count".}
proc get_char_count*(self: TextBuffer): int32 {.inline.} =
  gtk_text_buffer_get_char_count(self)
# proc get_char_count*(self: TextBuffer): int32 {.inline.} =

# gtk_text_buffer_get_copy_target_list
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# return: INTERFACE 'ptr TTargetList' 'ptr TTargetList'
proc gtk_text_buffer_get_copy_target_list(self: ptr TTextBuffer): ptr TTargetList {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_copy_target_list".}
proc get_copy_target_list*(self: TextBuffer): ptr TTargetList {.inline.} =
  gtk_text_buffer_get_copy_target_list(self)
# proc get_copy_target_list*(self: TextBuffer): ptr TTargetList {.inline.} =

# gtk_text_buffer_get_deserialize_formats
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg n_formats: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# return: ARRAY 'zeroTerminatedArray[ptr Gdk3.TAtom]' 'zeroTerminatedArray[ptr Gdk3.TAtom]'
proc gtk_text_buffer_get_deserialize_formats(self: ptr TTextBuffer, n_formats: ptr int32): zeroTerminatedArray[ptr Gdk3.TAtom] {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_deserialize_formats".}
proc get_deserialize_formats*(self: TextBuffer, n_formats: var int32): zeroTerminatedArray[ptr Gdk3.TAtom] {.inline.} =
  gtk_text_buffer_get_deserialize_formats(self, addr(n_formats))
# tuple-return
# n_formats: var int32
# proc get_deserialize_formats*(self: TextBuffer): zeroTerminatedArray[ptr Gdk3.TAtom] {.inline.} =

# gtk_text_buffer_get_end_iter
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' OUT caller-allocates
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_get_end_iter(self: ptr TTextBuffer, iter: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_end_iter".}
proc get_end_iter*(self: TextBuffer, iter: ptr TTextIter) {.inline.} =
  gtk_text_buffer_get_end_iter(self, iter)
# tuple-return
# iter: ptr TTextIter
# proc get_end_iter*(self: TextBuffer) {.inline.} =

# gtk_text_buffer_get_has_selection
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_buffer_get_has_selection(self: ptr TTextBuffer): bool {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_has_selection".}
proc get_has_selection*(self: TextBuffer): bool {.inline.} =
  gtk_text_buffer_get_has_selection(self)
# proc get_has_selection*(self: TextBuffer): bool {.inline.} =

# gtk_text_buffer_get_insert
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# return: INTERFACE 'TextMark' 'TransferNone[TTextMark]' (diff., need sugar)
proc gtk_text_buffer_get_insert(self: ptr TTextBuffer): TransferNone[TTextMark] {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_insert".}
proc get_insert*(self: TextBuffer): TextMark {.inline.} =
  wrap(gtk_text_buffer_get_insert(self))
# proc get_insert*(self: TextBuffer): TextMark {.inline.} =

# gtk_text_buffer_get_iter_at_child_anchor
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' OUT caller-allocates
# arg anchor: INTERFACE (OBJECT) 'TextChildAnchor' 'ptr TTextChildAnchor' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_get_iter_at_child_anchor(self: ptr TTextBuffer, iter: ptr TTextIter, anchor: ptr TTextChildAnchor) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_iter_at_child_anchor".}
proc get_iter_at_child_anchor*(self: TextBuffer, iter: ptr TTextIter, anchor: TextChildAnchor) {.inline.} =
  gtk_text_buffer_get_iter_at_child_anchor(self, iter, anchor.getPointer)
# tuple-return
# iter: ptr TTextIter
# proc get_iter_at_child_anchor*(self: TextBuffer, anchor: TextChildAnchor) {.inline.} =

# gtk_text_buffer_get_iter_at_line
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' OUT caller-allocates
# arg line_number: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_get_iter_at_line(self: ptr TTextBuffer, iter: ptr TTextIter, line_number: int32) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_iter_at_line".}
proc get_iter_at_line*(self: TextBuffer, iter: ptr TTextIter, line_number: int32) {.inline.} =
  gtk_text_buffer_get_iter_at_line(self, iter, line_number)
# tuple-return
# iter: ptr TTextIter
# proc get_iter_at_line*(self: TextBuffer, line_number: int32) {.inline.} =

# gtk_text_buffer_get_iter_at_line_index
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' OUT caller-allocates
# arg line_number: INT32 'int32' 'int32' IN
# arg byte_index: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_get_iter_at_line_index(self: ptr TTextBuffer, iter: ptr TTextIter, line_number: int32, byte_index: int32) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_iter_at_line_index".}
proc get_iter_at_line_index*(self: TextBuffer, iter: ptr TTextIter, line_number: int32, byte_index: int32) {.inline.} =
  gtk_text_buffer_get_iter_at_line_index(self, iter, line_number, byte_index)
# tuple-return
# iter: ptr TTextIter
# proc get_iter_at_line_index*(self: TextBuffer, line_number: int32, byte_index: int32) {.inline.} =

# gtk_text_buffer_get_iter_at_line_offset
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' OUT caller-allocates
# arg line_number: INT32 'int32' 'int32' IN
# arg char_offset: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_get_iter_at_line_offset(self: ptr TTextBuffer, iter: ptr TTextIter, line_number: int32, char_offset: int32) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_iter_at_line_offset".}
proc get_iter_at_line_offset*(self: TextBuffer, iter: ptr TTextIter, line_number: int32, char_offset: int32) {.inline.} =
  gtk_text_buffer_get_iter_at_line_offset(self, iter, line_number, char_offset)
# tuple-return
# iter: ptr TTextIter
# proc get_iter_at_line_offset*(self: TextBuffer, line_number: int32, char_offset: int32) {.inline.} =

# gtk_text_buffer_get_iter_at_mark
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' OUT caller-allocates
# arg mark: INTERFACE (OBJECT) 'TextMark' 'ptr TTextMark' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_get_iter_at_mark(self: ptr TTextBuffer, iter: ptr TTextIter, mark: ptr TTextMark) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_iter_at_mark".}
proc get_iter_at_mark*(self: TextBuffer, iter: ptr TTextIter, mark: TextMark) {.inline.} =
  gtk_text_buffer_get_iter_at_mark(self, iter, mark.getPointer)
# tuple-return
# iter: ptr TTextIter
# proc get_iter_at_mark*(self: TextBuffer, mark: TextMark) {.inline.} =

# gtk_text_buffer_get_iter_at_offset
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' OUT caller-allocates
# arg char_offset: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_get_iter_at_offset(self: ptr TTextBuffer, iter: ptr TTextIter, char_offset: int32) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_iter_at_offset".}
proc get_iter_at_offset*(self: TextBuffer, iter: ptr TTextIter, char_offset: int32) {.inline.} =
  gtk_text_buffer_get_iter_at_offset(self, iter, char_offset)
# tuple-return
# iter: ptr TTextIter
# proc get_iter_at_offset*(self: TextBuffer, char_offset: int32) {.inline.} =

# gtk_text_buffer_get_line_count
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_text_buffer_get_line_count(self: ptr TTextBuffer): int32 {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_line_count".}
proc get_line_count*(self: TextBuffer): int32 {.inline.} =
  gtk_text_buffer_get_line_count(self)
# proc get_line_count*(self: TextBuffer): int32 {.inline.} =

# gtk_text_buffer_get_mark
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'TextMark' 'TransferNone[TTextMark]' (diff., need sugar)
proc gtk_text_buffer_get_mark(self: ptr TTextBuffer, name: ucstring): TransferNone[TTextMark] {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_mark".}
proc get_mark*(self: TextBuffer, name: ustring): TextMark {.inline.} =
  wrap(gtk_text_buffer_get_mark(self, ucstring(name)))
# proc get_mark*(self: TextBuffer, name: ustring): TextMark {.inline.} =

# gtk_text_buffer_get_modified
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_buffer_get_modified(self: ptr TTextBuffer): bool {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_modified".}
proc get_modified*(self: TextBuffer): bool {.inline.} =
  gtk_text_buffer_get_modified(self)
# proc get_modified*(self: TextBuffer): bool {.inline.} =

# gtk_text_buffer_get_paste_target_list
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# return: INTERFACE 'ptr TTargetList' 'ptr TTargetList'
proc gtk_text_buffer_get_paste_target_list(self: ptr TTextBuffer): ptr TTargetList {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_paste_target_list".}
proc get_paste_target_list*(self: TextBuffer): ptr TTargetList {.inline.} =
  gtk_text_buffer_get_paste_target_list(self)
# proc get_paste_target_list*(self: TextBuffer): ptr TTargetList {.inline.} =

# gtk_text_buffer_get_selection_bound
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# return: INTERFACE 'TextMark' 'TransferNone[TTextMark]' (diff., need sugar)
proc gtk_text_buffer_get_selection_bound(self: ptr TTextBuffer): TransferNone[TTextMark] {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_selection_bound".}
proc get_selection_bound*(self: TextBuffer): TextMark {.inline.} =
  wrap(gtk_text_buffer_get_selection_bound(self))
# proc get_selection_bound*(self: TextBuffer): TextMark {.inline.} =

# gtk_text_buffer_get_selection_bounds
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg start: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' OUT caller-allocates
# arg end: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' OUT caller-allocates
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_buffer_get_selection_bounds(self: ptr TTextBuffer, start: ptr TTextIter, end_x: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_selection_bounds".}
proc get_selection_bounds*(self: TextBuffer, start: ptr TTextIter, end_x: ptr TTextIter): bool {.inline.} =
  gtk_text_buffer_get_selection_bounds(self, start, end_x)
# tuple-return
# start: ptr TTextIter
# end: ptr TTextIter
# proc get_selection_bounds*(self: TextBuffer): bool {.inline.} =

# gtk_text_buffer_get_serialize_formats
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg n_formats: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# return: ARRAY 'zeroTerminatedArray[ptr Gdk3.TAtom]' 'zeroTerminatedArray[ptr Gdk3.TAtom]'
proc gtk_text_buffer_get_serialize_formats(self: ptr TTextBuffer, n_formats: ptr int32): zeroTerminatedArray[ptr Gdk3.TAtom] {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_serialize_formats".}
proc get_serialize_formats*(self: TextBuffer, n_formats: var int32): zeroTerminatedArray[ptr Gdk3.TAtom] {.inline.} =
  gtk_text_buffer_get_serialize_formats(self, addr(n_formats))
# tuple-return
# n_formats: var int32
# proc get_serialize_formats*(self: TextBuffer): zeroTerminatedArray[ptr Gdk3.TAtom] {.inline.} =

# gtk_text_buffer_get_slice
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg start: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg end: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg include_hidden_chars: BOOLEAN 'bool' 'bool' IN
# return: UTF8 'ucstring' 'ucstring'
proc gtk_text_buffer_get_slice(self: ptr TTextBuffer, start: ptr TTextIter, end_x: ptr TTextIter, include_hidden_chars: bool): ucstring {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_slice".}
proc get_slice*(self: TextBuffer, start: ptr TTextIter, end_x: ptr TTextIter, include_hidden_chars: bool): ucstring {.inline.} =
  gtk_text_buffer_get_slice(self, start, end_x, include_hidden_chars)
# proc get_slice*(self: TextBuffer, start: ptr TTextIter, end_x: ptr TTextIter, include_hidden_chars: bool): ucstring {.inline.} =

# gtk_text_buffer_get_start_iter
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' OUT caller-allocates
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_get_start_iter(self: ptr TTextBuffer, iter: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_start_iter".}
proc get_start_iter*(self: TextBuffer, iter: ptr TTextIter) {.inline.} =
  gtk_text_buffer_get_start_iter(self, iter)
# tuple-return
# iter: ptr TTextIter
# proc get_start_iter*(self: TextBuffer) {.inline.} =

# gtk_text_buffer_get_tag_table
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# return: INTERFACE 'TextTagTable' 'TransferNone[TTextTagTable]' (diff., need sugar)
proc gtk_text_buffer_get_tag_table(self: ptr TTextBuffer): TransferNone[TTextTagTable] {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_tag_table".}
proc get_tag_table*(self: TextBuffer): TextTagTable {.inline.} =
  wrap(gtk_text_buffer_get_tag_table(self))
# proc get_tag_table*(self: TextBuffer): TextTagTable {.inline.} =

# gtk_text_buffer_get_text
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg start: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg end: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg include_hidden_chars: BOOLEAN 'bool' 'bool' IN
# return: UTF8 'ucstring' 'ucstring'
proc gtk_text_buffer_get_text(self: ptr TTextBuffer, start: ptr TTextIter, end_x: ptr TTextIter, include_hidden_chars: bool): ucstring {.cdecl, dynlib: lib, importc: "gtk_text_buffer_get_text".}
proc get_text*(self: TextBuffer, start: ptr TTextIter, end_x: ptr TTextIter, include_hidden_chars: bool): ucstring {.inline.} =
  gtk_text_buffer_get_text(self, start, end_x, include_hidden_chars)
# proc get_text*(self: TextBuffer, start: ptr TTextIter, end_x: ptr TTextIter, include_hidden_chars: bool): ucstring {.inline.} =

# gtk_text_buffer_insert
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg len: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_insert(self: ptr TTextBuffer, iter: ptr TTextIter, text: ucstring, len: int32) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_insert".}
proc insert*(self: TextBuffer, iter: ptr TTextIter, text: ustring, len: int32) {.inline.} =
  gtk_text_buffer_insert(self, iter, ucstring(text), len)
# proc insert*(self: TextBuffer, iter: ptr TTextIter, text: ustring, len: int32) {.inline.} =

# gtk_text_buffer_insert_at_cursor
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg len: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_insert_at_cursor(self: ptr TTextBuffer, text: ucstring, len: int32) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_insert_at_cursor".}
proc insert_at_cursor*(self: TextBuffer, text: ustring, len: int32) {.inline.} =
  gtk_text_buffer_insert_at_cursor(self, ucstring(text), len)
# proc insert_at_cursor*(self: TextBuffer, text: ustring, len: int32) {.inline.} =

# gtk_text_buffer_insert_child_anchor
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg anchor: INTERFACE (OBJECT) 'TextChildAnchor' 'ptr TTextChildAnchor' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_insert_child_anchor(self: ptr TTextBuffer, iter: ptr TTextIter, anchor: ptr TTextChildAnchor) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_insert_child_anchor".}
proc insert_child_anchor*(self: TextBuffer, iter: ptr TTextIter, anchor: TextChildAnchor) {.inline.} =
  gtk_text_buffer_insert_child_anchor(self, iter, anchor.getPointer)
# proc insert_child_anchor*(self: TextBuffer, iter: ptr TTextIter, anchor: TextChildAnchor) {.inline.} =

# gtk_text_buffer_insert_interactive
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg len: INT32 'int32' 'int32' IN
# arg default_editable: BOOLEAN 'bool' 'bool' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_buffer_insert_interactive(self: ptr TTextBuffer, iter: ptr TTextIter, text: ucstring, len: int32, default_editable: bool): bool {.cdecl, dynlib: lib, importc: "gtk_text_buffer_insert_interactive".}
proc insert_interactive*(self: TextBuffer, iter: ptr TTextIter, text: ustring, len: int32, default_editable: bool): bool {.inline.} =
  gtk_text_buffer_insert_interactive(self, iter, ucstring(text), len, default_editable)
# proc insert_interactive*(self: TextBuffer, iter: ptr TTextIter, text: ustring, len: int32, default_editable: bool): bool {.inline.} =

# gtk_text_buffer_insert_interactive_at_cursor
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg len: INT32 'int32' 'int32' IN
# arg default_editable: BOOLEAN 'bool' 'bool' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_buffer_insert_interactive_at_cursor(self: ptr TTextBuffer, text: ucstring, len: int32, default_editable: bool): bool {.cdecl, dynlib: lib, importc: "gtk_text_buffer_insert_interactive_at_cursor".}
proc insert_interactive_at_cursor*(self: TextBuffer, text: ustring, len: int32, default_editable: bool): bool {.inline.} =
  gtk_text_buffer_insert_interactive_at_cursor(self, ucstring(text), len, default_editable)
# proc insert_interactive_at_cursor*(self: TextBuffer, text: ustring, len: int32, default_editable: bool): bool {.inline.} =

# gtk_text_buffer_insert_markup
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg markup: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg len: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_insert_markup(self: ptr TTextBuffer, iter: ptr TTextIter, markup: ucstring, len: int32) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_insert_markup".}
proc insert_markup*(self: TextBuffer, iter: ptr TTextIter, markup: ustring, len: int32) {.inline.} =
  gtk_text_buffer_insert_markup(self, iter, ucstring(markup), len)
# proc insert_markup*(self: TextBuffer, iter: ptr TTextIter, markup: ustring, len: int32) {.inline.} =

# gtk_text_buffer_insert_pixbuf
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg pixbuf: INTERFACE (OBJECT) 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_insert_pixbuf(self: ptr TTextBuffer, iter: ptr TTextIter, pixbuf: ptr GdkPixbuf2.TPixbuf) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_insert_pixbuf".}
proc insert_pixbuf*(self: TextBuffer, iter: ptr TTextIter, pixbuf: GdkPixbuf2.Pixbuf) {.inline.} =
  gtk_text_buffer_insert_pixbuf(self, iter, pixbuf.getPointer)
# proc insert_pixbuf*(self: TextBuffer, iter: ptr TTextIter, pixbuf: GdkPixbuf2.Pixbuf) {.inline.} =

# gtk_text_buffer_insert_range
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg start: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg end: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_insert_range(self: ptr TTextBuffer, iter: ptr TTextIter, start: ptr TTextIter, end_x: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_insert_range".}
proc insert_range*(self: TextBuffer, iter: ptr TTextIter, start: ptr TTextIter, end_x: ptr TTextIter) {.inline.} =
  gtk_text_buffer_insert_range(self, iter, start, end_x)
# proc insert_range*(self: TextBuffer, iter: ptr TTextIter, start: ptr TTextIter, end_x: ptr TTextIter) {.inline.} =

# gtk_text_buffer_insert_range_interactive
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg start: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg end: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg default_editable: BOOLEAN 'bool' 'bool' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_buffer_insert_range_interactive(self: ptr TTextBuffer, iter: ptr TTextIter, start: ptr TTextIter, end_x: ptr TTextIter, default_editable: bool): bool {.cdecl, dynlib: lib, importc: "gtk_text_buffer_insert_range_interactive".}
proc insert_range_interactive*(self: TextBuffer, iter: ptr TTextIter, start: ptr TTextIter, end_x: ptr TTextIter, default_editable: bool): bool {.inline.} =
  gtk_text_buffer_insert_range_interactive(self, iter, start, end_x, default_editable)
# proc insert_range_interactive*(self: TextBuffer, iter: ptr TTextIter, start: ptr TTextIter, end_x: ptr TTextIter, default_editable: bool): bool {.inline.} =

# gtk_text_buffer_move_mark
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg mark: INTERFACE (OBJECT) 'TextMark' 'ptr TTextMark' IN (diff., need sugar)
# arg where: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_move_mark(self: ptr TTextBuffer, mark: ptr TTextMark, where: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_move_mark".}
proc move_mark*(self: TextBuffer, mark: TextMark, where: ptr TTextIter) {.inline.} =
  gtk_text_buffer_move_mark(self, mark.getPointer, where)
# proc move_mark*(self: TextBuffer, mark: TextMark, where: ptr TTextIter) {.inline.} =

# gtk_text_buffer_move_mark_by_name
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg where: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_move_mark_by_name(self: ptr TTextBuffer, name: ucstring, where: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_move_mark_by_name".}
proc move_mark_by_name*(self: TextBuffer, name: ustring, where: ptr TTextIter) {.inline.} =
  gtk_text_buffer_move_mark_by_name(self, ucstring(name), where)
# proc move_mark_by_name*(self: TextBuffer, name: ustring, where: ptr TTextIter) {.inline.} =

# gtk_text_buffer_paste_clipboard
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg clipboard: INTERFACE (OBJECT) 'Clipboard' 'ptr TClipboard' IN (diff., need sugar)
# arg override_location: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg default_editable: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_paste_clipboard(self: ptr TTextBuffer, clipboard: ptr TClipboard, override_location: ptr TTextIter, default_editable: bool) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_paste_clipboard".}
proc paste_clipboard*(self: TextBuffer, clipboard: Clipboard, override_location: ptr TTextIter, default_editable: bool) {.inline.} =
  gtk_text_buffer_paste_clipboard(self, clipboard.getPointer, override_location, default_editable)
# proc paste_clipboard*(self: TextBuffer, clipboard: Clipboard, override_location: ptr TTextIter, default_editable: bool) {.inline.} =

# gtk_text_buffer_place_cursor
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg where: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_place_cursor(self: ptr TTextBuffer, where: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_place_cursor".}
proc place_cursor*(self: TextBuffer, where: ptr TTextIter) {.inline.} =
  gtk_text_buffer_place_cursor(self, where)
# proc place_cursor*(self: TextBuffer, where: ptr TTextIter) {.inline.} =

# gtk_text_buffer_register_deserialize_format
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg mime_type: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg function: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg user_data: VOID 'pointer' 'pointer' IN
# arg user_data_destroy: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: INTERFACE 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom'
proc gtk_text_buffer_register_deserialize_format(self: ptr TTextBuffer, mime_type: ucstring, function: pointer, user_data: pointer, user_data_destroy: pointer): ptr Gdk3.TAtom {.cdecl, dynlib: lib, importc: "gtk_text_buffer_register_deserialize_format".}
proc register_deserialize_format*(self: TextBuffer, mime_type: ustring, function: pointer, user_data: pointer, user_data_destroy: pointer): ptr Gdk3.TAtom {.inline.} =
  gtk_text_buffer_register_deserialize_format(self, ucstring(mime_type), function, user_data, user_data_destroy)
# proc register_deserialize_format*(self: TextBuffer, mime_type: ustring, function: pointer, user_data: pointer, user_data_destroy: pointer): ptr Gdk3.TAtom {.inline.} =

# gtk_text_buffer_register_deserialize_tagset
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg tagset_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom'
proc gtk_text_buffer_register_deserialize_tagset(self: ptr TTextBuffer, tagset_name: ucstring): ptr Gdk3.TAtom {.cdecl, dynlib: lib, importc: "gtk_text_buffer_register_deserialize_tagset".}
proc register_deserialize_tagset*(self: TextBuffer, tagset_name: ustring): ptr Gdk3.TAtom {.inline.} =
  gtk_text_buffer_register_deserialize_tagset(self, ucstring(tagset_name))
# proc register_deserialize_tagset*(self: TextBuffer, tagset_name: ustring): ptr Gdk3.TAtom {.inline.} =

# gtk_text_buffer_register_serialize_format
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg mime_type: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg function: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg user_data: VOID 'pointer' 'pointer' IN
# arg user_data_destroy: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: INTERFACE 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom'
proc gtk_text_buffer_register_serialize_format(self: ptr TTextBuffer, mime_type: ucstring, function: pointer, user_data: pointer, user_data_destroy: pointer): ptr Gdk3.TAtom {.cdecl, dynlib: lib, importc: "gtk_text_buffer_register_serialize_format".}
proc register_serialize_format*(self: TextBuffer, mime_type: ustring, function: pointer, user_data: pointer, user_data_destroy: pointer): ptr Gdk3.TAtom {.inline.} =
  gtk_text_buffer_register_serialize_format(self, ucstring(mime_type), function, user_data, user_data_destroy)
# proc register_serialize_format*(self: TextBuffer, mime_type: ustring, function: pointer, user_data: pointer, user_data_destroy: pointer): ptr Gdk3.TAtom {.inline.} =

# gtk_text_buffer_register_serialize_tagset
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg tagset_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom'
proc gtk_text_buffer_register_serialize_tagset(self: ptr TTextBuffer, tagset_name: ucstring): ptr Gdk3.TAtom {.cdecl, dynlib: lib, importc: "gtk_text_buffer_register_serialize_tagset".}
proc register_serialize_tagset*(self: TextBuffer, tagset_name: ustring): ptr Gdk3.TAtom {.inline.} =
  gtk_text_buffer_register_serialize_tagset(self, ucstring(tagset_name))
# proc register_serialize_tagset*(self: TextBuffer, tagset_name: ustring): ptr Gdk3.TAtom {.inline.} =

# gtk_text_buffer_remove_all_tags
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg start: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg end: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_remove_all_tags(self: ptr TTextBuffer, start: ptr TTextIter, end_x: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_remove_all_tags".}
proc remove_all_tags*(self: TextBuffer, start: ptr TTextIter, end_x: ptr TTextIter) {.inline.} =
  gtk_text_buffer_remove_all_tags(self, start, end_x)
# proc remove_all_tags*(self: TextBuffer, start: ptr TTextIter, end_x: ptr TTextIter) {.inline.} =

# gtk_text_buffer_remove_selection_clipboard
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg clipboard: INTERFACE (OBJECT) 'Clipboard' 'ptr TClipboard' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_remove_selection_clipboard(self: ptr TTextBuffer, clipboard: ptr TClipboard) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_remove_selection_clipboard".}
proc remove_selection_clipboard*(self: TextBuffer, clipboard: Clipboard) {.inline.} =
  gtk_text_buffer_remove_selection_clipboard(self, clipboard.getPointer)
# proc remove_selection_clipboard*(self: TextBuffer, clipboard: Clipboard) {.inline.} =

# gtk_text_buffer_remove_tag
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg tag: INTERFACE (OBJECT) 'TextTag' 'ptr TTextTag' IN (diff., need sugar)
# arg start: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg end: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_remove_tag(self: ptr TTextBuffer, tag: ptr TTextTag, start: ptr TTextIter, end_x: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_remove_tag".}
proc remove_tag*(self: TextBuffer, tag: TextTag, start: ptr TTextIter, end_x: ptr TTextIter) {.inline.} =
  gtk_text_buffer_remove_tag(self, tag.getPointer, start, end_x)
# proc remove_tag*(self: TextBuffer, tag: TextTag, start: ptr TTextIter, end_x: ptr TTextIter) {.inline.} =

# gtk_text_buffer_remove_tag_by_name
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg start: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg end: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_remove_tag_by_name(self: ptr TTextBuffer, name: ucstring, start: ptr TTextIter, end_x: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_remove_tag_by_name".}
proc remove_tag_by_name*(self: TextBuffer, name: ustring, start: ptr TTextIter, end_x: ptr TTextIter) {.inline.} =
  gtk_text_buffer_remove_tag_by_name(self, ucstring(name), start, end_x)
# proc remove_tag_by_name*(self: TextBuffer, name: ustring, start: ptr TTextIter, end_x: ptr TTextIter) {.inline.} =

# gtk_text_buffer_select_range
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg ins: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg bound: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_select_range(self: ptr TTextBuffer, ins: ptr TTextIter, bound: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_select_range".}
proc select_range*(self: TextBuffer, ins: ptr TTextIter, bound: ptr TTextIter) {.inline.} =
  gtk_text_buffer_select_range(self, ins, bound)
# proc select_range*(self: TextBuffer, ins: ptr TTextIter, bound: ptr TTextIter) {.inline.} =

# gtk_text_buffer_serialize
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg content_buffer: INTERFACE (OBJECT) 'TextBuffer' 'ptr TTextBuffer' IN (diff., need sugar)
# arg format: INTERFACE (STRUCT) 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom' IN
# arg start: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg end: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg length: UINT32 'var uint32' 'ptr uint32' OUT (diff., need sugar)
# return: ARRAY 'string' 'cstring' (diff., need sugar)
proc gtk_text_buffer_serialize(self: ptr TTextBuffer, content_buffer: ptr TTextBuffer, format: ptr Gdk3.TAtom, start: ptr TTextIter, end_x: ptr TTextIter, length: ptr uint32): cstring {.cdecl, dynlib: lib, importc: "gtk_text_buffer_serialize".}
proc serialize*(self: TextBuffer, content_buffer: TextBuffer, format: ptr Gdk3.TAtom, start: ptr TTextIter, end_x: ptr TTextIter, length: var uint32): string {.inline.} =
  $(gtk_text_buffer_serialize(self, content_buffer.getPointer, format, start, end_x, addr(length)))
# tuple-return
# length: var uint32
# proc serialize*(self: TextBuffer, content_buffer: TextBuffer, format: ptr Gdk3.TAtom, start: ptr TTextIter, end_x: ptr TTextIter): string {.inline.} =

# gtk_text_buffer_set_modified
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_set_modified(self: ptr TTextBuffer, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_set_modified".}
proc set_modified*(self: TextBuffer, setting: bool) {.inline.} =
  gtk_text_buffer_set_modified(self, setting)
# proc set_modified*(self: TextBuffer, setting: bool) {.inline.} =

# gtk_text_buffer_set_text
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg len: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_set_text(self: ptr TTextBuffer, text: ucstring, len: int32) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_set_text".}
proc set_text*(self: TextBuffer, text: ustring, len: int32) {.inline.} =
  gtk_text_buffer_set_text(self, ucstring(text), len)
# proc set_text*(self: TextBuffer, text: ustring, len: int32) {.inline.} =

# gtk_text_buffer_unregister_deserialize_format
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg format: INTERFACE (STRUCT) 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_unregister_deserialize_format(self: ptr TTextBuffer, format: ptr Gdk3.TAtom) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_unregister_deserialize_format".}
proc unregister_deserialize_format*(self: TextBuffer, format: ptr Gdk3.TAtom) {.inline.} =
  gtk_text_buffer_unregister_deserialize_format(self, format)
# proc unregister_deserialize_format*(self: TextBuffer, format: ptr Gdk3.TAtom) {.inline.} =

# gtk_text_buffer_unregister_serialize_format
# flags: {isMethod} container: TextBuffer
# need sugar: is method
# arg format: INTERFACE (STRUCT) 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_buffer_unregister_serialize_format(self: ptr TTextBuffer, format: ptr Gdk3.TAtom) {.cdecl, dynlib: lib, importc: "gtk_text_buffer_unregister_serialize_format".}
proc unregister_serialize_format*(self: TextBuffer, format: ptr Gdk3.TAtom) {.inline.} =
  gtk_text_buffer_unregister_serialize_format(self, format)
# proc unregister_serialize_format*(self: TextBuffer, format: ptr Gdk3.TAtom) {.inline.} =

# initializer for TextCellAccessible: gtk_text_cell_accessible_get_type
proc gtk_text_cell_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_text_cell_accessible_get_type".}
template gtype*(klass_parameter: typedesc[TextCellAccessible]): GType = gtk_text_cell_accessible_get_type()
# initializer for TextChildAnchor: gtk_text_child_anchor_get_type
proc gtk_text_child_anchor_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_text_child_anchor_get_type".}
template gtype*(klass_parameter: typedesc[TextChildAnchor]): GType = gtk_text_child_anchor_get_type()
# gtk_text_child_anchor_new
# flags: {isConstructor} container: TextChildAnchor
# need sugar: is static method
# return: INTERFACE 'TextChildAnchor' 'TransferFull[TTextChildAnchor]' (diff., need sugar)
proc gtk_text_child_anchor_new(): TransferFull[TTextChildAnchor] {.cdecl, dynlib: lib, importc: "gtk_text_child_anchor_new".}
proc new_textchildanchor*(): TextChildAnchor {.inline.} =
  wrap(gtk_text_child_anchor_new())
# proc new_textchildanchor*(): TextChildAnchor {.inline.} =

# gtk_text_child_anchor_get_deleted
# flags: {isMethod} container: TextChildAnchor
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_child_anchor_get_deleted(self: ptr TTextChildAnchor): bool {.cdecl, dynlib: lib, importc: "gtk_text_child_anchor_get_deleted".}
proc get_deleted*(self: TextChildAnchor): bool {.inline.} =
  gtk_text_child_anchor_get_deleted(self)
# proc get_deleted*(self: TextChildAnchor): bool {.inline.} =

# gtk_text_child_anchor_get_widgets
# flags: {isMethod} container: TextChildAnchor
# need sugar: is method
# return: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_text_child_anchor_get_widgets(self: ptr TTextChildAnchor): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_text_child_anchor_get_widgets".}
proc get_widgets*(self: TextChildAnchor): ptr GLIST_TODO {.inline.} =
  gtk_text_child_anchor_get_widgets(self)
# proc get_widgets*(self: TextChildAnchor): ptr GLIST_TODO {.inline.} =

# initializer for TextMark: gtk_text_mark_get_type
proc gtk_text_mark_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_text_mark_get_type".}
template gtype*(klass_parameter: typedesc[TextMark]): GType = gtk_text_mark_get_type()
# gtk_text_mark_new
# flags: {isConstructor} container: TextMark
# need sugar: is static method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg left_gravity: BOOLEAN 'bool' 'bool' IN
# return: INTERFACE 'TextMark' 'TransferFull[TTextMark]' (diff., need sugar)
proc gtk_text_mark_new(name: ucstring, left_gravity: bool): TransferFull[TTextMark] {.cdecl, dynlib: lib, importc: "gtk_text_mark_new".}
proc new_textmark*(name: ustring, left_gravity: bool): TextMark {.inline.} =
  wrap(gtk_text_mark_new(ucstring(name), left_gravity))
# proc new_textmark*(name: ustring, left_gravity: bool): TextMark {.inline.} =

# gtk_text_mark_get_buffer
# flags: {isMethod} container: TextMark
# need sugar: is method
# return: INTERFACE 'TextBuffer' 'TransferNone[TTextBuffer]' (diff., need sugar)
proc gtk_text_mark_get_buffer(self: ptr TTextMark): TransferNone[TTextBuffer] {.cdecl, dynlib: lib, importc: "gtk_text_mark_get_buffer".}
proc get_buffer*(self: TextMark): TextBuffer {.inline.} =
  wrap(gtk_text_mark_get_buffer(self))
# proc get_buffer*(self: TextMark): TextBuffer {.inline.} =

# gtk_text_mark_get_deleted
# flags: {isMethod} container: TextMark
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_mark_get_deleted(self: ptr TTextMark): bool {.cdecl, dynlib: lib, importc: "gtk_text_mark_get_deleted".}
proc get_deleted*(self: TextMark): bool {.inline.} =
  gtk_text_mark_get_deleted(self)
# proc get_deleted*(self: TextMark): bool {.inline.} =

# gtk_text_mark_get_left_gravity
# flags: {isMethod} container: TextMark
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_mark_get_left_gravity(self: ptr TTextMark): bool {.cdecl, dynlib: lib, importc: "gtk_text_mark_get_left_gravity".}
proc get_left_gravity*(self: TextMark): bool {.inline.} =
  gtk_text_mark_get_left_gravity(self)
# proc get_left_gravity*(self: TextMark): bool {.inline.} =

# gtk_text_mark_get_name
# flags: {isMethod} container: TextMark
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_text_mark_get_name(self: ptr TTextMark): ucstring {.cdecl, dynlib: lib, importc: "gtk_text_mark_get_name".}
proc get_name*(self: TextMark): ucstring {.inline.} =
  gtk_text_mark_get_name(self)
# proc get_name*(self: TextMark): ucstring {.inline.} =

# gtk_text_mark_get_visible
# flags: {isMethod} container: TextMark
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_mark_get_visible(self: ptr TTextMark): bool {.cdecl, dynlib: lib, importc: "gtk_text_mark_get_visible".}
proc get_visible*(self: TextMark): bool {.inline.} =
  gtk_text_mark_get_visible(self)
# proc get_visible*(self: TextMark): bool {.inline.} =

# gtk_text_mark_set_visible
# flags: {isMethod} container: TextMark
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_mark_set_visible(self: ptr TTextMark, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_text_mark_set_visible".}
proc set_visible*(self: TextMark, setting: bool) {.inline.} =
  gtk_text_mark_set_visible(self, setting)
# proc set_visible*(self: TextMark, setting: bool) {.inline.} =

# initializer for TextTag: gtk_text_tag_get_type
proc gtk_text_tag_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_text_tag_get_type".}
template gtype*(klass_parameter: typedesc[TextTag]): GType = gtk_text_tag_get_type()
# gtk_text_tag_new
# flags: {isConstructor} container: TextTag
# need sugar: is static method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'TextTag' 'TransferFull[TTextTag]' (diff., need sugar)
proc gtk_text_tag_new(name: ucstring): TransferFull[TTextTag] {.cdecl, dynlib: lib, importc: "gtk_text_tag_new".}
proc new_texttag*(name: ustring): TextTag {.inline.} =
  wrap(gtk_text_tag_new(ucstring(name)))
# proc new_texttag*(name: ustring): TextTag {.inline.} =

# gtk_text_tag_event
# flags: {isMethod} container: TextTag
# need sugar: is method
# arg event_object: INTERFACE (OBJECT) 'GObject2.Object' 'ptr GObject2.TObject' IN (diff., need sugar)
# arg event: INTERFACE (UNION) 'ptr Gdk3.TEvent' 'ptr Gdk3.TEvent' IN
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_tag_event(self: ptr TTextTag, event_object: ptr GObject2.TObject, event: ptr Gdk3.TEvent, iter: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_tag_event".}
proc event*(self: TextTag, event_object: GObject2.Object, event: ptr Gdk3.TEvent, iter: ptr TTextIter): bool {.inline.} =
  gtk_text_tag_event(self, event_object.getPointer, event, iter)
# proc event*(self: TextTag, event_object: GObject2.Object, event: ptr Gdk3.TEvent, iter: ptr TTextIter): bool {.inline.} =

# gtk_text_tag_get_priority
# flags: {isMethod} container: TextTag
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_text_tag_get_priority(self: ptr TTextTag): int32 {.cdecl, dynlib: lib, importc: "gtk_text_tag_get_priority".}
proc get_priority*(self: TextTag): int32 {.inline.} =
  gtk_text_tag_get_priority(self)
# proc get_priority*(self: TextTag): int32 {.inline.} =

# gtk_text_tag_set_priority
# flags: {isMethod} container: TextTag
# need sugar: is method
# arg priority: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_tag_set_priority(self: ptr TTextTag, priority: int32) {.cdecl, dynlib: lib, importc: "gtk_text_tag_set_priority".}
proc set_priority*(self: TextTag, priority: int32) {.inline.} =
  gtk_text_tag_set_priority(self, priority)
# proc set_priority*(self: TextTag, priority: int32) {.inline.} =

# initializer for TextTagTable: gtk_text_tag_table_get_type
proc gtk_text_tag_table_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_text_tag_table_get_type".}
template gtype*(klass_parameter: typedesc[TextTagTable]): GType = gtk_text_tag_table_get_type()
# gtk_text_tag_table_new
# flags: {isConstructor} container: TextTagTable
# need sugar: is static method
# return: INTERFACE 'TextTagTable' 'TransferFull[TTextTagTable]' (diff., need sugar)
proc gtk_text_tag_table_new(): TransferFull[TTextTagTable] {.cdecl, dynlib: lib, importc: "gtk_text_tag_table_new".}
proc new_texttagtable*(): TextTagTable {.inline.} =
  wrap(gtk_text_tag_table_new())
# proc new_texttagtable*(): TextTagTable {.inline.} =

# gtk_text_tag_table_add
# flags: {isMethod} container: TextTagTable
# need sugar: is method
# arg tag: INTERFACE (OBJECT) 'TextTag' 'ptr TTextTag' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_tag_table_add(self: ptr TTextTagTable, tag: ptr TTextTag): bool {.cdecl, dynlib: lib, importc: "gtk_text_tag_table_add".}
proc add*(self: TextTagTable, tag: TextTag): bool {.inline.} =
  gtk_text_tag_table_add(self, tag.getPointer)
# proc add*(self: TextTagTable, tag: TextTag): bool {.inline.} =

# gtk_text_tag_table_foreach
# flags: {isMethod} container: TextTagTable
# need sugar: is method
# arg func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg data: VOID 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_tag_table_foreach(self: ptr TTextTagTable, func_x: pointer, data: pointer) {.cdecl, dynlib: lib, importc: "gtk_text_tag_table_foreach".}
proc foreach*(self: TextTagTable, func_x: pointer, data: pointer) {.inline.} =
  gtk_text_tag_table_foreach(self, func_x, data)
# proc foreach*(self: TextTagTable, func_x: pointer, data: pointer) {.inline.} =

# gtk_text_tag_table_get_size
# flags: {isMethod} container: TextTagTable
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_text_tag_table_get_size(self: ptr TTextTagTable): int32 {.cdecl, dynlib: lib, importc: "gtk_text_tag_table_get_size".}
proc get_size*(self: TextTagTable): int32 {.inline.} =
  gtk_text_tag_table_get_size(self)
# proc get_size*(self: TextTagTable): int32 {.inline.} =

# gtk_text_tag_table_lookup
# flags: {isMethod} container: TextTagTable
# need sugar: is method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'TextTag' 'TransferNone[TTextTag]' (diff., need sugar)
proc gtk_text_tag_table_lookup(self: ptr TTextTagTable, name: ucstring): TransferNone[TTextTag] {.cdecl, dynlib: lib, importc: "gtk_text_tag_table_lookup".}
proc lookup*(self: TextTagTable, name: ustring): TextTag {.inline.} =
  wrap(gtk_text_tag_table_lookup(self, ucstring(name)))
# proc lookup*(self: TextTagTable, name: ustring): TextTag {.inline.} =

# gtk_text_tag_table_remove
# flags: {isMethod} container: TextTagTable
# need sugar: is method
# arg tag: INTERFACE (OBJECT) 'TextTag' 'ptr TTextTag' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_tag_table_remove(self: ptr TTextTagTable, tag: ptr TTextTag) {.cdecl, dynlib: lib, importc: "gtk_text_tag_table_remove".}
proc remove*(self: TextTagTable, tag: TextTag) {.inline.} =
  gtk_text_tag_table_remove(self, tag.getPointer)
# proc remove*(self: TextTagTable, tag: TextTag) {.inline.} =

# initializer for TextView: gtk_text_view_get_type
proc gtk_text_view_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_text_view_get_type".}
template gtype*(klass_parameter: typedesc[TextView]): GType = gtk_text_view_get_type()
# gtk_text_view_new
# flags: {isConstructor} container: TextView
# need sugar: is static method
# return: INTERFACE 'TextView' 'TransferNone[TTextView]' (diff., need sugar)
proc gtk_text_view_new(): TransferNone[TTextView] {.cdecl, dynlib: lib, importc: "gtk_text_view_new".}
proc new_textview*(): TextView {.inline.} =
  wrap(gtk_text_view_new())
# proc new_textview*(): TextView {.inline.} =

# gtk_text_view_new_with_buffer
# flags: {isConstructor} container: TextView
# need sugar: is static method
# arg buffer: INTERFACE (OBJECT) 'TextBuffer' 'ptr TTextBuffer' IN (diff., need sugar)
# return: INTERFACE 'TextView' 'TransferNone[TTextView]' (diff., need sugar)
proc gtk_text_view_new_with_buffer(buffer: ptr TTextBuffer): TransferNone[TTextView] {.cdecl, dynlib: lib, importc: "gtk_text_view_new_with_buffer".}
proc new_textview_with_buffer*(buffer: TextBuffer): TextView {.inline.} =
  wrap(gtk_text_view_new_with_buffer(buffer.getPointer))
# proc new_textview_with_buffer*(buffer: TextBuffer): TextView {.inline.} =

# gtk_text_view_add_child_at_anchor
# flags: {isMethod} container: TextView
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg anchor: INTERFACE (OBJECT) 'TextChildAnchor' 'ptr TTextChildAnchor' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_add_child_at_anchor(self: ptr TTextView, child: ptr TWidget, anchor: ptr TTextChildAnchor) {.cdecl, dynlib: lib, importc: "gtk_text_view_add_child_at_anchor".}
proc add_child_at_anchor*(self: TextView, child: Widget, anchor: TextChildAnchor) {.inline.} =
  gtk_text_view_add_child_at_anchor(self, child.getPointer, anchor.getPointer)
# proc add_child_at_anchor*(self: TextView, child: Widget, anchor: TextChildAnchor) {.inline.} =

# gtk_text_view_add_child_in_window
# flags: {isMethod} container: TextView
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg which_window: INTERFACE (ENUM) 'TextWindowType' 'TextWindowType' IN
# arg xpos: INT32 'int32' 'int32' IN
# arg ypos: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_add_child_in_window(self: ptr TTextView, child: ptr TWidget, which_window: TextWindowType, xpos: int32, ypos: int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_add_child_in_window".}
proc add_child_in_window*(self: TextView, child: Widget, which_window: TextWindowType, xpos: int32, ypos: int32) {.inline.} =
  gtk_text_view_add_child_in_window(self, child.getPointer, which_window, xpos, ypos)
# proc add_child_in_window*(self: TextView, child: Widget, which_window: TextWindowType, xpos: int32, ypos: int32) {.inline.} =

# gtk_text_view_backward_display_line
# flags: {isMethod} container: TextView
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_view_backward_display_line(self: ptr TTextView, iter: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_backward_display_line".}
proc backward_display_line*(self: TextView, iter: ptr TTextIter): bool {.inline.} =
  gtk_text_view_backward_display_line(self, iter)
# proc backward_display_line*(self: TextView, iter: ptr TTextIter): bool {.inline.} =

# gtk_text_view_backward_display_line_start
# flags: {isMethod} container: TextView
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_view_backward_display_line_start(self: ptr TTextView, iter: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_backward_display_line_start".}
proc backward_display_line_start*(self: TextView, iter: ptr TTextIter): bool {.inline.} =
  gtk_text_view_backward_display_line_start(self, iter)
# proc backward_display_line_start*(self: TextView, iter: ptr TTextIter): bool {.inline.} =

# gtk_text_view_buffer_to_window_coords
# flags: {isMethod} container: TextView
# need sugar: is method
# arg win: INTERFACE (ENUM) 'TextWindowType' 'TextWindowType' IN
# arg buffer_x: INT32 'int32' 'int32' IN
# arg buffer_y: INT32 'int32' 'int32' IN
# arg window_x: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg window_y: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_buffer_to_window_coords(self: ptr TTextView, win: TextWindowType, buffer_x: int32, buffer_y: int32, window_x: ptr int32, window_y: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_buffer_to_window_coords".}
proc buffer_to_window_coords*(self: TextView, win: TextWindowType, buffer_x: int32, buffer_y: int32, window_x: var int32, window_y: var int32) {.inline.} =
  gtk_text_view_buffer_to_window_coords(self, win, buffer_x, buffer_y, addr(window_x), addr(window_y))
# tuple-return
# window_x: var int32
# window_y: var int32
# proc buffer_to_window_coords*(self: TextView, win: TextWindowType, buffer_x: int32, buffer_y: int32) {.inline.} =

# gtk_text_view_forward_display_line
# flags: {isMethod} container: TextView
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_view_forward_display_line(self: ptr TTextView, iter: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_forward_display_line".}
proc forward_display_line*(self: TextView, iter: ptr TTextIter): bool {.inline.} =
  gtk_text_view_forward_display_line(self, iter)
# proc forward_display_line*(self: TextView, iter: ptr TTextIter): bool {.inline.} =

# gtk_text_view_forward_display_line_end
# flags: {isMethod} container: TextView
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_view_forward_display_line_end(self: ptr TTextView, iter: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_forward_display_line_end".}
proc forward_display_line_end*(self: TextView, iter: ptr TTextIter): bool {.inline.} =
  gtk_text_view_forward_display_line_end(self, iter)
# proc forward_display_line_end*(self: TextView, iter: ptr TTextIter): bool {.inline.} =

# gtk_text_view_get_accepts_tab
# flags: {isMethod} container: TextView
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_view_get_accepts_tab(self: ptr TTextView): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_get_accepts_tab".}
proc get_accepts_tab*(self: TextView): bool {.inline.} =
  gtk_text_view_get_accepts_tab(self)
# proc get_accepts_tab*(self: TextView): bool {.inline.} =

# gtk_text_view_get_border_window_size
# flags: {isMethod} container: TextView
# need sugar: is method
# arg type: INTERFACE (ENUM) 'TextWindowType' 'TextWindowType' IN
# return: INT32 'int32' 'int32'
proc gtk_text_view_get_border_window_size(self: ptr TTextView, type_x: TextWindowType): int32 {.cdecl, dynlib: lib, importc: "gtk_text_view_get_border_window_size".}
proc get_border_window_size*(self: TextView, type_x: TextWindowType): int32 {.inline.} =
  gtk_text_view_get_border_window_size(self, type_x)
# proc get_border_window_size*(self: TextView, type_x: TextWindowType): int32 {.inline.} =

# gtk_text_view_get_bottom_margin
# flags: {isMethod} container: TextView
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_text_view_get_bottom_margin(self: ptr TTextView): int32 {.cdecl, dynlib: lib, importc: "gtk_text_view_get_bottom_margin".}
proc get_bottom_margin*(self: TextView): int32 {.inline.} =
  gtk_text_view_get_bottom_margin(self)
# proc get_bottom_margin*(self: TextView): int32 {.inline.} =

# gtk_text_view_get_buffer
# flags: {isMethod} container: TextView
# need sugar: is method
# return: INTERFACE 'TextBuffer' 'TransferNone[TTextBuffer]' (diff., need sugar)
proc gtk_text_view_get_buffer(self: ptr TTextView): TransferNone[TTextBuffer] {.cdecl, dynlib: lib, importc: "gtk_text_view_get_buffer".}
proc get_buffer*(self: TextView): TextBuffer {.inline.} =
  wrap(gtk_text_view_get_buffer(self))
# proc get_buffer*(self: TextView): TextBuffer {.inline.} =

# gtk_text_view_get_cursor_locations
# flags: {isMethod} container: TextView
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg strong: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' OUT caller-allocates optional
# arg weak: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' OUT caller-allocates optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_get_cursor_locations(self: ptr TTextView, iter: ptr TTextIter, strong: ptr Gdk3.TRectangle, weak: ptr Gdk3.TRectangle) {.cdecl, dynlib: lib, importc: "gtk_text_view_get_cursor_locations".}
proc get_cursor_locations*(self: TextView, iter: ptr TTextIter, strong: ptr Gdk3.TRectangle, weak: ptr Gdk3.TRectangle) {.inline.} =
  gtk_text_view_get_cursor_locations(self, iter, strong, weak)
# tuple-return
# strong: ptr Gdk3.TRectangle
# weak: ptr Gdk3.TRectangle
# proc get_cursor_locations*(self: TextView, iter: ptr TTextIter) {.inline.} =

# gtk_text_view_get_cursor_visible
# flags: {isMethod} container: TextView
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_view_get_cursor_visible(self: ptr TTextView): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_get_cursor_visible".}
proc get_cursor_visible*(self: TextView): bool {.inline.} =
  gtk_text_view_get_cursor_visible(self)
# proc get_cursor_visible*(self: TextView): bool {.inline.} =

# gtk_text_view_get_default_attributes
# flags: {isMethod} container: TextView
# need sugar: is method
# return: INTERFACE 'ptr TTextAttributes' 'ptr TTextAttributes'
proc gtk_text_view_get_default_attributes(self: ptr TTextView): ptr TTextAttributes {.cdecl, dynlib: lib, importc: "gtk_text_view_get_default_attributes".}
proc get_default_attributes*(self: TextView): ptr TTextAttributes {.inline.} =
  gtk_text_view_get_default_attributes(self)
# proc get_default_attributes*(self: TextView): ptr TTextAttributes {.inline.} =

# gtk_text_view_get_editable
# flags: {isMethod} container: TextView
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_view_get_editable(self: ptr TTextView): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_get_editable".}
proc get_editable*(self: TextView): bool {.inline.} =
  gtk_text_view_get_editable(self)
# proc get_editable*(self: TextView): bool {.inline.} =

# gtk_text_view_get_hadjustment
# flags: {isMethod} container: TextView (deprecated)
# gtk_text_view_get_indent
# flags: {isMethod} container: TextView
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_text_view_get_indent(self: ptr TTextView): int32 {.cdecl, dynlib: lib, importc: "gtk_text_view_get_indent".}
proc get_indent*(self: TextView): int32 {.inline.} =
  gtk_text_view_get_indent(self)
# proc get_indent*(self: TextView): int32 {.inline.} =

# gtk_text_view_get_input_hints
# flags: {isMethod} container: TextView
# need sugar: is method
# return: INTERFACE 'SInputHints' 'SInputHints'
proc gtk_text_view_get_input_hints(self: ptr TTextView): SInputHints {.cdecl, dynlib: lib, importc: "gtk_text_view_get_input_hints".}
proc get_input_hints*(self: TextView): SInputHints {.inline.} =
  gtk_text_view_get_input_hints(self)
# proc get_input_hints*(self: TextView): SInputHints {.inline.} =

# gtk_text_view_get_input_purpose
# flags: {isMethod} container: TextView
# need sugar: is method
# return: INTERFACE 'InputPurpose' 'InputPurpose'
proc gtk_text_view_get_input_purpose(self: ptr TTextView): InputPurpose {.cdecl, dynlib: lib, importc: "gtk_text_view_get_input_purpose".}
proc get_input_purpose*(self: TextView): InputPurpose {.inline.} =
  gtk_text_view_get_input_purpose(self)
# proc get_input_purpose*(self: TextView): InputPurpose {.inline.} =

# gtk_text_view_get_iter_at_location
# flags: {isMethod} container: TextView
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' OUT caller-allocates
# arg x: INT32 'int32' 'int32' IN
# arg y: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_get_iter_at_location(self: ptr TTextView, iter: ptr TTextIter, x: int32, y: int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_get_iter_at_location".}
proc get_iter_at_location*(self: TextView, iter: ptr TTextIter, x: int32, y: int32) {.inline.} =
  gtk_text_view_get_iter_at_location(self, iter, x, y)
# tuple-return
# iter: ptr TTextIter
# proc get_iter_at_location*(self: TextView, x: int32, y: int32) {.inline.} =

# gtk_text_view_get_iter_at_position
# flags: {isMethod} container: TextView
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' OUT caller-allocates
# arg trailing: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg x: INT32 'int32' 'int32' IN
# arg y: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_get_iter_at_position(self: ptr TTextView, iter: ptr TTextIter, trailing: ptr int32, x: int32, y: int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_get_iter_at_position".}
proc get_iter_at_position*(self: TextView, iter: ptr TTextIter, trailing: var int32, x: int32, y: int32) {.inline.} =
  gtk_text_view_get_iter_at_position(self, iter, addr(trailing), x, y)
# tuple-return
# iter: ptr TTextIter
# trailing: var int32
# proc get_iter_at_position*(self: TextView, x: int32, y: int32) {.inline.} =

# gtk_text_view_get_iter_location
# flags: {isMethod} container: TextView
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg location: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' OUT caller-allocates
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_get_iter_location(self: ptr TTextView, iter: ptr TTextIter, location: ptr Gdk3.TRectangle) {.cdecl, dynlib: lib, importc: "gtk_text_view_get_iter_location".}
proc get_iter_location*(self: TextView, iter: ptr TTextIter, location: ptr Gdk3.TRectangle) {.inline.} =
  gtk_text_view_get_iter_location(self, iter, location)
# tuple-return
# location: ptr Gdk3.TRectangle
# proc get_iter_location*(self: TextView, iter: ptr TTextIter) {.inline.} =

# gtk_text_view_get_justification
# flags: {isMethod} container: TextView
# need sugar: is method
# return: INTERFACE 'Justification' 'Justification'
proc gtk_text_view_get_justification(self: ptr TTextView): Justification {.cdecl, dynlib: lib, importc: "gtk_text_view_get_justification".}
proc get_justification*(self: TextView): Justification {.inline.} =
  gtk_text_view_get_justification(self)
# proc get_justification*(self: TextView): Justification {.inline.} =

# gtk_text_view_get_left_margin
# flags: {isMethod} container: TextView
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_text_view_get_left_margin(self: ptr TTextView): int32 {.cdecl, dynlib: lib, importc: "gtk_text_view_get_left_margin".}
proc get_left_margin*(self: TextView): int32 {.inline.} =
  gtk_text_view_get_left_margin(self)
# proc get_left_margin*(self: TextView): int32 {.inline.} =

# gtk_text_view_get_line_at_y
# flags: {isMethod} container: TextView
# need sugar: is method
# arg target_iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' OUT caller-allocates
# arg y: INT32 'int32' 'int32' IN
# arg line_top: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_get_line_at_y(self: ptr TTextView, target_iter: ptr TTextIter, y: int32, line_top: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_get_line_at_y".}
proc get_line_at_y*(self: TextView, target_iter: ptr TTextIter, y: int32, line_top: var int32) {.inline.} =
  gtk_text_view_get_line_at_y(self, target_iter, y, addr(line_top))
# tuple-return
# target_iter: ptr TTextIter
# line_top: var int32
# proc get_line_at_y*(self: TextView, y: int32) {.inline.} =

# gtk_text_view_get_line_yrange
# flags: {isMethod} container: TextView
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg y: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# arg height: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_get_line_yrange(self: ptr TTextView, iter: ptr TTextIter, y: ptr int32, height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_get_line_yrange".}
proc get_line_yrange*(self: TextView, iter: ptr TTextIter, y: var int32, height: var int32) {.inline.} =
  gtk_text_view_get_line_yrange(self, iter, addr(y), addr(height))
# tuple-return
# y: var int32
# height: var int32
# proc get_line_yrange*(self: TextView, iter: ptr TTextIter) {.inline.} =

# gtk_text_view_get_monospace
# flags: {isMethod} container: TextView
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_view_get_monospace(self: ptr TTextView): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_get_monospace".}
proc get_monospace*(self: TextView): bool {.inline.} =
  gtk_text_view_get_monospace(self)
# proc get_monospace*(self: TextView): bool {.inline.} =

# gtk_text_view_get_overwrite
# flags: {isMethod} container: TextView
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_view_get_overwrite(self: ptr TTextView): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_get_overwrite".}
proc get_overwrite*(self: TextView): bool {.inline.} =
  gtk_text_view_get_overwrite(self)
# proc get_overwrite*(self: TextView): bool {.inline.} =

# gtk_text_view_get_pixels_above_lines
# flags: {isMethod} container: TextView
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_text_view_get_pixels_above_lines(self: ptr TTextView): int32 {.cdecl, dynlib: lib, importc: "gtk_text_view_get_pixels_above_lines".}
proc get_pixels_above_lines*(self: TextView): int32 {.inline.} =
  gtk_text_view_get_pixels_above_lines(self)
# proc get_pixels_above_lines*(self: TextView): int32 {.inline.} =

# gtk_text_view_get_pixels_below_lines
# flags: {isMethod} container: TextView
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_text_view_get_pixels_below_lines(self: ptr TTextView): int32 {.cdecl, dynlib: lib, importc: "gtk_text_view_get_pixels_below_lines".}
proc get_pixels_below_lines*(self: TextView): int32 {.inline.} =
  gtk_text_view_get_pixels_below_lines(self)
# proc get_pixels_below_lines*(self: TextView): int32 {.inline.} =

# gtk_text_view_get_pixels_inside_wrap
# flags: {isMethod} container: TextView
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_text_view_get_pixels_inside_wrap(self: ptr TTextView): int32 {.cdecl, dynlib: lib, importc: "gtk_text_view_get_pixels_inside_wrap".}
proc get_pixels_inside_wrap*(self: TextView): int32 {.inline.} =
  gtk_text_view_get_pixels_inside_wrap(self)
# proc get_pixels_inside_wrap*(self: TextView): int32 {.inline.} =

# gtk_text_view_get_right_margin
# flags: {isMethod} container: TextView
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_text_view_get_right_margin(self: ptr TTextView): int32 {.cdecl, dynlib: lib, importc: "gtk_text_view_get_right_margin".}
proc get_right_margin*(self: TextView): int32 {.inline.} =
  gtk_text_view_get_right_margin(self)
# proc get_right_margin*(self: TextView): int32 {.inline.} =

# gtk_text_view_get_tabs
# flags: {isMethod} container: TextView
# need sugar: is method
# return: INTERFACE 'ptr Pango1.TTabArray' 'ptr Pango1.TTabArray'
proc gtk_text_view_get_tabs(self: ptr TTextView): ptr Pango1.TTabArray {.cdecl, dynlib: lib, importc: "gtk_text_view_get_tabs".}
proc get_tabs*(self: TextView): ptr Pango1.TTabArray {.inline.} =
  gtk_text_view_get_tabs(self)
# proc get_tabs*(self: TextView): ptr Pango1.TTabArray {.inline.} =

# gtk_text_view_get_top_margin
# flags: {isMethod} container: TextView
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_text_view_get_top_margin(self: ptr TTextView): int32 {.cdecl, dynlib: lib, importc: "gtk_text_view_get_top_margin".}
proc get_top_margin*(self: TextView): int32 {.inline.} =
  gtk_text_view_get_top_margin(self)
# proc get_top_margin*(self: TextView): int32 {.inline.} =

# gtk_text_view_get_vadjustment
# flags: {isMethod} container: TextView (deprecated)
# gtk_text_view_get_visible_rect
# flags: {isMethod} container: TextView
# need sugar: is method
# arg visible_rect: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' OUT caller-allocates
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_get_visible_rect(self: ptr TTextView, visible_rect: ptr Gdk3.TRectangle) {.cdecl, dynlib: lib, importc: "gtk_text_view_get_visible_rect".}
proc get_visible_rect*(self: TextView, visible_rect: ptr Gdk3.TRectangle) {.inline.} =
  gtk_text_view_get_visible_rect(self, visible_rect)
# tuple-return
# visible_rect: ptr Gdk3.TRectangle
# proc get_visible_rect*(self: TextView) {.inline.} =

# gtk_text_view_get_window
# flags: {isMethod} container: TextView
# need sugar: is method
# arg win: INTERFACE (ENUM) 'TextWindowType' 'TextWindowType' IN
# return: INTERFACE 'Gdk3.Window' 'TransferNone[Gdk3.TWindow]' (diff., need sugar)
proc gtk_text_view_get_window(self: ptr TTextView, win: TextWindowType): TransferNone[Gdk3.TWindow] {.cdecl, dynlib: lib, importc: "gtk_text_view_get_window".}
proc get_window*(self: TextView, win: TextWindowType): Gdk3.Window {.inline.} =
  wrap(gtk_text_view_get_window(self, win))
# proc get_window*(self: TextView, win: TextWindowType): Gdk3.Window {.inline.} =

# gtk_text_view_get_window_type
# flags: {isMethod} container: TextView
# need sugar: is method
# arg window: INTERFACE (OBJECT) 'Gdk3.Window' 'ptr Gdk3.TWindow' IN (diff., need sugar)
# return: INTERFACE 'TextWindowType' 'TextWindowType'
proc gtk_text_view_get_window_type(self: ptr TTextView, window: ptr Gdk3.TWindow): TextWindowType {.cdecl, dynlib: lib, importc: "gtk_text_view_get_window_type".}
proc get_window_type*(self: TextView, window: Gdk3.Window): TextWindowType {.inline.} =
  gtk_text_view_get_window_type(self, window.getPointer)
# proc get_window_type*(self: TextView, window: Gdk3.Window): TextWindowType {.inline.} =

# gtk_text_view_get_wrap_mode
# flags: {isMethod} container: TextView
# need sugar: is method
# return: INTERFACE 'WrapMode' 'WrapMode'
proc gtk_text_view_get_wrap_mode(self: ptr TTextView): WrapMode {.cdecl, dynlib: lib, importc: "gtk_text_view_get_wrap_mode".}
proc get_wrap_mode*(self: TextView): WrapMode {.inline.} =
  gtk_text_view_get_wrap_mode(self)
# proc get_wrap_mode*(self: TextView): WrapMode {.inline.} =

# gtk_text_view_im_context_filter_keypress
# flags: {isMethod} container: TextView
# need sugar: is method
# arg event: INTERFACE (STRUCT) 'ptr Gdk3.TEventKey' 'ptr Gdk3.TEventKey' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_view_im_context_filter_keypress(self: ptr TTextView, event: ptr Gdk3.TEventKey): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_im_context_filter_keypress".}
proc im_context_filter_keypress*(self: TextView, event: ptr Gdk3.TEventKey): bool {.inline.} =
  gtk_text_view_im_context_filter_keypress(self, event)
# proc im_context_filter_keypress*(self: TextView, event: ptr Gdk3.TEventKey): bool {.inline.} =

# gtk_text_view_move_child
# flags: {isMethod} container: TextView
# need sugar: is method
# arg child: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg xpos: INT32 'int32' 'int32' IN
# arg ypos: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_move_child(self: ptr TTextView, child: ptr TWidget, xpos: int32, ypos: int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_move_child".}
proc move_child*(self: TextView, child: Widget, xpos: int32, ypos: int32) {.inline.} =
  gtk_text_view_move_child(self, child.getPointer, xpos, ypos)
# proc move_child*(self: TextView, child: Widget, xpos: int32, ypos: int32) {.inline.} =

# gtk_text_view_move_mark_onscreen
# flags: {isMethod} container: TextView
# need sugar: is method
# arg mark: INTERFACE (OBJECT) 'TextMark' 'ptr TTextMark' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_view_move_mark_onscreen(self: ptr TTextView, mark: ptr TTextMark): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_move_mark_onscreen".}
proc move_mark_onscreen*(self: TextView, mark: TextMark): bool {.inline.} =
  gtk_text_view_move_mark_onscreen(self, mark.getPointer)
# proc move_mark_onscreen*(self: TextView, mark: TextMark): bool {.inline.} =

# gtk_text_view_move_visually
# flags: {isMethod} container: TextView
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg count: INT32 'int32' 'int32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_view_move_visually(self: ptr TTextView, iter: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_move_visually".}
proc move_visually*(self: TextView, iter: ptr TTextIter, count: int32): bool {.inline.} =
  gtk_text_view_move_visually(self, iter, count)
# proc move_visually*(self: TextView, iter: ptr TTextIter, count: int32): bool {.inline.} =

# gtk_text_view_place_cursor_onscreen
# flags: {isMethod} container: TextView
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_view_place_cursor_onscreen(self: ptr TTextView): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_place_cursor_onscreen".}
proc place_cursor_onscreen*(self: TextView): bool {.inline.} =
  gtk_text_view_place_cursor_onscreen(self)
# proc place_cursor_onscreen*(self: TextView): bool {.inline.} =

# gtk_text_view_reset_im_context
# flags: {isMethod} container: TextView
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_reset_im_context(self: ptr TTextView) {.cdecl, dynlib: lib, importc: "gtk_text_view_reset_im_context".}
proc reset_im_context*(self: TextView) {.inline.} =
  gtk_text_view_reset_im_context(self)
# proc reset_im_context*(self: TextView) {.inline.} =

# gtk_text_view_scroll_mark_onscreen
# flags: {isMethod} container: TextView
# need sugar: is method
# arg mark: INTERFACE (OBJECT) 'TextMark' 'ptr TTextMark' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_scroll_mark_onscreen(self: ptr TTextView, mark: ptr TTextMark) {.cdecl, dynlib: lib, importc: "gtk_text_view_scroll_mark_onscreen".}
proc scroll_mark_onscreen*(self: TextView, mark: TextMark) {.inline.} =
  gtk_text_view_scroll_mark_onscreen(self, mark.getPointer)
# proc scroll_mark_onscreen*(self: TextView, mark: TextMark) {.inline.} =

# gtk_text_view_scroll_to_iter
# flags: {isMethod} container: TextView
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg within_margin: DOUBLE 'float64' 'float64' IN
# arg use_align: BOOLEAN 'bool' 'bool' IN
# arg xalign: DOUBLE 'float64' 'float64' IN
# arg yalign: DOUBLE 'float64' 'float64' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_view_scroll_to_iter(self: ptr TTextView, iter: ptr TTextIter, within_margin: float64, use_align: bool, xalign: float64, yalign: float64): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_scroll_to_iter".}
proc scroll_to_iter*(self: TextView, iter: ptr TTextIter, within_margin: float64, use_align: bool, xalign: float64, yalign: float64): bool {.inline.} =
  gtk_text_view_scroll_to_iter(self, iter, within_margin, use_align, xalign, yalign)
# proc scroll_to_iter*(self: TextView, iter: ptr TTextIter, within_margin: float64, use_align: bool, xalign: float64, yalign: float64): bool {.inline.} =

# gtk_text_view_scroll_to_mark
# flags: {isMethod} container: TextView
# need sugar: is method
# arg mark: INTERFACE (OBJECT) 'TextMark' 'ptr TTextMark' IN (diff., need sugar)
# arg within_margin: DOUBLE 'float64' 'float64' IN
# arg use_align: BOOLEAN 'bool' 'bool' IN
# arg xalign: DOUBLE 'float64' 'float64' IN
# arg yalign: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_scroll_to_mark(self: ptr TTextView, mark: ptr TTextMark, within_margin: float64, use_align: bool, xalign: float64, yalign: float64) {.cdecl, dynlib: lib, importc: "gtk_text_view_scroll_to_mark".}
proc scroll_to_mark*(self: TextView, mark: TextMark, within_margin: float64, use_align: bool, xalign: float64, yalign: float64) {.inline.} =
  gtk_text_view_scroll_to_mark(self, mark.getPointer, within_margin, use_align, xalign, yalign)
# proc scroll_to_mark*(self: TextView, mark: TextMark, within_margin: float64, use_align: bool, xalign: float64, yalign: float64) {.inline.} =

# gtk_text_view_set_accepts_tab
# flags: {isMethod} container: TextView
# need sugar: is method
# arg accepts_tab: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_accepts_tab(self: ptr TTextView, accepts_tab: bool) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_accepts_tab".}
proc set_accepts_tab*(self: TextView, accepts_tab: bool) {.inline.} =
  gtk_text_view_set_accepts_tab(self, accepts_tab)
# proc set_accepts_tab*(self: TextView, accepts_tab: bool) {.inline.} =

# gtk_text_view_set_border_window_size
# flags: {isMethod} container: TextView
# need sugar: is method
# arg type: INTERFACE (ENUM) 'TextWindowType' 'TextWindowType' IN
# arg size: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_border_window_size(self: ptr TTextView, type_x: TextWindowType, size: int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_border_window_size".}
proc set_border_window_size*(self: TextView, type_x: TextWindowType, size: int32) {.inline.} =
  gtk_text_view_set_border_window_size(self, type_x, size)
# proc set_border_window_size*(self: TextView, type_x: TextWindowType, size: int32) {.inline.} =

# gtk_text_view_set_bottom_margin
# flags: {isMethod} container: TextView
# need sugar: is method
# arg bottom_margin: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_bottom_margin(self: ptr TTextView, bottom_margin: int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_bottom_margin".}
proc set_bottom_margin*(self: TextView, bottom_margin: int32) {.inline.} =
  gtk_text_view_set_bottom_margin(self, bottom_margin)
# proc set_bottom_margin*(self: TextView, bottom_margin: int32) {.inline.} =

# gtk_text_view_set_buffer
# flags: {isMethod} container: TextView
# need sugar: is method
# arg buffer: INTERFACE (OBJECT) 'TextBuffer' 'ptr TTextBuffer' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_buffer(self: ptr TTextView, buffer: ptr TTextBuffer) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_buffer".}
proc set_buffer*(self: TextView, buffer: TextBuffer) {.inline.} =
  gtk_text_view_set_buffer(self, buffer.getPointer)
# proc set_buffer*(self: TextView, buffer: TextBuffer) {.inline.} =

# gtk_text_view_set_cursor_visible
# flags: {isMethod} container: TextView
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_cursor_visible(self: ptr TTextView, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_cursor_visible".}
proc set_cursor_visible*(self: TextView, setting: bool) {.inline.} =
  gtk_text_view_set_cursor_visible(self, setting)
# proc set_cursor_visible*(self: TextView, setting: bool) {.inline.} =

# gtk_text_view_set_editable
# flags: {isMethod} container: TextView
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_editable(self: ptr TTextView, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_editable".}
proc set_editable*(self: TextView, setting: bool) {.inline.} =
  gtk_text_view_set_editable(self, setting)
# proc set_editable*(self: TextView, setting: bool) {.inline.} =

# gtk_text_view_set_indent
# flags: {isMethod} container: TextView
# need sugar: is method
# arg indent: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_indent(self: ptr TTextView, indent: int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_indent".}
proc set_indent*(self: TextView, indent: int32) {.inline.} =
  gtk_text_view_set_indent(self, indent)
# proc set_indent*(self: TextView, indent: int32) {.inline.} =

# gtk_text_view_set_input_hints
# flags: {isMethod} container: TextView
# need sugar: is method
# arg hints: INTERFACE (FLAGS) 'SInputHints' 'SInputHints' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_input_hints(self: ptr TTextView, hints: SInputHints) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_input_hints".}
proc set_input_hints*(self: TextView, hints: SInputHints) {.inline.} =
  gtk_text_view_set_input_hints(self, hints)
# proc set_input_hints*(self: TextView, hints: SInputHints) {.inline.} =

# gtk_text_view_set_input_purpose
# flags: {isMethod} container: TextView
# need sugar: is method
# arg purpose: INTERFACE (ENUM) 'InputPurpose' 'InputPurpose' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_input_purpose(self: ptr TTextView, purpose: InputPurpose) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_input_purpose".}
proc set_input_purpose*(self: TextView, purpose: InputPurpose) {.inline.} =
  gtk_text_view_set_input_purpose(self, purpose)
# proc set_input_purpose*(self: TextView, purpose: InputPurpose) {.inline.} =

# gtk_text_view_set_justification
# flags: {isMethod} container: TextView
# need sugar: is method
# arg justification: INTERFACE (ENUM) 'Justification' 'Justification' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_justification(self: ptr TTextView, justification: Justification) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_justification".}
proc set_justification*(self: TextView, justification: Justification) {.inline.} =
  gtk_text_view_set_justification(self, justification)
# proc set_justification*(self: TextView, justification: Justification) {.inline.} =

# gtk_text_view_set_left_margin
# flags: {isMethod} container: TextView
# need sugar: is method
# arg left_margin: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_left_margin(self: ptr TTextView, left_margin: int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_left_margin".}
proc set_left_margin*(self: TextView, left_margin: int32) {.inline.} =
  gtk_text_view_set_left_margin(self, left_margin)
# proc set_left_margin*(self: TextView, left_margin: int32) {.inline.} =

# gtk_text_view_set_monospace
# flags: {isMethod} container: TextView
# need sugar: is method
# arg monospace: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_monospace(self: ptr TTextView, monospace: bool) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_monospace".}
proc set_monospace*(self: TextView, monospace: bool) {.inline.} =
  gtk_text_view_set_monospace(self, monospace)
# proc set_monospace*(self: TextView, monospace: bool) {.inline.} =

# gtk_text_view_set_overwrite
# flags: {isMethod} container: TextView
# need sugar: is method
# arg overwrite: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_overwrite(self: ptr TTextView, overwrite: bool) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_overwrite".}
proc set_overwrite*(self: TextView, overwrite: bool) {.inline.} =
  gtk_text_view_set_overwrite(self, overwrite)
# proc set_overwrite*(self: TextView, overwrite: bool) {.inline.} =

# gtk_text_view_set_pixels_above_lines
# flags: {isMethod} container: TextView
# need sugar: is method
# arg pixels_above_lines: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_pixels_above_lines(self: ptr TTextView, pixels_above_lines: int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_pixels_above_lines".}
proc set_pixels_above_lines*(self: TextView, pixels_above_lines: int32) {.inline.} =
  gtk_text_view_set_pixels_above_lines(self, pixels_above_lines)
# proc set_pixels_above_lines*(self: TextView, pixels_above_lines: int32) {.inline.} =

# gtk_text_view_set_pixels_below_lines
# flags: {isMethod} container: TextView
# need sugar: is method
# arg pixels_below_lines: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_pixels_below_lines(self: ptr TTextView, pixels_below_lines: int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_pixels_below_lines".}
proc set_pixels_below_lines*(self: TextView, pixels_below_lines: int32) {.inline.} =
  gtk_text_view_set_pixels_below_lines(self, pixels_below_lines)
# proc set_pixels_below_lines*(self: TextView, pixels_below_lines: int32) {.inline.} =

# gtk_text_view_set_pixels_inside_wrap
# flags: {isMethod} container: TextView
# need sugar: is method
# arg pixels_inside_wrap: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_pixels_inside_wrap(self: ptr TTextView, pixels_inside_wrap: int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_pixels_inside_wrap".}
proc set_pixels_inside_wrap*(self: TextView, pixels_inside_wrap: int32) {.inline.} =
  gtk_text_view_set_pixels_inside_wrap(self, pixels_inside_wrap)
# proc set_pixels_inside_wrap*(self: TextView, pixels_inside_wrap: int32) {.inline.} =

# gtk_text_view_set_right_margin
# flags: {isMethod} container: TextView
# need sugar: is method
# arg right_margin: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_right_margin(self: ptr TTextView, right_margin: int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_right_margin".}
proc set_right_margin*(self: TextView, right_margin: int32) {.inline.} =
  gtk_text_view_set_right_margin(self, right_margin)
# proc set_right_margin*(self: TextView, right_margin: int32) {.inline.} =

# gtk_text_view_set_tabs
# flags: {isMethod} container: TextView
# need sugar: is method
# arg tabs: INTERFACE (STRUCT) 'ptr Pango1.TTabArray' 'ptr Pango1.TTabArray' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_tabs(self: ptr TTextView, tabs: ptr Pango1.TTabArray) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_tabs".}
proc set_tabs*(self: TextView, tabs: ptr Pango1.TTabArray) {.inline.} =
  gtk_text_view_set_tabs(self, tabs)
# proc set_tabs*(self: TextView, tabs: ptr Pango1.TTabArray) {.inline.} =

# gtk_text_view_set_top_margin
# flags: {isMethod} container: TextView
# need sugar: is method
# arg top_margin: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_top_margin(self: ptr TTextView, top_margin: int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_top_margin".}
proc set_top_margin*(self: TextView, top_margin: int32) {.inline.} =
  gtk_text_view_set_top_margin(self, top_margin)
# proc set_top_margin*(self: TextView, top_margin: int32) {.inline.} =

# gtk_text_view_set_wrap_mode
# flags: {isMethod} container: TextView
# need sugar: is method
# arg wrap_mode: INTERFACE (ENUM) 'WrapMode' 'WrapMode' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_set_wrap_mode(self: ptr TTextView, wrap_mode: WrapMode) {.cdecl, dynlib: lib, importc: "gtk_text_view_set_wrap_mode".}
proc set_wrap_mode*(self: TextView, wrap_mode: WrapMode) {.inline.} =
  gtk_text_view_set_wrap_mode(self, wrap_mode)
# proc set_wrap_mode*(self: TextView, wrap_mode: WrapMode) {.inline.} =

# gtk_text_view_starts_display_line
# flags: {isMethod} container: TextView
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_view_starts_display_line(self: ptr TTextView, iter: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_view_starts_display_line".}
proc starts_display_line*(self: TextView, iter: ptr TTextIter): bool {.inline.} =
  gtk_text_view_starts_display_line(self, iter)
# proc starts_display_line*(self: TextView, iter: ptr TTextIter): bool {.inline.} =

# gtk_text_view_window_to_buffer_coords
# flags: {isMethod} container: TextView
# need sugar: is method
# arg win: INTERFACE (ENUM) 'TextWindowType' 'TextWindowType' IN
# arg window_x: INT32 'int32' 'int32' IN
# arg window_y: INT32 'int32' 'int32' IN
# arg buffer_x: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg buffer_y: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_view_window_to_buffer_coords(self: ptr TTextView, win: TextWindowType, window_x: int32, window_y: int32, buffer_x: ptr int32, buffer_y: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_text_view_window_to_buffer_coords".}
proc window_to_buffer_coords*(self: TextView, win: TextWindowType, window_x: int32, window_y: int32, buffer_x: var int32, buffer_y: var int32) {.inline.} =
  gtk_text_view_window_to_buffer_coords(self, win, window_x, window_y, addr(buffer_x), addr(buffer_y))
# tuple-return
# buffer_x: var int32
# buffer_y: var int32
# proc window_to_buffer_coords*(self: TextView, win: TextWindowType, window_x: int32, window_y: int32) {.inline.} =

# initializer for TextViewAccessible: gtk_text_view_accessible_get_type
proc gtk_text_view_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_text_view_accessible_get_type".}
template gtype*(klass_parameter: typedesc[TextViewAccessible]): GType = gtk_text_view_accessible_get_type()
# initializer for ThemingEngine: gtk_theming_engine_get_type
proc gtk_theming_engine_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_theming_engine_get_type".}
template gtype*(klass_parameter: typedesc[ThemingEngine]): GType = gtk_theming_engine_get_type()
# gtk_theming_engine_load
# flags: {} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_background_color
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_border
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_border_color
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_color
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_direction
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_font
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_junction_sides
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_margin
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_padding
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_path
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_property
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_screen
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_state
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_get_style_property
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_has_class
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_has_region
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_lookup_color
# flags: {isMethod} container: ThemingEngine (deprecated)
# gtk_theming_engine_state_is_running
# flags: {isMethod} container: ThemingEngine (deprecated)
# initializer for ToggleAction: gtk_toggle_action_get_type
proc gtk_toggle_action_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_toggle_action_get_type".}
template gtype*(klass_parameter: typedesc[ToggleAction]): GType = gtk_toggle_action_get_type()
# gtk_toggle_action_new
# flags: {isConstructor} container: ToggleAction (deprecated)
# gtk_toggle_action_get_active
# flags: {isMethod} container: ToggleAction (deprecated)
# gtk_toggle_action_get_draw_as_radio
# flags: {isMethod} container: ToggleAction (deprecated)
# gtk_toggle_action_set_active
# flags: {isMethod} container: ToggleAction (deprecated)
# gtk_toggle_action_set_draw_as_radio
# flags: {isMethod} container: ToggleAction (deprecated)
# gtk_toggle_action_toggled
# flags: {isMethod} container: ToggleAction (deprecated)
# initializer for ToggleButton: gtk_toggle_button_get_type
proc gtk_toggle_button_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_toggle_button_get_type".}
template gtype*(klass_parameter: typedesc[ToggleButton]): GType = gtk_toggle_button_get_type()
# gtk_toggle_button_new
# flags: {isConstructor} container: ToggleButton
# need sugar: is static method
# return: INTERFACE 'ToggleButton' 'TransferNone[TToggleButton]' (diff., need sugar)
proc gtk_toggle_button_new(): TransferNone[TToggleButton] {.cdecl, dynlib: lib, importc: "gtk_toggle_button_new".}
proc new_togglebutton*(): ToggleButton {.inline.} =
  wrap(gtk_toggle_button_new())
# proc new_togglebutton*(): ToggleButton {.inline.} =

# gtk_toggle_button_new_with_label
# flags: {isConstructor} container: ToggleButton
# need sugar: is static method
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'ToggleButton' 'TransferNone[TToggleButton]' (diff., need sugar)
proc gtk_toggle_button_new_with_label(label: ucstring): TransferNone[TToggleButton] {.cdecl, dynlib: lib, importc: "gtk_toggle_button_new_with_label".}
proc new_togglebutton_with_label*(label: ustring): ToggleButton {.inline.} =
  wrap(gtk_toggle_button_new_with_label(ucstring(label)))
# proc new_togglebutton_with_label*(label: ustring): ToggleButton {.inline.} =

# gtk_toggle_button_new_with_mnemonic
# flags: {isConstructor} container: ToggleButton
# need sugar: is static method
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'ToggleButton' 'TransferNone[TToggleButton]' (diff., need sugar)
proc gtk_toggle_button_new_with_mnemonic(label: ucstring): TransferNone[TToggleButton] {.cdecl, dynlib: lib, importc: "gtk_toggle_button_new_with_mnemonic".}
proc new_togglebutton_with_mnemonic*(label: ustring): ToggleButton {.inline.} =
  wrap(gtk_toggle_button_new_with_mnemonic(ucstring(label)))
# proc new_togglebutton_with_mnemonic*(label: ustring): ToggleButton {.inline.} =

# gtk_toggle_button_get_active
# flags: {isMethod} container: ToggleButton
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_toggle_button_get_active(self: ptr TToggleButton): bool {.cdecl, dynlib: lib, importc: "gtk_toggle_button_get_active".}
proc get_active*(self: ToggleButton): bool {.inline.} =
  gtk_toggle_button_get_active(self)
# proc get_active*(self: ToggleButton): bool {.inline.} =

# gtk_toggle_button_get_inconsistent
# flags: {isMethod} container: ToggleButton
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_toggle_button_get_inconsistent(self: ptr TToggleButton): bool {.cdecl, dynlib: lib, importc: "gtk_toggle_button_get_inconsistent".}
proc get_inconsistent*(self: ToggleButton): bool {.inline.} =
  gtk_toggle_button_get_inconsistent(self)
# proc get_inconsistent*(self: ToggleButton): bool {.inline.} =

# gtk_toggle_button_get_mode
# flags: {isMethod} container: ToggleButton
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_toggle_button_get_mode(self: ptr TToggleButton): bool {.cdecl, dynlib: lib, importc: "gtk_toggle_button_get_mode".}
proc get_mode*(self: ToggleButton): bool {.inline.} =
  gtk_toggle_button_get_mode(self)
# proc get_mode*(self: ToggleButton): bool {.inline.} =

# gtk_toggle_button_set_active
# flags: {isMethod} container: ToggleButton
# need sugar: is method
# arg is_active: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_toggle_button_set_active(self: ptr TToggleButton, is_active: bool) {.cdecl, dynlib: lib, importc: "gtk_toggle_button_set_active".}
proc set_active*(self: ToggleButton, is_active: bool) {.inline.} =
  gtk_toggle_button_set_active(self, is_active)
# proc set_active*(self: ToggleButton, is_active: bool) {.inline.} =

# gtk_toggle_button_set_inconsistent
# flags: {isMethod} container: ToggleButton
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_toggle_button_set_inconsistent(self: ptr TToggleButton, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_toggle_button_set_inconsistent".}
proc set_inconsistent*(self: ToggleButton, setting: bool) {.inline.} =
  gtk_toggle_button_set_inconsistent(self, setting)
# proc set_inconsistent*(self: ToggleButton, setting: bool) {.inline.} =

# gtk_toggle_button_set_mode
# flags: {isMethod} container: ToggleButton
# need sugar: is method
# arg draw_indicator: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_toggle_button_set_mode(self: ptr TToggleButton, draw_indicator: bool) {.cdecl, dynlib: lib, importc: "gtk_toggle_button_set_mode".}
proc set_mode*(self: ToggleButton, draw_indicator: bool) {.inline.} =
  gtk_toggle_button_set_mode(self, draw_indicator)
# proc set_mode*(self: ToggleButton, draw_indicator: bool) {.inline.} =

# gtk_toggle_button_toggled
# flags: {isMethod} container: ToggleButton
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_toggle_button_toggled(self: ptr TToggleButton) {.cdecl, dynlib: lib, importc: "gtk_toggle_button_toggled".}
proc toggled*(self: ToggleButton) {.inline.} =
  gtk_toggle_button_toggled(self)
# proc toggled*(self: ToggleButton) {.inline.} =

# initializer for ToggleButtonAccessible: gtk_toggle_button_accessible_get_type
proc gtk_toggle_button_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_toggle_button_accessible_get_type".}
template gtype*(klass_parameter: typedesc[ToggleButtonAccessible]): GType = gtk_toggle_button_accessible_get_type()
# initializer for ToggleToolButton: gtk_toggle_tool_button_get_type
proc gtk_toggle_tool_button_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_toggle_tool_button_get_type".}
template gtype*(klass_parameter: typedesc[ToggleToolButton]): GType = gtk_toggle_tool_button_get_type()
# gtk_toggle_tool_button_new
# flags: {isConstructor} container: ToggleToolButton
# need sugar: is static method
# return: INTERFACE 'ToggleToolButton' 'TransferNone[TToggleToolButton]' (diff., need sugar)
proc gtk_toggle_tool_button_new(): TransferNone[TToggleToolButton] {.cdecl, dynlib: lib, importc: "gtk_toggle_tool_button_new".}
proc new_toggletoolbutton*(): ToggleToolButton {.inline.} =
  wrap(gtk_toggle_tool_button_new())
# proc new_toggletoolbutton*(): ToggleToolButton {.inline.} =

# gtk_toggle_tool_button_new_from_stock
# flags: {isConstructor} container: ToggleToolButton (deprecated)
# gtk_toggle_tool_button_get_active
# flags: {isMethod} container: ToggleToolButton
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_toggle_tool_button_get_active(self: ptr TToggleToolButton): bool {.cdecl, dynlib: lib, importc: "gtk_toggle_tool_button_get_active".}
proc get_active*(self: ToggleToolButton): bool {.inline.} =
  gtk_toggle_tool_button_get_active(self)
# proc get_active*(self: ToggleToolButton): bool {.inline.} =

# gtk_toggle_tool_button_set_active
# flags: {isMethod} container: ToggleToolButton
# need sugar: is method
# arg is_active: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_toggle_tool_button_set_active(self: ptr TToggleToolButton, is_active: bool) {.cdecl, dynlib: lib, importc: "gtk_toggle_tool_button_set_active".}
proc set_active*(self: ToggleToolButton, is_active: bool) {.inline.} =
  gtk_toggle_tool_button_set_active(self, is_active)
# proc set_active*(self: ToggleToolButton, is_active: bool) {.inline.} =

# initializer for ToolButton: gtk_tool_button_get_type
proc gtk_tool_button_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_tool_button_get_type".}
template gtype*(klass_parameter: typedesc[ToolButton]): GType = gtk_tool_button_get_type()
# gtk_tool_button_new
# flags: {isConstructor} container: ToolButton
# need sugar: is static method
# arg icon_widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'ToolButton' 'TransferNone[TToolButton]' (diff., need sugar)
proc gtk_tool_button_new(icon_widget: ptr TWidget, label: ucstring): TransferNone[TToolButton] {.cdecl, dynlib: lib, importc: "gtk_tool_button_new".}
proc new_toolbutton*(icon_widget: Widget, label: ustring): ToolButton {.inline.} =
  wrap(gtk_tool_button_new(icon_widget.getPointer, ucstring(label)))
# proc new_toolbutton*(icon_widget: Widget, label: ustring): ToolButton {.inline.} =

# gtk_tool_button_new_from_stock
# flags: {isConstructor} container: ToolButton (deprecated)
# gtk_tool_button_get_icon_name
# flags: {isMethod} container: ToolButton
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_tool_button_get_icon_name(self: ptr TToolButton): ucstring {.cdecl, dynlib: lib, importc: "gtk_tool_button_get_icon_name".}
proc get_icon_name*(self: ToolButton): ucstring {.inline.} =
  gtk_tool_button_get_icon_name(self)
# proc get_icon_name*(self: ToolButton): ucstring {.inline.} =

# gtk_tool_button_get_icon_widget
# flags: {isMethod} container: ToolButton
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_tool_button_get_icon_widget(self: ptr TToolButton): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_tool_button_get_icon_widget".}
proc get_icon_widget*(self: ToolButton): Widget {.inline.} =
  wrap(gtk_tool_button_get_icon_widget(self))
# proc get_icon_widget*(self: ToolButton): Widget {.inline.} =

# gtk_tool_button_get_label
# flags: {isMethod} container: ToolButton
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_tool_button_get_label(self: ptr TToolButton): ucstring {.cdecl, dynlib: lib, importc: "gtk_tool_button_get_label".}
proc get_label*(self: ToolButton): ucstring {.inline.} =
  gtk_tool_button_get_label(self)
# proc get_label*(self: ToolButton): ucstring {.inline.} =

# gtk_tool_button_get_label_widget
# flags: {isMethod} container: ToolButton
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_tool_button_get_label_widget(self: ptr TToolButton): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_tool_button_get_label_widget".}
proc get_label_widget*(self: ToolButton): Widget {.inline.} =
  wrap(gtk_tool_button_get_label_widget(self))
# proc get_label_widget*(self: ToolButton): Widget {.inline.} =

# gtk_tool_button_get_stock_id
# flags: {isMethod} container: ToolButton (deprecated)
# gtk_tool_button_get_use_underline
# flags: {isMethod} container: ToolButton
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tool_button_get_use_underline(self: ptr TToolButton): bool {.cdecl, dynlib: lib, importc: "gtk_tool_button_get_use_underline".}
proc get_use_underline*(self: ToolButton): bool {.inline.} =
  gtk_tool_button_get_use_underline(self)
# proc get_use_underline*(self: ToolButton): bool {.inline.} =

# gtk_tool_button_set_icon_name
# flags: {isMethod} container: ToolButton
# need sugar: is method
# arg icon_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_button_set_icon_name(self: ptr TToolButton, icon_name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_tool_button_set_icon_name".}
proc set_icon_name*(self: ToolButton, icon_name: ustring) {.inline.} =
  gtk_tool_button_set_icon_name(self, ucstring(icon_name))
# proc set_icon_name*(self: ToolButton, icon_name: ustring) {.inline.} =

# gtk_tool_button_set_icon_widget
# flags: {isMethod} container: ToolButton
# need sugar: is method
# arg icon_widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_button_set_icon_widget(self: ptr TToolButton, icon_widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_tool_button_set_icon_widget".}
proc set_icon_widget*(self: ToolButton, icon_widget: Widget) {.inline.} =
  gtk_tool_button_set_icon_widget(self, icon_widget.getPointer)
# proc set_icon_widget*(self: ToolButton, icon_widget: Widget) {.inline.} =

# gtk_tool_button_set_label
# flags: {isMethod} container: ToolButton
# need sugar: is method
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_button_set_label(self: ptr TToolButton, label: ucstring) {.cdecl, dynlib: lib, importc: "gtk_tool_button_set_label".}
proc set_label*(self: ToolButton, label: ustring) {.inline.} =
  gtk_tool_button_set_label(self, ucstring(label))
# proc set_label*(self: ToolButton, label: ustring) {.inline.} =

# gtk_tool_button_set_label_widget
# flags: {isMethod} container: ToolButton
# need sugar: is method
# arg label_widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_button_set_label_widget(self: ptr TToolButton, label_widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_tool_button_set_label_widget".}
proc set_label_widget*(self: ToolButton, label_widget: Widget) {.inline.} =
  gtk_tool_button_set_label_widget(self, label_widget.getPointer)
# proc set_label_widget*(self: ToolButton, label_widget: Widget) {.inline.} =

# gtk_tool_button_set_stock_id
# flags: {isMethod} container: ToolButton (deprecated)
# gtk_tool_button_set_use_underline
# flags: {isMethod} container: ToolButton
# need sugar: is method
# arg use_underline: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_button_set_use_underline(self: ptr TToolButton, use_underline: bool) {.cdecl, dynlib: lib, importc: "gtk_tool_button_set_use_underline".}
proc set_use_underline*(self: ToolButton, use_underline: bool) {.inline.} =
  gtk_tool_button_set_use_underline(self, use_underline)
# proc set_use_underline*(self: ToolButton, use_underline: bool) {.inline.} =

# initializer for ToolItem: gtk_tool_item_get_type
proc gtk_tool_item_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_type".}
template gtype*(klass_parameter: typedesc[ToolItem]): GType = gtk_tool_item_get_type()
# gtk_tool_item_new
# flags: {isConstructor} container: ToolItem
# need sugar: is static method
# return: INTERFACE 'ToolItem' 'TransferNone[TToolItem]' (diff., need sugar)
proc gtk_tool_item_new(): TransferNone[TToolItem] {.cdecl, dynlib: lib, importc: "gtk_tool_item_new".}
proc new_toolitem*(): ToolItem {.inline.} =
  wrap(gtk_tool_item_new())
# proc new_toolitem*(): ToolItem {.inline.} =

# gtk_tool_item_get_ellipsize_mode
# flags: {isMethod} container: ToolItem
# need sugar: is method
# return: INTERFACE 'Pango1.EllipsizeMode' 'Pango1.EllipsizeMode'
proc gtk_tool_item_get_ellipsize_mode(self: ptr TToolItem): Pango1.EllipsizeMode {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_ellipsize_mode".}
proc get_ellipsize_mode*(self: ToolItem): Pango1.EllipsizeMode {.inline.} =
  gtk_tool_item_get_ellipsize_mode(self)
# proc get_ellipsize_mode*(self: ToolItem): Pango1.EllipsizeMode {.inline.} =

# gtk_tool_item_get_expand
# flags: {isMethod} container: ToolItem
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tool_item_get_expand(self: ptr TToolItem): bool {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_expand".}
proc get_expand*(self: ToolItem): bool {.inline.} =
  gtk_tool_item_get_expand(self)
# proc get_expand*(self: ToolItem): bool {.inline.} =

# gtk_tool_item_get_homogeneous
# flags: {isMethod} container: ToolItem
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tool_item_get_homogeneous(self: ptr TToolItem): bool {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_homogeneous".}
proc get_homogeneous*(self: ToolItem): bool {.inline.} =
  gtk_tool_item_get_homogeneous(self)
# proc get_homogeneous*(self: ToolItem): bool {.inline.} =

# gtk_tool_item_get_icon_size
# flags: {isMethod} container: ToolItem
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_tool_item_get_icon_size(self: ptr TToolItem): int32 {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_icon_size".}
proc get_icon_size*(self: ToolItem): int32 {.inline.} =
  gtk_tool_item_get_icon_size(self)
# proc get_icon_size*(self: ToolItem): int32 {.inline.} =

# gtk_tool_item_get_is_important
# flags: {isMethod} container: ToolItem
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tool_item_get_is_important(self: ptr TToolItem): bool {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_is_important".}
proc get_is_important*(self: ToolItem): bool {.inline.} =
  gtk_tool_item_get_is_important(self)
# proc get_is_important*(self: ToolItem): bool {.inline.} =

# gtk_tool_item_get_orientation
# flags: {isMethod} container: ToolItem
# need sugar: is method
# return: INTERFACE 'Orientation' 'Orientation'
proc gtk_tool_item_get_orientation(self: ptr TToolItem): Orientation {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_orientation".}
proc get_orientation*(self: ToolItem): Orientation {.inline.} =
  gtk_tool_item_get_orientation(self)
# proc get_orientation*(self: ToolItem): Orientation {.inline.} =

# gtk_tool_item_get_proxy_menu_item
# flags: {isMethod} container: ToolItem
# need sugar: is method
# arg menu_item_id: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_tool_item_get_proxy_menu_item(self: ptr TToolItem, menu_item_id: ucstring): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_proxy_menu_item".}
proc get_proxy_menu_item*(self: ToolItem, menu_item_id: ustring): Widget {.inline.} =
  wrap(gtk_tool_item_get_proxy_menu_item(self, ucstring(menu_item_id)))
# proc get_proxy_menu_item*(self: ToolItem, menu_item_id: ustring): Widget {.inline.} =

# gtk_tool_item_get_relief_style
# flags: {isMethod} container: ToolItem
# need sugar: is method
# return: INTERFACE 'ReliefStyle' 'ReliefStyle'
proc gtk_tool_item_get_relief_style(self: ptr TToolItem): ReliefStyle {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_relief_style".}
proc get_relief_style*(self: ToolItem): ReliefStyle {.inline.} =
  gtk_tool_item_get_relief_style(self)
# proc get_relief_style*(self: ToolItem): ReliefStyle {.inline.} =

# gtk_tool_item_get_text_alignment
# flags: {isMethod} container: ToolItem
# need sugar: is method
# return: FLOAT 'float32' 'float32'
proc gtk_tool_item_get_text_alignment(self: ptr TToolItem): float32 {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_text_alignment".}
proc get_text_alignment*(self: ToolItem): float32 {.inline.} =
  gtk_tool_item_get_text_alignment(self)
# proc get_text_alignment*(self: ToolItem): float32 {.inline.} =

# gtk_tool_item_get_text_orientation
# flags: {isMethod} container: ToolItem
# need sugar: is method
# return: INTERFACE 'Orientation' 'Orientation'
proc gtk_tool_item_get_text_orientation(self: ptr TToolItem): Orientation {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_text_orientation".}
proc get_text_orientation*(self: ToolItem): Orientation {.inline.} =
  gtk_tool_item_get_text_orientation(self)
# proc get_text_orientation*(self: ToolItem): Orientation {.inline.} =

# gtk_tool_item_get_text_size_group
# flags: {isMethod} container: ToolItem
# need sugar: is method
# return: INTERFACE 'SizeGroup' 'TransferNone[TSizeGroup]' (diff., need sugar)
proc gtk_tool_item_get_text_size_group(self: ptr TToolItem): TransferNone[TSizeGroup] {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_text_size_group".}
proc get_text_size_group*(self: ToolItem): SizeGroup {.inline.} =
  wrap(gtk_tool_item_get_text_size_group(self))
# proc get_text_size_group*(self: ToolItem): SizeGroup {.inline.} =

# gtk_tool_item_get_toolbar_style
# flags: {isMethod} container: ToolItem
# need sugar: is method
# return: INTERFACE 'ToolbarStyle' 'ToolbarStyle'
proc gtk_tool_item_get_toolbar_style(self: ptr TToolItem): ToolbarStyle {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_toolbar_style".}
proc get_toolbar_style*(self: ToolItem): ToolbarStyle {.inline.} =
  gtk_tool_item_get_toolbar_style(self)
# proc get_toolbar_style*(self: ToolItem): ToolbarStyle {.inline.} =

# gtk_tool_item_get_use_drag_window
# flags: {isMethod} container: ToolItem
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tool_item_get_use_drag_window(self: ptr TToolItem): bool {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_use_drag_window".}
proc get_use_drag_window*(self: ToolItem): bool {.inline.} =
  gtk_tool_item_get_use_drag_window(self)
# proc get_use_drag_window*(self: ToolItem): bool {.inline.} =

# gtk_tool_item_get_visible_horizontal
# flags: {isMethod} container: ToolItem
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tool_item_get_visible_horizontal(self: ptr TToolItem): bool {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_visible_horizontal".}
proc get_visible_horizontal*(self: ToolItem): bool {.inline.} =
  gtk_tool_item_get_visible_horizontal(self)
# proc get_visible_horizontal*(self: ToolItem): bool {.inline.} =

# gtk_tool_item_get_visible_vertical
# flags: {isMethod} container: ToolItem
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tool_item_get_visible_vertical(self: ptr TToolItem): bool {.cdecl, dynlib: lib, importc: "gtk_tool_item_get_visible_vertical".}
proc get_visible_vertical*(self: ToolItem): bool {.inline.} =
  gtk_tool_item_get_visible_vertical(self)
# proc get_visible_vertical*(self: ToolItem): bool {.inline.} =

# gtk_tool_item_rebuild_menu
# flags: {isMethod} container: ToolItem
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_rebuild_menu(self: ptr TToolItem) {.cdecl, dynlib: lib, importc: "gtk_tool_item_rebuild_menu".}
proc rebuild_menu*(self: ToolItem) {.inline.} =
  gtk_tool_item_rebuild_menu(self)
# proc rebuild_menu*(self: ToolItem) {.inline.} =

# gtk_tool_item_retrieve_proxy_menu_item
# flags: {isMethod} container: ToolItem
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_tool_item_retrieve_proxy_menu_item(self: ptr TToolItem): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_tool_item_retrieve_proxy_menu_item".}
proc retrieve_proxy_menu_item*(self: ToolItem): Widget {.inline.} =
  wrap(gtk_tool_item_retrieve_proxy_menu_item(self))
# proc retrieve_proxy_menu_item*(self: ToolItem): Widget {.inline.} =

# gtk_tool_item_set_expand
# flags: {isMethod} container: ToolItem
# need sugar: is method
# arg expand: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_set_expand(self: ptr TToolItem, expand: bool) {.cdecl, dynlib: lib, importc: "gtk_tool_item_set_expand".}
proc set_expand*(self: ToolItem, expand: bool) {.inline.} =
  gtk_tool_item_set_expand(self, expand)
# proc set_expand*(self: ToolItem, expand: bool) {.inline.} =

# gtk_tool_item_set_homogeneous
# flags: {isMethod} container: ToolItem
# need sugar: is method
# arg homogeneous: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_set_homogeneous(self: ptr TToolItem, homogeneous: bool) {.cdecl, dynlib: lib, importc: "gtk_tool_item_set_homogeneous".}
proc set_homogeneous*(self: ToolItem, homogeneous: bool) {.inline.} =
  gtk_tool_item_set_homogeneous(self, homogeneous)
# proc set_homogeneous*(self: ToolItem, homogeneous: bool) {.inline.} =

# gtk_tool_item_set_is_important
# flags: {isMethod} container: ToolItem
# need sugar: is method
# arg is_important: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_set_is_important(self: ptr TToolItem, is_important: bool) {.cdecl, dynlib: lib, importc: "gtk_tool_item_set_is_important".}
proc set_is_important*(self: ToolItem, is_important: bool) {.inline.} =
  gtk_tool_item_set_is_important(self, is_important)
# proc set_is_important*(self: ToolItem, is_important: bool) {.inline.} =

# gtk_tool_item_set_proxy_menu_item
# flags: {isMethod} container: ToolItem
# need sugar: is method
# arg menu_item_id: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg menu_item: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_set_proxy_menu_item(self: ptr TToolItem, menu_item_id: ucstring, menu_item: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_tool_item_set_proxy_menu_item".}
proc set_proxy_menu_item*(self: ToolItem, menu_item_id: ustring, menu_item: Widget) {.inline.} =
  gtk_tool_item_set_proxy_menu_item(self, ucstring(menu_item_id), menu_item.getPointer)
# proc set_proxy_menu_item*(self: ToolItem, menu_item_id: ustring, menu_item: Widget) {.inline.} =

# gtk_tool_item_set_tooltip_markup
# flags: {isMethod} container: ToolItem
# need sugar: is method
# arg markup: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_set_tooltip_markup(self: ptr TToolItem, markup: ucstring) {.cdecl, dynlib: lib, importc: "gtk_tool_item_set_tooltip_markup".}
proc set_tooltip_markup*(self: ToolItem, markup: ustring) {.inline.} =
  gtk_tool_item_set_tooltip_markup(self, ucstring(markup))
# proc set_tooltip_markup*(self: ToolItem, markup: ustring) {.inline.} =

# gtk_tool_item_set_tooltip_text
# flags: {isMethod} container: ToolItem
# need sugar: is method
# arg text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_set_tooltip_text(self: ptr TToolItem, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_tool_item_set_tooltip_text".}
proc set_tooltip_text*(self: ToolItem, text: ustring) {.inline.} =
  gtk_tool_item_set_tooltip_text(self, ucstring(text))
# proc set_tooltip_text*(self: ToolItem, text: ustring) {.inline.} =

# gtk_tool_item_set_use_drag_window
# flags: {isMethod} container: ToolItem
# need sugar: is method
# arg use_drag_window: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_set_use_drag_window(self: ptr TToolItem, use_drag_window: bool) {.cdecl, dynlib: lib, importc: "gtk_tool_item_set_use_drag_window".}
proc set_use_drag_window*(self: ToolItem, use_drag_window: bool) {.inline.} =
  gtk_tool_item_set_use_drag_window(self, use_drag_window)
# proc set_use_drag_window*(self: ToolItem, use_drag_window: bool) {.inline.} =

# gtk_tool_item_set_visible_horizontal
# flags: {isMethod} container: ToolItem
# need sugar: is method
# arg visible_horizontal: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_set_visible_horizontal(self: ptr TToolItem, visible_horizontal: bool) {.cdecl, dynlib: lib, importc: "gtk_tool_item_set_visible_horizontal".}
proc set_visible_horizontal*(self: ToolItem, visible_horizontal: bool) {.inline.} =
  gtk_tool_item_set_visible_horizontal(self, visible_horizontal)
# proc set_visible_horizontal*(self: ToolItem, visible_horizontal: bool) {.inline.} =

# gtk_tool_item_set_visible_vertical
# flags: {isMethod} container: ToolItem
# need sugar: is method
# arg visible_vertical: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_set_visible_vertical(self: ptr TToolItem, visible_vertical: bool) {.cdecl, dynlib: lib, importc: "gtk_tool_item_set_visible_vertical".}
proc set_visible_vertical*(self: ToolItem, visible_vertical: bool) {.inline.} =
  gtk_tool_item_set_visible_vertical(self, visible_vertical)
# proc set_visible_vertical*(self: ToolItem, visible_vertical: bool) {.inline.} =

# gtk_tool_item_toolbar_reconfigured
# flags: {isMethod} container: ToolItem
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_toolbar_reconfigured(self: ptr TToolItem) {.cdecl, dynlib: lib, importc: "gtk_tool_item_toolbar_reconfigured".}
proc toolbar_reconfigured*(self: ToolItem) {.inline.} =
  gtk_tool_item_toolbar_reconfigured(self)
# proc toolbar_reconfigured*(self: ToolItem) {.inline.} =

# initializer for ToolItemGroup: gtk_tool_item_group_get_type
proc gtk_tool_item_group_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_get_type".}
template gtype*(klass_parameter: typedesc[ToolItemGroup]): GType = gtk_tool_item_group_get_type()
# gtk_tool_item_group_new
# flags: {isConstructor} container: ToolItemGroup
# need sugar: is static method
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'ToolItemGroup' 'TransferNone[TToolItemGroup]' (diff., need sugar)
proc gtk_tool_item_group_new(label: ucstring): TransferNone[TToolItemGroup] {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_new".}
proc new_toolitemgroup*(label: ustring): ToolItemGroup {.inline.} =
  wrap(gtk_tool_item_group_new(ucstring(label)))
# proc new_toolitemgroup*(label: ustring): ToolItemGroup {.inline.} =

# gtk_tool_item_group_get_collapsed
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tool_item_group_get_collapsed(self: ptr TToolItemGroup): bool {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_get_collapsed".}
proc get_collapsed*(self: ToolItemGroup): bool {.inline.} =
  gtk_tool_item_group_get_collapsed(self)
# proc get_collapsed*(self: ToolItemGroup): bool {.inline.} =

# gtk_tool_item_group_get_drop_item
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# arg x: INT32 'int32' 'int32' IN
# arg y: INT32 'int32' 'int32' IN
# return: INTERFACE 'ToolItem' 'TransferNone[TToolItem]' (diff., need sugar)
proc gtk_tool_item_group_get_drop_item(self: ptr TToolItemGroup, x: int32, y: int32): TransferNone[TToolItem] {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_get_drop_item".}
proc get_drop_item*(self: ToolItemGroup, x: int32, y: int32): ToolItem {.inline.} =
  wrap(gtk_tool_item_group_get_drop_item(self, x, y))
# proc get_drop_item*(self: ToolItemGroup, x: int32, y: int32): ToolItem {.inline.} =

# gtk_tool_item_group_get_ellipsize
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# return: INTERFACE 'Pango1.EllipsizeMode' 'Pango1.EllipsizeMode'
proc gtk_tool_item_group_get_ellipsize(self: ptr TToolItemGroup): Pango1.EllipsizeMode {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_get_ellipsize".}
proc get_ellipsize*(self: ToolItemGroup): Pango1.EllipsizeMode {.inline.} =
  gtk_tool_item_group_get_ellipsize(self)
# proc get_ellipsize*(self: ToolItemGroup): Pango1.EllipsizeMode {.inline.} =

# gtk_tool_item_group_get_header_relief
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# return: INTERFACE 'ReliefStyle' 'ReliefStyle'
proc gtk_tool_item_group_get_header_relief(self: ptr TToolItemGroup): ReliefStyle {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_get_header_relief".}
proc get_header_relief*(self: ToolItemGroup): ReliefStyle {.inline.} =
  gtk_tool_item_group_get_header_relief(self)
# proc get_header_relief*(self: ToolItemGroup): ReliefStyle {.inline.} =

# gtk_tool_item_group_get_item_position
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# arg item: INTERFACE (OBJECT) 'ToolItem' 'ptr TToolItem' IN (diff., need sugar)
# return: INT32 'int32' 'int32'
proc gtk_tool_item_group_get_item_position(self: ptr TToolItemGroup, item: ptr TToolItem): int32 {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_get_item_position".}
proc get_item_position*(self: ToolItemGroup, item: ToolItem): int32 {.inline.} =
  gtk_tool_item_group_get_item_position(self, item.getPointer)
# proc get_item_position*(self: ToolItemGroup, item: ToolItem): int32 {.inline.} =

# gtk_tool_item_group_get_label
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_tool_item_group_get_label(self: ptr TToolItemGroup): ucstring {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_get_label".}
proc get_label*(self: ToolItemGroup): ucstring {.inline.} =
  gtk_tool_item_group_get_label(self)
# proc get_label*(self: ToolItemGroup): ucstring {.inline.} =

# gtk_tool_item_group_get_label_widget
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_tool_item_group_get_label_widget(self: ptr TToolItemGroup): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_get_label_widget".}
proc get_label_widget*(self: ToolItemGroup): Widget {.inline.} =
  wrap(gtk_tool_item_group_get_label_widget(self))
# proc get_label_widget*(self: ToolItemGroup): Widget {.inline.} =

# gtk_tool_item_group_get_n_items
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# return: UINT32 'uint32' 'uint32'
proc gtk_tool_item_group_get_n_items(self: ptr TToolItemGroup): uint32 {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_get_n_items".}
proc get_n_items*(self: ToolItemGroup): uint32 {.inline.} =
  gtk_tool_item_group_get_n_items(self)
# proc get_n_items*(self: ToolItemGroup): uint32 {.inline.} =

# gtk_tool_item_group_get_nth_item
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# arg index: UINT32 'uint32' 'uint32' IN
# return: INTERFACE 'ToolItem' 'TransferNone[TToolItem]' (diff., need sugar)
proc gtk_tool_item_group_get_nth_item(self: ptr TToolItemGroup, index: uint32): TransferNone[TToolItem] {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_get_nth_item".}
proc get_nth_item*(self: ToolItemGroup, index: uint32): ToolItem {.inline.} =
  wrap(gtk_tool_item_group_get_nth_item(self, index))
# proc get_nth_item*(self: ToolItemGroup, index: uint32): ToolItem {.inline.} =

# gtk_tool_item_group_insert
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# arg item: INTERFACE (OBJECT) 'ToolItem' 'ptr TToolItem' IN (diff., need sugar)
# arg position: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_group_insert(self: ptr TToolItemGroup, item: ptr TToolItem, position: int32) {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_insert".}
proc insert*(self: ToolItemGroup, item: ToolItem, position: int32) {.inline.} =
  gtk_tool_item_group_insert(self, item.getPointer, position)
# proc insert*(self: ToolItemGroup, item: ToolItem, position: int32) {.inline.} =

# gtk_tool_item_group_set_collapsed
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# arg collapsed: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_group_set_collapsed(self: ptr TToolItemGroup, collapsed: bool) {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_set_collapsed".}
proc set_collapsed*(self: ToolItemGroup, collapsed: bool) {.inline.} =
  gtk_tool_item_group_set_collapsed(self, collapsed)
# proc set_collapsed*(self: ToolItemGroup, collapsed: bool) {.inline.} =

# gtk_tool_item_group_set_ellipsize
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# arg ellipsize: INTERFACE (ENUM) 'Pango1.EllipsizeMode' 'Pango1.EllipsizeMode' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_group_set_ellipsize(self: ptr TToolItemGroup, ellipsize: Pango1.EllipsizeMode) {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_set_ellipsize".}
proc set_ellipsize*(self: ToolItemGroup, ellipsize: Pango1.EllipsizeMode) {.inline.} =
  gtk_tool_item_group_set_ellipsize(self, ellipsize)
# proc set_ellipsize*(self: ToolItemGroup, ellipsize: Pango1.EllipsizeMode) {.inline.} =

# gtk_tool_item_group_set_header_relief
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# arg style: INTERFACE (ENUM) 'ReliefStyle' 'ReliefStyle' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_group_set_header_relief(self: ptr TToolItemGroup, style: ReliefStyle) {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_set_header_relief".}
proc set_header_relief*(self: ToolItemGroup, style: ReliefStyle) {.inline.} =
  gtk_tool_item_group_set_header_relief(self, style)
# proc set_header_relief*(self: ToolItemGroup, style: ReliefStyle) {.inline.} =

# gtk_tool_item_group_set_item_position
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# arg item: INTERFACE (OBJECT) 'ToolItem' 'ptr TToolItem' IN (diff., need sugar)
# arg position: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_group_set_item_position(self: ptr TToolItemGroup, item: ptr TToolItem, position: int32) {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_set_item_position".}
proc set_item_position*(self: ToolItemGroup, item: ToolItem, position: int32) {.inline.} =
  gtk_tool_item_group_set_item_position(self, item.getPointer, position)
# proc set_item_position*(self: ToolItemGroup, item: ToolItem, position: int32) {.inline.} =

# gtk_tool_item_group_set_label
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# arg label: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_group_set_label(self: ptr TToolItemGroup, label: ucstring) {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_set_label".}
proc set_label*(self: ToolItemGroup, label: ustring) {.inline.} =
  gtk_tool_item_group_set_label(self, ucstring(label))
# proc set_label*(self: ToolItemGroup, label: ustring) {.inline.} =

# gtk_tool_item_group_set_label_widget
# flags: {isMethod} container: ToolItemGroup
# need sugar: is method
# arg label_widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_item_group_set_label_widget(self: ptr TToolItemGroup, label_widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_tool_item_group_set_label_widget".}
proc set_label_widget*(self: ToolItemGroup, label_widget: Widget) {.inline.} =
  gtk_tool_item_group_set_label_widget(self, label_widget.getPointer)
# proc set_label_widget*(self: ToolItemGroup, label_widget: Widget) {.inline.} =

# initializer for ToolPalette: gtk_tool_palette_get_type
proc gtk_tool_palette_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_tool_palette_get_type".}
template gtype*(klass_parameter: typedesc[ToolPalette]): GType = gtk_tool_palette_get_type()
# gtk_tool_palette_new
# flags: {isConstructor} container: ToolPalette
# need sugar: is static method
# return: INTERFACE 'ToolPalette' 'TransferNone[TToolPalette]' (diff., need sugar)
proc gtk_tool_palette_new(): TransferNone[TToolPalette] {.cdecl, dynlib: lib, importc: "gtk_tool_palette_new".}
proc new_toolpalette*(): ToolPalette {.inline.} =
  wrap(gtk_tool_palette_new())
# proc new_toolpalette*(): ToolPalette {.inline.} =

# gtk_tool_palette_get_drag_target_group
# flags: {} container: ToolPalette
# need sugar: is static method
# return: INTERFACE 'ptr TTargetEntry' 'ptr TTargetEntry'
proc gtk_tool_palette_get_drag_target_group(): ptr TTargetEntry {.cdecl, dynlib: lib, importc: "gtk_tool_palette_get_drag_target_group".}
template get_drag_target_group*(klass_parameter: typedesc[ToolPalette]): ptr TTargetEntry =
  gtk_tool_palette_get_drag_target_group()
# template get_drag_target_group*(klass_parameter: typedesc[ToolPalette]): ptr TTargetEntry =

# gtk_tool_palette_get_drag_target_item
# flags: {} container: ToolPalette
# need sugar: is static method
# return: INTERFACE 'ptr TTargetEntry' 'ptr TTargetEntry'
proc gtk_tool_palette_get_drag_target_item(): ptr TTargetEntry {.cdecl, dynlib: lib, importc: "gtk_tool_palette_get_drag_target_item".}
template get_drag_target_item*(klass_parameter: typedesc[ToolPalette]): ptr TTargetEntry =
  gtk_tool_palette_get_drag_target_item()
# template get_drag_target_item*(klass_parameter: typedesc[ToolPalette]): ptr TTargetEntry =

# gtk_tool_palette_add_drag_dest
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg flags: INTERFACE (FLAGS) 'SDestDefaults' 'SDestDefaults' IN
# arg targets: INTERFACE (FLAGS) 'SToolPaletteDragTargets' 'SToolPaletteDragTargets' IN
# arg actions: INTERFACE (FLAGS) 'Gdk3.SDragAction' 'Gdk3.SDragAction' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_palette_add_drag_dest(self: ptr TToolPalette, widget: ptr TWidget, flags: SDestDefaults, targets: SToolPaletteDragTargets, actions: Gdk3.SDragAction) {.cdecl, dynlib: lib, importc: "gtk_tool_palette_add_drag_dest".}
proc add_drag_dest*(self: ToolPalette, widget: Widget, flags: SDestDefaults, targets: SToolPaletteDragTargets, actions: Gdk3.SDragAction) {.inline.} =
  gtk_tool_palette_add_drag_dest(self, widget.getPointer, flags, targets, actions)
# proc add_drag_dest*(self: ToolPalette, widget: Widget, flags: SDestDefaults, targets: SToolPaletteDragTargets, actions: Gdk3.SDragAction) {.inline.} =

# gtk_tool_palette_get_drag_item
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# arg selection: INTERFACE (STRUCT) 'ptr TSelectionData' 'ptr TSelectionData' IN
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_tool_palette_get_drag_item(self: ptr TToolPalette, selection: ptr TSelectionData): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_tool_palette_get_drag_item".}
proc get_drag_item*(self: ToolPalette, selection: ptr TSelectionData): Widget {.inline.} =
  wrap(gtk_tool_palette_get_drag_item(self, selection))
# proc get_drag_item*(self: ToolPalette, selection: ptr TSelectionData): Widget {.inline.} =

# gtk_tool_palette_get_drop_group
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# arg x: INT32 'int32' 'int32' IN
# arg y: INT32 'int32' 'int32' IN
# return: INTERFACE 'ToolItemGroup' 'TransferNone[TToolItemGroup]' (diff., need sugar)
proc gtk_tool_palette_get_drop_group(self: ptr TToolPalette, x: int32, y: int32): TransferNone[TToolItemGroup] {.cdecl, dynlib: lib, importc: "gtk_tool_palette_get_drop_group".}
proc get_drop_group*(self: ToolPalette, x: int32, y: int32): ToolItemGroup {.inline.} =
  wrap(gtk_tool_palette_get_drop_group(self, x, y))
# proc get_drop_group*(self: ToolPalette, x: int32, y: int32): ToolItemGroup {.inline.} =

# gtk_tool_palette_get_drop_item
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# arg x: INT32 'int32' 'int32' IN
# arg y: INT32 'int32' 'int32' IN
# return: INTERFACE 'ToolItem' 'TransferNone[TToolItem]' (diff., need sugar)
proc gtk_tool_palette_get_drop_item(self: ptr TToolPalette, x: int32, y: int32): TransferNone[TToolItem] {.cdecl, dynlib: lib, importc: "gtk_tool_palette_get_drop_item".}
proc get_drop_item*(self: ToolPalette, x: int32, y: int32): ToolItem {.inline.} =
  wrap(gtk_tool_palette_get_drop_item(self, x, y))
# proc get_drop_item*(self: ToolPalette, x: int32, y: int32): ToolItem {.inline.} =

# gtk_tool_palette_get_exclusive
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# arg group: INTERFACE (OBJECT) 'ToolItemGroup' 'ptr TToolItemGroup' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_tool_palette_get_exclusive(self: ptr TToolPalette, group: ptr TToolItemGroup): bool {.cdecl, dynlib: lib, importc: "gtk_tool_palette_get_exclusive".}
proc get_exclusive*(self: ToolPalette, group: ToolItemGroup): bool {.inline.} =
  gtk_tool_palette_get_exclusive(self, group.getPointer)
# proc get_exclusive*(self: ToolPalette, group: ToolItemGroup): bool {.inline.} =

# gtk_tool_palette_get_expand
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# arg group: INTERFACE (OBJECT) 'ToolItemGroup' 'ptr TToolItemGroup' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_tool_palette_get_expand(self: ptr TToolPalette, group: ptr TToolItemGroup): bool {.cdecl, dynlib: lib, importc: "gtk_tool_palette_get_expand".}
proc get_expand*(self: ToolPalette, group: ToolItemGroup): bool {.inline.} =
  gtk_tool_palette_get_expand(self, group.getPointer)
# proc get_expand*(self: ToolPalette, group: ToolItemGroup): bool {.inline.} =

# gtk_tool_palette_get_group_position
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# arg group: INTERFACE (OBJECT) 'ToolItemGroup' 'ptr TToolItemGroup' IN (diff., need sugar)
# return: INT32 'int32' 'int32'
proc gtk_tool_palette_get_group_position(self: ptr TToolPalette, group: ptr TToolItemGroup): int32 {.cdecl, dynlib: lib, importc: "gtk_tool_palette_get_group_position".}
proc get_group_position*(self: ToolPalette, group: ToolItemGroup): int32 {.inline.} =
  gtk_tool_palette_get_group_position(self, group.getPointer)
# proc get_group_position*(self: ToolPalette, group: ToolItemGroup): int32 {.inline.} =

# gtk_tool_palette_get_hadjustment
# flags: {isMethod} container: ToolPalette (deprecated)
# gtk_tool_palette_get_icon_size
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_tool_palette_get_icon_size(self: ptr TToolPalette): int32 {.cdecl, dynlib: lib, importc: "gtk_tool_palette_get_icon_size".}
proc get_icon_size*(self: ToolPalette): int32 {.inline.} =
  gtk_tool_palette_get_icon_size(self)
# proc get_icon_size*(self: ToolPalette): int32 {.inline.} =

# gtk_tool_palette_get_style
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# return: INTERFACE 'ToolbarStyle' 'ToolbarStyle'
proc gtk_tool_palette_get_style(self: ptr TToolPalette): ToolbarStyle {.cdecl, dynlib: lib, importc: "gtk_tool_palette_get_style".}
proc get_style*(self: ToolPalette): ToolbarStyle {.inline.} =
  gtk_tool_palette_get_style(self)
# proc get_style*(self: ToolPalette): ToolbarStyle {.inline.} =

# gtk_tool_palette_get_vadjustment
# flags: {isMethod} container: ToolPalette (deprecated)
# gtk_tool_palette_set_drag_source
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# arg targets: INTERFACE (FLAGS) 'SToolPaletteDragTargets' 'SToolPaletteDragTargets' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_palette_set_drag_source(self: ptr TToolPalette, targets: SToolPaletteDragTargets) {.cdecl, dynlib: lib, importc: "gtk_tool_palette_set_drag_source".}
proc set_drag_source*(self: ToolPalette, targets: SToolPaletteDragTargets) {.inline.} =
  gtk_tool_palette_set_drag_source(self, targets)
# proc set_drag_source*(self: ToolPalette, targets: SToolPaletteDragTargets) {.inline.} =

# gtk_tool_palette_set_exclusive
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# arg group: INTERFACE (OBJECT) 'ToolItemGroup' 'ptr TToolItemGroup' IN (diff., need sugar)
# arg exclusive: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_palette_set_exclusive(self: ptr TToolPalette, group: ptr TToolItemGroup, exclusive: bool) {.cdecl, dynlib: lib, importc: "gtk_tool_palette_set_exclusive".}
proc set_exclusive*(self: ToolPalette, group: ToolItemGroup, exclusive: bool) {.inline.} =
  gtk_tool_palette_set_exclusive(self, group.getPointer, exclusive)
# proc set_exclusive*(self: ToolPalette, group: ToolItemGroup, exclusive: bool) {.inline.} =

# gtk_tool_palette_set_expand
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# arg group: INTERFACE (OBJECT) 'ToolItemGroup' 'ptr TToolItemGroup' IN (diff., need sugar)
# arg expand: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_palette_set_expand(self: ptr TToolPalette, group: ptr TToolItemGroup, expand: bool) {.cdecl, dynlib: lib, importc: "gtk_tool_palette_set_expand".}
proc set_expand*(self: ToolPalette, group: ToolItemGroup, expand: bool) {.inline.} =
  gtk_tool_palette_set_expand(self, group.getPointer, expand)
# proc set_expand*(self: ToolPalette, group: ToolItemGroup, expand: bool) {.inline.} =

# gtk_tool_palette_set_group_position
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# arg group: INTERFACE (OBJECT) 'ToolItemGroup' 'ptr TToolItemGroup' IN (diff., need sugar)
# arg position: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_palette_set_group_position(self: ptr TToolPalette, group: ptr TToolItemGroup, position: int32) {.cdecl, dynlib: lib, importc: "gtk_tool_palette_set_group_position".}
proc set_group_position*(self: ToolPalette, group: ToolItemGroup, position: int32) {.inline.} =
  gtk_tool_palette_set_group_position(self, group.getPointer, position)
# proc set_group_position*(self: ToolPalette, group: ToolItemGroup, position: int32) {.inline.} =

# gtk_tool_palette_set_icon_size
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# arg icon_size: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_palette_set_icon_size(self: ptr TToolPalette, icon_size: int32) {.cdecl, dynlib: lib, importc: "gtk_tool_palette_set_icon_size".}
proc set_icon_size*(self: ToolPalette, icon_size: int32) {.inline.} =
  gtk_tool_palette_set_icon_size(self, icon_size)
# proc set_icon_size*(self: ToolPalette, icon_size: int32) {.inline.} =

# gtk_tool_palette_set_style
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# arg style: INTERFACE (ENUM) 'ToolbarStyle' 'ToolbarStyle' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_palette_set_style(self: ptr TToolPalette, style: ToolbarStyle) {.cdecl, dynlib: lib, importc: "gtk_tool_palette_set_style".}
proc set_style*(self: ToolPalette, style: ToolbarStyle) {.inline.} =
  gtk_tool_palette_set_style(self, style)
# proc set_style*(self: ToolPalette, style: ToolbarStyle) {.inline.} =

# gtk_tool_palette_unset_icon_size
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_palette_unset_icon_size(self: ptr TToolPalette) {.cdecl, dynlib: lib, importc: "gtk_tool_palette_unset_icon_size".}
proc unset_icon_size*(self: ToolPalette) {.inline.} =
  gtk_tool_palette_unset_icon_size(self)
# proc unset_icon_size*(self: ToolPalette) {.inline.} =

# gtk_tool_palette_unset_style
# flags: {isMethod} container: ToolPalette
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tool_palette_unset_style(self: ptr TToolPalette) {.cdecl, dynlib: lib, importc: "gtk_tool_palette_unset_style".}
proc unset_style*(self: ToolPalette) {.inline.} =
  gtk_tool_palette_unset_style(self)
# proc unset_style*(self: ToolPalette) {.inline.} =

# initializer for Toolbar: gtk_toolbar_get_type
proc gtk_toolbar_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_toolbar_get_type".}
template gtype*(klass_parameter: typedesc[Toolbar]): GType = gtk_toolbar_get_type()
# gtk_toolbar_new
# flags: {isConstructor} container: Toolbar
# need sugar: is static method
# return: INTERFACE 'Toolbar' 'TransferNone[TToolbar]' (diff., need sugar)
proc gtk_toolbar_new(): TransferNone[TToolbar] {.cdecl, dynlib: lib, importc: "gtk_toolbar_new".}
proc new_toolbar*(): Toolbar {.inline.} =
  wrap(gtk_toolbar_new())
# proc new_toolbar*(): Toolbar {.inline.} =

# gtk_toolbar_get_drop_index
# flags: {isMethod} container: Toolbar
# need sugar: is method
# arg x: INT32 'int32' 'int32' IN
# arg y: INT32 'int32' 'int32' IN
# return: INT32 'int32' 'int32'
proc gtk_toolbar_get_drop_index(self: ptr TToolbar, x: int32, y: int32): int32 {.cdecl, dynlib: lib, importc: "gtk_toolbar_get_drop_index".}
proc get_drop_index*(self: Toolbar, x: int32, y: int32): int32 {.inline.} =
  gtk_toolbar_get_drop_index(self, x, y)
# proc get_drop_index*(self: Toolbar, x: int32, y: int32): int32 {.inline.} =

# gtk_toolbar_get_icon_size
# flags: {isMethod} container: Toolbar
# need sugar: is method
# return: INTERFACE 'IconSize' 'IconSize'
proc gtk_toolbar_get_icon_size(self: ptr TToolbar): IconSize {.cdecl, dynlib: lib, importc: "gtk_toolbar_get_icon_size".}
proc get_icon_size*(self: Toolbar): IconSize {.inline.} =
  gtk_toolbar_get_icon_size(self)
# proc get_icon_size*(self: Toolbar): IconSize {.inline.} =

# gtk_toolbar_get_item_index
# flags: {isMethod} container: Toolbar
# need sugar: is method
# arg item: INTERFACE (OBJECT) 'ToolItem' 'ptr TToolItem' IN (diff., need sugar)
# return: INT32 'int32' 'int32'
proc gtk_toolbar_get_item_index(self: ptr TToolbar, item: ptr TToolItem): int32 {.cdecl, dynlib: lib, importc: "gtk_toolbar_get_item_index".}
proc get_item_index*(self: Toolbar, item: ToolItem): int32 {.inline.} =
  gtk_toolbar_get_item_index(self, item.getPointer)
# proc get_item_index*(self: Toolbar, item: ToolItem): int32 {.inline.} =

# gtk_toolbar_get_n_items
# flags: {isMethod} container: Toolbar
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_toolbar_get_n_items(self: ptr TToolbar): int32 {.cdecl, dynlib: lib, importc: "gtk_toolbar_get_n_items".}
proc get_n_items*(self: Toolbar): int32 {.inline.} =
  gtk_toolbar_get_n_items(self)
# proc get_n_items*(self: Toolbar): int32 {.inline.} =

# gtk_toolbar_get_nth_item
# flags: {isMethod} container: Toolbar
# need sugar: is method
# arg n: INT32 'int32' 'int32' IN
# return: INTERFACE 'ToolItem' 'TransferNone[TToolItem]' (diff., need sugar)
proc gtk_toolbar_get_nth_item(self: ptr TToolbar, n: int32): TransferNone[TToolItem] {.cdecl, dynlib: lib, importc: "gtk_toolbar_get_nth_item".}
proc get_nth_item*(self: Toolbar, n: int32): ToolItem {.inline.} =
  wrap(gtk_toolbar_get_nth_item(self, n))
# proc get_nth_item*(self: Toolbar, n: int32): ToolItem {.inline.} =

# gtk_toolbar_get_relief_style
# flags: {isMethod} container: Toolbar
# need sugar: is method
# return: INTERFACE 'ReliefStyle' 'ReliefStyle'
proc gtk_toolbar_get_relief_style(self: ptr TToolbar): ReliefStyle {.cdecl, dynlib: lib, importc: "gtk_toolbar_get_relief_style".}
proc get_relief_style*(self: Toolbar): ReliefStyle {.inline.} =
  gtk_toolbar_get_relief_style(self)
# proc get_relief_style*(self: Toolbar): ReliefStyle {.inline.} =

# gtk_toolbar_get_show_arrow
# flags: {isMethod} container: Toolbar
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_toolbar_get_show_arrow(self: ptr TToolbar): bool {.cdecl, dynlib: lib, importc: "gtk_toolbar_get_show_arrow".}
proc get_show_arrow*(self: Toolbar): bool {.inline.} =
  gtk_toolbar_get_show_arrow(self)
# proc get_show_arrow*(self: Toolbar): bool {.inline.} =

# gtk_toolbar_get_style
# flags: {isMethod} container: Toolbar
# need sugar: is method
# return: INTERFACE 'ToolbarStyle' 'ToolbarStyle'
proc gtk_toolbar_get_style(self: ptr TToolbar): ToolbarStyle {.cdecl, dynlib: lib, importc: "gtk_toolbar_get_style".}
proc get_style*(self: Toolbar): ToolbarStyle {.inline.} =
  gtk_toolbar_get_style(self)
# proc get_style*(self: Toolbar): ToolbarStyle {.inline.} =

# gtk_toolbar_insert
# flags: {isMethod} container: Toolbar
# need sugar: is method
# arg item: INTERFACE (OBJECT) 'ToolItem' 'ptr TToolItem' IN (diff., need sugar)
# arg pos: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_toolbar_insert(self: ptr TToolbar, item: ptr TToolItem, pos: int32) {.cdecl, dynlib: lib, importc: "gtk_toolbar_insert".}
proc insert*(self: Toolbar, item: ToolItem, pos: int32) {.inline.} =
  gtk_toolbar_insert(self, item.getPointer, pos)
# proc insert*(self: Toolbar, item: ToolItem, pos: int32) {.inline.} =

# gtk_toolbar_set_drop_highlight_item
# flags: {isMethod} container: Toolbar
# need sugar: is method
# arg tool_item: INTERFACE (OBJECT) 'ToolItem' 'ptr TToolItem' IN (diff., need sugar)
# arg index_: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_toolbar_set_drop_highlight_item(self: ptr TToolbar, tool_item: ptr TToolItem, index_x: int32) {.cdecl, dynlib: lib, importc: "gtk_toolbar_set_drop_highlight_item".}
proc set_drop_highlight_item*(self: Toolbar, tool_item: ToolItem, index_x: int32) {.inline.} =
  gtk_toolbar_set_drop_highlight_item(self, tool_item.getPointer, index_x)
# proc set_drop_highlight_item*(self: Toolbar, tool_item: ToolItem, index_x: int32) {.inline.} =

# gtk_toolbar_set_icon_size
# flags: {isMethod} container: Toolbar
# need sugar: is method
# arg icon_size: INTERFACE (ENUM) 'IconSize' 'IconSize' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_toolbar_set_icon_size(self: ptr TToolbar, icon_size: IconSize) {.cdecl, dynlib: lib, importc: "gtk_toolbar_set_icon_size".}
proc set_icon_size*(self: Toolbar, icon_size: IconSize) {.inline.} =
  gtk_toolbar_set_icon_size(self, icon_size)
# proc set_icon_size*(self: Toolbar, icon_size: IconSize) {.inline.} =

# gtk_toolbar_set_show_arrow
# flags: {isMethod} container: Toolbar
# need sugar: is method
# arg show_arrow: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_toolbar_set_show_arrow(self: ptr TToolbar, show_arrow: bool) {.cdecl, dynlib: lib, importc: "gtk_toolbar_set_show_arrow".}
proc set_show_arrow*(self: Toolbar, show_arrow: bool) {.inline.} =
  gtk_toolbar_set_show_arrow(self, show_arrow)
# proc set_show_arrow*(self: Toolbar, show_arrow: bool) {.inline.} =

# gtk_toolbar_set_style
# flags: {isMethod} container: Toolbar
# need sugar: is method
# arg style: INTERFACE (ENUM) 'ToolbarStyle' 'ToolbarStyle' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_toolbar_set_style(self: ptr TToolbar, style: ToolbarStyle) {.cdecl, dynlib: lib, importc: "gtk_toolbar_set_style".}
proc set_style*(self: Toolbar, style: ToolbarStyle) {.inline.} =
  gtk_toolbar_set_style(self, style)
# proc set_style*(self: Toolbar, style: ToolbarStyle) {.inline.} =

# gtk_toolbar_unset_icon_size
# flags: {isMethod} container: Toolbar
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_toolbar_unset_icon_size(self: ptr TToolbar) {.cdecl, dynlib: lib, importc: "gtk_toolbar_unset_icon_size".}
proc unset_icon_size*(self: Toolbar) {.inline.} =
  gtk_toolbar_unset_icon_size(self)
# proc unset_icon_size*(self: Toolbar) {.inline.} =

# gtk_toolbar_unset_style
# flags: {isMethod} container: Toolbar
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_toolbar_unset_style(self: ptr TToolbar) {.cdecl, dynlib: lib, importc: "gtk_toolbar_unset_style".}
proc unset_style*(self: Toolbar) {.inline.} =
  gtk_toolbar_unset_style(self)
# proc unset_style*(self: Toolbar) {.inline.} =

# initializer for Tooltip: gtk_tooltip_get_type
proc gtk_tooltip_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_tooltip_get_type".}
template gtype*(klass_parameter: typedesc[Tooltip]): GType = gtk_tooltip_get_type()
# gtk_tooltip_trigger_tooltip_query
# flags: {} container: Tooltip
# need sugar: is static method
# arg display: INTERFACE (OBJECT) 'Gdk3.Display' 'ptr Gdk3.TDisplay' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tooltip_trigger_tooltip_query(display: ptr Gdk3.TDisplay) {.cdecl, dynlib: lib, importc: "gtk_tooltip_trigger_tooltip_query".}
template trigger_tooltip_query*(klass_parameter: typedesc[Tooltip], display: Gdk3.Display) =
  gtk_tooltip_trigger_tooltip_query(display.getPointer)
# template trigger_tooltip_query*(klass_parameter: typedesc[Tooltip], display: Gdk3.Display) =

# gtk_tooltip_set_custom
# flags: {isMethod} container: Tooltip
# need sugar: is method
# arg custom_widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tooltip_set_custom(self: ptr TTooltip, custom_widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_tooltip_set_custom".}
proc set_custom*(self: Tooltip, custom_widget: Widget) {.inline.} =
  gtk_tooltip_set_custom(self, custom_widget.getPointer)
# proc set_custom*(self: Tooltip, custom_widget: Widget) {.inline.} =

# gtk_tooltip_set_icon
# flags: {isMethod} container: Tooltip
# need sugar: is method
# arg pixbuf: INTERFACE (OBJECT) 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tooltip_set_icon(self: ptr TTooltip, pixbuf: ptr GdkPixbuf2.TPixbuf) {.cdecl, dynlib: lib, importc: "gtk_tooltip_set_icon".}
proc set_icon*(self: Tooltip, pixbuf: GdkPixbuf2.Pixbuf) {.inline.} =
  gtk_tooltip_set_icon(self, pixbuf.getPointer)
# proc set_icon*(self: Tooltip, pixbuf: GdkPixbuf2.Pixbuf) {.inline.} =

# gtk_tooltip_set_icon_from_gicon
# flags: {isMethod} container: Tooltip
# need sugar: is method
# arg gicon: INTERFACE (INTERFACE) 'ptr Gio2.TIcon' 'ptr Gio2.TIcon' IN
# arg size: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tooltip_set_icon_from_gicon(self: ptr TTooltip, gicon: ptr Gio2.TIcon, size: int32) {.cdecl, dynlib: lib, importc: "gtk_tooltip_set_icon_from_gicon".}
proc set_icon_from_gicon*(self: Tooltip, gicon: ptr Gio2.TIcon, size: int32) {.inline.} =
  gtk_tooltip_set_icon_from_gicon(self, gicon, size)
# proc set_icon_from_gicon*(self: Tooltip, gicon: ptr Gio2.TIcon, size: int32) {.inline.} =

# gtk_tooltip_set_icon_from_icon_name
# flags: {isMethod} container: Tooltip
# need sugar: is method
# arg icon_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg size: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tooltip_set_icon_from_icon_name(self: ptr TTooltip, icon_name: ucstring, size: int32) {.cdecl, dynlib: lib, importc: "gtk_tooltip_set_icon_from_icon_name".}
proc set_icon_from_icon_name*(self: Tooltip, icon_name: ustring, size: int32) {.inline.} =
  gtk_tooltip_set_icon_from_icon_name(self, ucstring(icon_name), size)
# proc set_icon_from_icon_name*(self: Tooltip, icon_name: ustring, size: int32) {.inline.} =

# gtk_tooltip_set_icon_from_stock
# flags: {isMethod} container: Tooltip (deprecated)
# gtk_tooltip_set_markup
# flags: {isMethod} container: Tooltip
# need sugar: is method
# arg markup: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tooltip_set_markup(self: ptr TTooltip, markup: ucstring) {.cdecl, dynlib: lib, importc: "gtk_tooltip_set_markup".}
proc set_markup*(self: Tooltip, markup: ustring) {.inline.} =
  gtk_tooltip_set_markup(self, ucstring(markup))
# proc set_markup*(self: Tooltip, markup: ustring) {.inline.} =

# gtk_tooltip_set_text
# flags: {isMethod} container: Tooltip
# need sugar: is method
# arg text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tooltip_set_text(self: ptr TTooltip, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_tooltip_set_text".}
proc set_text*(self: Tooltip, text: ustring) {.inline.} =
  gtk_tooltip_set_text(self, ucstring(text))
# proc set_text*(self: Tooltip, text: ustring) {.inline.} =

# gtk_tooltip_set_tip_area
# flags: {isMethod} container: Tooltip
# need sugar: is method
# arg rect: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tooltip_set_tip_area(self: ptr TTooltip, rect: ptr Gdk3.TRectangle) {.cdecl, dynlib: lib, importc: "gtk_tooltip_set_tip_area".}
proc set_tip_area*(self: Tooltip, rect: ptr Gdk3.TRectangle) {.inline.} =
  gtk_tooltip_set_tip_area(self, rect)
# proc set_tip_area*(self: Tooltip, rect: ptr Gdk3.TRectangle) {.inline.} =

# initializer for ToplevelAccessible: gtk_toplevel_accessible_get_type
proc gtk_toplevel_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_toplevel_accessible_get_type".}
template gtype*(klass_parameter: typedesc[ToplevelAccessible]): GType = gtk_toplevel_accessible_get_type()
# gtk_toplevel_accessible_get_children
# flags: {isMethod} container: ToplevelAccessible
# need sugar: is method
# return: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_toplevel_accessible_get_children(self: ptr TToplevelAccessible): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_toplevel_accessible_get_children".}
proc get_children*(self: ToplevelAccessible): ptr GLIST_TODO {.inline.} =
  gtk_toplevel_accessible_get_children(self)
# proc get_children*(self: ToplevelAccessible): ptr GLIST_TODO {.inline.} =

# initializer for TreeModelFilter: gtk_tree_model_filter_get_type
proc gtk_tree_model_filter_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_tree_model_filter_get_type".}
template gtype*(klass_parameter: typedesc[TreeModelFilter]): GType = gtk_tree_model_filter_get_type()
# gtk_tree_model_filter_clear_cache
# flags: {isMethod} container: TreeModelFilter
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_model_filter_clear_cache(self: ptr TTreeModelFilter) {.cdecl, dynlib: lib, importc: "gtk_tree_model_filter_clear_cache".}
proc clear_cache*(self: TreeModelFilter) {.inline.} =
  gtk_tree_model_filter_clear_cache(self)
# proc clear_cache*(self: TreeModelFilter) {.inline.} =

# gtk_tree_model_filter_convert_child_iter_to_iter
# flags: {isMethod} container: TreeModelFilter
# need sugar: is method
# arg filter_iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' OUT caller-allocates
# arg child_iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_model_filter_convert_child_iter_to_iter(self: ptr TTreeModelFilter, filter_iter: ptr TTreeIter, child_iter: ptr TTreeIter): bool {.cdecl, dynlib: lib, importc: "gtk_tree_model_filter_convert_child_iter_to_iter".}
proc convert_child_iter_to_iter*(self: TreeModelFilter, filter_iter: ptr TTreeIter, child_iter: ptr TTreeIter): bool {.inline.} =
  gtk_tree_model_filter_convert_child_iter_to_iter(self, filter_iter, child_iter)
# tuple-return
# filter_iter: ptr TTreeIter
# proc convert_child_iter_to_iter*(self: TreeModelFilter, child_iter: ptr TTreeIter): bool {.inline.} =

# gtk_tree_model_filter_convert_child_path_to_path
# flags: {isMethod} container: TreeModelFilter
# need sugar: is method
# arg child_path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: INTERFACE 'ptr TTreePath' 'ptr TTreePath'
proc gtk_tree_model_filter_convert_child_path_to_path(self: ptr TTreeModelFilter, child_path: ptr TTreePath): ptr TTreePath {.cdecl, dynlib: lib, importc: "gtk_tree_model_filter_convert_child_path_to_path".}
proc convert_child_path_to_path*(self: TreeModelFilter, child_path: ptr TTreePath): ptr TTreePath {.inline.} =
  gtk_tree_model_filter_convert_child_path_to_path(self, child_path)
# proc convert_child_path_to_path*(self: TreeModelFilter, child_path: ptr TTreePath): ptr TTreePath {.inline.} =

# gtk_tree_model_filter_convert_iter_to_child_iter
# flags: {isMethod} container: TreeModelFilter
# need sugar: is method
# arg child_iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' OUT caller-allocates
# arg filter_iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_model_filter_convert_iter_to_child_iter(self: ptr TTreeModelFilter, child_iter: ptr TTreeIter, filter_iter: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_tree_model_filter_convert_iter_to_child_iter".}
proc convert_iter_to_child_iter*(self: TreeModelFilter, child_iter: ptr TTreeIter, filter_iter: ptr TTreeIter) {.inline.} =
  gtk_tree_model_filter_convert_iter_to_child_iter(self, child_iter, filter_iter)
# tuple-return
# child_iter: ptr TTreeIter
# proc convert_iter_to_child_iter*(self: TreeModelFilter, filter_iter: ptr TTreeIter) {.inline.} =

# gtk_tree_model_filter_convert_path_to_child_path
# flags: {isMethod} container: TreeModelFilter
# need sugar: is method
# arg filter_path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: INTERFACE 'ptr TTreePath' 'ptr TTreePath'
proc gtk_tree_model_filter_convert_path_to_child_path(self: ptr TTreeModelFilter, filter_path: ptr TTreePath): ptr TTreePath {.cdecl, dynlib: lib, importc: "gtk_tree_model_filter_convert_path_to_child_path".}
proc convert_path_to_child_path*(self: TreeModelFilter, filter_path: ptr TTreePath): ptr TTreePath {.inline.} =
  gtk_tree_model_filter_convert_path_to_child_path(self, filter_path)
# proc convert_path_to_child_path*(self: TreeModelFilter, filter_path: ptr TTreePath): ptr TTreePath {.inline.} =

# gtk_tree_model_filter_get_model
# flags: {isMethod} container: TreeModelFilter
# need sugar: is method
# return: INTERFACE 'ptr TTreeModel' 'TransferNone[TTreeModel]' (diff., need sugar)
proc gtk_tree_model_filter_get_model(self: ptr TTreeModelFilter): TransferNone[TTreeModel] {.cdecl, dynlib: lib, importc: "gtk_tree_model_filter_get_model".}
proc get_model*(self: TreeModelFilter): ptr TTreeModel {.inline.} =
  wrap(gtk_tree_model_filter_get_model(self))
# proc get_model*(self: TreeModelFilter): ptr TTreeModel {.inline.} =

# gtk_tree_model_filter_refilter
# flags: {isMethod} container: TreeModelFilter
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_model_filter_refilter(self: ptr TTreeModelFilter) {.cdecl, dynlib: lib, importc: "gtk_tree_model_filter_refilter".}
proc refilter*(self: TreeModelFilter) {.inline.} =
  gtk_tree_model_filter_refilter(self)
# proc refilter*(self: TreeModelFilter) {.inline.} =

# gtk_tree_model_filter_set_modify_func
# flags: {isMethod} container: TreeModelFilter
# need sugar: is method
# arg n_columns: INT32 'int32' 'int32' IN
# arg types: ARRAY 'var openarray[GType]' 'openarray[GType]' IN (diff., need sugar) array lengthArg: 0
# arg func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg data: VOID 'pointer' 'pointer' IN
# arg destroy: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_model_filter_set_modify_func(self: ptr TTreeModelFilter, n_columns: int32, types: openarray[GType], func_x: pointer, data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_tree_model_filter_set_modify_func".}
proc set_modify_func*(self: TreeModelFilter, types: var openarray[GType], func_x: pointer, data: pointer, destroy: pointer) {.inline.} =
  gtk_tree_model_filter_set_modify_func(self, types.len.int32, types, func_x, data, destroy)
# proc set_modify_func*(self: TreeModelFilter, types: var openarray[GType], func_x: pointer, data: pointer, destroy: pointer) {.inline.} =

# gtk_tree_model_filter_set_visible_column
# flags: {isMethod} container: TreeModelFilter
# need sugar: is method
# arg column: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_model_filter_set_visible_column(self: ptr TTreeModelFilter, column: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_model_filter_set_visible_column".}
proc set_visible_column*(self: TreeModelFilter, column: int32) {.inline.} =
  gtk_tree_model_filter_set_visible_column(self, column)
# proc set_visible_column*(self: TreeModelFilter, column: int32) {.inline.} =

# gtk_tree_model_filter_set_visible_func
# flags: {isMethod} container: TreeModelFilter
# need sugar: is method
# arg func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg data: VOID 'pointer' 'pointer' IN
# arg destroy: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_model_filter_set_visible_func(self: ptr TTreeModelFilter, func_x: pointer, data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_tree_model_filter_set_visible_func".}
proc set_visible_func*(self: TreeModelFilter, func_x: pointer, data: pointer, destroy: pointer) {.inline.} =
  gtk_tree_model_filter_set_visible_func(self, func_x, data, destroy)
# proc set_visible_func*(self: TreeModelFilter, func_x: pointer, data: pointer, destroy: pointer) {.inline.} =

# initializer for TreeModelSort: gtk_tree_model_sort_get_type
proc gtk_tree_model_sort_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_tree_model_sort_get_type".}
template gtype*(klass_parameter: typedesc[TreeModelSort]): GType = gtk_tree_model_sort_get_type()
# gtk_tree_model_sort_clear_cache
# flags: {isMethod} container: TreeModelSort
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_model_sort_clear_cache(self: ptr TTreeModelSort) {.cdecl, dynlib: lib, importc: "gtk_tree_model_sort_clear_cache".}
proc clear_cache*(self: TreeModelSort) {.inline.} =
  gtk_tree_model_sort_clear_cache(self)
# proc clear_cache*(self: TreeModelSort) {.inline.} =

# gtk_tree_model_sort_convert_child_iter_to_iter
# flags: {isMethod} container: TreeModelSort
# need sugar: is method
# arg sort_iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' OUT caller-allocates
# arg child_iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_model_sort_convert_child_iter_to_iter(self: ptr TTreeModelSort, sort_iter: ptr TTreeIter, child_iter: ptr TTreeIter): bool {.cdecl, dynlib: lib, importc: "gtk_tree_model_sort_convert_child_iter_to_iter".}
proc convert_child_iter_to_iter*(self: TreeModelSort, sort_iter: ptr TTreeIter, child_iter: ptr TTreeIter): bool {.inline.} =
  gtk_tree_model_sort_convert_child_iter_to_iter(self, sort_iter, child_iter)
# tuple-return
# sort_iter: ptr TTreeIter
# proc convert_child_iter_to_iter*(self: TreeModelSort, child_iter: ptr TTreeIter): bool {.inline.} =

# gtk_tree_model_sort_convert_child_path_to_path
# flags: {isMethod} container: TreeModelSort
# need sugar: is method
# arg child_path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: INTERFACE 'ptr TTreePath' 'ptr TTreePath'
proc gtk_tree_model_sort_convert_child_path_to_path(self: ptr TTreeModelSort, child_path: ptr TTreePath): ptr TTreePath {.cdecl, dynlib: lib, importc: "gtk_tree_model_sort_convert_child_path_to_path".}
proc convert_child_path_to_path*(self: TreeModelSort, child_path: ptr TTreePath): ptr TTreePath {.inline.} =
  gtk_tree_model_sort_convert_child_path_to_path(self, child_path)
# proc convert_child_path_to_path*(self: TreeModelSort, child_path: ptr TTreePath): ptr TTreePath {.inline.} =

# gtk_tree_model_sort_convert_iter_to_child_iter
# flags: {isMethod} container: TreeModelSort
# need sugar: is method
# arg child_iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' OUT caller-allocates
# arg sorted_iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_model_sort_convert_iter_to_child_iter(self: ptr TTreeModelSort, child_iter: ptr TTreeIter, sorted_iter: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_tree_model_sort_convert_iter_to_child_iter".}
proc convert_iter_to_child_iter*(self: TreeModelSort, child_iter: ptr TTreeIter, sorted_iter: ptr TTreeIter) {.inline.} =
  gtk_tree_model_sort_convert_iter_to_child_iter(self, child_iter, sorted_iter)
# tuple-return
# child_iter: ptr TTreeIter
# proc convert_iter_to_child_iter*(self: TreeModelSort, sorted_iter: ptr TTreeIter) {.inline.} =

# gtk_tree_model_sort_convert_path_to_child_path
# flags: {isMethod} container: TreeModelSort
# need sugar: is method
# arg sorted_path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: INTERFACE 'ptr TTreePath' 'ptr TTreePath'
proc gtk_tree_model_sort_convert_path_to_child_path(self: ptr TTreeModelSort, sorted_path: ptr TTreePath): ptr TTreePath {.cdecl, dynlib: lib, importc: "gtk_tree_model_sort_convert_path_to_child_path".}
proc convert_path_to_child_path*(self: TreeModelSort, sorted_path: ptr TTreePath): ptr TTreePath {.inline.} =
  gtk_tree_model_sort_convert_path_to_child_path(self, sorted_path)
# proc convert_path_to_child_path*(self: TreeModelSort, sorted_path: ptr TTreePath): ptr TTreePath {.inline.} =

# gtk_tree_model_sort_get_model
# flags: {isMethod} container: TreeModelSort
# need sugar: is method
# return: INTERFACE 'ptr TTreeModel' 'TransferNone[TTreeModel]' (diff., need sugar)
proc gtk_tree_model_sort_get_model(self: ptr TTreeModelSort): TransferNone[TTreeModel] {.cdecl, dynlib: lib, importc: "gtk_tree_model_sort_get_model".}
proc get_model*(self: TreeModelSort): ptr TTreeModel {.inline.} =
  wrap(gtk_tree_model_sort_get_model(self))
# proc get_model*(self: TreeModelSort): ptr TTreeModel {.inline.} =

# gtk_tree_model_sort_iter_is_valid
# flags: {isMethod} container: TreeModelSort
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_model_sort_iter_is_valid(self: ptr TTreeModelSort, iter: ptr TTreeIter): bool {.cdecl, dynlib: lib, importc: "gtk_tree_model_sort_iter_is_valid".}
proc iter_is_valid*(self: TreeModelSort, iter: ptr TTreeIter): bool {.inline.} =
  gtk_tree_model_sort_iter_is_valid(self, iter)
# proc iter_is_valid*(self: TreeModelSort, iter: ptr TTreeIter): bool {.inline.} =

# gtk_tree_model_sort_reset_default_sort_func
# flags: {isMethod} container: TreeModelSort
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_model_sort_reset_default_sort_func(self: ptr TTreeModelSort) {.cdecl, dynlib: lib, importc: "gtk_tree_model_sort_reset_default_sort_func".}
proc reset_default_sort_func*(self: TreeModelSort) {.inline.} =
  gtk_tree_model_sort_reset_default_sort_func(self)
# proc reset_default_sort_func*(self: TreeModelSort) {.inline.} =

# initializer for TreeSelection: gtk_tree_selection_get_type
proc gtk_tree_selection_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_tree_selection_get_type".}
template gtype*(klass_parameter: typedesc[TreeSelection]): GType = gtk_tree_selection_get_type()
# gtk_tree_selection_count_selected_rows
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_tree_selection_count_selected_rows(self: ptr TTreeSelection): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_selection_count_selected_rows".}
proc count_selected_rows*(self: TreeSelection): int32 {.inline.} =
  gtk_tree_selection_count_selected_rows(self)
# proc count_selected_rows*(self: TreeSelection): int32 {.inline.} =

# gtk_tree_selection_get_mode
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# return: INTERFACE 'SelectionMode' 'SelectionMode'
proc gtk_tree_selection_get_mode(self: ptr TTreeSelection): SelectionMode {.cdecl, dynlib: lib, importc: "gtk_tree_selection_get_mode".}
proc get_mode*(self: TreeSelection): SelectionMode {.inline.} =
  gtk_tree_selection_get_mode(self)
# proc get_mode*(self: TreeSelection): SelectionMode {.inline.} =

# gtk_tree_selection_get_selected
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# arg model: INTERFACE (INTERFACE) 'ptr TTreeModel' 'ptr TTreeModel' OUT optional
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' OUT caller-allocates optional
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_selection_get_selected(self: ptr TTreeSelection, model: ptr TTreeModel, iter: ptr TTreeIter): bool {.cdecl, dynlib: lib, importc: "gtk_tree_selection_get_selected".}
proc get_selected*(self: TreeSelection, model: ptr TTreeModel, iter: ptr TTreeIter): bool {.inline.} =
  gtk_tree_selection_get_selected(self, model, iter)
# tuple-return
# model: ptr TTreeModel
# iter: ptr TTreeIter
# proc get_selected*(self: TreeSelection): bool {.inline.} =

# gtk_tree_selection_get_selected_rows
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# arg model: INTERFACE (INTERFACE) 'ptr TTreeModel' 'ptr TTreeModel' OUT optional
# return: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_tree_selection_get_selected_rows(self: ptr TTreeSelection, model: ptr TTreeModel): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_tree_selection_get_selected_rows".}
proc get_selected_rows*(self: TreeSelection, model: ptr TTreeModel): ptr GLIST_TODO {.inline.} =
  gtk_tree_selection_get_selected_rows(self, model)
# tuple-return
# model: ptr TTreeModel
# proc get_selected_rows*(self: TreeSelection): ptr GLIST_TODO {.inline.} =

# gtk_tree_selection_get_tree_view
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# return: INTERFACE 'TreeView' 'TransferNone[TTreeView]' (diff., need sugar)
proc gtk_tree_selection_get_tree_view(self: ptr TTreeSelection): TransferNone[TTreeView] {.cdecl, dynlib: lib, importc: "gtk_tree_selection_get_tree_view".}
proc get_tree_view*(self: TreeSelection): TreeView {.inline.} =
  wrap(gtk_tree_selection_get_tree_view(self))
# proc get_tree_view*(self: TreeSelection): TreeView {.inline.} =

# gtk_tree_selection_iter_is_selected
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_selection_iter_is_selected(self: ptr TTreeSelection, iter: ptr TTreeIter): bool {.cdecl, dynlib: lib, importc: "gtk_tree_selection_iter_is_selected".}
proc iter_is_selected*(self: TreeSelection, iter: ptr TTreeIter): bool {.inline.} =
  gtk_tree_selection_iter_is_selected(self, iter)
# proc iter_is_selected*(self: TreeSelection, iter: ptr TTreeIter): bool {.inline.} =

# gtk_tree_selection_path_is_selected
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_selection_path_is_selected(self: ptr TTreeSelection, path: ptr TTreePath): bool {.cdecl, dynlib: lib, importc: "gtk_tree_selection_path_is_selected".}
proc path_is_selected*(self: TreeSelection, path: ptr TTreePath): bool {.inline.} =
  gtk_tree_selection_path_is_selected(self, path)
# proc path_is_selected*(self: TreeSelection, path: ptr TTreePath): bool {.inline.} =

# gtk_tree_selection_select_all
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_selection_select_all(self: ptr TTreeSelection) {.cdecl, dynlib: lib, importc: "gtk_tree_selection_select_all".}
proc select_all*(self: TreeSelection) {.inline.} =
  gtk_tree_selection_select_all(self)
# proc select_all*(self: TreeSelection) {.inline.} =

# gtk_tree_selection_select_iter
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_selection_select_iter(self: ptr TTreeSelection, iter: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_tree_selection_select_iter".}
proc select_iter*(self: TreeSelection, iter: ptr TTreeIter) {.inline.} =
  gtk_tree_selection_select_iter(self, iter)
# proc select_iter*(self: TreeSelection, iter: ptr TTreeIter) {.inline.} =

# gtk_tree_selection_select_path
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_selection_select_path(self: ptr TTreeSelection, path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_tree_selection_select_path".}
proc select_path*(self: TreeSelection, path: ptr TTreePath) {.inline.} =
  gtk_tree_selection_select_path(self, path)
# proc select_path*(self: TreeSelection, path: ptr TTreePath) {.inline.} =

# gtk_tree_selection_select_range
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# arg start_path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# arg end_path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_selection_select_range(self: ptr TTreeSelection, start_path: ptr TTreePath, end_path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_tree_selection_select_range".}
proc select_range*(self: TreeSelection, start_path: ptr TTreePath, end_path: ptr TTreePath) {.inline.} =
  gtk_tree_selection_select_range(self, start_path, end_path)
# proc select_range*(self: TreeSelection, start_path: ptr TTreePath, end_path: ptr TTreePath) {.inline.} =

# gtk_tree_selection_selected_foreach
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# arg func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg data: VOID 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_selection_selected_foreach(self: ptr TTreeSelection, func_x: pointer, data: pointer) {.cdecl, dynlib: lib, importc: "gtk_tree_selection_selected_foreach".}
proc selected_foreach*(self: TreeSelection, func_x: pointer, data: pointer) {.inline.} =
  gtk_tree_selection_selected_foreach(self, func_x, data)
# proc selected_foreach*(self: TreeSelection, func_x: pointer, data: pointer) {.inline.} =

# gtk_tree_selection_set_mode
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# arg type: INTERFACE (ENUM) 'SelectionMode' 'SelectionMode' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_selection_set_mode(self: ptr TTreeSelection, type_x: SelectionMode) {.cdecl, dynlib: lib, importc: "gtk_tree_selection_set_mode".}
proc set_mode*(self: TreeSelection, type_x: SelectionMode) {.inline.} =
  gtk_tree_selection_set_mode(self, type_x)
# proc set_mode*(self: TreeSelection, type_x: SelectionMode) {.inline.} =

# gtk_tree_selection_set_select_function
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# arg func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg data: VOID 'pointer' 'pointer' IN
# arg destroy: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_selection_set_select_function(self: ptr TTreeSelection, func_x: pointer, data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_tree_selection_set_select_function".}
proc set_select_function*(self: TreeSelection, func_x: pointer, data: pointer, destroy: pointer) {.inline.} =
  gtk_tree_selection_set_select_function(self, func_x, data, destroy)
# proc set_select_function*(self: TreeSelection, func_x: pointer, data: pointer, destroy: pointer) {.inline.} =

# gtk_tree_selection_unselect_all
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_selection_unselect_all(self: ptr TTreeSelection) {.cdecl, dynlib: lib, importc: "gtk_tree_selection_unselect_all".}
proc unselect_all*(self: TreeSelection) {.inline.} =
  gtk_tree_selection_unselect_all(self)
# proc unselect_all*(self: TreeSelection) {.inline.} =

# gtk_tree_selection_unselect_iter
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_selection_unselect_iter(self: ptr TTreeSelection, iter: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_tree_selection_unselect_iter".}
proc unselect_iter*(self: TreeSelection, iter: ptr TTreeIter) {.inline.} =
  gtk_tree_selection_unselect_iter(self, iter)
# proc unselect_iter*(self: TreeSelection, iter: ptr TTreeIter) {.inline.} =

# gtk_tree_selection_unselect_path
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_selection_unselect_path(self: ptr TTreeSelection, path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_tree_selection_unselect_path".}
proc unselect_path*(self: TreeSelection, path: ptr TTreePath) {.inline.} =
  gtk_tree_selection_unselect_path(self, path)
# proc unselect_path*(self: TreeSelection, path: ptr TTreePath) {.inline.} =

# gtk_tree_selection_unselect_range
# flags: {isMethod} container: TreeSelection
# need sugar: is method
# arg start_path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# arg end_path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_selection_unselect_range(self: ptr TTreeSelection, start_path: ptr TTreePath, end_path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_tree_selection_unselect_range".}
proc unselect_range*(self: TreeSelection, start_path: ptr TTreePath, end_path: ptr TTreePath) {.inline.} =
  gtk_tree_selection_unselect_range(self, start_path, end_path)
# proc unselect_range*(self: TreeSelection, start_path: ptr TTreePath, end_path: ptr TTreePath) {.inline.} =

# initializer for TreeStore: gtk_tree_store_get_type
proc gtk_tree_store_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_tree_store_get_type".}
template gtype*(klass_parameter: typedesc[TreeStore]): GType = gtk_tree_store_get_type()
# gtk_tree_store_newv
# flags: {isConstructor} container: TreeStore
# need sugar: is static method
# arg n_columns: INT32 'int32' 'int32' IN
# arg types: ARRAY 'var openarray[GType]' 'openarray[GType]' IN (diff., need sugar) array lengthArg: 0
# return: INTERFACE 'TreeStore' 'TransferFull[TTreeStore]' (diff., need sugar)
proc gtk_tree_store_newv(n_columns: int32, types: openarray[GType]): TransferFull[TTreeStore] {.cdecl, dynlib: lib, importc: "gtk_tree_store_newv".}
proc new_treestore*(types: var openarray[GType]): TreeStore {.inline.} =
  wrap(gtk_tree_store_newv(types.len.int32, types))
# proc new_treestore*(types: var openarray[GType]): TreeStore {.inline.} =

# gtk_tree_store_append
# flags: {isMethod} container: TreeStore
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' OUT caller-allocates
# arg parent: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_store_append(self: ptr TTreeStore, iter: ptr TTreeIter, parent: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_tree_store_append".}
proc append*(self: TreeStore, iter: ptr TTreeIter, parent: ptr TTreeIter) {.inline.} =
  gtk_tree_store_append(self, iter, parent)
# tuple-return
# iter: ptr TTreeIter
# proc append*(self: TreeStore, parent: ptr TTreeIter) {.inline.} =

# gtk_tree_store_clear
# flags: {isMethod} container: TreeStore
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_store_clear(self: ptr TTreeStore) {.cdecl, dynlib: lib, importc: "gtk_tree_store_clear".}
proc clear*(self: TreeStore) {.inline.} =
  gtk_tree_store_clear(self)
# proc clear*(self: TreeStore) {.inline.} =

# gtk_tree_store_insert
# flags: {isMethod} container: TreeStore
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' OUT caller-allocates
# arg parent: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# arg position: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_store_insert(self: ptr TTreeStore, iter: ptr TTreeIter, parent: ptr TTreeIter, position: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_store_insert".}
proc insert*(self: TreeStore, iter: ptr TTreeIter, parent: ptr TTreeIter, position: int32) {.inline.} =
  gtk_tree_store_insert(self, iter, parent, position)
# tuple-return
# iter: ptr TTreeIter
# proc insert*(self: TreeStore, parent: ptr TTreeIter, position: int32) {.inline.} =

# gtk_tree_store_insert_after
# flags: {isMethod} container: TreeStore
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' OUT caller-allocates
# arg parent: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# arg sibling: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_store_insert_after(self: ptr TTreeStore, iter: ptr TTreeIter, parent: ptr TTreeIter, sibling: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_tree_store_insert_after".}
proc insert_after*(self: TreeStore, iter: ptr TTreeIter, parent: ptr TTreeIter, sibling: ptr TTreeIter) {.inline.} =
  gtk_tree_store_insert_after(self, iter, parent, sibling)
# tuple-return
# iter: ptr TTreeIter
# proc insert_after*(self: TreeStore, parent: ptr TTreeIter, sibling: ptr TTreeIter) {.inline.} =

# gtk_tree_store_insert_before
# flags: {isMethod} container: TreeStore
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' OUT caller-allocates
# arg parent: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# arg sibling: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_store_insert_before(self: ptr TTreeStore, iter: ptr TTreeIter, parent: ptr TTreeIter, sibling: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_tree_store_insert_before".}
proc insert_before*(self: TreeStore, iter: ptr TTreeIter, parent: ptr TTreeIter, sibling: ptr TTreeIter) {.inline.} =
  gtk_tree_store_insert_before(self, iter, parent, sibling)
# tuple-return
# iter: ptr TTreeIter
# proc insert_before*(self: TreeStore, parent: ptr TTreeIter, sibling: ptr TTreeIter) {.inline.} =

# gtk_tree_store_insert_with_valuesv
# flags: {isMethod} container: TreeStore
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' OUT caller-allocates optional
# arg parent: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# arg position: INT32 'int32' 'int32' IN
# arg columns: ARRAY 'var openarray[int32]' 'openarray[int32]' IN (diff., need sugar) array lengthArg: 5
# arg values: ARRAY 'var openarray[GObject2.TValue]' 'openarray[GObject2.TValue]' IN (diff., need sugar) array lengthArg: 5
# arg n_values: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_store_insert_with_valuesv(self: ptr TTreeStore, iter: ptr TTreeIter, parent: ptr TTreeIter, position: int32, columns: openarray[int32], values: openarray[GObject2.TValue], n_values: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_store_insert_with_valuesv".}
proc insert_with_values*(self: TreeStore, iter: ptr TTreeIter, parent: ptr TTreeIter, position: int32, columns: var openarray[int32], values: var openarray[GObject2.TValue]) {.inline.} =
  gtk_tree_store_insert_with_valuesv(self, iter, parent, position, columns, values, values.len.int32)
# tuple-return
# iter: ptr TTreeIter
# proc insert_with_values*(self: TreeStore, parent: ptr TTreeIter, position: int32, columns: var openarray[int32], values: var openarray[GObject2.TValue]) {.inline.} =

# gtk_tree_store_is_ancestor
# flags: {isMethod} container: TreeStore
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# arg descendant: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_store_is_ancestor(self: ptr TTreeStore, iter: ptr TTreeIter, descendant: ptr TTreeIter): bool {.cdecl, dynlib: lib, importc: "gtk_tree_store_is_ancestor".}
proc is_ancestor*(self: TreeStore, iter: ptr TTreeIter, descendant: ptr TTreeIter): bool {.inline.} =
  gtk_tree_store_is_ancestor(self, iter, descendant)
# proc is_ancestor*(self: TreeStore, iter: ptr TTreeIter, descendant: ptr TTreeIter): bool {.inline.} =

# gtk_tree_store_iter_depth
# flags: {isMethod} container: TreeStore
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: INT32 'int32' 'int32'
proc gtk_tree_store_iter_depth(self: ptr TTreeStore, iter: ptr TTreeIter): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_store_iter_depth".}
proc iter_depth*(self: TreeStore, iter: ptr TTreeIter): int32 {.inline.} =
  gtk_tree_store_iter_depth(self, iter)
# proc iter_depth*(self: TreeStore, iter: ptr TTreeIter): int32 {.inline.} =

# gtk_tree_store_iter_is_valid
# flags: {isMethod} container: TreeStore
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_store_iter_is_valid(self: ptr TTreeStore, iter: ptr TTreeIter): bool {.cdecl, dynlib: lib, importc: "gtk_tree_store_iter_is_valid".}
proc iter_is_valid*(self: TreeStore, iter: ptr TTreeIter): bool {.inline.} =
  gtk_tree_store_iter_is_valid(self, iter)
# proc iter_is_valid*(self: TreeStore, iter: ptr TTreeIter): bool {.inline.} =

# gtk_tree_store_move_after
# flags: {isMethod} container: TreeStore
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# arg position: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_store_move_after(self: ptr TTreeStore, iter: ptr TTreeIter, position: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_tree_store_move_after".}
proc move_after*(self: TreeStore, iter: ptr TTreeIter, position: ptr TTreeIter) {.inline.} =
  gtk_tree_store_move_after(self, iter, position)
# proc move_after*(self: TreeStore, iter: ptr TTreeIter, position: ptr TTreeIter) {.inline.} =

# gtk_tree_store_move_before
# flags: {isMethod} container: TreeStore
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# arg position: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_store_move_before(self: ptr TTreeStore, iter: ptr TTreeIter, position: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_tree_store_move_before".}
proc move_before*(self: TreeStore, iter: ptr TTreeIter, position: ptr TTreeIter) {.inline.} =
  gtk_tree_store_move_before(self, iter, position)
# proc move_before*(self: TreeStore, iter: ptr TTreeIter, position: ptr TTreeIter) {.inline.} =

# gtk_tree_store_prepend
# flags: {isMethod} container: TreeStore
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' OUT caller-allocates
# arg parent: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_store_prepend(self: ptr TTreeStore, iter: ptr TTreeIter, parent: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_tree_store_prepend".}
proc prepend*(self: TreeStore, iter: ptr TTreeIter, parent: ptr TTreeIter) {.inline.} =
  gtk_tree_store_prepend(self, iter, parent)
# tuple-return
# iter: ptr TTreeIter
# proc prepend*(self: TreeStore, parent: ptr TTreeIter) {.inline.} =

# gtk_tree_store_remove
# flags: {isMethod} container: TreeStore
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_store_remove(self: ptr TTreeStore, iter: ptr TTreeIter): bool {.cdecl, dynlib: lib, importc: "gtk_tree_store_remove".}
proc remove*(self: TreeStore, iter: ptr TTreeIter): bool {.inline.} =
  gtk_tree_store_remove(self, iter)
# proc remove*(self: TreeStore, iter: ptr TTreeIter): bool {.inline.} =

# gtk_tree_store_set_column_types
# flags: {isMethod} container: TreeStore
# need sugar: is method
# arg n_columns: INT32 'int32' 'int32' IN
# arg types: ARRAY 'var openarray[GType]' 'openarray[GType]' IN (diff., need sugar) array lengthArg: 0
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_store_set_column_types(self: ptr TTreeStore, n_columns: int32, types: openarray[GType]) {.cdecl, dynlib: lib, importc: "gtk_tree_store_set_column_types".}
proc set_column_types*(self: TreeStore, types: var openarray[GType]) {.inline.} =
  gtk_tree_store_set_column_types(self, types.len.int32, types)
# proc set_column_types*(self: TreeStore, types: var openarray[GType]) {.inline.} =

# gtk_tree_store_set_value
# flags: {isMethod} container: TreeStore
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# arg column: INT32 'int32' 'int32' IN
# arg value: INTERFACE (STRUCT) 'ptr GObject2.TValue' 'ptr GObject2.TValue' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_store_set_value(self: ptr TTreeStore, iter: ptr TTreeIter, column: int32, value: ptr GObject2.TValue) {.cdecl, dynlib: lib, importc: "gtk_tree_store_set_value".}
proc set_value*(self: TreeStore, iter: ptr TTreeIter, column: int32, value: ptr GObject2.TValue) {.inline.} =
  gtk_tree_store_set_value(self, iter, column, value)
# proc set_value*(self: TreeStore, iter: ptr TTreeIter, column: int32, value: ptr GObject2.TValue) {.inline.} =

# gtk_tree_store_set_valuesv
# flags: {isMethod} container: TreeStore
# need sugar: is method
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# arg columns: ARRAY 'var openarray[int32]' 'openarray[int32]' IN (diff., need sugar) array lengthArg: 3
# arg values: ARRAY 'var openarray[GObject2.TValue]' 'openarray[GObject2.TValue]' IN (diff., need sugar) array lengthArg: 3
# arg n_values: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_store_set_valuesv(self: ptr TTreeStore, iter: ptr TTreeIter, columns: openarray[int32], values: openarray[GObject2.TValue], n_values: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_store_set_valuesv".}
proc set*(self: TreeStore, iter: ptr TTreeIter, columns: var openarray[int32], values: var openarray[GObject2.TValue]) {.inline.} =
  gtk_tree_store_set_valuesv(self, iter, columns, values, values.len.int32)
# proc set*(self: TreeStore, iter: ptr TTreeIter, columns: var openarray[int32], values: var openarray[GObject2.TValue]) {.inline.} =

# gtk_tree_store_swap
# flags: {isMethod} container: TreeStore
# need sugar: is method
# arg a: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# arg b: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_store_swap(self: ptr TTreeStore, a: ptr TTreeIter, b: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_tree_store_swap".}
proc swap*(self: TreeStore, a: ptr TTreeIter, b: ptr TTreeIter) {.inline.} =
  gtk_tree_store_swap(self, a, b)
# proc swap*(self: TreeStore, a: ptr TTreeIter, b: ptr TTreeIter) {.inline.} =

# initializer for TreeView: gtk_tree_view_get_type
proc gtk_tree_view_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_type".}
template gtype*(klass_parameter: typedesc[TreeView]): GType = gtk_tree_view_get_type()
# gtk_tree_view_new
# flags: {isConstructor} container: TreeView
# need sugar: is static method
# return: INTERFACE 'TreeView' 'TransferNone[TTreeView]' (diff., need sugar)
proc gtk_tree_view_new(): TransferNone[TTreeView] {.cdecl, dynlib: lib, importc: "gtk_tree_view_new".}
proc new_treeview*(): TreeView {.inline.} =
  wrap(gtk_tree_view_new())
# proc new_treeview*(): TreeView {.inline.} =

# gtk_tree_view_new_with_model
# flags: {isConstructor} container: TreeView
# need sugar: is static method
# arg model: INTERFACE (INTERFACE) 'ptr TTreeModel' 'ptr TTreeModel' IN
# return: INTERFACE 'TreeView' 'TransferNone[TTreeView]' (diff., need sugar)
proc gtk_tree_view_new_with_model(model: ptr TTreeModel): TransferNone[TTreeView] {.cdecl, dynlib: lib, importc: "gtk_tree_view_new_with_model".}
proc new_treeview_with_model*(model: ptr TTreeModel): TreeView {.inline.} =
  wrap(gtk_tree_view_new_with_model(model))
# proc new_treeview_with_model*(model: ptr TTreeModel): TreeView {.inline.} =

# gtk_tree_view_append_column
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg column: INTERFACE (OBJECT) 'TreeViewColumn' 'ptr TTreeViewColumn' IN (diff., need sugar)
# return: INT32 'int32' 'int32'
proc gtk_tree_view_append_column(self: ptr TTreeView, column: ptr TTreeViewColumn): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_append_column".}
proc append_column*(self: TreeView, column: TreeViewColumn): int32 {.inline.} =
  gtk_tree_view_append_column(self, column.getPointer)
# proc append_column*(self: TreeView, column: TreeViewColumn): int32 {.inline.} =

# gtk_tree_view_collapse_all
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_collapse_all(self: ptr TTreeView) {.cdecl, dynlib: lib, importc: "gtk_tree_view_collapse_all".}
proc collapse_all*(self: TreeView) {.inline.} =
  gtk_tree_view_collapse_all(self)
# proc collapse_all*(self: TreeView) {.inline.} =

# gtk_tree_view_collapse_row
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_collapse_row(self: ptr TTreeView, path: ptr TTreePath): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_collapse_row".}
proc collapse_row*(self: TreeView, path: ptr TTreePath): bool {.inline.} =
  gtk_tree_view_collapse_row(self, path)
# proc collapse_row*(self: TreeView, path: ptr TTreePath): bool {.inline.} =

# gtk_tree_view_columns_autosize
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_columns_autosize(self: ptr TTreeView) {.cdecl, dynlib: lib, importc: "gtk_tree_view_columns_autosize".}
proc columns_autosize*(self: TreeView) {.inline.} =
  gtk_tree_view_columns_autosize(self)
# proc columns_autosize*(self: TreeView) {.inline.} =

# gtk_tree_view_convert_bin_window_to_tree_coords
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg bx: INT32 'int32' 'int32' IN
# arg by: INT32 'int32' 'int32' IN
# arg tx: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# arg ty: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_convert_bin_window_to_tree_coords(self: ptr TTreeView, bx: int32, by: int32, tx: ptr int32, ty: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_convert_bin_window_to_tree_coords".}
proc convert_bin_window_to_tree_coords*(self: TreeView, bx: int32, by: int32, tx: var int32, ty: var int32) {.inline.} =
  gtk_tree_view_convert_bin_window_to_tree_coords(self, bx, by, addr(tx), addr(ty))
# tuple-return
# tx: var int32
# ty: var int32
# proc convert_bin_window_to_tree_coords*(self: TreeView, bx: int32, by: int32) {.inline.} =

# gtk_tree_view_convert_bin_window_to_widget_coords
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg bx: INT32 'int32' 'int32' IN
# arg by: INT32 'int32' 'int32' IN
# arg wx: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# arg wy: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_convert_bin_window_to_widget_coords(self: ptr TTreeView, bx: int32, by: int32, wx: ptr int32, wy: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_convert_bin_window_to_widget_coords".}
proc convert_bin_window_to_widget_coords*(self: TreeView, bx: int32, by: int32, wx: var int32, wy: var int32) {.inline.} =
  gtk_tree_view_convert_bin_window_to_widget_coords(self, bx, by, addr(wx), addr(wy))
# tuple-return
# wx: var int32
# wy: var int32
# proc convert_bin_window_to_widget_coords*(self: TreeView, bx: int32, by: int32) {.inline.} =

# gtk_tree_view_convert_tree_to_bin_window_coords
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg tx: INT32 'int32' 'int32' IN
# arg ty: INT32 'int32' 'int32' IN
# arg bx: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# arg by: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_convert_tree_to_bin_window_coords(self: ptr TTreeView, tx: int32, ty: int32, bx: ptr int32, by: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_convert_tree_to_bin_window_coords".}
proc convert_tree_to_bin_window_coords*(self: TreeView, tx: int32, ty: int32, bx: var int32, by: var int32) {.inline.} =
  gtk_tree_view_convert_tree_to_bin_window_coords(self, tx, ty, addr(bx), addr(by))
# tuple-return
# bx: var int32
# by: var int32
# proc convert_tree_to_bin_window_coords*(self: TreeView, tx: int32, ty: int32) {.inline.} =

# gtk_tree_view_convert_tree_to_widget_coords
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg tx: INT32 'int32' 'int32' IN
# arg ty: INT32 'int32' 'int32' IN
# arg wx: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# arg wy: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_convert_tree_to_widget_coords(self: ptr TTreeView, tx: int32, ty: int32, wx: ptr int32, wy: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_convert_tree_to_widget_coords".}
proc convert_tree_to_widget_coords*(self: TreeView, tx: int32, ty: int32, wx: var int32, wy: var int32) {.inline.} =
  gtk_tree_view_convert_tree_to_widget_coords(self, tx, ty, addr(wx), addr(wy))
# tuple-return
# wx: var int32
# wy: var int32
# proc convert_tree_to_widget_coords*(self: TreeView, tx: int32, ty: int32) {.inline.} =

# gtk_tree_view_convert_widget_to_bin_window_coords
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg wx: INT32 'int32' 'int32' IN
# arg wy: INT32 'int32' 'int32' IN
# arg bx: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# arg by: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_convert_widget_to_bin_window_coords(self: ptr TTreeView, wx: int32, wy: int32, bx: ptr int32, by: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_convert_widget_to_bin_window_coords".}
proc convert_widget_to_bin_window_coords*(self: TreeView, wx: int32, wy: int32, bx: var int32, by: var int32) {.inline.} =
  gtk_tree_view_convert_widget_to_bin_window_coords(self, wx, wy, addr(bx), addr(by))
# tuple-return
# bx: var int32
# by: var int32
# proc convert_widget_to_bin_window_coords*(self: TreeView, wx: int32, wy: int32) {.inline.} =

# gtk_tree_view_convert_widget_to_tree_coords
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg wx: INT32 'int32' 'int32' IN
# arg wy: INT32 'int32' 'int32' IN
# arg tx: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# arg ty: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_convert_widget_to_tree_coords(self: ptr TTreeView, wx: int32, wy: int32, tx: ptr int32, ty: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_convert_widget_to_tree_coords".}
proc convert_widget_to_tree_coords*(self: TreeView, wx: int32, wy: int32, tx: var int32, ty: var int32) {.inline.} =
  gtk_tree_view_convert_widget_to_tree_coords(self, wx, wy, addr(tx), addr(ty))
# tuple-return
# tx: var int32
# ty: var int32
# proc convert_widget_to_tree_coords*(self: TreeView, wx: int32, wy: int32) {.inline.} =

# gtk_tree_view_create_row_drag_icon
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: INTERFACE 'ptr cairo1.TSurface' 'ptr cairo1.TSurface'
proc gtk_tree_view_create_row_drag_icon(self: ptr TTreeView, path: ptr TTreePath): ptr cairo1.TSurface {.cdecl, dynlib: lib, importc: "gtk_tree_view_create_row_drag_icon".}
proc create_row_drag_icon*(self: TreeView, path: ptr TTreePath): ptr cairo1.TSurface {.inline.} =
  gtk_tree_view_create_row_drag_icon(self, path)
# proc create_row_drag_icon*(self: TreeView, path: ptr TTreePath): ptr cairo1.TSurface {.inline.} =

# gtk_tree_view_enable_model_drag_dest
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg targets: ARRAY 'var openarray[TTargetEntry]' 'openarray[TTargetEntry]' IN (diff., need sugar) array lengthArg: 1
# arg n_targets: INT32 'int32' 'int32' IN
# arg actions: INTERFACE (FLAGS) 'Gdk3.SDragAction' 'Gdk3.SDragAction' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_enable_model_drag_dest(self: ptr TTreeView, targets: openarray[TTargetEntry], n_targets: int32, actions: Gdk3.SDragAction) {.cdecl, dynlib: lib, importc: "gtk_tree_view_enable_model_drag_dest".}
proc enable_model_drag_dest*(self: TreeView, targets: var openarray[TTargetEntry], actions: Gdk3.SDragAction) {.inline.} =
  gtk_tree_view_enable_model_drag_dest(self, targets, targets.len.int32, actions)
# proc enable_model_drag_dest*(self: TreeView, targets: var openarray[TTargetEntry], actions: Gdk3.SDragAction) {.inline.} =

# gtk_tree_view_enable_model_drag_source
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg start_button_mask: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# arg targets: ARRAY 'var openarray[TTargetEntry]' 'openarray[TTargetEntry]' IN (diff., need sugar) array lengthArg: 2
# arg n_targets: INT32 'int32' 'int32' IN
# arg actions: INTERFACE (FLAGS) 'Gdk3.SDragAction' 'Gdk3.SDragAction' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_enable_model_drag_source(self: ptr TTreeView, start_button_mask: Gdk3.SModifierType, targets: openarray[TTargetEntry], n_targets: int32, actions: Gdk3.SDragAction) {.cdecl, dynlib: lib, importc: "gtk_tree_view_enable_model_drag_source".}
proc enable_model_drag_source*(self: TreeView, start_button_mask: Gdk3.SModifierType, targets: var openarray[TTargetEntry], actions: Gdk3.SDragAction) {.inline.} =
  gtk_tree_view_enable_model_drag_source(self, start_button_mask, targets, targets.len.int32, actions)
# proc enable_model_drag_source*(self: TreeView, start_button_mask: Gdk3.SModifierType, targets: var openarray[TTargetEntry], actions: Gdk3.SDragAction) {.inline.} =

# gtk_tree_view_expand_all
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_expand_all(self: ptr TTreeView) {.cdecl, dynlib: lib, importc: "gtk_tree_view_expand_all".}
proc expand_all*(self: TreeView) {.inline.} =
  gtk_tree_view_expand_all(self)
# proc expand_all*(self: TreeView) {.inline.} =

# gtk_tree_view_expand_row
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# arg open_all: BOOLEAN 'bool' 'bool' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_expand_row(self: ptr TTreeView, path: ptr TTreePath, open_all: bool): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_expand_row".}
proc expand_row*(self: TreeView, path: ptr TTreePath, open_all: bool): bool {.inline.} =
  gtk_tree_view_expand_row(self, path, open_all)
# proc expand_row*(self: TreeView, path: ptr TTreePath, open_all: bool): bool {.inline.} =

# gtk_tree_view_expand_to_path
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_expand_to_path(self: ptr TTreeView, path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_tree_view_expand_to_path".}
proc expand_to_path*(self: TreeView, path: ptr TTreePath) {.inline.} =
  gtk_tree_view_expand_to_path(self, path)
# proc expand_to_path*(self: TreeView, path: ptr TTreePath) {.inline.} =

# gtk_tree_view_get_activate_on_single_click
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_get_activate_on_single_click(self: ptr TTreeView): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_activate_on_single_click".}
proc get_activate_on_single_click*(self: TreeView): bool {.inline.} =
  gtk_tree_view_get_activate_on_single_click(self)
# proc get_activate_on_single_click*(self: TreeView): bool {.inline.} =

# gtk_tree_view_get_background_area
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# arg column: INTERFACE (OBJECT) 'TreeViewColumn' 'ptr TTreeViewColumn' IN (diff., need sugar)
# arg rect: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' OUT caller-allocates
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_get_background_area(self: ptr TTreeView, path: ptr TTreePath, column: ptr TTreeViewColumn, rect: ptr Gdk3.TRectangle) {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_background_area".}
proc get_background_area*(self: TreeView, path: ptr TTreePath, column: TreeViewColumn, rect: ptr Gdk3.TRectangle) {.inline.} =
  gtk_tree_view_get_background_area(self, path, column.getPointer, rect)
# tuple-return
# rect: ptr Gdk3.TRectangle
# proc get_background_area*(self: TreeView, path: ptr TTreePath, column: TreeViewColumn) {.inline.} =

# gtk_tree_view_get_bin_window
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: INTERFACE 'Gdk3.Window' 'TransferNone[Gdk3.TWindow]' (diff., need sugar)
proc gtk_tree_view_get_bin_window(self: ptr TTreeView): TransferNone[Gdk3.TWindow] {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_bin_window".}
proc get_bin_window*(self: TreeView): Gdk3.Window {.inline.} =
  wrap(gtk_tree_view_get_bin_window(self))
# proc get_bin_window*(self: TreeView): Gdk3.Window {.inline.} =

# gtk_tree_view_get_cell_area
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# arg column: INTERFACE (OBJECT) 'TreeViewColumn' 'ptr TTreeViewColumn' IN (diff., need sugar)
# arg rect: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' OUT caller-allocates
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_get_cell_area(self: ptr TTreeView, path: ptr TTreePath, column: ptr TTreeViewColumn, rect: ptr Gdk3.TRectangle) {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_cell_area".}
proc get_cell_area*(self: TreeView, path: ptr TTreePath, column: TreeViewColumn, rect: ptr Gdk3.TRectangle) {.inline.} =
  gtk_tree_view_get_cell_area(self, path, column.getPointer, rect)
# tuple-return
# rect: ptr Gdk3.TRectangle
# proc get_cell_area*(self: TreeView, path: ptr TTreePath, column: TreeViewColumn) {.inline.} =

# gtk_tree_view_get_column
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg n: INT32 'int32' 'int32' IN
# return: INTERFACE 'TreeViewColumn' 'TransferNone[TTreeViewColumn]' (diff., need sugar)
proc gtk_tree_view_get_column(self: ptr TTreeView, n: int32): TransferNone[TTreeViewColumn] {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_column".}
proc get_column*(self: TreeView, n: int32): TreeViewColumn {.inline.} =
  wrap(gtk_tree_view_get_column(self, n))
# proc get_column*(self: TreeView, n: int32): TreeViewColumn {.inline.} =

# gtk_tree_view_get_columns
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_tree_view_get_columns(self: ptr TTreeView): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_columns".}
proc get_columns*(self: TreeView): ptr GLIST_TODO {.inline.} =
  gtk_tree_view_get_columns(self)
# proc get_columns*(self: TreeView): ptr GLIST_TODO {.inline.} =

# gtk_tree_view_get_cursor
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' OUT optional
# arg focus_column: INTERFACE (OBJECT) 'var TreeViewColumn' 'ptr TTreeViewColumn' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_get_cursor(self: ptr TTreeView, path: ptr TTreePath, focus_column: ptr TTreeViewColumn) {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_cursor".}
proc get_cursor*(self: TreeView, path: ptr TTreePath, focus_column: var TreeViewColumn) {.inline.} =
  gtk_tree_view_get_cursor(self, path, focus_column.getPointer)
# tuple-return
# path: ptr TTreePath
# focus_column: var TreeViewColumn
# proc get_cursor*(self: TreeView) {.inline.} =

# gtk_tree_view_get_dest_row_at_pos
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg drag_x: INT32 'int32' 'int32' IN
# arg drag_y: INT32 'int32' 'int32' IN
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' OUT optional
# arg pos: INTERFACE (ENUM) 'TreeViewDropPosition' 'TreeViewDropPosition' OUT optional
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_get_dest_row_at_pos(self: ptr TTreeView, drag_x: int32, drag_y: int32, path: ptr TTreePath, pos: TreeViewDropPosition): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_dest_row_at_pos".}
proc get_dest_row_at_pos*(self: TreeView, drag_x: int32, drag_y: int32, path: ptr TTreePath, pos: TreeViewDropPosition): bool {.inline.} =
  gtk_tree_view_get_dest_row_at_pos(self, drag_x, drag_y, path, pos)
# tuple-return
# path: ptr TTreePath
# pos: TreeViewDropPosition
# proc get_dest_row_at_pos*(self: TreeView, drag_x: int32, drag_y: int32): bool {.inline.} =

# gtk_tree_view_get_drag_dest_row
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' OUT optional
# arg pos: INTERFACE (ENUM) 'TreeViewDropPosition' 'TreeViewDropPosition' OUT optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_get_drag_dest_row(self: ptr TTreeView, path: ptr TTreePath, pos: TreeViewDropPosition) {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_drag_dest_row".}
proc get_drag_dest_row*(self: TreeView, path: ptr TTreePath, pos: TreeViewDropPosition) {.inline.} =
  gtk_tree_view_get_drag_dest_row(self, path, pos)
# tuple-return
# path: ptr TTreePath
# pos: TreeViewDropPosition
# proc get_drag_dest_row*(self: TreeView) {.inline.} =

# gtk_tree_view_get_enable_search
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_get_enable_search(self: ptr TTreeView): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_enable_search".}
proc get_enable_search*(self: TreeView): bool {.inline.} =
  gtk_tree_view_get_enable_search(self)
# proc get_enable_search*(self: TreeView): bool {.inline.} =

# gtk_tree_view_get_enable_tree_lines
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_get_enable_tree_lines(self: ptr TTreeView): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_enable_tree_lines".}
proc get_enable_tree_lines*(self: TreeView): bool {.inline.} =
  gtk_tree_view_get_enable_tree_lines(self)
# proc get_enable_tree_lines*(self: TreeView): bool {.inline.} =

# gtk_tree_view_get_expander_column
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: INTERFACE 'TreeViewColumn' 'TransferNone[TTreeViewColumn]' (diff., need sugar)
proc gtk_tree_view_get_expander_column(self: ptr TTreeView): TransferNone[TTreeViewColumn] {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_expander_column".}
proc get_expander_column*(self: TreeView): TreeViewColumn {.inline.} =
  wrap(gtk_tree_view_get_expander_column(self))
# proc get_expander_column*(self: TreeView): TreeViewColumn {.inline.} =

# gtk_tree_view_get_fixed_height_mode
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_get_fixed_height_mode(self: ptr TTreeView): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_fixed_height_mode".}
proc get_fixed_height_mode*(self: TreeView): bool {.inline.} =
  gtk_tree_view_get_fixed_height_mode(self)
# proc get_fixed_height_mode*(self: TreeView): bool {.inline.} =

# gtk_tree_view_get_grid_lines
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: INTERFACE 'TreeViewGridLines' 'TreeViewGridLines'
proc gtk_tree_view_get_grid_lines(self: ptr TTreeView): TreeViewGridLines {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_grid_lines".}
proc get_grid_lines*(self: TreeView): TreeViewGridLines {.inline.} =
  gtk_tree_view_get_grid_lines(self)
# proc get_grid_lines*(self: TreeView): TreeViewGridLines {.inline.} =

# gtk_tree_view_get_hadjustment
# flags: {isMethod} container: TreeView (deprecated)
# gtk_tree_view_get_headers_clickable
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_get_headers_clickable(self: ptr TTreeView): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_headers_clickable".}
proc get_headers_clickable*(self: TreeView): bool {.inline.} =
  gtk_tree_view_get_headers_clickable(self)
# proc get_headers_clickable*(self: TreeView): bool {.inline.} =

# gtk_tree_view_get_headers_visible
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_get_headers_visible(self: ptr TTreeView): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_headers_visible".}
proc get_headers_visible*(self: TreeView): bool {.inline.} =
  gtk_tree_view_get_headers_visible(self)
# proc get_headers_visible*(self: TreeView): bool {.inline.} =

# gtk_tree_view_get_hover_expand
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_get_hover_expand(self: ptr TTreeView): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_hover_expand".}
proc get_hover_expand*(self: TreeView): bool {.inline.} =
  gtk_tree_view_get_hover_expand(self)
# proc get_hover_expand*(self: TreeView): bool {.inline.} =

# gtk_tree_view_get_hover_selection
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_get_hover_selection(self: ptr TTreeView): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_hover_selection".}
proc get_hover_selection*(self: TreeView): bool {.inline.} =
  gtk_tree_view_get_hover_selection(self)
# proc get_hover_selection*(self: TreeView): bool {.inline.} =

# gtk_tree_view_get_level_indentation
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_tree_view_get_level_indentation(self: ptr TTreeView): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_level_indentation".}
proc get_level_indentation*(self: TreeView): int32 {.inline.} =
  gtk_tree_view_get_level_indentation(self)
# proc get_level_indentation*(self: TreeView): int32 {.inline.} =

# gtk_tree_view_get_model
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: INTERFACE 'ptr TTreeModel' 'TransferNone[TTreeModel]' (diff., need sugar)
proc gtk_tree_view_get_model(self: ptr TTreeView): TransferNone[TTreeModel] {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_model".}
proc get_model*(self: TreeView): ptr TTreeModel {.inline.} =
  wrap(gtk_tree_view_get_model(self))
# proc get_model*(self: TreeView): ptr TTreeModel {.inline.} =

# gtk_tree_view_get_n_columns
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: UINT32 'uint32' 'uint32'
proc gtk_tree_view_get_n_columns(self: ptr TTreeView): uint32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_n_columns".}
proc get_n_columns*(self: TreeView): uint32 {.inline.} =
  gtk_tree_view_get_n_columns(self)
# proc get_n_columns*(self: TreeView): uint32 {.inline.} =

# gtk_tree_view_get_path_at_pos
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg x: INT32 'int32' 'int32' IN
# arg y: INT32 'int32' 'int32' IN
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' OUT optional
# arg column: INTERFACE (OBJECT) 'var TreeViewColumn' 'ptr TTreeViewColumn' OUT (diff., need sugar) optional
# arg cell_x: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg cell_y: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_get_path_at_pos(self: ptr TTreeView, x: int32, y: int32, path: ptr TTreePath, column: ptr TTreeViewColumn, cell_x: ptr int32, cell_y: ptr int32): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_path_at_pos".}
proc get_path_at_pos*(self: TreeView, x: int32, y: int32, path: ptr TTreePath, column: var TreeViewColumn, cell_x: var int32, cell_y: var int32): bool {.inline.} =
  gtk_tree_view_get_path_at_pos(self, x, y, path, column.getPointer, addr(cell_x), addr(cell_y))
# tuple-return
# path: ptr TTreePath
# column: var TreeViewColumn
# cell_x: var int32
# cell_y: var int32
# proc get_path_at_pos*(self: TreeView, x: int32, y: int32): bool {.inline.} =

# gtk_tree_view_get_reorderable
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_get_reorderable(self: ptr TTreeView): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_reorderable".}
proc get_reorderable*(self: TreeView): bool {.inline.} =
  gtk_tree_view_get_reorderable(self)
# proc get_reorderable*(self: TreeView): bool {.inline.} =

# gtk_tree_view_get_rubber_banding
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_get_rubber_banding(self: ptr TTreeView): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_rubber_banding".}
proc get_rubber_banding*(self: TreeView): bool {.inline.} =
  gtk_tree_view_get_rubber_banding(self)
# proc get_rubber_banding*(self: TreeView): bool {.inline.} =

# gtk_tree_view_get_rules_hint
# flags: {isMethod} container: TreeView (deprecated)
# gtk_tree_view_get_search_column
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_tree_view_get_search_column(self: ptr TTreeView): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_search_column".}
proc get_search_column*(self: TreeView): int32 {.inline.} =
  gtk_tree_view_get_search_column(self)
# proc get_search_column*(self: TreeView): int32 {.inline.} =

# gtk_tree_view_get_search_entry
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: INTERFACE 'Entry' 'TransferNone[TEntry]' (diff., need sugar)
proc gtk_tree_view_get_search_entry(self: ptr TTreeView): TransferNone[TEntry] {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_search_entry".}
proc get_search_entry*(self: TreeView): Entry {.inline.} =
  wrap(gtk_tree_view_get_search_entry(self))
# proc get_search_entry*(self: TreeView): Entry {.inline.} =

# gtk_tree_view_get_selection
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: INTERFACE 'TreeSelection' 'TransferNone[TTreeSelection]' (diff., need sugar)
proc gtk_tree_view_get_selection(self: ptr TTreeView): TransferNone[TTreeSelection] {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_selection".}
proc get_selection*(self: TreeView): TreeSelection {.inline.} =
  wrap(gtk_tree_view_get_selection(self))
# proc get_selection*(self: TreeView): TreeSelection {.inline.} =

# gtk_tree_view_get_show_expanders
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_get_show_expanders(self: ptr TTreeView): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_show_expanders".}
proc get_show_expanders*(self: TreeView): bool {.inline.} =
  gtk_tree_view_get_show_expanders(self)
# proc get_show_expanders*(self: TreeView): bool {.inline.} =

# gtk_tree_view_get_tooltip_column
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_tree_view_get_tooltip_column(self: ptr TTreeView): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_tooltip_column".}
proc get_tooltip_column*(self: TreeView): int32 {.inline.} =
  gtk_tree_view_get_tooltip_column(self)
# proc get_tooltip_column*(self: TreeView): int32 {.inline.} =

# gtk_tree_view_get_tooltip_context
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg x: INT32 'var int32' 'ptr int32' INOUT (diff., need sugar)
# arg y: INT32 'var int32' 'ptr int32' INOUT (diff., need sugar)
# arg keyboard_tip: BOOLEAN 'bool' 'bool' IN
# arg model: INTERFACE (INTERFACE) 'ptr TTreeModel' 'ptr TTreeModel' OUT optional
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' OUT optional
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' OUT caller-allocates optional
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_get_tooltip_context(self: ptr TTreeView, x: ptr int32, y: ptr int32, keyboard_tip: bool, model: ptr TTreeModel, path: ptr TTreePath, iter: ptr TTreeIter): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_tooltip_context".}
proc get_tooltip_context*(self: TreeView, x: var int32, y: var int32, keyboard_tip: bool, model: ptr TTreeModel, path: ptr TTreePath, iter: ptr TTreeIter): bool {.inline.} =
  gtk_tree_view_get_tooltip_context(self, addr(x), addr(y), keyboard_tip, model, path, iter)
# tuple-return
# model: ptr TTreeModel
# path: ptr TTreePath
# iter: ptr TTreeIter
# proc get_tooltip_context*(self: TreeView, x: var int32, y: var int32, keyboard_tip: bool): bool {.inline.} =

# gtk_tree_view_get_vadjustment
# flags: {isMethod} container: TreeView (deprecated)
# gtk_tree_view_get_visible_range
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg start_path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' OUT optional
# arg end_path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' OUT optional
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_get_visible_range(self: ptr TTreeView, start_path: ptr TTreePath, end_path: ptr TTreePath): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_visible_range".}
proc get_visible_range*(self: TreeView, start_path: ptr TTreePath, end_path: ptr TTreePath): bool {.inline.} =
  gtk_tree_view_get_visible_range(self, start_path, end_path)
# tuple-return
# start_path: ptr TTreePath
# end_path: ptr TTreePath
# proc get_visible_range*(self: TreeView): bool {.inline.} =

# gtk_tree_view_get_visible_rect
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg visible_rect: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' OUT caller-allocates
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_get_visible_rect(self: ptr TTreeView, visible_rect: ptr Gdk3.TRectangle) {.cdecl, dynlib: lib, importc: "gtk_tree_view_get_visible_rect".}
proc get_visible_rect*(self: TreeView, visible_rect: ptr Gdk3.TRectangle) {.inline.} =
  gtk_tree_view_get_visible_rect(self, visible_rect)
# tuple-return
# visible_rect: ptr Gdk3.TRectangle
# proc get_visible_rect*(self: TreeView) {.inline.} =

# gtk_tree_view_insert_column
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg column: INTERFACE (OBJECT) 'TreeViewColumn' 'ptr TTreeViewColumn' IN (diff., need sugar)
# arg position: INT32 'int32' 'int32' IN
# return: INT32 'int32' 'int32'
proc gtk_tree_view_insert_column(self: ptr TTreeView, column: ptr TTreeViewColumn, position: int32): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_insert_column".}
proc insert_column*(self: TreeView, column: TreeViewColumn, position: int32): int32 {.inline.} =
  gtk_tree_view_insert_column(self, column.getPointer, position)
# proc insert_column*(self: TreeView, column: TreeViewColumn, position: int32): int32 {.inline.} =

# gtk_tree_view_insert_column_with_data_func
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg position: INT32 'int32' 'int32' IN
# arg title: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg cell: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# arg func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg data: VOID 'pointer' 'pointer' IN
# arg dnotify: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: INT32 'int32' 'int32'
proc gtk_tree_view_insert_column_with_data_func(self: ptr TTreeView, position: int32, title: ucstring, cell: ptr TCellRenderer, func_x: pointer, data: pointer, dnotify: pointer): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_insert_column_with_data_func".}
proc insert_column_with_data_func*(self: TreeView, position: int32, title: ustring, cell: CellRenderer, func_x: pointer, data: pointer, dnotify: pointer): int32 {.inline.} =
  gtk_tree_view_insert_column_with_data_func(self, position, ucstring(title), cell.getPointer, func_x, data, dnotify)
# proc insert_column_with_data_func*(self: TreeView, position: int32, title: ustring, cell: CellRenderer, func_x: pointer, data: pointer, dnotify: pointer): int32 {.inline.} =

# gtk_tree_view_is_blank_at_pos
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg x: INT32 'int32' 'int32' IN
# arg y: INT32 'int32' 'int32' IN
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' OUT optional
# arg column: INTERFACE (OBJECT) 'var TreeViewColumn' 'ptr TTreeViewColumn' OUT (diff., need sugar) optional
# arg cell_x: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg cell_y: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_is_blank_at_pos(self: ptr TTreeView, x: int32, y: int32, path: ptr TTreePath, column: ptr TTreeViewColumn, cell_x: ptr int32, cell_y: ptr int32): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_is_blank_at_pos".}
proc is_blank_at_pos*(self: TreeView, x: int32, y: int32, path: ptr TTreePath, column: var TreeViewColumn, cell_x: var int32, cell_y: var int32): bool {.inline.} =
  gtk_tree_view_is_blank_at_pos(self, x, y, path, column.getPointer, addr(cell_x), addr(cell_y))
# tuple-return
# path: ptr TTreePath
# column: var TreeViewColumn
# cell_x: var int32
# cell_y: var int32
# proc is_blank_at_pos*(self: TreeView, x: int32, y: int32): bool {.inline.} =

# gtk_tree_view_is_rubber_banding_active
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_is_rubber_banding_active(self: ptr TTreeView): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_is_rubber_banding_active".}
proc is_rubber_banding_active*(self: TreeView): bool {.inline.} =
  gtk_tree_view_is_rubber_banding_active(self)
# proc is_rubber_banding_active*(self: TreeView): bool {.inline.} =

# gtk_tree_view_map_expanded_rows
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg data: VOID 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_map_expanded_rows(self: ptr TTreeView, func_x: pointer, data: pointer) {.cdecl, dynlib: lib, importc: "gtk_tree_view_map_expanded_rows".}
proc map_expanded_rows*(self: TreeView, func_x: pointer, data: pointer) {.inline.} =
  gtk_tree_view_map_expanded_rows(self, func_x, data)
# proc map_expanded_rows*(self: TreeView, func_x: pointer, data: pointer) {.inline.} =

# gtk_tree_view_move_column_after
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg column: INTERFACE (OBJECT) 'TreeViewColumn' 'ptr TTreeViewColumn' IN (diff., need sugar)
# arg base_column: INTERFACE (OBJECT) 'TreeViewColumn' 'ptr TTreeViewColumn' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_move_column_after(self: ptr TTreeView, column: ptr TTreeViewColumn, base_column: ptr TTreeViewColumn) {.cdecl, dynlib: lib, importc: "gtk_tree_view_move_column_after".}
proc move_column_after*(self: TreeView, column: TreeViewColumn, base_column: TreeViewColumn) {.inline.} =
  gtk_tree_view_move_column_after(self, column.getPointer, base_column.getPointer)
# proc move_column_after*(self: TreeView, column: TreeViewColumn, base_column: TreeViewColumn) {.inline.} =

# gtk_tree_view_remove_column
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg column: INTERFACE (OBJECT) 'TreeViewColumn' 'ptr TTreeViewColumn' IN (diff., need sugar)
# return: INT32 'int32' 'int32'
proc gtk_tree_view_remove_column(self: ptr TTreeView, column: ptr TTreeViewColumn): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_remove_column".}
proc remove_column*(self: TreeView, column: TreeViewColumn): int32 {.inline.} =
  gtk_tree_view_remove_column(self, column.getPointer)
# proc remove_column*(self: TreeView, column: TreeViewColumn): int32 {.inline.} =

# gtk_tree_view_row_activated
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# arg column: INTERFACE (OBJECT) 'TreeViewColumn' 'ptr TTreeViewColumn' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_row_activated(self: ptr TTreeView, path: ptr TTreePath, column: ptr TTreeViewColumn) {.cdecl, dynlib: lib, importc: "gtk_tree_view_row_activated".}
proc row_activated*(self: TreeView, path: ptr TTreePath, column: TreeViewColumn) {.inline.} =
  gtk_tree_view_row_activated(self, path, column.getPointer)
# proc row_activated*(self: TreeView, path: ptr TTreePath, column: TreeViewColumn) {.inline.} =

# gtk_tree_view_row_expanded
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_row_expanded(self: ptr TTreeView, path: ptr TTreePath): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_row_expanded".}
proc row_expanded*(self: TreeView, path: ptr TTreePath): bool {.inline.} =
  gtk_tree_view_row_expanded(self, path)
# proc row_expanded*(self: TreeView, path: ptr TTreePath): bool {.inline.} =

# gtk_tree_view_scroll_to_cell
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# arg column: INTERFACE (OBJECT) 'TreeViewColumn' 'ptr TTreeViewColumn' IN (diff., need sugar)
# arg use_align: BOOLEAN 'bool' 'bool' IN
# arg row_align: FLOAT 'float32' 'float32' IN
# arg col_align: FLOAT 'float32' 'float32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_scroll_to_cell(self: ptr TTreeView, path: ptr TTreePath, column: ptr TTreeViewColumn, use_align: bool, row_align: float32, col_align: float32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_scroll_to_cell".}
proc scroll_to_cell*(self: TreeView, path: ptr TTreePath, column: TreeViewColumn, use_align: bool, row_align: float32, col_align: float32) {.inline.} =
  gtk_tree_view_scroll_to_cell(self, path, column.getPointer, use_align, row_align, col_align)
# proc scroll_to_cell*(self: TreeView, path: ptr TTreePath, column: TreeViewColumn, use_align: bool, row_align: float32, col_align: float32) {.inline.} =

# gtk_tree_view_scroll_to_point
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg tree_x: INT32 'int32' 'int32' IN
# arg tree_y: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_scroll_to_point(self: ptr TTreeView, tree_x: int32, tree_y: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_scroll_to_point".}
proc scroll_to_point*(self: TreeView, tree_x: int32, tree_y: int32) {.inline.} =
  gtk_tree_view_scroll_to_point(self, tree_x, tree_y)
# proc scroll_to_point*(self: TreeView, tree_x: int32, tree_y: int32) {.inline.} =

# gtk_tree_view_set_activate_on_single_click
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg single: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_activate_on_single_click(self: ptr TTreeView, single: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_activate_on_single_click".}
proc set_activate_on_single_click*(self: TreeView, single: bool) {.inline.} =
  gtk_tree_view_set_activate_on_single_click(self, single)
# proc set_activate_on_single_click*(self: TreeView, single: bool) {.inline.} =

# gtk_tree_view_set_column_drag_function
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg user_data: VOID 'pointer' 'pointer' IN
# arg destroy: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_column_drag_function(self: ptr TTreeView, func_x: pointer, user_data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_column_drag_function".}
proc set_column_drag_function*(self: TreeView, func_x: pointer, user_data: pointer, destroy: pointer) {.inline.} =
  gtk_tree_view_set_column_drag_function(self, func_x, user_data, destroy)
# proc set_column_drag_function*(self: TreeView, func_x: pointer, user_data: pointer, destroy: pointer) {.inline.} =

# gtk_tree_view_set_cursor
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# arg focus_column: INTERFACE (OBJECT) 'TreeViewColumn' 'ptr TTreeViewColumn' IN (diff., need sugar)
# arg start_editing: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_cursor(self: ptr TTreeView, path: ptr TTreePath, focus_column: ptr TTreeViewColumn, start_editing: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_cursor".}
proc set_cursor*(self: TreeView, path: ptr TTreePath, focus_column: TreeViewColumn, start_editing: bool) {.inline.} =
  gtk_tree_view_set_cursor(self, path, focus_column.getPointer, start_editing)
# proc set_cursor*(self: TreeView, path: ptr TTreePath, focus_column: TreeViewColumn, start_editing: bool) {.inline.} =

# gtk_tree_view_set_cursor_on_cell
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# arg focus_column: INTERFACE (OBJECT) 'TreeViewColumn' 'ptr TTreeViewColumn' IN (diff., need sugar)
# arg focus_cell: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# arg start_editing: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_cursor_on_cell(self: ptr TTreeView, path: ptr TTreePath, focus_column: ptr TTreeViewColumn, focus_cell: ptr TCellRenderer, start_editing: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_cursor_on_cell".}
proc set_cursor_on_cell*(self: TreeView, path: ptr TTreePath, focus_column: TreeViewColumn, focus_cell: CellRenderer, start_editing: bool) {.inline.} =
  gtk_tree_view_set_cursor_on_cell(self, path, focus_column.getPointer, focus_cell.getPointer, start_editing)
# proc set_cursor_on_cell*(self: TreeView, path: ptr TTreePath, focus_column: TreeViewColumn, focus_cell: CellRenderer, start_editing: bool) {.inline.} =

# gtk_tree_view_set_destroy_count_func
# flags: {isMethod} container: TreeView (deprecated)
# gtk_tree_view_set_drag_dest_row
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# arg pos: INTERFACE (ENUM) 'TreeViewDropPosition' 'TreeViewDropPosition' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_drag_dest_row(self: ptr TTreeView, path: ptr TTreePath, pos: TreeViewDropPosition) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_drag_dest_row".}
proc set_drag_dest_row*(self: TreeView, path: ptr TTreePath, pos: TreeViewDropPosition) {.inline.} =
  gtk_tree_view_set_drag_dest_row(self, path, pos)
# proc set_drag_dest_row*(self: TreeView, path: ptr TTreePath, pos: TreeViewDropPosition) {.inline.} =

# gtk_tree_view_set_enable_search
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg enable_search: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_enable_search(self: ptr TTreeView, enable_search: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_enable_search".}
proc set_enable_search*(self: TreeView, enable_search: bool) {.inline.} =
  gtk_tree_view_set_enable_search(self, enable_search)
# proc set_enable_search*(self: TreeView, enable_search: bool) {.inline.} =

# gtk_tree_view_set_enable_tree_lines
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg enabled: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_enable_tree_lines(self: ptr TTreeView, enabled: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_enable_tree_lines".}
proc set_enable_tree_lines*(self: TreeView, enabled: bool) {.inline.} =
  gtk_tree_view_set_enable_tree_lines(self, enabled)
# proc set_enable_tree_lines*(self: TreeView, enabled: bool) {.inline.} =

# gtk_tree_view_set_expander_column
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg column: INTERFACE (OBJECT) 'TreeViewColumn' 'ptr TTreeViewColumn' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_expander_column(self: ptr TTreeView, column: ptr TTreeViewColumn) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_expander_column".}
proc set_expander_column*(self: TreeView, column: TreeViewColumn) {.inline.} =
  gtk_tree_view_set_expander_column(self, column.getPointer)
# proc set_expander_column*(self: TreeView, column: TreeViewColumn) {.inline.} =

# gtk_tree_view_set_fixed_height_mode
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg enable: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_fixed_height_mode(self: ptr TTreeView, enable: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_fixed_height_mode".}
proc set_fixed_height_mode*(self: TreeView, enable: bool) {.inline.} =
  gtk_tree_view_set_fixed_height_mode(self, enable)
# proc set_fixed_height_mode*(self: TreeView, enable: bool) {.inline.} =

# gtk_tree_view_set_grid_lines
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg grid_lines: INTERFACE (ENUM) 'TreeViewGridLines' 'TreeViewGridLines' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_grid_lines(self: ptr TTreeView, grid_lines: TreeViewGridLines) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_grid_lines".}
proc set_grid_lines*(self: TreeView, grid_lines: TreeViewGridLines) {.inline.} =
  gtk_tree_view_set_grid_lines(self, grid_lines)
# proc set_grid_lines*(self: TreeView, grid_lines: TreeViewGridLines) {.inline.} =

# gtk_tree_view_set_hadjustment
# flags: {isMethod} container: TreeView (deprecated)
# gtk_tree_view_set_headers_clickable
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_headers_clickable(self: ptr TTreeView, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_headers_clickable".}
proc set_headers_clickable*(self: TreeView, setting: bool) {.inline.} =
  gtk_tree_view_set_headers_clickable(self, setting)
# proc set_headers_clickable*(self: TreeView, setting: bool) {.inline.} =

# gtk_tree_view_set_headers_visible
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg headers_visible: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_headers_visible(self: ptr TTreeView, headers_visible: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_headers_visible".}
proc set_headers_visible*(self: TreeView, headers_visible: bool) {.inline.} =
  gtk_tree_view_set_headers_visible(self, headers_visible)
# proc set_headers_visible*(self: TreeView, headers_visible: bool) {.inline.} =

# gtk_tree_view_set_hover_expand
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg expand: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_hover_expand(self: ptr TTreeView, expand: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_hover_expand".}
proc set_hover_expand*(self: TreeView, expand: bool) {.inline.} =
  gtk_tree_view_set_hover_expand(self, expand)
# proc set_hover_expand*(self: TreeView, expand: bool) {.inline.} =

# gtk_tree_view_set_hover_selection
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg hover: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_hover_selection(self: ptr TTreeView, hover: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_hover_selection".}
proc set_hover_selection*(self: TreeView, hover: bool) {.inline.} =
  gtk_tree_view_set_hover_selection(self, hover)
# proc set_hover_selection*(self: TreeView, hover: bool) {.inline.} =

# gtk_tree_view_set_level_indentation
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg indentation: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_level_indentation(self: ptr TTreeView, indentation: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_level_indentation".}
proc set_level_indentation*(self: TreeView, indentation: int32) {.inline.} =
  gtk_tree_view_set_level_indentation(self, indentation)
# proc set_level_indentation*(self: TreeView, indentation: int32) {.inline.} =

# gtk_tree_view_set_model
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg model: INTERFACE (INTERFACE) 'ptr TTreeModel' 'ptr TTreeModel' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_model(self: ptr TTreeView, model: ptr TTreeModel) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_model".}
proc set_model*(self: TreeView, model: ptr TTreeModel) {.inline.} =
  gtk_tree_view_set_model(self, model)
# proc set_model*(self: TreeView, model: ptr TTreeModel) {.inline.} =

# gtk_tree_view_set_reorderable
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg reorderable: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_reorderable(self: ptr TTreeView, reorderable: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_reorderable".}
proc set_reorderable*(self: TreeView, reorderable: bool) {.inline.} =
  gtk_tree_view_set_reorderable(self, reorderable)
# proc set_reorderable*(self: TreeView, reorderable: bool) {.inline.} =

# gtk_tree_view_set_row_separator_func
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg data: VOID 'pointer' 'pointer' IN
# arg destroy: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_row_separator_func(self: ptr TTreeView, func_x: pointer, data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_row_separator_func".}
proc set_row_separator_func*(self: TreeView, func_x: pointer, data: pointer, destroy: pointer) {.inline.} =
  gtk_tree_view_set_row_separator_func(self, func_x, data, destroy)
# proc set_row_separator_func*(self: TreeView, func_x: pointer, data: pointer, destroy: pointer) {.inline.} =

# gtk_tree_view_set_rubber_banding
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg enable: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_rubber_banding(self: ptr TTreeView, enable: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_rubber_banding".}
proc set_rubber_banding*(self: TreeView, enable: bool) {.inline.} =
  gtk_tree_view_set_rubber_banding(self, enable)
# proc set_rubber_banding*(self: TreeView, enable: bool) {.inline.} =

# gtk_tree_view_set_rules_hint
# flags: {isMethod} container: TreeView (deprecated)
# gtk_tree_view_set_search_column
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg column: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_search_column(self: ptr TTreeView, column: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_search_column".}
proc set_search_column*(self: TreeView, column: int32) {.inline.} =
  gtk_tree_view_set_search_column(self, column)
# proc set_search_column*(self: TreeView, column: int32) {.inline.} =

# gtk_tree_view_set_search_entry
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg entry: INTERFACE (OBJECT) 'Entry' 'ptr TEntry' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_search_entry(self: ptr TTreeView, entry: ptr TEntry) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_search_entry".}
proc set_search_entry*(self: TreeView, entry: Entry) {.inline.} =
  gtk_tree_view_set_search_entry(self, entry.getPointer)
# proc set_search_entry*(self: TreeView, entry: Entry) {.inline.} =

# gtk_tree_view_set_search_equal_func
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg search_equal_func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg search_user_data: VOID 'pointer' 'pointer' IN
# arg search_destroy: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_search_equal_func(self: ptr TTreeView, search_equal_func: pointer, search_user_data: pointer, search_destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_search_equal_func".}
proc set_search_equal_func*(self: TreeView, search_equal_func: pointer, search_user_data: pointer, search_destroy: pointer) {.inline.} =
  gtk_tree_view_set_search_equal_func(self, search_equal_func, search_user_data, search_destroy)
# proc set_search_equal_func*(self: TreeView, search_equal_func: pointer, search_user_data: pointer, search_destroy: pointer) {.inline.} =

# gtk_tree_view_set_search_position_func
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg data: VOID 'pointer' 'pointer' IN
# arg destroy: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_search_position_func(self: ptr TTreeView, func_x: pointer, data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_search_position_func".}
proc set_search_position_func*(self: TreeView, func_x: pointer, data: pointer, destroy: pointer) {.inline.} =
  gtk_tree_view_set_search_position_func(self, func_x, data, destroy)
# proc set_search_position_func*(self: TreeView, func_x: pointer, data: pointer, destroy: pointer) {.inline.} =

# gtk_tree_view_set_show_expanders
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg enabled: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_show_expanders(self: ptr TTreeView, enabled: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_show_expanders".}
proc set_show_expanders*(self: TreeView, enabled: bool) {.inline.} =
  gtk_tree_view_set_show_expanders(self, enabled)
# proc set_show_expanders*(self: TreeView, enabled: bool) {.inline.} =

# gtk_tree_view_set_tooltip_cell
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg tooltip: INTERFACE (OBJECT) 'Tooltip' 'ptr TTooltip' IN (diff., need sugar)
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# arg column: INTERFACE (OBJECT) 'TreeViewColumn' 'ptr TTreeViewColumn' IN (diff., need sugar)
# arg cell: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_tooltip_cell(self: ptr TTreeView, tooltip: ptr TTooltip, path: ptr TTreePath, column: ptr TTreeViewColumn, cell: ptr TCellRenderer) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_tooltip_cell".}
proc set_tooltip_cell*(self: TreeView, tooltip: Tooltip, path: ptr TTreePath, column: TreeViewColumn, cell: CellRenderer) {.inline.} =
  gtk_tree_view_set_tooltip_cell(self, tooltip.getPointer, path, column.getPointer, cell.getPointer)
# proc set_tooltip_cell*(self: TreeView, tooltip: Tooltip, path: ptr TTreePath, column: TreeViewColumn, cell: CellRenderer) {.inline.} =

# gtk_tree_view_set_tooltip_column
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg column: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_tooltip_column(self: ptr TTreeView, column: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_tooltip_column".}
proc set_tooltip_column*(self: TreeView, column: int32) {.inline.} =
  gtk_tree_view_set_tooltip_column(self, column)
# proc set_tooltip_column*(self: TreeView, column: int32) {.inline.} =

# gtk_tree_view_set_tooltip_row
# flags: {isMethod} container: TreeView
# need sugar: is method
# arg tooltip: INTERFACE (OBJECT) 'Tooltip' 'ptr TTooltip' IN (diff., need sugar)
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_set_tooltip_row(self: ptr TTreeView, tooltip: ptr TTooltip, path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_tree_view_set_tooltip_row".}
proc set_tooltip_row*(self: TreeView, tooltip: Tooltip, path: ptr TTreePath) {.inline.} =
  gtk_tree_view_set_tooltip_row(self, tooltip.getPointer, path)
# proc set_tooltip_row*(self: TreeView, tooltip: Tooltip, path: ptr TTreePath) {.inline.} =

# gtk_tree_view_set_vadjustment
# flags: {isMethod} container: TreeView (deprecated)
# gtk_tree_view_unset_rows_drag_dest
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_unset_rows_drag_dest(self: ptr TTreeView) {.cdecl, dynlib: lib, importc: "gtk_tree_view_unset_rows_drag_dest".}
proc unset_rows_drag_dest*(self: TreeView) {.inline.} =
  gtk_tree_view_unset_rows_drag_dest(self)
# proc unset_rows_drag_dest*(self: TreeView) {.inline.} =

# gtk_tree_view_unset_rows_drag_source
# flags: {isMethod} container: TreeView
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_unset_rows_drag_source(self: ptr TTreeView) {.cdecl, dynlib: lib, importc: "gtk_tree_view_unset_rows_drag_source".}
proc unset_rows_drag_source*(self: TreeView) {.inline.} =
  gtk_tree_view_unset_rows_drag_source(self)
# proc unset_rows_drag_source*(self: TreeView) {.inline.} =

# initializer for TreeViewAccessible: gtk_tree_view_accessible_get_type
proc gtk_tree_view_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_tree_view_accessible_get_type".}
template gtype*(klass_parameter: typedesc[TreeViewAccessible]): GType = gtk_tree_view_accessible_get_type()
# initializer for TreeViewColumn: gtk_tree_view_column_get_type
proc gtk_tree_view_column_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_type".}
template gtype*(klass_parameter: typedesc[TreeViewColumn]): GType = gtk_tree_view_column_get_type()
# gtk_tree_view_column_new
# flags: {isConstructor} container: TreeViewColumn
# need sugar: is static method
# return: INTERFACE 'TreeViewColumn' 'TransferNone[TTreeViewColumn]' (diff., need sugar)
proc gtk_tree_view_column_new(): TransferNone[TTreeViewColumn] {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_new".}
proc new_treeviewcolumn*(): TreeViewColumn {.inline.} =
  wrap(gtk_tree_view_column_new())
# proc new_treeviewcolumn*(): TreeViewColumn {.inline.} =

# gtk_tree_view_column_new_with_area
# flags: {isConstructor} container: TreeViewColumn
# need sugar: is static method
# arg area: INTERFACE (OBJECT) 'CellArea' 'ptr TCellArea' IN (diff., need sugar)
# return: INTERFACE 'TreeViewColumn' 'TransferNone[TTreeViewColumn]' (diff., need sugar)
proc gtk_tree_view_column_new_with_area(area: ptr TCellArea): TransferNone[TTreeViewColumn] {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_new_with_area".}
proc new_treeviewcolumn_with_area*(area: CellArea): TreeViewColumn {.inline.} =
  wrap(gtk_tree_view_column_new_with_area(area.getPointer))
# proc new_treeviewcolumn_with_area*(area: CellArea): TreeViewColumn {.inline.} =

# gtk_tree_view_column_add_attribute
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# arg cell_renderer: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# arg attribute: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg column: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_add_attribute(self: ptr TTreeViewColumn, cell_renderer: ptr TCellRenderer, attribute: ucstring, column: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_add_attribute".}
proc add_attribute*(self: TreeViewColumn, cell_renderer: CellRenderer, attribute: ustring, column: int32) {.inline.} =
  gtk_tree_view_column_add_attribute(self, cell_renderer.getPointer, ucstring(attribute), column)
# proc add_attribute*(self: TreeViewColumn, cell_renderer: CellRenderer, attribute: ustring, column: int32) {.inline.} =

# gtk_tree_view_column_cell_get_position
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# arg cell_renderer: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# arg x_offset: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg width: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_column_cell_get_position(self: ptr TTreeViewColumn, cell_renderer: ptr TCellRenderer, x_offset: ptr int32, width: ptr int32): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_cell_get_position".}
proc cell_get_position*(self: TreeViewColumn, cell_renderer: CellRenderer, x_offset: var int32, width: var int32): bool {.inline.} =
  gtk_tree_view_column_cell_get_position(self, cell_renderer.getPointer, addr(x_offset), addr(width))
# tuple-return
# x_offset: var int32
# width: var int32
# proc cell_get_position*(self: TreeViewColumn, cell_renderer: CellRenderer): bool {.inline.} =

# gtk_tree_view_column_cell_get_size
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# arg cell_area: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# arg x_offset: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg y_offset: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg width: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg height: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_cell_get_size(self: ptr TTreeViewColumn, cell_area: ptr Gdk3.TRectangle, x_offset: ptr int32, y_offset: ptr int32, width: ptr int32, height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_cell_get_size".}
proc cell_get_size*(self: TreeViewColumn, cell_area: ptr Gdk3.TRectangle, x_offset: var int32, y_offset: var int32, width: var int32, height: var int32) {.inline.} =
  gtk_tree_view_column_cell_get_size(self, cell_area, addr(x_offset), addr(y_offset), addr(width), addr(height))
# tuple-return
# x_offset: var int32
# y_offset: var int32
# width: var int32
# height: var int32
# proc cell_get_size*(self: TreeViewColumn, cell_area: ptr Gdk3.TRectangle) {.inline.} =

# gtk_tree_view_column_cell_is_visible
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_column_cell_is_visible(self: ptr TTreeViewColumn): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_cell_is_visible".}
proc cell_is_visible*(self: TreeViewColumn): bool {.inline.} =
  gtk_tree_view_column_cell_is_visible(self)
# proc cell_is_visible*(self: TreeViewColumn): bool {.inline.} =

# gtk_tree_view_column_cell_set_cell_data
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# arg tree_model: INTERFACE (INTERFACE) 'ptr TTreeModel' 'ptr TTreeModel' IN
# arg iter: INTERFACE (STRUCT) 'ptr TTreeIter' 'ptr TTreeIter' IN
# arg is_expander: BOOLEAN 'bool' 'bool' IN
# arg is_expanded: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_cell_set_cell_data(self: ptr TTreeViewColumn, tree_model: ptr TTreeModel, iter: ptr TTreeIter, is_expander: bool, is_expanded: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_cell_set_cell_data".}
proc cell_set_cell_data*(self: TreeViewColumn, tree_model: ptr TTreeModel, iter: ptr TTreeIter, is_expander: bool, is_expanded: bool) {.inline.} =
  gtk_tree_view_column_cell_set_cell_data(self, tree_model, iter, is_expander, is_expanded)
# proc cell_set_cell_data*(self: TreeViewColumn, tree_model: ptr TTreeModel, iter: ptr TTreeIter, is_expander: bool, is_expanded: bool) {.inline.} =

# gtk_tree_view_column_clear
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_clear(self: ptr TTreeViewColumn) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_clear".}
proc clear*(self: TreeViewColumn) {.inline.} =
  gtk_tree_view_column_clear(self)
# proc clear*(self: TreeViewColumn) {.inline.} =

# gtk_tree_view_column_clear_attributes
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# arg cell_renderer: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_clear_attributes(self: ptr TTreeViewColumn, cell_renderer: ptr TCellRenderer) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_clear_attributes".}
proc clear_attributes*(self: TreeViewColumn, cell_renderer: CellRenderer) {.inline.} =
  gtk_tree_view_column_clear_attributes(self, cell_renderer.getPointer)
# proc clear_attributes*(self: TreeViewColumn, cell_renderer: CellRenderer) {.inline.} =

# gtk_tree_view_column_clicked
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_clicked(self: ptr TTreeViewColumn) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_clicked".}
proc clicked*(self: TreeViewColumn) {.inline.} =
  gtk_tree_view_column_clicked(self)
# proc clicked*(self: TreeViewColumn) {.inline.} =

# gtk_tree_view_column_focus_cell
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# arg cell: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_focus_cell(self: ptr TTreeViewColumn, cell: ptr TCellRenderer) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_focus_cell".}
proc focus_cell*(self: TreeViewColumn, cell: CellRenderer) {.inline.} =
  gtk_tree_view_column_focus_cell(self, cell.getPointer)
# proc focus_cell*(self: TreeViewColumn, cell: CellRenderer) {.inline.} =

# gtk_tree_view_column_get_alignment
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# return: FLOAT 'float32' 'float32'
proc gtk_tree_view_column_get_alignment(self: ptr TTreeViewColumn): float32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_alignment".}
proc get_alignment*(self: TreeViewColumn): float32 {.inline.} =
  gtk_tree_view_column_get_alignment(self)
# proc get_alignment*(self: TreeViewColumn): float32 {.inline.} =

# gtk_tree_view_column_get_button
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_tree_view_column_get_button(self: ptr TTreeViewColumn): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_button".}
proc get_button*(self: TreeViewColumn): Widget {.inline.} =
  wrap(gtk_tree_view_column_get_button(self))
# proc get_button*(self: TreeViewColumn): Widget {.inline.} =

# gtk_tree_view_column_get_clickable
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_column_get_clickable(self: ptr TTreeViewColumn): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_clickable".}
proc get_clickable*(self: TreeViewColumn): bool {.inline.} =
  gtk_tree_view_column_get_clickable(self)
# proc get_clickable*(self: TreeViewColumn): bool {.inline.} =

# gtk_tree_view_column_get_expand
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_column_get_expand(self: ptr TTreeViewColumn): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_expand".}
proc get_expand*(self: TreeViewColumn): bool {.inline.} =
  gtk_tree_view_column_get_expand(self)
# proc get_expand*(self: TreeViewColumn): bool {.inline.} =

# gtk_tree_view_column_get_fixed_width
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_tree_view_column_get_fixed_width(self: ptr TTreeViewColumn): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_fixed_width".}
proc get_fixed_width*(self: TreeViewColumn): int32 {.inline.} =
  gtk_tree_view_column_get_fixed_width(self)
# proc get_fixed_width*(self: TreeViewColumn): int32 {.inline.} =

# gtk_tree_view_column_get_max_width
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_tree_view_column_get_max_width(self: ptr TTreeViewColumn): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_max_width".}
proc get_max_width*(self: TreeViewColumn): int32 {.inline.} =
  gtk_tree_view_column_get_max_width(self)
# proc get_max_width*(self: TreeViewColumn): int32 {.inline.} =

# gtk_tree_view_column_get_min_width
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_tree_view_column_get_min_width(self: ptr TTreeViewColumn): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_min_width".}
proc get_min_width*(self: TreeViewColumn): int32 {.inline.} =
  gtk_tree_view_column_get_min_width(self)
# proc get_min_width*(self: TreeViewColumn): int32 {.inline.} =

# gtk_tree_view_column_get_reorderable
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_column_get_reorderable(self: ptr TTreeViewColumn): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_reorderable".}
proc get_reorderable*(self: TreeViewColumn): bool {.inline.} =
  gtk_tree_view_column_get_reorderable(self)
# proc get_reorderable*(self: TreeViewColumn): bool {.inline.} =

# gtk_tree_view_column_get_resizable
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_column_get_resizable(self: ptr TTreeViewColumn): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_resizable".}
proc get_resizable*(self: TreeViewColumn): bool {.inline.} =
  gtk_tree_view_column_get_resizable(self)
# proc get_resizable*(self: TreeViewColumn): bool {.inline.} =

# gtk_tree_view_column_get_sizing
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# return: INTERFACE 'TreeViewColumnSizing' 'TreeViewColumnSizing'
proc gtk_tree_view_column_get_sizing(self: ptr TTreeViewColumn): TreeViewColumnSizing {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_sizing".}
proc get_sizing*(self: TreeViewColumn): TreeViewColumnSizing {.inline.} =
  gtk_tree_view_column_get_sizing(self)
# proc get_sizing*(self: TreeViewColumn): TreeViewColumnSizing {.inline.} =

# gtk_tree_view_column_get_sort_column_id
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_tree_view_column_get_sort_column_id(self: ptr TTreeViewColumn): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_sort_column_id".}
proc get_sort_column_id*(self: TreeViewColumn): int32 {.inline.} =
  gtk_tree_view_column_get_sort_column_id(self)
# proc get_sort_column_id*(self: TreeViewColumn): int32 {.inline.} =

# gtk_tree_view_column_get_sort_indicator
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_column_get_sort_indicator(self: ptr TTreeViewColumn): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_sort_indicator".}
proc get_sort_indicator*(self: TreeViewColumn): bool {.inline.} =
  gtk_tree_view_column_get_sort_indicator(self)
# proc get_sort_indicator*(self: TreeViewColumn): bool {.inline.} =

# gtk_tree_view_column_get_sort_order
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# return: INTERFACE 'SortType' 'SortType'
proc gtk_tree_view_column_get_sort_order(self: ptr TTreeViewColumn): SortType {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_sort_order".}
proc get_sort_order*(self: TreeViewColumn): SortType {.inline.} =
  gtk_tree_view_column_get_sort_order(self)
# proc get_sort_order*(self: TreeViewColumn): SortType {.inline.} =

# gtk_tree_view_column_get_spacing
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_tree_view_column_get_spacing(self: ptr TTreeViewColumn): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_spacing".}
proc get_spacing*(self: TreeViewColumn): int32 {.inline.} =
  gtk_tree_view_column_get_spacing(self)
# proc get_spacing*(self: TreeViewColumn): int32 {.inline.} =

# gtk_tree_view_column_get_title
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_tree_view_column_get_title(self: ptr TTreeViewColumn): ucstring {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_title".}
proc get_title*(self: TreeViewColumn): ucstring {.inline.} =
  gtk_tree_view_column_get_title(self)
# proc get_title*(self: TreeViewColumn): ucstring {.inline.} =

# gtk_tree_view_column_get_tree_view
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_tree_view_column_get_tree_view(self: ptr TTreeViewColumn): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_tree_view".}
proc get_tree_view*(self: TreeViewColumn): Widget {.inline.} =
  wrap(gtk_tree_view_column_get_tree_view(self))
# proc get_tree_view*(self: TreeViewColumn): Widget {.inline.} =

# gtk_tree_view_column_get_visible
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_view_column_get_visible(self: ptr TTreeViewColumn): bool {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_visible".}
proc get_visible*(self: TreeViewColumn): bool {.inline.} =
  gtk_tree_view_column_get_visible(self)
# proc get_visible*(self: TreeViewColumn): bool {.inline.} =

# gtk_tree_view_column_get_widget
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_tree_view_column_get_widget(self: ptr TTreeViewColumn): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_widget".}
proc get_widget*(self: TreeViewColumn): Widget {.inline.} =
  wrap(gtk_tree_view_column_get_widget(self))
# proc get_widget*(self: TreeViewColumn): Widget {.inline.} =

# gtk_tree_view_column_get_width
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_tree_view_column_get_width(self: ptr TTreeViewColumn): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_width".}
proc get_width*(self: TreeViewColumn): int32 {.inline.} =
  gtk_tree_view_column_get_width(self)
# proc get_width*(self: TreeViewColumn): int32 {.inline.} =

# gtk_tree_view_column_get_x_offset
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_tree_view_column_get_x_offset(self: ptr TTreeViewColumn): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_get_x_offset".}
proc get_x_offset*(self: TreeViewColumn): int32 {.inline.} =
  gtk_tree_view_column_get_x_offset(self)
# proc get_x_offset*(self: TreeViewColumn): int32 {.inline.} =

# gtk_tree_view_column_pack_end
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# arg cell: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# arg expand: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_pack_end(self: ptr TTreeViewColumn, cell: ptr TCellRenderer, expand: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_pack_end".}
proc pack_end*(self: TreeViewColumn, cell: CellRenderer, expand: bool) {.inline.} =
  gtk_tree_view_column_pack_end(self, cell.getPointer, expand)
# proc pack_end*(self: TreeViewColumn, cell: CellRenderer, expand: bool) {.inline.} =

# gtk_tree_view_column_pack_start
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# arg cell: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# arg expand: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_pack_start(self: ptr TTreeViewColumn, cell: ptr TCellRenderer, expand: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_pack_start".}
proc pack_start*(self: TreeViewColumn, cell: CellRenderer, expand: bool) {.inline.} =
  gtk_tree_view_column_pack_start(self, cell.getPointer, expand)
# proc pack_start*(self: TreeViewColumn, cell: CellRenderer, expand: bool) {.inline.} =

# gtk_tree_view_column_queue_resize
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_queue_resize(self: ptr TTreeViewColumn) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_queue_resize".}
proc queue_resize*(self: TreeViewColumn) {.inline.} =
  gtk_tree_view_column_queue_resize(self)
# proc queue_resize*(self: TreeViewColumn) {.inline.} =

# gtk_tree_view_column_set_alignment
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# arg xalign: FLOAT 'float32' 'float32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_alignment(self: ptr TTreeViewColumn, xalign: float32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_alignment".}
proc set_alignment*(self: TreeViewColumn, xalign: float32) {.inline.} =
  gtk_tree_view_column_set_alignment(self, xalign)
# proc set_alignment*(self: TreeViewColumn, xalign: float32) {.inline.} =

# gtk_tree_view_column_set_cell_data_func
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# arg cell_renderer: INTERFACE (OBJECT) 'CellRenderer' 'ptr TCellRenderer' IN (diff., need sugar)
# arg func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg func_data: VOID 'pointer' 'pointer' IN
# arg destroy: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_cell_data_func(self: ptr TTreeViewColumn, cell_renderer: ptr TCellRenderer, func_x: pointer, func_data: pointer, destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_cell_data_func".}
proc set_cell_data_func*(self: TreeViewColumn, cell_renderer: CellRenderer, func_x: pointer, func_data: pointer, destroy: pointer) {.inline.} =
  gtk_tree_view_column_set_cell_data_func(self, cell_renderer.getPointer, func_x, func_data, destroy)
# proc set_cell_data_func*(self: TreeViewColumn, cell_renderer: CellRenderer, func_x: pointer, func_data: pointer, destroy: pointer) {.inline.} =

# gtk_tree_view_column_set_clickable
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# arg clickable: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_clickable(self: ptr TTreeViewColumn, clickable: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_clickable".}
proc set_clickable*(self: TreeViewColumn, clickable: bool) {.inline.} =
  gtk_tree_view_column_set_clickable(self, clickable)
# proc set_clickable*(self: TreeViewColumn, clickable: bool) {.inline.} =

# gtk_tree_view_column_set_expand
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# arg expand: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_expand(self: ptr TTreeViewColumn, expand: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_expand".}
proc set_expand*(self: TreeViewColumn, expand: bool) {.inline.} =
  gtk_tree_view_column_set_expand(self, expand)
# proc set_expand*(self: TreeViewColumn, expand: bool) {.inline.} =

# gtk_tree_view_column_set_fixed_width
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# arg fixed_width: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_fixed_width(self: ptr TTreeViewColumn, fixed_width: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_fixed_width".}
proc set_fixed_width*(self: TreeViewColumn, fixed_width: int32) {.inline.} =
  gtk_tree_view_column_set_fixed_width(self, fixed_width)
# proc set_fixed_width*(self: TreeViewColumn, fixed_width: int32) {.inline.} =

# gtk_tree_view_column_set_max_width
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# arg max_width: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_max_width(self: ptr TTreeViewColumn, max_width: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_max_width".}
proc set_max_width*(self: TreeViewColumn, max_width: int32) {.inline.} =
  gtk_tree_view_column_set_max_width(self, max_width)
# proc set_max_width*(self: TreeViewColumn, max_width: int32) {.inline.} =

# gtk_tree_view_column_set_min_width
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# arg min_width: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_min_width(self: ptr TTreeViewColumn, min_width: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_min_width".}
proc set_min_width*(self: TreeViewColumn, min_width: int32) {.inline.} =
  gtk_tree_view_column_set_min_width(self, min_width)
# proc set_min_width*(self: TreeViewColumn, min_width: int32) {.inline.} =

# gtk_tree_view_column_set_reorderable
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# arg reorderable: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_reorderable(self: ptr TTreeViewColumn, reorderable: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_reorderable".}
proc set_reorderable*(self: TreeViewColumn, reorderable: bool) {.inline.} =
  gtk_tree_view_column_set_reorderable(self, reorderable)
# proc set_reorderable*(self: TreeViewColumn, reorderable: bool) {.inline.} =

# gtk_tree_view_column_set_resizable
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# arg resizable: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_resizable(self: ptr TTreeViewColumn, resizable: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_resizable".}
proc set_resizable*(self: TreeViewColumn, resizable: bool) {.inline.} =
  gtk_tree_view_column_set_resizable(self, resizable)
# proc set_resizable*(self: TreeViewColumn, resizable: bool) {.inline.} =

# gtk_tree_view_column_set_sizing
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# arg type: INTERFACE (ENUM) 'TreeViewColumnSizing' 'TreeViewColumnSizing' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_sizing(self: ptr TTreeViewColumn, type_x: TreeViewColumnSizing) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_sizing".}
proc set_sizing*(self: TreeViewColumn, type_x: TreeViewColumnSizing) {.inline.} =
  gtk_tree_view_column_set_sizing(self, type_x)
# proc set_sizing*(self: TreeViewColumn, type_x: TreeViewColumnSizing) {.inline.} =

# gtk_tree_view_column_set_sort_column_id
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# arg sort_column_id: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_sort_column_id(self: ptr TTreeViewColumn, sort_column_id: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_sort_column_id".}
proc set_sort_column_id*(self: TreeViewColumn, sort_column_id: int32) {.inline.} =
  gtk_tree_view_column_set_sort_column_id(self, sort_column_id)
# proc set_sort_column_id*(self: TreeViewColumn, sort_column_id: int32) {.inline.} =

# gtk_tree_view_column_set_sort_indicator
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_sort_indicator(self: ptr TTreeViewColumn, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_sort_indicator".}
proc set_sort_indicator*(self: TreeViewColumn, setting: bool) {.inline.} =
  gtk_tree_view_column_set_sort_indicator(self, setting)
# proc set_sort_indicator*(self: TreeViewColumn, setting: bool) {.inline.} =

# gtk_tree_view_column_set_sort_order
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# arg order: INTERFACE (ENUM) 'SortType' 'SortType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_sort_order(self: ptr TTreeViewColumn, order: SortType) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_sort_order".}
proc set_sort_order*(self: TreeViewColumn, order: SortType) {.inline.} =
  gtk_tree_view_column_set_sort_order(self, order)
# proc set_sort_order*(self: TreeViewColumn, order: SortType) {.inline.} =

# gtk_tree_view_column_set_spacing
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# arg spacing: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_spacing(self: ptr TTreeViewColumn, spacing: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_spacing".}
proc set_spacing*(self: TreeViewColumn, spacing: int32) {.inline.} =
  gtk_tree_view_column_set_spacing(self, spacing)
# proc set_spacing*(self: TreeViewColumn, spacing: int32) {.inline.} =

# gtk_tree_view_column_set_title
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# arg title: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_title(self: ptr TTreeViewColumn, title: ucstring) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_title".}
proc set_title*(self: TreeViewColumn, title: ustring) {.inline.} =
  gtk_tree_view_column_set_title(self, ucstring(title))
# proc set_title*(self: TreeViewColumn, title: ustring) {.inline.} =

# gtk_tree_view_column_set_visible
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# arg visible: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_visible(self: ptr TTreeViewColumn, visible: bool) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_visible".}
proc set_visible*(self: TreeViewColumn, visible: bool) {.inline.} =
  gtk_tree_view_column_set_visible(self, visible)
# proc set_visible*(self: TreeViewColumn, visible: bool) {.inline.} =

# gtk_tree_view_column_set_widget
# flags: {isMethod} container: TreeViewColumn
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_view_column_set_widget(self: ptr TTreeViewColumn, widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_tree_view_column_set_widget".}
proc set_widget*(self: TreeViewColumn, widget: Widget) {.inline.} =
  gtk_tree_view_column_set_widget(self, widget.getPointer)
# proc set_widget*(self: TreeViewColumn, widget: Widget) {.inline.} =

# initializer for UIManager: gtk_ui_manager_get_type
proc gtk_ui_manager_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_ui_manager_get_type".}
template gtype*(klass_parameter: typedesc[UIManager]): GType = gtk_ui_manager_get_type()
# gtk_ui_manager_new
# flags: {isConstructor} container: UIManager (deprecated)
# gtk_ui_manager_add_ui
# flags: {isMethod} container: UIManager (deprecated)
# gtk_ui_manager_add_ui_from_file
# flags: {isMethod, throws} container: UIManager (deprecated)
# can throw
# gtk_ui_manager_add_ui_from_resource
# flags: {isMethod, throws} container: UIManager (deprecated)
# can throw
# gtk_ui_manager_add_ui_from_string
# flags: {isMethod, throws} container: UIManager (deprecated)
# can throw
# gtk_ui_manager_ensure_update
# flags: {isMethod} container: UIManager (deprecated)
# gtk_ui_manager_get_accel_group
# flags: {isMethod} container: UIManager (deprecated)
# gtk_ui_manager_get_action
# flags: {isMethod} container: UIManager (deprecated)
# gtk_ui_manager_get_action_groups
# flags: {isMethod} container: UIManager (deprecated)
# gtk_ui_manager_get_add_tearoffs
# flags: {isMethod} container: UIManager (deprecated)
# gtk_ui_manager_get_toplevels
# flags: {isMethod} container: UIManager (deprecated)
# gtk_ui_manager_get_ui
# flags: {isMethod} container: UIManager (deprecated)
# gtk_ui_manager_get_widget
# flags: {isMethod} container: UIManager (deprecated)
# gtk_ui_manager_insert_action_group
# flags: {isMethod} container: UIManager (deprecated)
# gtk_ui_manager_new_merge_id
# flags: {isMethod} container: UIManager (deprecated)
# gtk_ui_manager_remove_action_group
# flags: {isMethod} container: UIManager (deprecated)
# gtk_ui_manager_remove_ui
# flags: {isMethod} container: UIManager (deprecated)
# gtk_ui_manager_set_add_tearoffs
# flags: {isMethod} container: UIManager (deprecated)
# initializer for VBox: gtk_vbox_get_type
proc gtk_vbox_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_vbox_get_type".}
template gtype*(klass_parameter: typedesc[VBox]): GType = gtk_vbox_get_type()
# gtk_vbox_new
# flags: {isConstructor} container: VBox (deprecated)
# initializer for VButtonBox: gtk_vbutton_box_get_type
proc gtk_vbutton_box_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_vbutton_box_get_type".}
template gtype*(klass_parameter: typedesc[VButtonBox]): GType = gtk_vbutton_box_get_type()
# gtk_vbutton_box_new
# flags: {isConstructor} container: VButtonBox (deprecated)
# initializer for VPaned: gtk_vpaned_get_type
proc gtk_vpaned_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_vpaned_get_type".}
template gtype*(klass_parameter: typedesc[VPaned]): GType = gtk_vpaned_get_type()
# gtk_vpaned_new
# flags: {isConstructor} container: VPaned (deprecated)
# initializer for VScale: gtk_vscale_get_type
proc gtk_vscale_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_vscale_get_type".}
template gtype*(klass_parameter: typedesc[VScale]): GType = gtk_vscale_get_type()
# gtk_vscale_new
# flags: {isConstructor} container: VScale (deprecated)
# gtk_vscale_new_with_range
# flags: {isConstructor} container: VScale (deprecated)
# initializer for VScrollbar: gtk_vscrollbar_get_type
proc gtk_vscrollbar_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_vscrollbar_get_type".}
template gtype*(klass_parameter: typedesc[VScrollbar]): GType = gtk_vscrollbar_get_type()
# gtk_vscrollbar_new
# flags: {isConstructor} container: VScrollbar (deprecated)
# initializer for VSeparator: gtk_vseparator_get_type
proc gtk_vseparator_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_vseparator_get_type".}
template gtype*(klass_parameter: typedesc[VSeparator]): GType = gtk_vseparator_get_type()
# gtk_vseparator_new
# flags: {isConstructor} container: VSeparator (deprecated)
# initializer for Viewport: gtk_viewport_get_type
proc gtk_viewport_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_viewport_get_type".}
template gtype*(klass_parameter: typedesc[Viewport]): GType = gtk_viewport_get_type()
# gtk_viewport_new
# flags: {isConstructor} container: Viewport
# need sugar: is static method
# arg hadjustment: INTERFACE (OBJECT) 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# arg vadjustment: INTERFACE (OBJECT) 'Adjustment' 'ptr TAdjustment' IN (diff., need sugar)
# return: INTERFACE 'Viewport' 'TransferNone[TViewport]' (diff., need sugar)
proc gtk_viewport_new(hadjustment: ptr TAdjustment, vadjustment: ptr TAdjustment): TransferNone[TViewport] {.cdecl, dynlib: lib, importc: "gtk_viewport_new".}
proc new_viewport*(hadjustment: Adjustment, vadjustment: Adjustment): Viewport {.inline.} =
  wrap(gtk_viewport_new(hadjustment.getPointer, vadjustment.getPointer))
# proc new_viewport*(hadjustment: Adjustment, vadjustment: Adjustment): Viewport {.inline.} =

# gtk_viewport_get_bin_window
# flags: {isMethod} container: Viewport
# need sugar: is method
# return: INTERFACE 'Gdk3.Window' 'TransferNone[Gdk3.TWindow]' (diff., need sugar)
proc gtk_viewport_get_bin_window(self: ptr TViewport): TransferNone[Gdk3.TWindow] {.cdecl, dynlib: lib, importc: "gtk_viewport_get_bin_window".}
proc get_bin_window*(self: Viewport): Gdk3.Window {.inline.} =
  wrap(gtk_viewport_get_bin_window(self))
# proc get_bin_window*(self: Viewport): Gdk3.Window {.inline.} =

# gtk_viewport_get_hadjustment
# flags: {isMethod} container: Viewport (deprecated)
# gtk_viewport_get_shadow_type
# flags: {isMethod} container: Viewport
# need sugar: is method
# return: INTERFACE 'ShadowType' 'ShadowType'
proc gtk_viewport_get_shadow_type(self: ptr TViewport): ShadowType {.cdecl, dynlib: lib, importc: "gtk_viewport_get_shadow_type".}
proc get_shadow_type*(self: Viewport): ShadowType {.inline.} =
  gtk_viewport_get_shadow_type(self)
# proc get_shadow_type*(self: Viewport): ShadowType {.inline.} =

# gtk_viewport_get_vadjustment
# flags: {isMethod} container: Viewport (deprecated)
# gtk_viewport_get_view_window
# flags: {isMethod} container: Viewport
# need sugar: is method
# return: INTERFACE 'Gdk3.Window' 'TransferNone[Gdk3.TWindow]' (diff., need sugar)
proc gtk_viewport_get_view_window(self: ptr TViewport): TransferNone[Gdk3.TWindow] {.cdecl, dynlib: lib, importc: "gtk_viewport_get_view_window".}
proc get_view_window*(self: Viewport): Gdk3.Window {.inline.} =
  wrap(gtk_viewport_get_view_window(self))
# proc get_view_window*(self: Viewport): Gdk3.Window {.inline.} =

# gtk_viewport_set_hadjustment
# flags: {isMethod} container: Viewport (deprecated)
# gtk_viewport_set_shadow_type
# flags: {isMethod} container: Viewport
# need sugar: is method
# arg type: INTERFACE (ENUM) 'ShadowType' 'ShadowType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_viewport_set_shadow_type(self: ptr TViewport, type_x: ShadowType) {.cdecl, dynlib: lib, importc: "gtk_viewport_set_shadow_type".}
proc set_shadow_type*(self: Viewport, type_x: ShadowType) {.inline.} =
  gtk_viewport_set_shadow_type(self, type_x)
# proc set_shadow_type*(self: Viewport, type_x: ShadowType) {.inline.} =

# gtk_viewport_set_vadjustment
# flags: {isMethod} container: Viewport (deprecated)
# initializer for VolumeButton: gtk_volume_button_get_type
proc gtk_volume_button_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_volume_button_get_type".}
template gtype*(klass_parameter: typedesc[VolumeButton]): GType = gtk_volume_button_get_type()
# gtk_volume_button_new
# flags: {isConstructor} container: VolumeButton
# need sugar: is static method
# return: INTERFACE 'VolumeButton' 'TransferNone[TVolumeButton]' (diff., need sugar)
proc gtk_volume_button_new(): TransferNone[TVolumeButton] {.cdecl, dynlib: lib, importc: "gtk_volume_button_new".}
proc new_volumebutton*(): VolumeButton {.inline.} =
  wrap(gtk_volume_button_new())
# proc new_volumebutton*(): VolumeButton {.inline.} =

# initializer for Widget: gtk_widget_get_type
proc gtk_widget_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_widget_get_type".}
template gtype*(klass_parameter: typedesc[Widget]): GType = gtk_widget_get_type()
# gtk_widget_get_default_direction
# flags: {} container: Widget
# need sugar: is static method
# return: INTERFACE 'TextDirection' 'TextDirection'
proc gtk_widget_get_default_direction(): TextDirection {.cdecl, dynlib: lib, importc: "gtk_widget_get_default_direction".}
template get_default_direction*(klass_parameter: typedesc[Widget]): TextDirection =
  gtk_widget_get_default_direction()
# template get_default_direction*(klass_parameter: typedesc[Widget]): TextDirection =

# gtk_widget_get_default_style
# flags: {} container: Widget (deprecated)
# gtk_widget_pop_composite_child
# flags: {} container: Widget (deprecated)
# gtk_widget_push_composite_child
# flags: {} container: Widget (deprecated)
# gtk_widget_set_default_direction
# flags: {} container: Widget
# need sugar: is static method
# arg dir: INTERFACE (ENUM) 'TextDirection' 'TextDirection' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_default_direction(dir: TextDirection) {.cdecl, dynlib: lib, importc: "gtk_widget_set_default_direction".}
template set_default_direction*(klass_parameter: typedesc[Widget], dir: TextDirection) =
  gtk_widget_set_default_direction(dir)
# template set_default_direction*(klass_parameter: typedesc[Widget], dir: TextDirection) =

# gtk_widget_activate
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_activate(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_activate".}
proc activate*(self: Widget): bool {.inline.} =
  gtk_widget_activate(self)
# proc activate*(self: Widget): bool {.inline.} =

# gtk_widget_add_accelerator
# flags: {isMethod} container: Widget
# need sugar: is method
# arg accel_signal: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg accel_group: INTERFACE (OBJECT) 'AccelGroup' 'ptr TAccelGroup' IN (diff., need sugar)
# arg accel_key: UINT32 'uint32' 'uint32' IN
# arg accel_mods: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# arg accel_flags: INTERFACE (FLAGS) 'SAccelFlags' 'SAccelFlags' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_add_accelerator(self: ptr TWidget, accel_signal: ucstring, accel_group: ptr TAccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType, accel_flags: SAccelFlags) {.cdecl, dynlib: lib, importc: "gtk_widget_add_accelerator".}
proc add_accelerator*(self: Widget, accel_signal: ustring, accel_group: AccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType, accel_flags: SAccelFlags) {.inline.} =
  gtk_widget_add_accelerator(self, ucstring(accel_signal), accel_group.getPointer, accel_key, accel_mods, accel_flags)
# proc add_accelerator*(self: Widget, accel_signal: ustring, accel_group: AccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType, accel_flags: SAccelFlags) {.inline.} =

# gtk_widget_add_device_events
# flags: {isMethod} container: Widget
# need sugar: is method
# arg device: INTERFACE (OBJECT) 'Gdk3.Device' 'ptr Gdk3.TDevice' IN (diff., need sugar)
# arg events: INTERFACE (FLAGS) 'Gdk3.SEventMask' 'Gdk3.SEventMask' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_add_device_events(self: ptr TWidget, device: ptr Gdk3.TDevice, events: Gdk3.SEventMask) {.cdecl, dynlib: lib, importc: "gtk_widget_add_device_events".}
proc add_device_events*(self: Widget, device: Gdk3.Device, events: Gdk3.SEventMask) {.inline.} =
  gtk_widget_add_device_events(self, device.getPointer, events)
# proc add_device_events*(self: Widget, device: Gdk3.Device, events: Gdk3.SEventMask) {.inline.} =

# gtk_widget_add_events
# flags: {isMethod} container: Widget
# need sugar: is method
# arg events: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_add_events(self: ptr TWidget, events: int32) {.cdecl, dynlib: lib, importc: "gtk_widget_add_events".}
proc add_events*(self: Widget, events: int32) {.inline.} =
  gtk_widget_add_events(self, events)
# proc add_events*(self: Widget, events: int32) {.inline.} =

# gtk_widget_add_mnemonic_label
# flags: {isMethod} container: Widget
# need sugar: is method
# arg label: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_add_mnemonic_label(self: ptr TWidget, label: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_add_mnemonic_label".}
proc add_mnemonic_label*(self: Widget, label: Widget) {.inline.} =
  gtk_widget_add_mnemonic_label(self, label.getPointer)
# proc add_mnemonic_label*(self: Widget, label: Widget) {.inline.} =

# gtk_widget_add_tick_callback
# flags: {isMethod} container: Widget
# need sugar: is method
# arg callback: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg user_data: VOID 'pointer' 'pointer' IN
# arg notify: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: UINT32 'uint32' 'uint32'
proc gtk_widget_add_tick_callback(self: ptr TWidget, callback: pointer, user_data: pointer, notify: pointer): uint32 {.cdecl, dynlib: lib, importc: "gtk_widget_add_tick_callback".}
proc add_tick_callback*(self: Widget, callback: pointer, user_data: pointer, notify: pointer): uint32 {.inline.} =
  gtk_widget_add_tick_callback(self, callback, user_data, notify)
# proc add_tick_callback*(self: Widget, callback: pointer, user_data: pointer, notify: pointer): uint32 {.inline.} =

# gtk_widget_can_activate_accel
# flags: {isMethod} container: Widget
# need sugar: is method
# arg signal_id: UINT32 'uint32' 'uint32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_can_activate_accel(self: ptr TWidget, signal_id: uint32): bool {.cdecl, dynlib: lib, importc: "gtk_widget_can_activate_accel".}
proc can_activate_accel*(self: Widget, signal_id: uint32): bool {.inline.} =
  gtk_widget_can_activate_accel(self, signal_id)
# proc can_activate_accel*(self: Widget, signal_id: uint32): bool {.inline.} =

# gtk_widget_child_focus
# flags: {isMethod} container: Widget
# need sugar: is method
# arg direction: INTERFACE (ENUM) 'DirectionType' 'DirectionType' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_child_focus(self: ptr TWidget, direction: DirectionType): bool {.cdecl, dynlib: lib, importc: "gtk_widget_child_focus".}
proc child_focus*(self: Widget, direction: DirectionType): bool {.inline.} =
  gtk_widget_child_focus(self, direction)
# proc child_focus*(self: Widget, direction: DirectionType): bool {.inline.} =

# gtk_widget_child_notify
# flags: {isMethod} container: Widget
# need sugar: is method
# arg child_property: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_child_notify(self: ptr TWidget, child_property: ucstring) {.cdecl, dynlib: lib, importc: "gtk_widget_child_notify".}
proc child_notify*(self: Widget, child_property: ustring) {.inline.} =
  gtk_widget_child_notify(self, ucstring(child_property))
# proc child_notify*(self: Widget, child_property: ustring) {.inline.} =

# gtk_widget_class_path
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_compute_expand
# flags: {isMethod} container: Widget
# need sugar: is method
# arg orientation: INTERFACE (ENUM) 'Orientation' 'Orientation' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_compute_expand(self: ptr TWidget, orientation: Orientation): bool {.cdecl, dynlib: lib, importc: "gtk_widget_compute_expand".}
proc compute_expand*(self: Widget, orientation: Orientation): bool {.inline.} =
  gtk_widget_compute_expand(self, orientation)
# proc compute_expand*(self: Widget, orientation: Orientation): bool {.inline.} =

# gtk_widget_create_pango_context
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INTERFACE 'Pango1.Context' 'TransferFull[Pango1.TContext]' (diff., need sugar)
proc gtk_widget_create_pango_context(self: ptr TWidget): TransferFull[Pango1.TContext] {.cdecl, dynlib: lib, importc: "gtk_widget_create_pango_context".}
proc create_pango_context*(self: Widget): Pango1.Context {.inline.} =
  wrap(gtk_widget_create_pango_context(self))
# proc create_pango_context*(self: Widget): Pango1.Context {.inline.} =

# gtk_widget_create_pango_layout
# flags: {isMethod} container: Widget
# need sugar: is method
# arg text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'Pango1.Layout' 'TransferFull[Pango1.TLayout]' (diff., need sugar)
proc gtk_widget_create_pango_layout(self: ptr TWidget, text: ucstring): TransferFull[Pango1.TLayout] {.cdecl, dynlib: lib, importc: "gtk_widget_create_pango_layout".}
proc create_pango_layout*(self: Widget, text: ustring): Pango1.Layout {.inline.} =
  wrap(gtk_widget_create_pango_layout(self, ucstring(text)))
# proc create_pango_layout*(self: Widget, text: ustring): Pango1.Layout {.inline.} =

# gtk_widget_destroy
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_destroy(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_destroy".}
proc destroy*(self: Widget) {.inline.} =
  gtk_widget_destroy(self)
# proc destroy*(self: Widget) {.inline.} =

# gtk_widget_destroyed
# flags: {isMethod} container: Widget
# need sugar: is method
# arg widget_pointer: INTERFACE (OBJECT) 'var Widget' 'ptr TWidget' INOUT (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_destroyed(self: ptr TWidget, widget_pointer: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_destroyed".}
proc destroyed*(self: Widget, widget_pointer: var Widget) {.inline.} =
  gtk_widget_destroyed(self, widget_pointer.getPointer)
# proc destroyed*(self: Widget, widget_pointer: var Widget) {.inline.} =

# gtk_widget_device_is_shadowed
# flags: {isMethod} container: Widget
# need sugar: is method
# arg device: INTERFACE (OBJECT) 'Gdk3.Device' 'ptr Gdk3.TDevice' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_device_is_shadowed(self: ptr TWidget, device: ptr Gdk3.TDevice): bool {.cdecl, dynlib: lib, importc: "gtk_widget_device_is_shadowed".}
proc device_is_shadowed*(self: Widget, device: Gdk3.Device): bool {.inline.} =
  gtk_widget_device_is_shadowed(self, device.getPointer)
# proc device_is_shadowed*(self: Widget, device: Gdk3.Device): bool {.inline.} =

# gtk_drag_begin
# flags: {isMethod} container: Widget (deprecated)
# gtk_drag_begin_with_coordinates
# flags: {isMethod} container: Widget
# need sugar: is method
# arg targets: INTERFACE (STRUCT) 'ptr TTargetList' 'ptr TTargetList' IN
# arg actions: INTERFACE (FLAGS) 'Gdk3.SDragAction' 'Gdk3.SDragAction' IN
# arg button: INT32 'int32' 'int32' IN
# arg event: INTERFACE (UNION) 'ptr Gdk3.TEvent' 'ptr Gdk3.TEvent' IN
# arg x: INT32 'int32' 'int32' IN
# arg y: INT32 'int32' 'int32' IN
# return: INTERFACE 'Gdk3.DragContext' 'TransferNone[Gdk3.TDragContext]' (diff., need sugar)
proc gtk_drag_begin_with_coordinates(self: ptr TWidget, targets: ptr TTargetList, actions: Gdk3.SDragAction, button: int32, event: ptr Gdk3.TEvent, x: int32, y: int32): TransferNone[Gdk3.TDragContext] {.cdecl, dynlib: lib, importc: "gtk_drag_begin_with_coordinates".}
proc drag_begin_with_coordinates*(self: Widget, targets: ptr TTargetList, actions: Gdk3.SDragAction, button: int32, event: ptr Gdk3.TEvent, x: int32, y: int32): Gdk3.DragContext {.inline.} =
  wrap(gtk_drag_begin_with_coordinates(self, targets, actions, button, event, x, y))
# proc drag_begin_with_coordinates*(self: Widget, targets: ptr TTargetList, actions: Gdk3.SDragAction, button: int32, event: ptr Gdk3.TEvent, x: int32, y: int32): Gdk3.DragContext {.inline.} =

# gtk_drag_check_threshold
# flags: {isMethod} container: Widget
# need sugar: is method
# arg start_x: INT32 'int32' 'int32' IN
# arg start_y: INT32 'int32' 'int32' IN
# arg current_x: INT32 'int32' 'int32' IN
# arg current_y: INT32 'int32' 'int32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_drag_check_threshold(self: ptr TWidget, start_x: int32, start_y: int32, current_x: int32, current_y: int32): bool {.cdecl, dynlib: lib, importc: "gtk_drag_check_threshold".}
proc drag_check_threshold*(self: Widget, start_x: int32, start_y: int32, current_x: int32, current_y: int32): bool {.inline.} =
  gtk_drag_check_threshold(self, start_x, start_y, current_x, current_y)
# proc drag_check_threshold*(self: Widget, start_x: int32, start_y: int32, current_x: int32, current_y: int32): bool {.inline.} =

# gtk_drag_dest_add_image_targets
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_dest_add_image_targets(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_drag_dest_add_image_targets".}
proc drag_dest_add_image_targets*(self: Widget) {.inline.} =
  gtk_drag_dest_add_image_targets(self)
# proc drag_dest_add_image_targets*(self: Widget) {.inline.} =

# gtk_drag_dest_add_text_targets
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_dest_add_text_targets(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_drag_dest_add_text_targets".}
proc drag_dest_add_text_targets*(self: Widget) {.inline.} =
  gtk_drag_dest_add_text_targets(self)
# proc drag_dest_add_text_targets*(self: Widget) {.inline.} =

# gtk_drag_dest_add_uri_targets
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_dest_add_uri_targets(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_drag_dest_add_uri_targets".}
proc drag_dest_add_uri_targets*(self: Widget) {.inline.} =
  gtk_drag_dest_add_uri_targets(self)
# proc drag_dest_add_uri_targets*(self: Widget) {.inline.} =

# gtk_drag_dest_find_target
# flags: {isMethod} container: Widget
# need sugar: is method
# arg context: INTERFACE (OBJECT) 'Gdk3.DragContext' 'ptr Gdk3.TDragContext' IN (diff., need sugar)
# arg target_list: INTERFACE (STRUCT) 'ptr TTargetList' 'ptr TTargetList' IN
# return: INTERFACE 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom'
proc gtk_drag_dest_find_target(self: ptr TWidget, context: ptr Gdk3.TDragContext, target_list: ptr TTargetList): ptr Gdk3.TAtom {.cdecl, dynlib: lib, importc: "gtk_drag_dest_find_target".}
proc drag_dest_find_target*(self: Widget, context: Gdk3.DragContext, target_list: ptr TTargetList): ptr Gdk3.TAtom {.inline.} =
  gtk_drag_dest_find_target(self, context.getPointer, target_list)
# proc drag_dest_find_target*(self: Widget, context: Gdk3.DragContext, target_list: ptr TTargetList): ptr Gdk3.TAtom {.inline.} =

# gtk_drag_dest_get_target_list
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INTERFACE 'ptr TTargetList' 'ptr TTargetList'
proc gtk_drag_dest_get_target_list(self: ptr TWidget): ptr TTargetList {.cdecl, dynlib: lib, importc: "gtk_drag_dest_get_target_list".}
proc drag_dest_get_target_list*(self: Widget): ptr TTargetList {.inline.} =
  gtk_drag_dest_get_target_list(self)
# proc drag_dest_get_target_list*(self: Widget): ptr TTargetList {.inline.} =

# gtk_drag_dest_get_track_motion
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_drag_dest_get_track_motion(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_drag_dest_get_track_motion".}
proc drag_dest_get_track_motion*(self: Widget): bool {.inline.} =
  gtk_drag_dest_get_track_motion(self)
# proc drag_dest_get_track_motion*(self: Widget): bool {.inline.} =

# gtk_drag_dest_set
# flags: {isMethod} container: Widget
# need sugar: is method
# arg flags: INTERFACE (FLAGS) 'SDestDefaults' 'SDestDefaults' IN
# arg targets: ARRAY 'var openarray[TTargetEntry]' 'openarray[TTargetEntry]' IN (diff., need sugar) array lengthArg: 2
# arg n_targets: INT32 'int32' 'int32' IN
# arg actions: INTERFACE (FLAGS) 'Gdk3.SDragAction' 'Gdk3.SDragAction' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_dest_set(self: ptr TWidget, flags: SDestDefaults, targets: openarray[TTargetEntry], n_targets: int32, actions: Gdk3.SDragAction) {.cdecl, dynlib: lib, importc: "gtk_drag_dest_set".}
proc drag_dest_set*(self: Widget, flags: SDestDefaults, targets: var openarray[TTargetEntry], actions: Gdk3.SDragAction) {.inline.} =
  gtk_drag_dest_set(self, flags, targets, targets.len.int32, actions)
# proc drag_dest_set*(self: Widget, flags: SDestDefaults, targets: var openarray[TTargetEntry], actions: Gdk3.SDragAction) {.inline.} =

# gtk_drag_dest_set_proxy
# flags: {isMethod} container: Widget
# need sugar: is method
# arg proxy_window: INTERFACE (OBJECT) 'Gdk3.Window' 'ptr Gdk3.TWindow' IN (diff., need sugar)
# arg protocol: INTERFACE (ENUM) 'Gdk3.DragProtocol' 'Gdk3.DragProtocol' IN
# arg use_coordinates: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_dest_set_proxy(self: ptr TWidget, proxy_window: ptr Gdk3.TWindow, protocol: Gdk3.DragProtocol, use_coordinates: bool) {.cdecl, dynlib: lib, importc: "gtk_drag_dest_set_proxy".}
proc drag_dest_set_proxy*(self: Widget, proxy_window: Gdk3.Window, protocol: Gdk3.DragProtocol, use_coordinates: bool) {.inline.} =
  gtk_drag_dest_set_proxy(self, proxy_window.getPointer, protocol, use_coordinates)
# proc drag_dest_set_proxy*(self: Widget, proxy_window: Gdk3.Window, protocol: Gdk3.DragProtocol, use_coordinates: bool) {.inline.} =

# gtk_drag_dest_set_target_list
# flags: {isMethod} container: Widget
# need sugar: is method
# arg target_list: INTERFACE (STRUCT) 'ptr TTargetList' 'ptr TTargetList' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_dest_set_target_list(self: ptr TWidget, target_list: ptr TTargetList) {.cdecl, dynlib: lib, importc: "gtk_drag_dest_set_target_list".}
proc drag_dest_set_target_list*(self: Widget, target_list: ptr TTargetList) {.inline.} =
  gtk_drag_dest_set_target_list(self, target_list)
# proc drag_dest_set_target_list*(self: Widget, target_list: ptr TTargetList) {.inline.} =

# gtk_drag_dest_set_track_motion
# flags: {isMethod} container: Widget
# need sugar: is method
# arg track_motion: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_dest_set_track_motion(self: ptr TWidget, track_motion: bool) {.cdecl, dynlib: lib, importc: "gtk_drag_dest_set_track_motion".}
proc drag_dest_set_track_motion*(self: Widget, track_motion: bool) {.inline.} =
  gtk_drag_dest_set_track_motion(self, track_motion)
# proc drag_dest_set_track_motion*(self: Widget, track_motion: bool) {.inline.} =

# gtk_drag_dest_unset
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_dest_unset(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_drag_dest_unset".}
proc drag_dest_unset*(self: Widget) {.inline.} =
  gtk_drag_dest_unset(self)
# proc drag_dest_unset*(self: Widget) {.inline.} =

# gtk_drag_get_data
# flags: {isMethod} container: Widget
# need sugar: is method
# arg context: INTERFACE (OBJECT) 'Gdk3.DragContext' 'ptr Gdk3.TDragContext' IN (diff., need sugar)
# arg target: INTERFACE (STRUCT) 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom' IN
# arg time_: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_get_data(self: ptr TWidget, context: ptr Gdk3.TDragContext, target: ptr Gdk3.TAtom, time_x: uint32) {.cdecl, dynlib: lib, importc: "gtk_drag_get_data".}
proc drag_get_data*(self: Widget, context: Gdk3.DragContext, target: ptr Gdk3.TAtom, time_x: uint32) {.inline.} =
  gtk_drag_get_data(self, context.getPointer, target, time_x)
# proc drag_get_data*(self: Widget, context: Gdk3.DragContext, target: ptr Gdk3.TAtom, time_x: uint32) {.inline.} =

# gtk_drag_highlight
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_highlight(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_drag_highlight".}
proc drag_highlight*(self: Widget) {.inline.} =
  gtk_drag_highlight(self)
# proc drag_highlight*(self: Widget) {.inline.} =

# gtk_drag_source_add_image_targets
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_source_add_image_targets(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_drag_source_add_image_targets".}
proc drag_source_add_image_targets*(self: Widget) {.inline.} =
  gtk_drag_source_add_image_targets(self)
# proc drag_source_add_image_targets*(self: Widget) {.inline.} =

# gtk_drag_source_add_text_targets
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_source_add_text_targets(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_drag_source_add_text_targets".}
proc drag_source_add_text_targets*(self: Widget) {.inline.} =
  gtk_drag_source_add_text_targets(self)
# proc drag_source_add_text_targets*(self: Widget) {.inline.} =

# gtk_drag_source_add_uri_targets
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_source_add_uri_targets(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_drag_source_add_uri_targets".}
proc drag_source_add_uri_targets*(self: Widget) {.inline.} =
  gtk_drag_source_add_uri_targets(self)
# proc drag_source_add_uri_targets*(self: Widget) {.inline.} =

# gtk_drag_source_get_target_list
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INTERFACE 'ptr TTargetList' 'ptr TTargetList'
proc gtk_drag_source_get_target_list(self: ptr TWidget): ptr TTargetList {.cdecl, dynlib: lib, importc: "gtk_drag_source_get_target_list".}
proc drag_source_get_target_list*(self: Widget): ptr TTargetList {.inline.} =
  gtk_drag_source_get_target_list(self)
# proc drag_source_get_target_list*(self: Widget): ptr TTargetList {.inline.} =

# gtk_drag_source_set
# flags: {isMethod} container: Widget
# need sugar: is method
# arg start_button_mask: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# arg targets: ARRAY 'var openarray[TTargetEntry]' 'openarray[TTargetEntry]' IN (diff., need sugar) array lengthArg: 2
# arg n_targets: INT32 'int32' 'int32' IN
# arg actions: INTERFACE (FLAGS) 'Gdk3.SDragAction' 'Gdk3.SDragAction' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_source_set(self: ptr TWidget, start_button_mask: Gdk3.SModifierType, targets: openarray[TTargetEntry], n_targets: int32, actions: Gdk3.SDragAction) {.cdecl, dynlib: lib, importc: "gtk_drag_source_set".}
proc drag_source_set*(self: Widget, start_button_mask: Gdk3.SModifierType, targets: var openarray[TTargetEntry], actions: Gdk3.SDragAction) {.inline.} =
  gtk_drag_source_set(self, start_button_mask, targets, targets.len.int32, actions)
# proc drag_source_set*(self: Widget, start_button_mask: Gdk3.SModifierType, targets: var openarray[TTargetEntry], actions: Gdk3.SDragAction) {.inline.} =

# gtk_drag_source_set_icon_gicon
# flags: {isMethod} container: Widget
# need sugar: is method
# arg icon: INTERFACE (INTERFACE) 'ptr Gio2.TIcon' 'ptr Gio2.TIcon' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_source_set_icon_gicon(self: ptr TWidget, icon: ptr Gio2.TIcon) {.cdecl, dynlib: lib, importc: "gtk_drag_source_set_icon_gicon".}
proc drag_source_set_icon_gicon*(self: Widget, icon: ptr Gio2.TIcon) {.inline.} =
  gtk_drag_source_set_icon_gicon(self, icon)
# proc drag_source_set_icon_gicon*(self: Widget, icon: ptr Gio2.TIcon) {.inline.} =

# gtk_drag_source_set_icon_name
# flags: {isMethod} container: Widget
# need sugar: is method
# arg icon_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_source_set_icon_name(self: ptr TWidget, icon_name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_drag_source_set_icon_name".}
proc drag_source_set_icon_name*(self: Widget, icon_name: ustring) {.inline.} =
  gtk_drag_source_set_icon_name(self, ucstring(icon_name))
# proc drag_source_set_icon_name*(self: Widget, icon_name: ustring) {.inline.} =

# gtk_drag_source_set_icon_pixbuf
# flags: {isMethod} container: Widget
# need sugar: is method
# arg pixbuf: INTERFACE (OBJECT) 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_source_set_icon_pixbuf(self: ptr TWidget, pixbuf: ptr GdkPixbuf2.TPixbuf) {.cdecl, dynlib: lib, importc: "gtk_drag_source_set_icon_pixbuf".}
proc drag_source_set_icon_pixbuf*(self: Widget, pixbuf: GdkPixbuf2.Pixbuf) {.inline.} =
  gtk_drag_source_set_icon_pixbuf(self, pixbuf.getPointer)
# proc drag_source_set_icon_pixbuf*(self: Widget, pixbuf: GdkPixbuf2.Pixbuf) {.inline.} =

# gtk_drag_source_set_icon_stock
# flags: {isMethod} container: Widget (deprecated)
# gtk_drag_source_set_target_list
# flags: {isMethod} container: Widget
# need sugar: is method
# arg target_list: INTERFACE (STRUCT) 'ptr TTargetList' 'ptr TTargetList' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_source_set_target_list(self: ptr TWidget, target_list: ptr TTargetList) {.cdecl, dynlib: lib, importc: "gtk_drag_source_set_target_list".}
proc drag_source_set_target_list*(self: Widget, target_list: ptr TTargetList) {.inline.} =
  gtk_drag_source_set_target_list(self, target_list)
# proc drag_source_set_target_list*(self: Widget, target_list: ptr TTargetList) {.inline.} =

# gtk_drag_source_unset
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_source_unset(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_drag_source_unset".}
proc drag_source_unset*(self: Widget) {.inline.} =
  gtk_drag_source_unset(self)
# proc drag_source_unset*(self: Widget) {.inline.} =

# gtk_drag_unhighlight
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_drag_unhighlight(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_drag_unhighlight".}
proc drag_unhighlight*(self: Widget) {.inline.} =
  gtk_drag_unhighlight(self)
# proc drag_unhighlight*(self: Widget) {.inline.} =

# gtk_widget_draw
# flags: {isMethod} container: Widget
# need sugar: is method
# arg cr: INTERFACE (STRUCT) 'ptr cairo1.TContext' 'ptr cairo1.TContext' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_draw(self: ptr TWidget, cr: ptr cairo1.TContext) {.cdecl, dynlib: lib, importc: "gtk_widget_draw".}
proc draw*(self: Widget, cr: ptr cairo1.TContext) {.inline.} =
  gtk_widget_draw(self, cr)
# proc draw*(self: Widget, cr: ptr cairo1.TContext) {.inline.} =

# gtk_widget_ensure_style
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_error_bell
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_error_bell(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_error_bell".}
proc error_bell*(self: Widget) {.inline.} =
  gtk_widget_error_bell(self)
# proc error_bell*(self: Widget) {.inline.} =

# gtk_widget_event
# flags: {isMethod} container: Widget
# need sugar: is method
# arg event: INTERFACE (UNION) 'ptr Gdk3.TEvent' 'ptr Gdk3.TEvent' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_event(self: ptr TWidget, event: ptr Gdk3.TEvent): bool {.cdecl, dynlib: lib, importc: "gtk_widget_event".}
proc event*(self: Widget, event: ptr Gdk3.TEvent): bool {.inline.} =
  gtk_widget_event(self, event)
# proc event*(self: Widget, event: ptr Gdk3.TEvent): bool {.inline.} =

# gtk_widget_freeze_child_notify
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_freeze_child_notify(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_freeze_child_notify".}
proc freeze_child_notify*(self: Widget) {.inline.} =
  gtk_widget_freeze_child_notify(self)
# proc freeze_child_notify*(self: Widget) {.inline.} =

# gtk_widget_get_accessible
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INTERFACE 'Atk1.Object' 'TransferNone[Atk1.TObject]' (diff., need sugar)
proc gtk_widget_get_accessible(self: ptr TWidget): TransferNone[Atk1.TObject] {.cdecl, dynlib: lib, importc: "gtk_widget_get_accessible".}
proc get_accessible*(self: Widget): Atk1.Object {.inline.} =
  wrap(gtk_widget_get_accessible(self))
# proc get_accessible*(self: Widget): Atk1.Object {.inline.} =

# gtk_widget_get_action_group
# flags: {isMethod} container: Widget
# need sugar: is method
# arg prefix: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'ptr Gio2.TActionGroup' 'TransferNone[Gio2.TActionGroup]' (diff., need sugar)
proc gtk_widget_get_action_group(self: ptr TWidget, prefix: ucstring): TransferNone[Gio2.TActionGroup] {.cdecl, dynlib: lib, importc: "gtk_widget_get_action_group".}
proc get_action_group*(self: Widget, prefix: ustring): ptr Gio2.TActionGroup {.inline.} =
  wrap(gtk_widget_get_action_group(self, ucstring(prefix)))
# proc get_action_group*(self: Widget, prefix: ustring): ptr Gio2.TActionGroup {.inline.} =

# gtk_widget_get_allocated_baseline
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_widget_get_allocated_baseline(self: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_get_allocated_baseline".}
proc get_allocated_baseline*(self: Widget): int32 {.inline.} =
  gtk_widget_get_allocated_baseline(self)
# proc get_allocated_baseline*(self: Widget): int32 {.inline.} =

# gtk_widget_get_allocated_height
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_widget_get_allocated_height(self: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_get_allocated_height".}
proc get_allocated_height*(self: Widget): int32 {.inline.} =
  gtk_widget_get_allocated_height(self)
# proc get_allocated_height*(self: Widget): int32 {.inline.} =

# gtk_widget_get_allocated_width
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_widget_get_allocated_width(self: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_get_allocated_width".}
proc get_allocated_width*(self: Widget): int32 {.inline.} =
  gtk_widget_get_allocated_width(self)
# proc get_allocated_width*(self: Widget): int32 {.inline.} =

# gtk_widget_get_allocation
# flags: {isMethod} container: Widget
# need sugar: is method
# arg allocation: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' OUT caller-allocates
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_get_allocation(self: ptr TWidget, allocation: ptr Gdk3.TRectangle) {.cdecl, dynlib: lib, importc: "gtk_widget_get_allocation".}
proc get_allocation*(self: Widget, allocation: ptr Gdk3.TRectangle) {.inline.} =
  gtk_widget_get_allocation(self, allocation)
# tuple-return
# allocation: ptr Gdk3.TRectangle
# proc get_allocation*(self: Widget) {.inline.} =

# gtk_widget_get_ancestor
# flags: {isMethod} container: Widget
# need sugar: is method
# arg widget_type: GTYPE 'GType' 'GType' IN
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_widget_get_ancestor(self: ptr TWidget, widget_type: GType): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_widget_get_ancestor".}
proc get_ancestor*(self: Widget, widget_type: GType): Widget {.inline.} =
  wrap(gtk_widget_get_ancestor(self, widget_type))
# proc get_ancestor*(self: Widget, widget_type: GType): Widget {.inline.} =

# gtk_widget_get_app_paintable
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_get_app_paintable(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_app_paintable".}
proc get_app_paintable*(self: Widget): bool {.inline.} =
  gtk_widget_get_app_paintable(self)
# proc get_app_paintable*(self: Widget): bool {.inline.} =

# gtk_widget_get_can_default
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_get_can_default(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_can_default".}
proc get_can_default*(self: Widget): bool {.inline.} =
  gtk_widget_get_can_default(self)
# proc get_can_default*(self: Widget): bool {.inline.} =

# gtk_widget_get_can_focus
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_get_can_focus(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_can_focus".}
proc get_can_focus*(self: Widget): bool {.inline.} =
  gtk_widget_get_can_focus(self)
# proc get_can_focus*(self: Widget): bool {.inline.} =

# gtk_widget_get_child_requisition
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_get_child_visible
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_get_child_visible(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_child_visible".}
proc get_child_visible*(self: Widget): bool {.inline.} =
  gtk_widget_get_child_visible(self)
# proc get_child_visible*(self: Widget): bool {.inline.} =

# gtk_widget_get_clip
# flags: {isMethod} container: Widget
# need sugar: is method
# arg clip: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' OUT caller-allocates
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_get_clip(self: ptr TWidget, clip: ptr Gdk3.TRectangle) {.cdecl, dynlib: lib, importc: "gtk_widget_get_clip".}
proc get_clip*(self: Widget, clip: ptr Gdk3.TRectangle) {.inline.} =
  gtk_widget_get_clip(self, clip)
# tuple-return
# clip: ptr Gdk3.TRectangle
# proc get_clip*(self: Widget) {.inline.} =

# gtk_widget_get_clipboard
# flags: {isMethod} container: Widget
# need sugar: is method
# arg selection: INTERFACE (STRUCT) 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom' IN
# return: INTERFACE 'Clipboard' 'TransferNone[TClipboard]' (diff., need sugar)
proc gtk_widget_get_clipboard(self: ptr TWidget, selection: ptr Gdk3.TAtom): TransferNone[TClipboard] {.cdecl, dynlib: lib, importc: "gtk_widget_get_clipboard".}
proc get_clipboard*(self: Widget, selection: ptr Gdk3.TAtom): Clipboard {.inline.} =
  wrap(gtk_widget_get_clipboard(self, selection))
# proc get_clipboard*(self: Widget, selection: ptr Gdk3.TAtom): Clipboard {.inline.} =

# gtk_widget_get_composite_name
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_get_device_enabled
# flags: {isMethod} container: Widget
# need sugar: is method
# arg device: INTERFACE (OBJECT) 'Gdk3.Device' 'ptr Gdk3.TDevice' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_get_device_enabled(self: ptr TWidget, device: ptr Gdk3.TDevice): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_device_enabled".}
proc get_device_enabled*(self: Widget, device: Gdk3.Device): bool {.inline.} =
  gtk_widget_get_device_enabled(self, device.getPointer)
# proc get_device_enabled*(self: Widget, device: Gdk3.Device): bool {.inline.} =

# gtk_widget_get_device_events
# flags: {isMethod} container: Widget
# need sugar: is method
# arg device: INTERFACE (OBJECT) 'Gdk3.Device' 'ptr Gdk3.TDevice' IN (diff., need sugar)
# return: INTERFACE 'Gdk3.SEventMask' 'Gdk3.SEventMask'
proc gtk_widget_get_device_events(self: ptr TWidget, device: ptr Gdk3.TDevice): Gdk3.SEventMask {.cdecl, dynlib: lib, importc: "gtk_widget_get_device_events".}
proc get_device_events*(self: Widget, device: Gdk3.Device): Gdk3.SEventMask {.inline.} =
  gtk_widget_get_device_events(self, device.getPointer)
# proc get_device_events*(self: Widget, device: Gdk3.Device): Gdk3.SEventMask {.inline.} =

# gtk_widget_get_direction
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INTERFACE 'TextDirection' 'TextDirection'
proc gtk_widget_get_direction(self: ptr TWidget): TextDirection {.cdecl, dynlib: lib, importc: "gtk_widget_get_direction".}
proc get_direction*(self: Widget): TextDirection {.inline.} =
  gtk_widget_get_direction(self)
# proc get_direction*(self: Widget): TextDirection {.inline.} =

# gtk_widget_get_display
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INTERFACE 'Gdk3.Display' 'TransferNone[Gdk3.TDisplay]' (diff., need sugar)
proc gtk_widget_get_display(self: ptr TWidget): TransferNone[Gdk3.TDisplay] {.cdecl, dynlib: lib, importc: "gtk_widget_get_display".}
proc get_display*(self: Widget): Gdk3.Display {.inline.} =
  wrap(gtk_widget_get_display(self))
# proc get_display*(self: Widget): Gdk3.Display {.inline.} =

# gtk_widget_get_double_buffered
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_get_double_buffered(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_double_buffered".}
proc get_double_buffered*(self: Widget): bool {.inline.} =
  gtk_widget_get_double_buffered(self)
# proc get_double_buffered*(self: Widget): bool {.inline.} =

# gtk_widget_get_events
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_widget_get_events(self: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_get_events".}
proc get_events*(self: Widget): int32 {.inline.} =
  gtk_widget_get_events(self)
# proc get_events*(self: Widget): int32 {.inline.} =

# gtk_widget_get_font_map
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INTERFACE 'Pango1.FontMap' 'TransferNone[Pango1.TFontMap]' (diff., need sugar)
proc gtk_widget_get_font_map(self: ptr TWidget): TransferNone[Pango1.TFontMap] {.cdecl, dynlib: lib, importc: "gtk_widget_get_font_map".}
proc get_font_map*(self: Widget): Pango1.FontMap {.inline.} =
  wrap(gtk_widget_get_font_map(self))
# proc get_font_map*(self: Widget): Pango1.FontMap {.inline.} =

# gtk_widget_get_font_options
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INTERFACE 'ptr cairo1.TFontOptions' 'ptr cairo1.TFontOptions'
proc gtk_widget_get_font_options(self: ptr TWidget): ptr cairo1.TFontOptions {.cdecl, dynlib: lib, importc: "gtk_widget_get_font_options".}
proc get_font_options*(self: Widget): ptr cairo1.TFontOptions {.inline.} =
  gtk_widget_get_font_options(self)
# proc get_font_options*(self: Widget): ptr cairo1.TFontOptions {.inline.} =

# gtk_widget_get_frame_clock
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INTERFACE 'Gdk3.FrameClock' 'TransferNone[Gdk3.TFrameClock]' (diff., need sugar)
proc gtk_widget_get_frame_clock(self: ptr TWidget): TransferNone[Gdk3.TFrameClock] {.cdecl, dynlib: lib, importc: "gtk_widget_get_frame_clock".}
proc get_frame_clock*(self: Widget): Gdk3.FrameClock {.inline.} =
  wrap(gtk_widget_get_frame_clock(self))
# proc get_frame_clock*(self: Widget): Gdk3.FrameClock {.inline.} =

# gtk_widget_get_halign
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INTERFACE 'Align' 'Align'
proc gtk_widget_get_halign(self: ptr TWidget): Align {.cdecl, dynlib: lib, importc: "gtk_widget_get_halign".}
proc get_halign*(self: Widget): Align {.inline.} =
  gtk_widget_get_halign(self)
# proc get_halign*(self: Widget): Align {.inline.} =

# gtk_widget_get_has_tooltip
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_get_has_tooltip(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_has_tooltip".}
proc get_has_tooltip*(self: Widget): bool {.inline.} =
  gtk_widget_get_has_tooltip(self)
# proc get_has_tooltip*(self: Widget): bool {.inline.} =

# gtk_widget_get_has_window
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_get_has_window(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_has_window".}
proc get_has_window*(self: Widget): bool {.inline.} =
  gtk_widget_get_has_window(self)
# proc get_has_window*(self: Widget): bool {.inline.} =

# gtk_widget_get_hexpand
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_get_hexpand(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_hexpand".}
proc get_hexpand*(self: Widget): bool {.inline.} =
  gtk_widget_get_hexpand(self)
# proc get_hexpand*(self: Widget): bool {.inline.} =

# gtk_widget_get_hexpand_set
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_get_hexpand_set(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_hexpand_set".}
proc get_hexpand_set*(self: Widget): bool {.inline.} =
  gtk_widget_get_hexpand_set(self)
# proc get_hexpand_set*(self: Widget): bool {.inline.} =

# gtk_widget_get_mapped
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_get_mapped(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_mapped".}
proc get_mapped*(self: Widget): bool {.inline.} =
  gtk_widget_get_mapped(self)
# proc get_mapped*(self: Widget): bool {.inline.} =

# gtk_widget_get_margin_bottom
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_widget_get_margin_bottom(self: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_get_margin_bottom".}
proc get_margin_bottom*(self: Widget): int32 {.inline.} =
  gtk_widget_get_margin_bottom(self)
# proc get_margin_bottom*(self: Widget): int32 {.inline.} =

# gtk_widget_get_margin_end
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_widget_get_margin_end(self: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_get_margin_end".}
proc get_margin_end*(self: Widget): int32 {.inline.} =
  gtk_widget_get_margin_end(self)
# proc get_margin_end*(self: Widget): int32 {.inline.} =

# gtk_widget_get_margin_left
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_get_margin_right
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_get_margin_start
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_widget_get_margin_start(self: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_get_margin_start".}
proc get_margin_start*(self: Widget): int32 {.inline.} =
  gtk_widget_get_margin_start(self)
# proc get_margin_start*(self: Widget): int32 {.inline.} =

# gtk_widget_get_margin_top
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_widget_get_margin_top(self: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_get_margin_top".}
proc get_margin_top*(self: Widget): int32 {.inline.} =
  gtk_widget_get_margin_top(self)
# proc get_margin_top*(self: Widget): int32 {.inline.} =

# gtk_widget_get_modifier_mask
# flags: {isMethod} container: Widget
# need sugar: is method
# arg intent: INTERFACE (ENUM) 'Gdk3.ModifierIntent' 'Gdk3.ModifierIntent' IN
# return: INTERFACE 'Gdk3.SModifierType' 'Gdk3.SModifierType'
proc gtk_widget_get_modifier_mask(self: ptr TWidget, intent: Gdk3.ModifierIntent): Gdk3.SModifierType {.cdecl, dynlib: lib, importc: "gtk_widget_get_modifier_mask".}
proc get_modifier_mask*(self: Widget, intent: Gdk3.ModifierIntent): Gdk3.SModifierType {.inline.} =
  gtk_widget_get_modifier_mask(self, intent)
# proc get_modifier_mask*(self: Widget, intent: Gdk3.ModifierIntent): Gdk3.SModifierType {.inline.} =

# gtk_widget_get_modifier_style
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_get_name
# flags: {isMethod} container: Widget
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_widget_get_name(self: ptr TWidget): ucstring {.cdecl, dynlib: lib, importc: "gtk_widget_get_name".}
proc get_name*(self: Widget): ucstring {.inline.} =
  gtk_widget_get_name(self)
# proc get_name*(self: Widget): ucstring {.inline.} =

# gtk_widget_get_no_show_all
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_get_no_show_all(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_no_show_all".}
proc get_no_show_all*(self: Widget): bool {.inline.} =
  gtk_widget_get_no_show_all(self)
# proc get_no_show_all*(self: Widget): bool {.inline.} =

# gtk_widget_get_opacity
# flags: {isMethod} container: Widget
# need sugar: is method
# return: DOUBLE 'float64' 'float64'
proc gtk_widget_get_opacity(self: ptr TWidget): float64 {.cdecl, dynlib: lib, importc: "gtk_widget_get_opacity".}
proc get_opacity*(self: Widget): float64 {.inline.} =
  gtk_widget_get_opacity(self)
# proc get_opacity*(self: Widget): float64 {.inline.} =

# gtk_widget_get_pango_context
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INTERFACE 'Pango1.Context' 'TransferNone[Pango1.TContext]' (diff., need sugar)
proc gtk_widget_get_pango_context(self: ptr TWidget): TransferNone[Pango1.TContext] {.cdecl, dynlib: lib, importc: "gtk_widget_get_pango_context".}
proc get_pango_context*(self: Widget): Pango1.Context {.inline.} =
  wrap(gtk_widget_get_pango_context(self))
# proc get_pango_context*(self: Widget): Pango1.Context {.inline.} =

# gtk_widget_get_parent
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_widget_get_parent(self: ptr TWidget): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_widget_get_parent".}
proc get_parent*(self: Widget): Widget {.inline.} =
  wrap(gtk_widget_get_parent(self))
# proc get_parent*(self: Widget): Widget {.inline.} =

# gtk_widget_get_parent_window
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INTERFACE 'Gdk3.Window' 'TransferNone[Gdk3.TWindow]' (diff., need sugar)
proc gtk_widget_get_parent_window(self: ptr TWidget): TransferNone[Gdk3.TWindow] {.cdecl, dynlib: lib, importc: "gtk_widget_get_parent_window".}
proc get_parent_window*(self: Widget): Gdk3.Window {.inline.} =
  wrap(gtk_widget_get_parent_window(self))
# proc get_parent_window*(self: Widget): Gdk3.Window {.inline.} =

# gtk_widget_get_path
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INTERFACE 'ptr TWidgetPath' 'ptr TWidgetPath'
proc gtk_widget_get_path(self: ptr TWidget): ptr TWidgetPath {.cdecl, dynlib: lib, importc: "gtk_widget_get_path".}
proc get_path*(self: Widget): ptr TWidgetPath {.inline.} =
  gtk_widget_get_path(self)
# proc get_path*(self: Widget): ptr TWidgetPath {.inline.} =

# gtk_widget_get_pointer
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_get_preferred_height
# flags: {isMethod} container: Widget
# need sugar: is method
# arg minimum_height: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg natural_height: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_get_preferred_height(self: ptr TWidget, minimum_height: ptr int32, natural_height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_widget_get_preferred_height".}
proc get_preferred_height*(self: Widget, minimum_height: var int32, natural_height: var int32) {.inline.} =
  gtk_widget_get_preferred_height(self, addr(minimum_height), addr(natural_height))
# tuple-return
# minimum_height: var int32
# natural_height: var int32
# proc get_preferred_height*(self: Widget) {.inline.} =

# gtk_widget_get_preferred_height_and_baseline_for_width
# flags: {isMethod} container: Widget
# need sugar: is method
# arg width: INT32 'int32' 'int32' IN
# arg minimum_height: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg natural_height: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg minimum_baseline: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg natural_baseline: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_get_preferred_height_and_baseline_for_width(self: ptr TWidget, width: int32, minimum_height: ptr int32, natural_height: ptr int32, minimum_baseline: ptr int32, natural_baseline: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_widget_get_preferred_height_and_baseline_for_width".}
proc get_preferred_height_and_baseline_for_width*(self: Widget, width: int32, minimum_height: var int32, natural_height: var int32, minimum_baseline: var int32, natural_baseline: var int32) {.inline.} =
  gtk_widget_get_preferred_height_and_baseline_for_width(self, width, addr(minimum_height), addr(natural_height), addr(minimum_baseline), addr(natural_baseline))
# tuple-return
# minimum_height: var int32
# natural_height: var int32
# minimum_baseline: var int32
# natural_baseline: var int32
# proc get_preferred_height_and_baseline_for_width*(self: Widget, width: int32) {.inline.} =

# gtk_widget_get_preferred_height_for_width
# flags: {isMethod} container: Widget
# need sugar: is method
# arg width: INT32 'int32' 'int32' IN
# arg minimum_height: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg natural_height: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_get_preferred_height_for_width(self: ptr TWidget, width: int32, minimum_height: ptr int32, natural_height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_widget_get_preferred_height_for_width".}
proc get_preferred_height_for_width*(self: Widget, width: int32, minimum_height: var int32, natural_height: var int32) {.inline.} =
  gtk_widget_get_preferred_height_for_width(self, width, addr(minimum_height), addr(natural_height))
# tuple-return
# minimum_height: var int32
# natural_height: var int32
# proc get_preferred_height_for_width*(self: Widget, width: int32) {.inline.} =

# gtk_widget_get_preferred_size
# flags: {isMethod} container: Widget
# need sugar: is method
# arg minimum_size: INTERFACE (STRUCT) 'ptr TRequisition' 'ptr TRequisition' OUT caller-allocates optional
# arg natural_size: INTERFACE (STRUCT) 'ptr TRequisition' 'ptr TRequisition' OUT caller-allocates optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_get_preferred_size(self: ptr TWidget, minimum_size: ptr TRequisition, natural_size: ptr TRequisition) {.cdecl, dynlib: lib, importc: "gtk_widget_get_preferred_size".}
proc get_preferred_size*(self: Widget, minimum_size: ptr TRequisition, natural_size: ptr TRequisition) {.inline.} =
  gtk_widget_get_preferred_size(self, minimum_size, natural_size)
# tuple-return
# minimum_size: ptr TRequisition
# natural_size: ptr TRequisition
# proc get_preferred_size*(self: Widget) {.inline.} =

# gtk_widget_get_preferred_width
# flags: {isMethod} container: Widget
# need sugar: is method
# arg minimum_width: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg natural_width: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_get_preferred_width(self: ptr TWidget, minimum_width: ptr int32, natural_width: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_widget_get_preferred_width".}
proc get_preferred_width*(self: Widget, minimum_width: var int32, natural_width: var int32) {.inline.} =
  gtk_widget_get_preferred_width(self, addr(minimum_width), addr(natural_width))
# tuple-return
# minimum_width: var int32
# natural_width: var int32
# proc get_preferred_width*(self: Widget) {.inline.} =

# gtk_widget_get_preferred_width_for_height
# flags: {isMethod} container: Widget
# need sugar: is method
# arg height: INT32 'int32' 'int32' IN
# arg minimum_width: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg natural_width: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_get_preferred_width_for_height(self: ptr TWidget, height: int32, minimum_width: ptr int32, natural_width: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_widget_get_preferred_width_for_height".}
proc get_preferred_width_for_height*(self: Widget, height: int32, minimum_width: var int32, natural_width: var int32) {.inline.} =
  gtk_widget_get_preferred_width_for_height(self, height, addr(minimum_width), addr(natural_width))
# tuple-return
# minimum_width: var int32
# natural_width: var int32
# proc get_preferred_width_for_height*(self: Widget, height: int32) {.inline.} =

# gtk_widget_get_realized
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_get_realized(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_realized".}
proc get_realized*(self: Widget): bool {.inline.} =
  gtk_widget_get_realized(self)
# proc get_realized*(self: Widget): bool {.inline.} =

# gtk_widget_get_receives_default
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_get_receives_default(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_receives_default".}
proc get_receives_default*(self: Widget): bool {.inline.} =
  gtk_widget_get_receives_default(self)
# proc get_receives_default*(self: Widget): bool {.inline.} =

# gtk_widget_get_request_mode
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INTERFACE 'SizeRequestMode' 'SizeRequestMode'
proc gtk_widget_get_request_mode(self: ptr TWidget): SizeRequestMode {.cdecl, dynlib: lib, importc: "gtk_widget_get_request_mode".}
proc get_request_mode*(self: Widget): SizeRequestMode {.inline.} =
  gtk_widget_get_request_mode(self)
# proc get_request_mode*(self: Widget): SizeRequestMode {.inline.} =

# gtk_widget_get_requisition
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_get_root_window
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_get_scale_factor
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_widget_get_scale_factor(self: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_get_scale_factor".}
proc get_scale_factor*(self: Widget): int32 {.inline.} =
  gtk_widget_get_scale_factor(self)
# proc get_scale_factor*(self: Widget): int32 {.inline.} =

# gtk_widget_get_screen
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INTERFACE 'Gdk3.Screen' 'TransferNone[Gdk3.TScreen]' (diff., need sugar)
proc gtk_widget_get_screen(self: ptr TWidget): TransferNone[Gdk3.TScreen] {.cdecl, dynlib: lib, importc: "gtk_widget_get_screen".}
proc get_screen*(self: Widget): Gdk3.Screen {.inline.} =
  wrap(gtk_widget_get_screen(self))
# proc get_screen*(self: Widget): Gdk3.Screen {.inline.} =

# gtk_widget_get_sensitive
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_get_sensitive(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_sensitive".}
proc get_sensitive*(self: Widget): bool {.inline.} =
  gtk_widget_get_sensitive(self)
# proc get_sensitive*(self: Widget): bool {.inline.} =

# gtk_widget_get_settings
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INTERFACE 'Settings' 'TransferNone[TSettings]' (diff., need sugar)
proc gtk_widget_get_settings(self: ptr TWidget): TransferNone[TSettings] {.cdecl, dynlib: lib, importc: "gtk_widget_get_settings".}
proc get_settings*(self: Widget): Settings {.inline.} =
  wrap(gtk_widget_get_settings(self))
# proc get_settings*(self: Widget): Settings {.inline.} =

# gtk_widget_get_size_request
# flags: {isMethod} container: Widget
# need sugar: is method
# arg width: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg height: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_get_size_request(self: ptr TWidget, width: ptr int32, height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_widget_get_size_request".}
proc get_size_request*(self: Widget, width: var int32, height: var int32) {.inline.} =
  gtk_widget_get_size_request(self, addr(width), addr(height))
# tuple-return
# width: var int32
# height: var int32
# proc get_size_request*(self: Widget) {.inline.} =

# gtk_widget_get_state
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_get_state_flags
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INTERFACE 'SStateFlags' 'SStateFlags'
proc gtk_widget_get_state_flags(self: ptr TWidget): SStateFlags {.cdecl, dynlib: lib, importc: "gtk_widget_get_state_flags".}
proc get_state_flags*(self: Widget): SStateFlags {.inline.} =
  gtk_widget_get_state_flags(self)
# proc get_state_flags*(self: Widget): SStateFlags {.inline.} =

# gtk_widget_get_style
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_get_style_context
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INTERFACE 'StyleContext' 'TransferNone[TStyleContext]' (diff., need sugar)
proc gtk_widget_get_style_context(self: ptr TWidget): TransferNone[TStyleContext] {.cdecl, dynlib: lib, importc: "gtk_widget_get_style_context".}
proc get_style_context*(self: Widget): StyleContext {.inline.} =
  wrap(gtk_widget_get_style_context(self))
# proc get_style_context*(self: Widget): StyleContext {.inline.} =

# gtk_widget_get_support_multidevice
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_get_support_multidevice(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_support_multidevice".}
proc get_support_multidevice*(self: Widget): bool {.inline.} =
  gtk_widget_get_support_multidevice(self)
# proc get_support_multidevice*(self: Widget): bool {.inline.} =

# gtk_widget_get_template_child
# flags: {isMethod} container: Widget
# need sugar: is method
# arg widget_type: GTYPE 'GType' 'GType' IN
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'GObject2.Object' 'TransferNone[GObject2.TObject]' (diff., need sugar)
proc gtk_widget_get_template_child(self: ptr TWidget, widget_type: GType, name: ucstring): TransferNone[GObject2.TObject] {.cdecl, dynlib: lib, importc: "gtk_widget_get_template_child".}
proc get_template_child*(self: Widget, widget_type: GType, name: ustring): GObject2.Object {.inline.} =
  wrap(gtk_widget_get_template_child(self, widget_type, ucstring(name)))
# proc get_template_child*(self: Widget, widget_type: GType, name: ustring): GObject2.Object {.inline.} =

# gtk_widget_get_tooltip_markup
# flags: {isMethod} container: Widget
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_widget_get_tooltip_markup(self: ptr TWidget): ucstring {.cdecl, dynlib: lib, importc: "gtk_widget_get_tooltip_markup".}
proc get_tooltip_markup*(self: Widget): ucstring {.inline.} =
  gtk_widget_get_tooltip_markup(self)
# proc get_tooltip_markup*(self: Widget): ucstring {.inline.} =

# gtk_widget_get_tooltip_text
# flags: {isMethod} container: Widget
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_widget_get_tooltip_text(self: ptr TWidget): ucstring {.cdecl, dynlib: lib, importc: "gtk_widget_get_tooltip_text".}
proc get_tooltip_text*(self: Widget): ucstring {.inline.} =
  gtk_widget_get_tooltip_text(self)
# proc get_tooltip_text*(self: Widget): ucstring {.inline.} =

# gtk_widget_get_tooltip_window
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INTERFACE 'Window' 'TransferNone[TWindow]' (diff., need sugar)
proc gtk_widget_get_tooltip_window(self: ptr TWidget): TransferNone[TWindow] {.cdecl, dynlib: lib, importc: "gtk_widget_get_tooltip_window".}
proc get_tooltip_window*(self: Widget): Window {.inline.} =
  wrap(gtk_widget_get_tooltip_window(self))
# proc get_tooltip_window*(self: Widget): Window {.inline.} =

# gtk_widget_get_toplevel
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_widget_get_toplevel(self: ptr TWidget): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_widget_get_toplevel".}
proc get_toplevel*(self: Widget): Widget {.inline.} =
  wrap(gtk_widget_get_toplevel(self))
# proc get_toplevel*(self: Widget): Widget {.inline.} =

# gtk_widget_get_valign
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INTERFACE 'Align' 'Align'
proc gtk_widget_get_valign(self: ptr TWidget): Align {.cdecl, dynlib: lib, importc: "gtk_widget_get_valign".}
proc get_valign*(self: Widget): Align {.inline.} =
  gtk_widget_get_valign(self)
# proc get_valign*(self: Widget): Align {.inline.} =

# gtk_widget_get_valign_with_baseline
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INTERFACE 'Align' 'Align'
proc gtk_widget_get_valign_with_baseline(self: ptr TWidget): Align {.cdecl, dynlib: lib, importc: "gtk_widget_get_valign_with_baseline".}
proc get_valign_with_baseline*(self: Widget): Align {.inline.} =
  gtk_widget_get_valign_with_baseline(self)
# proc get_valign_with_baseline*(self: Widget): Align {.inline.} =

# gtk_widget_get_vexpand
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_get_vexpand(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_vexpand".}
proc get_vexpand*(self: Widget): bool {.inline.} =
  gtk_widget_get_vexpand(self)
# proc get_vexpand*(self: Widget): bool {.inline.} =

# gtk_widget_get_vexpand_set
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_get_vexpand_set(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_vexpand_set".}
proc get_vexpand_set*(self: Widget): bool {.inline.} =
  gtk_widget_get_vexpand_set(self)
# proc get_vexpand_set*(self: Widget): bool {.inline.} =

# gtk_widget_get_visible
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_get_visible(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_get_visible".}
proc get_visible*(self: Widget): bool {.inline.} =
  gtk_widget_get_visible(self)
# proc get_visible*(self: Widget): bool {.inline.} =

# gtk_widget_get_visual
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INTERFACE 'Gdk3.Visual' 'TransferNone[Gdk3.TVisual]' (diff., need sugar)
proc gtk_widget_get_visual(self: ptr TWidget): TransferNone[Gdk3.TVisual] {.cdecl, dynlib: lib, importc: "gtk_widget_get_visual".}
proc get_visual*(self: Widget): Gdk3.Visual {.inline.} =
  wrap(gtk_widget_get_visual(self))
# proc get_visual*(self: Widget): Gdk3.Visual {.inline.} =

# gtk_widget_get_window
# flags: {isMethod} container: Widget
# need sugar: is method
# return: INTERFACE 'Gdk3.Window' 'TransferNone[Gdk3.TWindow]' (diff., need sugar)
proc gtk_widget_get_window(self: ptr TWidget): TransferNone[Gdk3.TWindow] {.cdecl, dynlib: lib, importc: "gtk_widget_get_window".}
proc get_window*(self: Widget): Gdk3.Window {.inline.} =
  wrap(gtk_widget_get_window(self))
# proc get_window*(self: Widget): Gdk3.Window {.inline.} =

# gtk_grab_add
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_grab_add(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_grab_add".}
proc grab_add*(self: Widget) {.inline.} =
  gtk_grab_add(self)
# proc grab_add*(self: Widget) {.inline.} =

# gtk_widget_grab_default
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_grab_default(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_grab_default".}
proc grab_default*(self: Widget) {.inline.} =
  gtk_widget_grab_default(self)
# proc grab_default*(self: Widget) {.inline.} =

# gtk_widget_grab_focus
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_grab_focus(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_grab_focus".}
proc grab_focus*(self: Widget) {.inline.} =
  gtk_widget_grab_focus(self)
# proc grab_focus*(self: Widget) {.inline.} =

# gtk_grab_remove
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_grab_remove(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_grab_remove".}
proc grab_remove*(self: Widget) {.inline.} =
  gtk_grab_remove(self)
# proc grab_remove*(self: Widget) {.inline.} =

# gtk_widget_has_default
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_has_default(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_has_default".}
proc has_default*(self: Widget): bool {.inline.} =
  gtk_widget_has_default(self)
# proc has_default*(self: Widget): bool {.inline.} =

# gtk_widget_has_focus
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_has_focus(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_has_focus".}
proc has_focus*(self: Widget): bool {.inline.} =
  gtk_widget_has_focus(self)
# proc has_focus*(self: Widget): bool {.inline.} =

# gtk_widget_has_grab
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_has_grab(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_has_grab".}
proc has_grab*(self: Widget): bool {.inline.} =
  gtk_widget_has_grab(self)
# proc has_grab*(self: Widget): bool {.inline.} =

# gtk_widget_has_rc_style
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_has_screen
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_has_screen(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_has_screen".}
proc has_screen*(self: Widget): bool {.inline.} =
  gtk_widget_has_screen(self)
# proc has_screen*(self: Widget): bool {.inline.} =

# gtk_widget_has_visible_focus
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_has_visible_focus(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_has_visible_focus".}
proc has_visible_focus*(self: Widget): bool {.inline.} =
  gtk_widget_has_visible_focus(self)
# proc has_visible_focus*(self: Widget): bool {.inline.} =

# gtk_widget_hide
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_hide(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_hide".}
proc hide*(self: Widget) {.inline.} =
  gtk_widget_hide(self)
# proc hide*(self: Widget) {.inline.} =

# gtk_widget_hide_on_delete
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_hide_on_delete(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_hide_on_delete".}
proc hide_on_delete*(self: Widget): bool {.inline.} =
  gtk_widget_hide_on_delete(self)
# proc hide_on_delete*(self: Widget): bool {.inline.} =

# gtk_widget_in_destruction
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_in_destruction(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_in_destruction".}
proc in_destruction*(self: Widget): bool {.inline.} =
  gtk_widget_in_destruction(self)
# proc in_destruction*(self: Widget): bool {.inline.} =

# gtk_widget_init_template
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_init_template(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_init_template".}
proc init_template*(self: Widget) {.inline.} =
  gtk_widget_init_template(self)
# proc init_template*(self: Widget) {.inline.} =

# gtk_widget_input_shape_combine_region
# flags: {isMethod} container: Widget
# need sugar: is method
# arg region: INTERFACE (STRUCT) 'ptr cairo1.TRegion' 'ptr cairo1.TRegion' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_input_shape_combine_region(self: ptr TWidget, region: ptr cairo1.TRegion) {.cdecl, dynlib: lib, importc: "gtk_widget_input_shape_combine_region".}
proc input_shape_combine_region*(self: Widget, region: ptr cairo1.TRegion) {.inline.} =
  gtk_widget_input_shape_combine_region(self, region)
# proc input_shape_combine_region*(self: Widget, region: ptr cairo1.TRegion) {.inline.} =

# gtk_widget_insert_action_group
# flags: {isMethod} container: Widget
# need sugar: is method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg group: INTERFACE (INTERFACE) 'ptr Gio2.TActionGroup' 'ptr Gio2.TActionGroup' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_insert_action_group(self: ptr TWidget, name: ucstring, group: ptr Gio2.TActionGroup) {.cdecl, dynlib: lib, importc: "gtk_widget_insert_action_group".}
proc insert_action_group*(self: Widget, name: ustring, group: ptr Gio2.TActionGroup) {.inline.} =
  gtk_widget_insert_action_group(self, ucstring(name), group)
# proc insert_action_group*(self: Widget, name: ustring, group: ptr Gio2.TActionGroup) {.inline.} =

# gtk_widget_intersect
# flags: {isMethod} container: Widget
# need sugar: is method
# arg area: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# arg intersection: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_intersect(self: ptr TWidget, area: ptr Gdk3.TRectangle, intersection: ptr Gdk3.TRectangle): bool {.cdecl, dynlib: lib, importc: "gtk_widget_intersect".}
proc intersect*(self: Widget, area: ptr Gdk3.TRectangle, intersection: ptr Gdk3.TRectangle): bool {.inline.} =
  gtk_widget_intersect(self, area, intersection)
# proc intersect*(self: Widget, area: ptr Gdk3.TRectangle, intersection: ptr Gdk3.TRectangle): bool {.inline.} =

# gtk_widget_is_ancestor
# flags: {isMethod} container: Widget
# need sugar: is method
# arg ancestor: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_is_ancestor(self: ptr TWidget, ancestor: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_is_ancestor".}
proc is_ancestor*(self: Widget, ancestor: Widget): bool {.inline.} =
  gtk_widget_is_ancestor(self, ancestor.getPointer)
# proc is_ancestor*(self: Widget, ancestor: Widget): bool {.inline.} =

# gtk_widget_is_composited
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_is_composited(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_is_composited".}
proc is_composited*(self: Widget): bool {.inline.} =
  gtk_widget_is_composited(self)
# proc is_composited*(self: Widget): bool {.inline.} =

# gtk_widget_is_drawable
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_is_drawable(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_is_drawable".}
proc is_drawable*(self: Widget): bool {.inline.} =
  gtk_widget_is_drawable(self)
# proc is_drawable*(self: Widget): bool {.inline.} =

# gtk_widget_is_focus
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_is_focus(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_is_focus".}
proc is_focus*(self: Widget): bool {.inline.} =
  gtk_widget_is_focus(self)
# proc is_focus*(self: Widget): bool {.inline.} =

# gtk_widget_is_sensitive
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_is_sensitive(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_is_sensitive".}
proc is_sensitive*(self: Widget): bool {.inline.} =
  gtk_widget_is_sensitive(self)
# proc is_sensitive*(self: Widget): bool {.inline.} =

# gtk_widget_is_toplevel
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_is_toplevel(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_is_toplevel".}
proc is_toplevel*(self: Widget): bool {.inline.} =
  gtk_widget_is_toplevel(self)
# proc is_toplevel*(self: Widget): bool {.inline.} =

# gtk_widget_is_visible
# flags: {isMethod} container: Widget
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_is_visible(self: ptr TWidget): bool {.cdecl, dynlib: lib, importc: "gtk_widget_is_visible".}
proc is_visible*(self: Widget): bool {.inline.} =
  gtk_widget_is_visible(self)
# proc is_visible*(self: Widget): bool {.inline.} =

# gtk_widget_keynav_failed
# flags: {isMethod} container: Widget
# need sugar: is method
# arg direction: INTERFACE (ENUM) 'DirectionType' 'DirectionType' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_keynav_failed(self: ptr TWidget, direction: DirectionType): bool {.cdecl, dynlib: lib, importc: "gtk_widget_keynav_failed".}
proc keynav_failed*(self: Widget, direction: DirectionType): bool {.inline.} =
  gtk_widget_keynav_failed(self, direction)
# proc keynav_failed*(self: Widget, direction: DirectionType): bool {.inline.} =

# gtk_widget_list_accel_closures
# flags: {isMethod} container: Widget
# need sugar: is method
# return: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_widget_list_accel_closures(self: ptr TWidget): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_widget_list_accel_closures".}
proc list_accel_closures*(self: Widget): ptr GLIST_TODO {.inline.} =
  gtk_widget_list_accel_closures(self)
# proc list_accel_closures*(self: Widget): ptr GLIST_TODO {.inline.} =

# gtk_widget_list_action_prefixes
# flags: {isMethod} container: Widget
# need sugar: is method
# return: ARRAY 'zeroTerminatedArray[ucstring]' 'zeroTerminatedArray[ucstring]'
proc gtk_widget_list_action_prefixes(self: ptr TWidget): zeroTerminatedArray[ucstring] {.cdecl, dynlib: lib, importc: "gtk_widget_list_action_prefixes".}
proc list_action_prefixes*(self: Widget): zeroTerminatedArray[ucstring] {.inline.} =
  gtk_widget_list_action_prefixes(self)
# proc list_action_prefixes*(self: Widget): zeroTerminatedArray[ucstring] {.inline.} =

# gtk_widget_list_mnemonic_labels
# flags: {isMethod} container: Widget
# need sugar: is method
# return: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_widget_list_mnemonic_labels(self: ptr TWidget): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_widget_list_mnemonic_labels".}
proc list_mnemonic_labels*(self: Widget): ptr GLIST_TODO {.inline.} =
  gtk_widget_list_mnemonic_labels(self)
# proc list_mnemonic_labels*(self: Widget): ptr GLIST_TODO {.inline.} =

# gtk_widget_map
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_map(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_map".}
proc map*(self: Widget) {.inline.} =
  gtk_widget_map(self)
# proc map*(self: Widget) {.inline.} =

# gtk_widget_mnemonic_activate
# flags: {isMethod} container: Widget
# need sugar: is method
# arg group_cycling: BOOLEAN 'bool' 'bool' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_mnemonic_activate(self: ptr TWidget, group_cycling: bool): bool {.cdecl, dynlib: lib, importc: "gtk_widget_mnemonic_activate".}
proc mnemonic_activate*(self: Widget, group_cycling: bool): bool {.inline.} =
  gtk_widget_mnemonic_activate(self, group_cycling)
# proc mnemonic_activate*(self: Widget, group_cycling: bool): bool {.inline.} =

# gtk_widget_modify_base
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_modify_bg
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_modify_cursor
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_modify_fg
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_modify_font
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_modify_style
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_modify_text
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_override_background_color
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_override_color
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_override_cursor
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_override_font
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_override_symbolic_color
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_path
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_queue_compute_expand
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_queue_compute_expand(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_queue_compute_expand".}
proc queue_compute_expand*(self: Widget) {.inline.} =
  gtk_widget_queue_compute_expand(self)
# proc queue_compute_expand*(self: Widget) {.inline.} =

# gtk_widget_queue_draw
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_queue_draw(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_queue_draw".}
proc queue_draw*(self: Widget) {.inline.} =
  gtk_widget_queue_draw(self)
# proc queue_draw*(self: Widget) {.inline.} =

# gtk_widget_queue_draw_area
# flags: {isMethod} container: Widget
# need sugar: is method
# arg x: INT32 'int32' 'int32' IN
# arg y: INT32 'int32' 'int32' IN
# arg width: INT32 'int32' 'int32' IN
# arg height: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_queue_draw_area(self: ptr TWidget, x: int32, y: int32, width: int32, height: int32) {.cdecl, dynlib: lib, importc: "gtk_widget_queue_draw_area".}
proc queue_draw_area*(self: Widget, x: int32, y: int32, width: int32, height: int32) {.inline.} =
  gtk_widget_queue_draw_area(self, x, y, width, height)
# proc queue_draw_area*(self: Widget, x: int32, y: int32, width: int32, height: int32) {.inline.} =

# gtk_widget_queue_draw_region
# flags: {isMethod} container: Widget
# need sugar: is method
# arg region: INTERFACE (STRUCT) 'ptr cairo1.TRegion' 'ptr cairo1.TRegion' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_queue_draw_region(self: ptr TWidget, region: ptr cairo1.TRegion) {.cdecl, dynlib: lib, importc: "gtk_widget_queue_draw_region".}
proc queue_draw_region*(self: Widget, region: ptr cairo1.TRegion) {.inline.} =
  gtk_widget_queue_draw_region(self, region)
# proc queue_draw_region*(self: Widget, region: ptr cairo1.TRegion) {.inline.} =

# gtk_widget_queue_resize
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_queue_resize(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_queue_resize".}
proc queue_resize*(self: Widget) {.inline.} =
  gtk_widget_queue_resize(self)
# proc queue_resize*(self: Widget) {.inline.} =

# gtk_widget_queue_resize_no_redraw
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_queue_resize_no_redraw(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_queue_resize_no_redraw".}
proc queue_resize_no_redraw*(self: Widget) {.inline.} =
  gtk_widget_queue_resize_no_redraw(self)
# proc queue_resize_no_redraw*(self: Widget) {.inline.} =

# gtk_widget_realize
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_realize(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_realize".}
proc realize*(self: Widget) {.inline.} =
  gtk_widget_realize(self)
# proc realize*(self: Widget) {.inline.} =

# gtk_widget_region_intersect
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_register_window
# flags: {isMethod} container: Widget
# need sugar: is method
# arg window: INTERFACE (OBJECT) 'Gdk3.Window' 'ptr Gdk3.TWindow' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_register_window(self: ptr TWidget, window: ptr Gdk3.TWindow) {.cdecl, dynlib: lib, importc: "gtk_widget_register_window".}
proc register_window*(self: Widget, window: Gdk3.Window) {.inline.} =
  gtk_widget_register_window(self, window.getPointer)
# proc register_window*(self: Widget, window: Gdk3.Window) {.inline.} =

# gtk_widget_remove_accelerator
# flags: {isMethod} container: Widget
# need sugar: is method
# arg accel_group: INTERFACE (OBJECT) 'AccelGroup' 'ptr TAccelGroup' IN (diff., need sugar)
# arg accel_key: UINT32 'uint32' 'uint32' IN
# arg accel_mods: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_remove_accelerator(self: ptr TWidget, accel_group: ptr TAccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType): bool {.cdecl, dynlib: lib, importc: "gtk_widget_remove_accelerator".}
proc remove_accelerator*(self: Widget, accel_group: AccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType): bool {.inline.} =
  gtk_widget_remove_accelerator(self, accel_group.getPointer, accel_key, accel_mods)
# proc remove_accelerator*(self: Widget, accel_group: AccelGroup, accel_key: uint32, accel_mods: Gdk3.SModifierType): bool {.inline.} =

# gtk_widget_remove_mnemonic_label
# flags: {isMethod} container: Widget
# need sugar: is method
# arg label: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_remove_mnemonic_label(self: ptr TWidget, label: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_remove_mnemonic_label".}
proc remove_mnemonic_label*(self: Widget, label: Widget) {.inline.} =
  gtk_widget_remove_mnemonic_label(self, label.getPointer)
# proc remove_mnemonic_label*(self: Widget, label: Widget) {.inline.} =

# gtk_widget_remove_tick_callback
# flags: {isMethod} container: Widget
# need sugar: is method
# arg id: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_remove_tick_callback(self: ptr TWidget, id: uint32) {.cdecl, dynlib: lib, importc: "gtk_widget_remove_tick_callback".}
proc remove_tick_callback*(self: Widget, id: uint32) {.inline.} =
  gtk_widget_remove_tick_callback(self, id)
# proc remove_tick_callback*(self: Widget, id: uint32) {.inline.} =

# gtk_widget_render_icon
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_render_icon_pixbuf
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_reparent
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_reset_rc_styles
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_reset_style
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_reset_style(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_reset_style".}
proc reset_style*(self: Widget) {.inline.} =
  gtk_widget_reset_style(self)
# proc reset_style*(self: Widget) {.inline.} =

# gtk_widget_send_expose
# flags: {isMethod} container: Widget
# need sugar: is method
# arg event: INTERFACE (UNION) 'ptr Gdk3.TEvent' 'ptr Gdk3.TEvent' IN
# return: INT32 'int32' 'int32'
proc gtk_widget_send_expose(self: ptr TWidget, event: ptr Gdk3.TEvent): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_send_expose".}
proc send_expose*(self: Widget, event: ptr Gdk3.TEvent): int32 {.inline.} =
  gtk_widget_send_expose(self, event)
# proc send_expose*(self: Widget, event: ptr Gdk3.TEvent): int32 {.inline.} =

# gtk_widget_send_focus_change
# flags: {isMethod} container: Widget
# need sugar: is method
# arg event: INTERFACE (UNION) 'ptr Gdk3.TEvent' 'ptr Gdk3.TEvent' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_send_focus_change(self: ptr TWidget, event: ptr Gdk3.TEvent): bool {.cdecl, dynlib: lib, importc: "gtk_widget_send_focus_change".}
proc send_focus_change*(self: Widget, event: ptr Gdk3.TEvent): bool {.inline.} =
  gtk_widget_send_focus_change(self, event)
# proc send_focus_change*(self: Widget, event: ptr Gdk3.TEvent): bool {.inline.} =

# gtk_widget_set_accel_path
# flags: {isMethod} container: Widget
# need sugar: is method
# arg accel_path: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg accel_group: INTERFACE (OBJECT) 'AccelGroup' 'ptr TAccelGroup' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_accel_path(self: ptr TWidget, accel_path: ucstring, accel_group: ptr TAccelGroup) {.cdecl, dynlib: lib, importc: "gtk_widget_set_accel_path".}
proc set_accel_path*(self: Widget, accel_path: ustring, accel_group: AccelGroup) {.inline.} =
  gtk_widget_set_accel_path(self, ucstring(accel_path), accel_group.getPointer)
# proc set_accel_path*(self: Widget, accel_path: ustring, accel_group: AccelGroup) {.inline.} =

# gtk_widget_set_allocation
# flags: {isMethod} container: Widget
# need sugar: is method
# arg allocation: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_allocation(self: ptr TWidget, allocation: ptr Gdk3.TRectangle) {.cdecl, dynlib: lib, importc: "gtk_widget_set_allocation".}
proc set_allocation*(self: Widget, allocation: ptr Gdk3.TRectangle) {.inline.} =
  gtk_widget_set_allocation(self, allocation)
# proc set_allocation*(self: Widget, allocation: ptr Gdk3.TRectangle) {.inline.} =

# gtk_widget_set_app_paintable
# flags: {isMethod} container: Widget
# need sugar: is method
# arg app_paintable: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_app_paintable(self: ptr TWidget, app_paintable: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_app_paintable".}
proc set_app_paintable*(self: Widget, app_paintable: bool) {.inline.} =
  gtk_widget_set_app_paintable(self, app_paintable)
# proc set_app_paintable*(self: Widget, app_paintable: bool) {.inline.} =

# gtk_widget_set_can_default
# flags: {isMethod} container: Widget
# need sugar: is method
# arg can_default: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_can_default(self: ptr TWidget, can_default: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_can_default".}
proc set_can_default*(self: Widget, can_default: bool) {.inline.} =
  gtk_widget_set_can_default(self, can_default)
# proc set_can_default*(self: Widget, can_default: bool) {.inline.} =

# gtk_widget_set_can_focus
# flags: {isMethod} container: Widget
# need sugar: is method
# arg can_focus: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_can_focus(self: ptr TWidget, can_focus: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_can_focus".}
proc set_can_focus*(self: Widget, can_focus: bool) {.inline.} =
  gtk_widget_set_can_focus(self, can_focus)
# proc set_can_focus*(self: Widget, can_focus: bool) {.inline.} =

# gtk_widget_set_child_visible
# flags: {isMethod} container: Widget
# need sugar: is method
# arg is_visible: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_child_visible(self: ptr TWidget, is_visible: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_child_visible".}
proc set_child_visible*(self: Widget, is_visible: bool) {.inline.} =
  gtk_widget_set_child_visible(self, is_visible)
# proc set_child_visible*(self: Widget, is_visible: bool) {.inline.} =

# gtk_widget_set_clip
# flags: {isMethod} container: Widget
# need sugar: is method
# arg clip: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_clip(self: ptr TWidget, clip: ptr Gdk3.TRectangle) {.cdecl, dynlib: lib, importc: "gtk_widget_set_clip".}
proc set_clip*(self: Widget, clip: ptr Gdk3.TRectangle) {.inline.} =
  gtk_widget_set_clip(self, clip)
# proc set_clip*(self: Widget, clip: ptr Gdk3.TRectangle) {.inline.} =

# gtk_widget_set_composite_name
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_set_device_enabled
# flags: {isMethod} container: Widget
# need sugar: is method
# arg device: INTERFACE (OBJECT) 'Gdk3.Device' 'ptr Gdk3.TDevice' IN (diff., need sugar)
# arg enabled: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_device_enabled(self: ptr TWidget, device: ptr Gdk3.TDevice, enabled: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_device_enabled".}
proc set_device_enabled*(self: Widget, device: Gdk3.Device, enabled: bool) {.inline.} =
  gtk_widget_set_device_enabled(self, device.getPointer, enabled)
# proc set_device_enabled*(self: Widget, device: Gdk3.Device, enabled: bool) {.inline.} =

# gtk_widget_set_device_events
# flags: {isMethod} container: Widget
# need sugar: is method
# arg device: INTERFACE (OBJECT) 'Gdk3.Device' 'ptr Gdk3.TDevice' IN (diff., need sugar)
# arg events: INTERFACE (FLAGS) 'Gdk3.SEventMask' 'Gdk3.SEventMask' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_device_events(self: ptr TWidget, device: ptr Gdk3.TDevice, events: Gdk3.SEventMask) {.cdecl, dynlib: lib, importc: "gtk_widget_set_device_events".}
proc set_device_events*(self: Widget, device: Gdk3.Device, events: Gdk3.SEventMask) {.inline.} =
  gtk_widget_set_device_events(self, device.getPointer, events)
# proc set_device_events*(self: Widget, device: Gdk3.Device, events: Gdk3.SEventMask) {.inline.} =

# gtk_widget_set_direction
# flags: {isMethod} container: Widget
# need sugar: is method
# arg dir: INTERFACE (ENUM) 'TextDirection' 'TextDirection' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_direction(self: ptr TWidget, dir: TextDirection) {.cdecl, dynlib: lib, importc: "gtk_widget_set_direction".}
proc set_direction*(self: Widget, dir: TextDirection) {.inline.} =
  gtk_widget_set_direction(self, dir)
# proc set_direction*(self: Widget, dir: TextDirection) {.inline.} =

# gtk_widget_set_double_buffered
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_set_events
# flags: {isMethod} container: Widget
# need sugar: is method
# arg events: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_events(self: ptr TWidget, events: int32) {.cdecl, dynlib: lib, importc: "gtk_widget_set_events".}
proc set_events*(self: Widget, events: int32) {.inline.} =
  gtk_widget_set_events(self, events)
# proc set_events*(self: Widget, events: int32) {.inline.} =

# gtk_widget_set_font_map
# flags: {isMethod} container: Widget
# need sugar: is method
# arg font_map: INTERFACE (OBJECT) 'Pango1.FontMap' 'ptr Pango1.TFontMap' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_font_map(self: ptr TWidget, font_map: ptr Pango1.TFontMap) {.cdecl, dynlib: lib, importc: "gtk_widget_set_font_map".}
proc set_font_map*(self: Widget, font_map: Pango1.FontMap) {.inline.} =
  gtk_widget_set_font_map(self, font_map.getPointer)
# proc set_font_map*(self: Widget, font_map: Pango1.FontMap) {.inline.} =

# gtk_widget_set_font_options
# flags: {isMethod} container: Widget
# need sugar: is method
# arg options: INTERFACE (STRUCT) 'ptr cairo1.TFontOptions' 'ptr cairo1.TFontOptions' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_font_options(self: ptr TWidget, options: ptr cairo1.TFontOptions) {.cdecl, dynlib: lib, importc: "gtk_widget_set_font_options".}
proc set_font_options*(self: Widget, options: ptr cairo1.TFontOptions) {.inline.} =
  gtk_widget_set_font_options(self, options)
# proc set_font_options*(self: Widget, options: ptr cairo1.TFontOptions) {.inline.} =

# gtk_widget_set_halign
# flags: {isMethod} container: Widget
# need sugar: is method
# arg align: INTERFACE (ENUM) 'Align' 'Align' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_halign(self: ptr TWidget, align: Align) {.cdecl, dynlib: lib, importc: "gtk_widget_set_halign".}
proc set_halign*(self: Widget, align: Align) {.inline.} =
  gtk_widget_set_halign(self, align)
# proc set_halign*(self: Widget, align: Align) {.inline.} =

# gtk_widget_set_has_tooltip
# flags: {isMethod} container: Widget
# need sugar: is method
# arg has_tooltip: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_has_tooltip(self: ptr TWidget, has_tooltip: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_has_tooltip".}
proc set_has_tooltip*(self: Widget, has_tooltip: bool) {.inline.} =
  gtk_widget_set_has_tooltip(self, has_tooltip)
# proc set_has_tooltip*(self: Widget, has_tooltip: bool) {.inline.} =

# gtk_widget_set_has_window
# flags: {isMethod} container: Widget
# need sugar: is method
# arg has_window: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_has_window(self: ptr TWidget, has_window: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_has_window".}
proc set_has_window*(self: Widget, has_window: bool) {.inline.} =
  gtk_widget_set_has_window(self, has_window)
# proc set_has_window*(self: Widget, has_window: bool) {.inline.} =

# gtk_widget_set_hexpand
# flags: {isMethod} container: Widget
# need sugar: is method
# arg expand: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_hexpand(self: ptr TWidget, expand: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_hexpand".}
proc set_hexpand*(self: Widget, expand: bool) {.inline.} =
  gtk_widget_set_hexpand(self, expand)
# proc set_hexpand*(self: Widget, expand: bool) {.inline.} =

# gtk_widget_set_hexpand_set
# flags: {isMethod} container: Widget
# need sugar: is method
# arg set: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_hexpand_set(self: ptr TWidget, set: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_hexpand_set".}
proc set_hexpand_set*(self: Widget, set: bool) {.inline.} =
  gtk_widget_set_hexpand_set(self, set)
# proc set_hexpand_set*(self: Widget, set: bool) {.inline.} =

# gtk_widget_set_mapped
# flags: {isMethod} container: Widget
# need sugar: is method
# arg mapped: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_mapped(self: ptr TWidget, mapped: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_mapped".}
proc set_mapped*(self: Widget, mapped: bool) {.inline.} =
  gtk_widget_set_mapped(self, mapped)
# proc set_mapped*(self: Widget, mapped: bool) {.inline.} =

# gtk_widget_set_margin_bottom
# flags: {isMethod} container: Widget
# need sugar: is method
# arg margin: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_margin_bottom(self: ptr TWidget, margin: int32) {.cdecl, dynlib: lib, importc: "gtk_widget_set_margin_bottom".}
proc set_margin_bottom*(self: Widget, margin: int32) {.inline.} =
  gtk_widget_set_margin_bottom(self, margin)
# proc set_margin_bottom*(self: Widget, margin: int32) {.inline.} =

# gtk_widget_set_margin_end
# flags: {isMethod} container: Widget
# need sugar: is method
# arg margin: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_margin_end(self: ptr TWidget, margin: int32) {.cdecl, dynlib: lib, importc: "gtk_widget_set_margin_end".}
proc set_margin_end*(self: Widget, margin: int32) {.inline.} =
  gtk_widget_set_margin_end(self, margin)
# proc set_margin_end*(self: Widget, margin: int32) {.inline.} =

# gtk_widget_set_margin_left
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_set_margin_right
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_set_margin_start
# flags: {isMethod} container: Widget
# need sugar: is method
# arg margin: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_margin_start(self: ptr TWidget, margin: int32) {.cdecl, dynlib: lib, importc: "gtk_widget_set_margin_start".}
proc set_margin_start*(self: Widget, margin: int32) {.inline.} =
  gtk_widget_set_margin_start(self, margin)
# proc set_margin_start*(self: Widget, margin: int32) {.inline.} =

# gtk_widget_set_margin_top
# flags: {isMethod} container: Widget
# need sugar: is method
# arg margin: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_margin_top(self: ptr TWidget, margin: int32) {.cdecl, dynlib: lib, importc: "gtk_widget_set_margin_top".}
proc set_margin_top*(self: Widget, margin: int32) {.inline.} =
  gtk_widget_set_margin_top(self, margin)
# proc set_margin_top*(self: Widget, margin: int32) {.inline.} =

# gtk_widget_set_name
# flags: {isMethod} container: Widget
# need sugar: is method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_name(self: ptr TWidget, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_widget_set_name".}
proc set_name*(self: Widget, name: ustring) {.inline.} =
  gtk_widget_set_name(self, ucstring(name))
# proc set_name*(self: Widget, name: ustring) {.inline.} =

# gtk_widget_set_no_show_all
# flags: {isMethod} container: Widget
# need sugar: is method
# arg no_show_all: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_no_show_all(self: ptr TWidget, no_show_all: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_no_show_all".}
proc set_no_show_all*(self: Widget, no_show_all: bool) {.inline.} =
  gtk_widget_set_no_show_all(self, no_show_all)
# proc set_no_show_all*(self: Widget, no_show_all: bool) {.inline.} =

# gtk_widget_set_opacity
# flags: {isMethod} container: Widget
# need sugar: is method
# arg opacity: DOUBLE 'float64' 'float64' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_opacity(self: ptr TWidget, opacity: float64) {.cdecl, dynlib: lib, importc: "gtk_widget_set_opacity".}
proc set_opacity*(self: Widget, opacity: float64) {.inline.} =
  gtk_widget_set_opacity(self, opacity)
# proc set_opacity*(self: Widget, opacity: float64) {.inline.} =

# gtk_widget_set_parent
# flags: {isMethod} container: Widget
# need sugar: is method
# arg parent: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_parent(self: ptr TWidget, parent: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_set_parent".}
proc set_parent*(self: Widget, parent: Widget) {.inline.} =
  gtk_widget_set_parent(self, parent.getPointer)
# proc set_parent*(self: Widget, parent: Widget) {.inline.} =

# gtk_widget_set_parent_window
# flags: {isMethod} container: Widget
# need sugar: is method
# arg parent_window: INTERFACE (OBJECT) 'Gdk3.Window' 'ptr Gdk3.TWindow' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_parent_window(self: ptr TWidget, parent_window: ptr Gdk3.TWindow) {.cdecl, dynlib: lib, importc: "gtk_widget_set_parent_window".}
proc set_parent_window*(self: Widget, parent_window: Gdk3.Window) {.inline.} =
  gtk_widget_set_parent_window(self, parent_window.getPointer)
# proc set_parent_window*(self: Widget, parent_window: Gdk3.Window) {.inline.} =

# gtk_widget_set_realized
# flags: {isMethod} container: Widget
# need sugar: is method
# arg realized: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_realized(self: ptr TWidget, realized: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_realized".}
proc set_realized*(self: Widget, realized: bool) {.inline.} =
  gtk_widget_set_realized(self, realized)
# proc set_realized*(self: Widget, realized: bool) {.inline.} =

# gtk_widget_set_receives_default
# flags: {isMethod} container: Widget
# need sugar: is method
# arg receives_default: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_receives_default(self: ptr TWidget, receives_default: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_receives_default".}
proc set_receives_default*(self: Widget, receives_default: bool) {.inline.} =
  gtk_widget_set_receives_default(self, receives_default)
# proc set_receives_default*(self: Widget, receives_default: bool) {.inline.} =

# gtk_widget_set_redraw_on_allocate
# flags: {isMethod} container: Widget
# need sugar: is method
# arg redraw_on_allocate: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_redraw_on_allocate(self: ptr TWidget, redraw_on_allocate: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_redraw_on_allocate".}
proc set_redraw_on_allocate*(self: Widget, redraw_on_allocate: bool) {.inline.} =
  gtk_widget_set_redraw_on_allocate(self, redraw_on_allocate)
# proc set_redraw_on_allocate*(self: Widget, redraw_on_allocate: bool) {.inline.} =

# gtk_widget_set_sensitive
# flags: {isMethod} container: Widget
# need sugar: is method
# arg sensitive: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_sensitive(self: ptr TWidget, sensitive: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_sensitive".}
proc set_sensitive*(self: Widget, sensitive: bool) {.inline.} =
  gtk_widget_set_sensitive(self, sensitive)
# proc set_sensitive*(self: Widget, sensitive: bool) {.inline.} =

# gtk_widget_set_size_request
# flags: {isMethod} container: Widget
# need sugar: is method
# arg width: INT32 'int32' 'int32' IN
# arg height: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_size_request(self: ptr TWidget, width: int32, height: int32) {.cdecl, dynlib: lib, importc: "gtk_widget_set_size_request".}
proc set_size_request*(self: Widget, width: int32, height: int32) {.inline.} =
  gtk_widget_set_size_request(self, width, height)
# proc set_size_request*(self: Widget, width: int32, height: int32) {.inline.} =

# gtk_widget_set_state
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_set_state_flags
# flags: {isMethod} container: Widget
# need sugar: is method
# arg flags: INTERFACE (FLAGS) 'SStateFlags' 'SStateFlags' IN
# arg clear: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_state_flags(self: ptr TWidget, flags: SStateFlags, clear: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_state_flags".}
proc set_state_flags*(self: Widget, flags: SStateFlags, clear: bool) {.inline.} =
  gtk_widget_set_state_flags(self, flags, clear)
# proc set_state_flags*(self: Widget, flags: SStateFlags, clear: bool) {.inline.} =

# gtk_widget_set_style
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_set_support_multidevice
# flags: {isMethod} container: Widget
# need sugar: is method
# arg support_multidevice: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_support_multidevice(self: ptr TWidget, support_multidevice: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_support_multidevice".}
proc set_support_multidevice*(self: Widget, support_multidevice: bool) {.inline.} =
  gtk_widget_set_support_multidevice(self, support_multidevice)
# proc set_support_multidevice*(self: Widget, support_multidevice: bool) {.inline.} =

# gtk_widget_set_tooltip_markup
# flags: {isMethod} container: Widget
# need sugar: is method
# arg markup: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_tooltip_markup(self: ptr TWidget, markup: ucstring) {.cdecl, dynlib: lib, importc: "gtk_widget_set_tooltip_markup".}
proc set_tooltip_markup*(self: Widget, markup: ustring) {.inline.} =
  gtk_widget_set_tooltip_markup(self, ucstring(markup))
# proc set_tooltip_markup*(self: Widget, markup: ustring) {.inline.} =

# gtk_widget_set_tooltip_text
# flags: {isMethod} container: Widget
# need sugar: is method
# arg text: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_tooltip_text(self: ptr TWidget, text: ucstring) {.cdecl, dynlib: lib, importc: "gtk_widget_set_tooltip_text".}
proc set_tooltip_text*(self: Widget, text: ustring) {.inline.} =
  gtk_widget_set_tooltip_text(self, ucstring(text))
# proc set_tooltip_text*(self: Widget, text: ustring) {.inline.} =

# gtk_widget_set_tooltip_window
# flags: {isMethod} container: Widget
# need sugar: is method
# arg custom_window: INTERFACE (OBJECT) 'Window' 'ptr TWindow' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_tooltip_window(self: ptr TWidget, custom_window: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_widget_set_tooltip_window".}
proc set_tooltip_window*(self: Widget, custom_window: Window) {.inline.} =
  gtk_widget_set_tooltip_window(self, custom_window.getPointer)
# proc set_tooltip_window*(self: Widget, custom_window: Window) {.inline.} =

# gtk_widget_set_valign
# flags: {isMethod} container: Widget
# need sugar: is method
# arg align: INTERFACE (ENUM) 'Align' 'Align' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_valign(self: ptr TWidget, align: Align) {.cdecl, dynlib: lib, importc: "gtk_widget_set_valign".}
proc set_valign*(self: Widget, align: Align) {.inline.} =
  gtk_widget_set_valign(self, align)
# proc set_valign*(self: Widget, align: Align) {.inline.} =

# gtk_widget_set_vexpand
# flags: {isMethod} container: Widget
# need sugar: is method
# arg expand: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_vexpand(self: ptr TWidget, expand: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_vexpand".}
proc set_vexpand*(self: Widget, expand: bool) {.inline.} =
  gtk_widget_set_vexpand(self, expand)
# proc set_vexpand*(self: Widget, expand: bool) {.inline.} =

# gtk_widget_set_vexpand_set
# flags: {isMethod} container: Widget
# need sugar: is method
# arg set: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_vexpand_set(self: ptr TWidget, set: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_vexpand_set".}
proc set_vexpand_set*(self: Widget, set: bool) {.inline.} =
  gtk_widget_set_vexpand_set(self, set)
# proc set_vexpand_set*(self: Widget, set: bool) {.inline.} =

# gtk_widget_set_visible
# flags: {isMethod} container: Widget
# need sugar: is method
# arg visible: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_visible(self: ptr TWidget, visible: bool) {.cdecl, dynlib: lib, importc: "gtk_widget_set_visible".}
proc set_visible*(self: Widget, visible: bool) {.inline.} =
  gtk_widget_set_visible(self, visible)
# proc set_visible*(self: Widget, visible: bool) {.inline.} =

# gtk_widget_set_visual
# flags: {isMethod} container: Widget
# need sugar: is method
# arg visual: INTERFACE (OBJECT) 'Gdk3.Visual' 'ptr Gdk3.TVisual' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_visual(self: ptr TWidget, visual: ptr Gdk3.TVisual) {.cdecl, dynlib: lib, importc: "gtk_widget_set_visual".}
proc set_visual*(self: Widget, visual: Gdk3.Visual) {.inline.} =
  gtk_widget_set_visual(self, visual.getPointer)
# proc set_visual*(self: Widget, visual: Gdk3.Visual) {.inline.} =

# gtk_widget_set_window
# flags: {isMethod} container: Widget
# need sugar: is method
# arg window: INTERFACE (OBJECT) 'Gdk3.Window' 'ptr Gdk3.TWindow' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_set_window(self: ptr TWidget, window: ptr Gdk3.TWindow) {.cdecl, dynlib: lib, importc: "gtk_widget_set_window".}
proc set_window*(self: Widget, window: Gdk3.Window) {.inline.} =
  gtk_widget_set_window(self, window.getPointer)
# proc set_window*(self: Widget, window: Gdk3.Window) {.inline.} =

# gtk_widget_shape_combine_region
# flags: {isMethod} container: Widget
# need sugar: is method
# arg region: INTERFACE (STRUCT) 'ptr cairo1.TRegion' 'ptr cairo1.TRegion' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_shape_combine_region(self: ptr TWidget, region: ptr cairo1.TRegion) {.cdecl, dynlib: lib, importc: "gtk_widget_shape_combine_region".}
proc shape_combine_region*(self: Widget, region: ptr cairo1.TRegion) {.inline.} =
  gtk_widget_shape_combine_region(self, region)
# proc shape_combine_region*(self: Widget, region: ptr cairo1.TRegion) {.inline.} =

# gtk_widget_show
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_show(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_show".}
proc show*(self: Widget) {.inline.} =
  gtk_widget_show(self)
# proc show*(self: Widget) {.inline.} =

# gtk_widget_show_all
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_show_all(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_show_all".}
proc show_all*(self: Widget) {.inline.} =
  gtk_widget_show_all(self)
# proc show_all*(self: Widget) {.inline.} =

# gtk_widget_show_now
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_show_now(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_show_now".}
proc show_now*(self: Widget) {.inline.} =
  gtk_widget_show_now(self)
# proc show_now*(self: Widget) {.inline.} =

# gtk_widget_size_allocate
# flags: {isMethod} container: Widget
# need sugar: is method
# arg allocation: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_size_allocate(self: ptr TWidget, allocation: ptr Gdk3.TRectangle) {.cdecl, dynlib: lib, importc: "gtk_widget_size_allocate".}
proc size_allocate*(self: Widget, allocation: ptr Gdk3.TRectangle) {.inline.} =
  gtk_widget_size_allocate(self, allocation)
# proc size_allocate*(self: Widget, allocation: ptr Gdk3.TRectangle) {.inline.} =

# gtk_widget_size_allocate_with_baseline
# flags: {isMethod} container: Widget
# need sugar: is method
# arg allocation: INTERFACE (STRUCT) 'ptr Gdk3.TRectangle' 'ptr Gdk3.TRectangle' IN
# arg baseline: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_size_allocate_with_baseline(self: ptr TWidget, allocation: ptr Gdk3.TRectangle, baseline: int32) {.cdecl, dynlib: lib, importc: "gtk_widget_size_allocate_with_baseline".}
proc size_allocate_with_baseline*(self: Widget, allocation: ptr Gdk3.TRectangle, baseline: int32) {.inline.} =
  gtk_widget_size_allocate_with_baseline(self, allocation, baseline)
# proc size_allocate_with_baseline*(self: Widget, allocation: ptr Gdk3.TRectangle, baseline: int32) {.inline.} =

# gtk_widget_size_request
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_style_attach
# flags: {isMethod} container: Widget (deprecated)
# gtk_widget_style_get_property
# flags: {isMethod} container: Widget
# need sugar: is method
# arg property_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg value: INTERFACE (STRUCT) 'ptr GObject2.TValue' 'ptr GObject2.TValue' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_style_get_property(self: ptr TWidget, property_name: ucstring, value: ptr GObject2.TValue) {.cdecl, dynlib: lib, importc: "gtk_widget_style_get_property".}
proc style_get_property*(self: Widget, property_name: ustring, value: ptr GObject2.TValue) {.inline.} =
  gtk_widget_style_get_property(self, ucstring(property_name), value)
# proc style_get_property*(self: Widget, property_name: ustring, value: ptr GObject2.TValue) {.inline.} =

# gtk_widget_thaw_child_notify
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_thaw_child_notify(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_thaw_child_notify".}
proc thaw_child_notify*(self: Widget) {.inline.} =
  gtk_widget_thaw_child_notify(self)
# proc thaw_child_notify*(self: Widget) {.inline.} =

# gtk_widget_translate_coordinates
# flags: {isMethod} container: Widget
# need sugar: is method
# arg dest_widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg src_x: INT32 'int32' 'int32' IN
# arg src_y: INT32 'int32' 'int32' IN
# arg dest_x: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# arg dest_y: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_translate_coordinates(self: ptr TWidget, dest_widget: ptr TWidget, src_x: int32, src_y: int32, dest_x: ptr int32, dest_y: ptr int32): bool {.cdecl, dynlib: lib, importc: "gtk_widget_translate_coordinates".}
proc translate_coordinates*(self: Widget, dest_widget: Widget, src_x: int32, src_y: int32, dest_x: var int32, dest_y: var int32): bool {.inline.} =
  gtk_widget_translate_coordinates(self, dest_widget.getPointer, src_x, src_y, addr(dest_x), addr(dest_y))
# tuple-return
# dest_x: var int32
# dest_y: var int32
# proc translate_coordinates*(self: Widget, dest_widget: Widget, src_x: int32, src_y: int32): bool {.inline.} =

# gtk_widget_trigger_tooltip_query
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_trigger_tooltip_query(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_trigger_tooltip_query".}
proc trigger_tooltip_query*(self: Widget) {.inline.} =
  gtk_widget_trigger_tooltip_query(self)
# proc trigger_tooltip_query*(self: Widget) {.inline.} =

# gtk_widget_unmap
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_unmap(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_unmap".}
proc unmap*(self: Widget) {.inline.} =
  gtk_widget_unmap(self)
# proc unmap*(self: Widget) {.inline.} =

# gtk_widget_unparent
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_unparent(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_unparent".}
proc unparent*(self: Widget) {.inline.} =
  gtk_widget_unparent(self)
# proc unparent*(self: Widget) {.inline.} =

# gtk_widget_unrealize
# flags: {isMethod} container: Widget
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_unrealize(self: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_widget_unrealize".}
proc unrealize*(self: Widget) {.inline.} =
  gtk_widget_unrealize(self)
# proc unrealize*(self: Widget) {.inline.} =

# gtk_widget_unregister_window
# flags: {isMethod} container: Widget
# need sugar: is method
# arg window: INTERFACE (OBJECT) 'Gdk3.Window' 'ptr Gdk3.TWindow' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_unregister_window(self: ptr TWidget, window: ptr Gdk3.TWindow) {.cdecl, dynlib: lib, importc: "gtk_widget_unregister_window".}
proc unregister_window*(self: Widget, window: Gdk3.Window) {.inline.} =
  gtk_widget_unregister_window(self, window.getPointer)
# proc unregister_window*(self: Widget, window: Gdk3.Window) {.inline.} =

# gtk_widget_unset_state_flags
# flags: {isMethod} container: Widget
# need sugar: is method
# arg flags: INTERFACE (FLAGS) 'SStateFlags' 'SStateFlags' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_unset_state_flags(self: ptr TWidget, flags: SStateFlags) {.cdecl, dynlib: lib, importc: "gtk_widget_unset_state_flags".}
proc unset_state_flags*(self: Widget, flags: SStateFlags) {.inline.} =
  gtk_widget_unset_state_flags(self, flags)
# proc unset_state_flags*(self: Widget, flags: SStateFlags) {.inline.} =

# initializer for WidgetAccessible: gtk_widget_accessible_get_type
proc gtk_widget_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_widget_accessible_get_type".}
template gtype*(klass_parameter: typedesc[WidgetAccessible]): GType = gtk_widget_accessible_get_type()
# initializer for Window: gtk_window_get_type
proc gtk_window_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_window_get_type".}
template gtype*(klass_parameter: typedesc[Window]): GType = gtk_window_get_type()
# gtk_window_new
# flags: {isConstructor} container: Window
# need sugar: is static method
# arg type: INTERFACE (ENUM) 'WindowType' 'WindowType' IN
# return: INTERFACE 'Window' 'TransferNone[TWindow]' (diff., need sugar)
proc gtk_window_new(type_x: WindowType): TransferNone[TWindow] {.cdecl, dynlib: lib, importc: "gtk_window_new".}
proc new_window*(type_x: WindowType): Window {.inline.} =
  wrap(gtk_window_new(type_x))
# proc new_window*(type_x: WindowType): Window {.inline.} =

# gtk_window_get_default_icon_list
# flags: {} container: Window
# need sugar: is static method
# return: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_window_get_default_icon_list(): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_window_get_default_icon_list".}
template get_default_icon_list*(klass_parameter: typedesc[Window]): ptr GLIST_TODO =
  gtk_window_get_default_icon_list()
# template get_default_icon_list*(klass_parameter: typedesc[Window]): ptr GLIST_TODO =

# gtk_window_get_default_icon_name
# flags: {} container: Window
# need sugar: is static method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_window_get_default_icon_name(): ucstring {.cdecl, dynlib: lib, importc: "gtk_window_get_default_icon_name".}
template get_default_icon_name*(klass_parameter: typedesc[Window]): ucstring =
  gtk_window_get_default_icon_name()
# template get_default_icon_name*(klass_parameter: typedesc[Window]): ucstring =

# gtk_window_list_toplevels
# flags: {} container: Window
# need sugar: is static method
# return: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_window_list_toplevels(): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_window_list_toplevels".}
template list_toplevels*(klass_parameter: typedesc[Window]): ptr GLIST_TODO =
  gtk_window_list_toplevels()
# template list_toplevels*(klass_parameter: typedesc[Window]): ptr GLIST_TODO =

# gtk_window_set_auto_startup_notification
# flags: {} container: Window
# need sugar: is static method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_auto_startup_notification(setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_auto_startup_notification".}
template set_auto_startup_notification*(klass_parameter: typedesc[Window], setting: bool) =
  gtk_window_set_auto_startup_notification(setting)
# template set_auto_startup_notification*(klass_parameter: typedesc[Window], setting: bool) =

# gtk_window_set_default_icon
# flags: {} container: Window
# need sugar: is static method
# arg icon: INTERFACE (OBJECT) 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_default_icon(icon: ptr GdkPixbuf2.TPixbuf) {.cdecl, dynlib: lib, importc: "gtk_window_set_default_icon".}
template set_default_icon*(klass_parameter: typedesc[Window], icon: GdkPixbuf2.Pixbuf) =
  gtk_window_set_default_icon(icon.getPointer)
# template set_default_icon*(klass_parameter: typedesc[Window], icon: GdkPixbuf2.Pixbuf) =

# gtk_window_set_default_icon_from_file
# flags: {throws} container: Window
# can throw
# need sugar: is static method
# arg filename: FILENAME 'string' 'cstring' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_window_set_default_icon_from_file(filename: cstring, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_window_set_default_icon_from_file".}
template set_default_icon_from_file*(klass_parameter: typedesc[Window], filename: string): bool =
  gtk_window_set_default_icon_from_file(cstring(filename))
# template set_default_icon_from_file*(klass_parameter: typedesc[Window], filename: string): bool =

# gtk_window_set_default_icon_list
# flags: {} container: Window
# need sugar: is static method
# arg list: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_default_icon_list(list: ptr GLIST_TODO) {.cdecl, dynlib: lib, importc: "gtk_window_set_default_icon_list".}
template set_default_icon_list*(klass_parameter: typedesc[Window], list: ptr GLIST_TODO) =
  gtk_window_set_default_icon_list(list)
# template set_default_icon_list*(klass_parameter: typedesc[Window], list: ptr GLIST_TODO) =

# gtk_window_set_default_icon_name
# flags: {} container: Window
# need sugar: is static method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_default_icon_name(name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_window_set_default_icon_name".}
template set_default_icon_name*(klass_parameter: typedesc[Window], name: ustring) =
  gtk_window_set_default_icon_name(ucstring(name))
# template set_default_icon_name*(klass_parameter: typedesc[Window], name: ustring) =

# gtk_window_set_interactive_debugging
# flags: {} container: Window
# need sugar: is static method
# arg enable: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_interactive_debugging(enable: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_interactive_debugging".}
template set_interactive_debugging*(klass_parameter: typedesc[Window], enable: bool) =
  gtk_window_set_interactive_debugging(enable)
# template set_interactive_debugging*(klass_parameter: typedesc[Window], enable: bool) =

# gtk_window_activate_default
# flags: {isMethod} container: Window
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_window_activate_default(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_activate_default".}
proc activate_default*(self: Window): bool {.inline.} =
  gtk_window_activate_default(self)
# proc activate_default*(self: Window): bool {.inline.} =

# gtk_window_activate_focus
# flags: {isMethod} container: Window
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_window_activate_focus(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_activate_focus".}
proc activate_focus*(self: Window): bool {.inline.} =
  gtk_window_activate_focus(self)
# proc activate_focus*(self: Window): bool {.inline.} =

# gtk_window_activate_key
# flags: {isMethod} container: Window
# need sugar: is method
# arg event: INTERFACE (STRUCT) 'ptr Gdk3.TEventKey' 'ptr Gdk3.TEventKey' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_window_activate_key(self: ptr TWindow, event: ptr Gdk3.TEventKey): bool {.cdecl, dynlib: lib, importc: "gtk_window_activate_key".}
proc activate_key*(self: Window, event: ptr Gdk3.TEventKey): bool {.inline.} =
  gtk_window_activate_key(self, event)
# proc activate_key*(self: Window, event: ptr Gdk3.TEventKey): bool {.inline.} =

# gtk_window_add_accel_group
# flags: {isMethod} container: Window
# need sugar: is method
# arg accel_group: INTERFACE (OBJECT) 'AccelGroup' 'ptr TAccelGroup' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_add_accel_group(self: ptr TWindow, accel_group: ptr TAccelGroup) {.cdecl, dynlib: lib, importc: "gtk_window_add_accel_group".}
proc add_accel_group*(self: Window, accel_group: AccelGroup) {.inline.} =
  gtk_window_add_accel_group(self, accel_group.getPointer)
# proc add_accel_group*(self: Window, accel_group: AccelGroup) {.inline.} =

# gtk_window_add_mnemonic
# flags: {isMethod} container: Window
# need sugar: is method
# arg keyval: UINT32 'uint32' 'uint32' IN
# arg target: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_add_mnemonic(self: ptr TWindow, keyval: uint32, target: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_window_add_mnemonic".}
proc add_mnemonic*(self: Window, keyval: uint32, target: Widget) {.inline.} =
  gtk_window_add_mnemonic(self, keyval, target.getPointer)
# proc add_mnemonic*(self: Window, keyval: uint32, target: Widget) {.inline.} =

# gtk_window_begin_move_drag
# flags: {isMethod} container: Window
# need sugar: is method
# arg button: INT32 'int32' 'int32' IN
# arg root_x: INT32 'int32' 'int32' IN
# arg root_y: INT32 'int32' 'int32' IN
# arg timestamp: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_begin_move_drag(self: ptr TWindow, button: int32, root_x: int32, root_y: int32, timestamp: uint32) {.cdecl, dynlib: lib, importc: "gtk_window_begin_move_drag".}
proc begin_move_drag*(self: Window, button: int32, root_x: int32, root_y: int32, timestamp: uint32) {.inline.} =
  gtk_window_begin_move_drag(self, button, root_x, root_y, timestamp)
# proc begin_move_drag*(self: Window, button: int32, root_x: int32, root_y: int32, timestamp: uint32) {.inline.} =

# gtk_window_begin_resize_drag
# flags: {isMethod} container: Window
# need sugar: is method
# arg edge: INTERFACE (ENUM) 'Gdk3.WindowEdge' 'Gdk3.WindowEdge' IN
# arg button: INT32 'int32' 'int32' IN
# arg root_x: INT32 'int32' 'int32' IN
# arg root_y: INT32 'int32' 'int32' IN
# arg timestamp: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_begin_resize_drag(self: ptr TWindow, edge: Gdk3.WindowEdge, button: int32, root_x: int32, root_y: int32, timestamp: uint32) {.cdecl, dynlib: lib, importc: "gtk_window_begin_resize_drag".}
proc begin_resize_drag*(self: Window, edge: Gdk3.WindowEdge, button: int32, root_x: int32, root_y: int32, timestamp: uint32) {.inline.} =
  gtk_window_begin_resize_drag(self, edge, button, root_x, root_y, timestamp)
# proc begin_resize_drag*(self: Window, edge: Gdk3.WindowEdge, button: int32, root_x: int32, root_y: int32, timestamp: uint32) {.inline.} =

# gtk_window_close
# flags: {isMethod} container: Window
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_close(self: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_window_close".}
proc close*(self: Window) {.inline.} =
  gtk_window_close(self)
# proc close*(self: Window) {.inline.} =

# gtk_window_deiconify
# flags: {isMethod} container: Window
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_deiconify(self: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_window_deiconify".}
proc deiconify*(self: Window) {.inline.} =
  gtk_window_deiconify(self)
# proc deiconify*(self: Window) {.inline.} =

# gtk_window_fullscreen
# flags: {isMethod} container: Window
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_fullscreen(self: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_window_fullscreen".}
proc fullscreen*(self: Window) {.inline.} =
  gtk_window_fullscreen(self)
# proc fullscreen*(self: Window) {.inline.} =

# gtk_window_fullscreen_on_monitor
# flags: {isMethod} container: Window
# need sugar: is method
# arg screen: INTERFACE (OBJECT) 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# arg monitor: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_fullscreen_on_monitor(self: ptr TWindow, screen: ptr Gdk3.TScreen, monitor: int32) {.cdecl, dynlib: lib, importc: "gtk_window_fullscreen_on_monitor".}
proc fullscreen_on_monitor*(self: Window, screen: Gdk3.Screen, monitor: int32) {.inline.} =
  gtk_window_fullscreen_on_monitor(self, screen.getPointer, monitor)
# proc fullscreen_on_monitor*(self: Window, screen: Gdk3.Screen, monitor: int32) {.inline.} =

# gtk_window_get_accept_focus
# flags: {isMethod} container: Window
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_window_get_accept_focus(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_get_accept_focus".}
proc get_accept_focus*(self: Window): bool {.inline.} =
  gtk_window_get_accept_focus(self)
# proc get_accept_focus*(self: Window): bool {.inline.} =

# gtk_window_get_application
# flags: {isMethod} container: Window
# need sugar: is method
# return: INTERFACE 'Application' 'TransferNone[TApplication]' (diff., need sugar)
proc gtk_window_get_application(self: ptr TWindow): TransferNone[TApplication] {.cdecl, dynlib: lib, importc: "gtk_window_get_application".}
proc get_application*(self: Window): Application {.inline.} =
  wrap(gtk_window_get_application(self))
# proc get_application*(self: Window): Application {.inline.} =

# gtk_window_get_attached_to
# flags: {isMethod} container: Window
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_window_get_attached_to(self: ptr TWindow): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_window_get_attached_to".}
proc get_attached_to*(self: Window): Widget {.inline.} =
  wrap(gtk_window_get_attached_to(self))
# proc get_attached_to*(self: Window): Widget {.inline.} =

# gtk_window_get_decorated
# flags: {isMethod} container: Window
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_window_get_decorated(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_get_decorated".}
proc get_decorated*(self: Window): bool {.inline.} =
  gtk_window_get_decorated(self)
# proc get_decorated*(self: Window): bool {.inline.} =

# gtk_window_get_default_size
# flags: {isMethod} container: Window
# need sugar: is method
# arg width: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg height: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_get_default_size(self: ptr TWindow, width: ptr int32, height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_window_get_default_size".}
proc get_default_size*(self: Window, width: var int32, height: var int32) {.inline.} =
  gtk_window_get_default_size(self, addr(width), addr(height))
# tuple-return
# width: var int32
# height: var int32
# proc get_default_size*(self: Window) {.inline.} =

# gtk_window_get_default_widget
# flags: {isMethod} container: Window
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_window_get_default_widget(self: ptr TWindow): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_window_get_default_widget".}
proc get_default_widget*(self: Window): Widget {.inline.} =
  wrap(gtk_window_get_default_widget(self))
# proc get_default_widget*(self: Window): Widget {.inline.} =

# gtk_window_get_deletable
# flags: {isMethod} container: Window
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_window_get_deletable(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_get_deletable".}
proc get_deletable*(self: Window): bool {.inline.} =
  gtk_window_get_deletable(self)
# proc get_deletable*(self: Window): bool {.inline.} =

# gtk_window_get_destroy_with_parent
# flags: {isMethod} container: Window
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_window_get_destroy_with_parent(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_get_destroy_with_parent".}
proc get_destroy_with_parent*(self: Window): bool {.inline.} =
  gtk_window_get_destroy_with_parent(self)
# proc get_destroy_with_parent*(self: Window): bool {.inline.} =

# gtk_window_get_focus
# flags: {isMethod} container: Window
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_window_get_focus(self: ptr TWindow): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_window_get_focus".}
proc get_focus*(self: Window): Widget {.inline.} =
  wrap(gtk_window_get_focus(self))
# proc get_focus*(self: Window): Widget {.inline.} =

# gtk_window_get_focus_on_map
# flags: {isMethod} container: Window
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_window_get_focus_on_map(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_get_focus_on_map".}
proc get_focus_on_map*(self: Window): bool {.inline.} =
  gtk_window_get_focus_on_map(self)
# proc get_focus_on_map*(self: Window): bool {.inline.} =

# gtk_window_get_focus_visible
# flags: {isMethod} container: Window
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_window_get_focus_visible(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_get_focus_visible".}
proc get_focus_visible*(self: Window): bool {.inline.} =
  gtk_window_get_focus_visible(self)
# proc get_focus_visible*(self: Window): bool {.inline.} =

# gtk_window_get_gravity
# flags: {isMethod} container: Window
# need sugar: is method
# return: INTERFACE 'Gdk3.Gravity' 'Gdk3.Gravity'
proc gtk_window_get_gravity(self: ptr TWindow): Gdk3.Gravity {.cdecl, dynlib: lib, importc: "gtk_window_get_gravity".}
proc get_gravity*(self: Window): Gdk3.Gravity {.inline.} =
  gtk_window_get_gravity(self)
# proc get_gravity*(self: Window): Gdk3.Gravity {.inline.} =

# gtk_window_get_group
# flags: {isMethod} container: Window
# need sugar: is method
# return: INTERFACE 'WindowGroup' 'TransferNone[TWindowGroup]' (diff., need sugar)
proc gtk_window_get_group(self: ptr TWindow): TransferNone[TWindowGroup] {.cdecl, dynlib: lib, importc: "gtk_window_get_group".}
proc get_group*(self: Window): WindowGroup {.inline.} =
  wrap(gtk_window_get_group(self))
# proc get_group*(self: Window): WindowGroup {.inline.} =

# gtk_window_get_has_resize_grip
# flags: {isMethod} container: Window (deprecated)
# gtk_window_get_hide_titlebar_when_maximized
# flags: {isMethod} container: Window
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_window_get_hide_titlebar_when_maximized(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_get_hide_titlebar_when_maximized".}
proc get_hide_titlebar_when_maximized*(self: Window): bool {.inline.} =
  gtk_window_get_hide_titlebar_when_maximized(self)
# proc get_hide_titlebar_when_maximized*(self: Window): bool {.inline.} =

# gtk_window_get_icon
# flags: {isMethod} container: Window
# need sugar: is method
# return: INTERFACE 'GdkPixbuf2.Pixbuf' 'TransferNone[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_window_get_icon(self: ptr TWindow): TransferNone[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_window_get_icon".}
proc get_icon*(self: Window): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_window_get_icon(self))
# proc get_icon*(self: Window): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_window_get_icon_list
# flags: {isMethod} container: Window
# need sugar: is method
# return: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_window_get_icon_list(self: ptr TWindow): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_window_get_icon_list".}
proc get_icon_list*(self: Window): ptr GLIST_TODO {.inline.} =
  gtk_window_get_icon_list(self)
# proc get_icon_list*(self: Window): ptr GLIST_TODO {.inline.} =

# gtk_window_get_icon_name
# flags: {isMethod} container: Window
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_window_get_icon_name(self: ptr TWindow): ucstring {.cdecl, dynlib: lib, importc: "gtk_window_get_icon_name".}
proc get_icon_name*(self: Window): ucstring {.inline.} =
  gtk_window_get_icon_name(self)
# proc get_icon_name*(self: Window): ucstring {.inline.} =

# gtk_window_get_mnemonic_modifier
# flags: {isMethod} container: Window
# need sugar: is method
# return: INTERFACE 'Gdk3.SModifierType' 'Gdk3.SModifierType'
proc gtk_window_get_mnemonic_modifier(self: ptr TWindow): Gdk3.SModifierType {.cdecl, dynlib: lib, importc: "gtk_window_get_mnemonic_modifier".}
proc get_mnemonic_modifier*(self: Window): Gdk3.SModifierType {.inline.} =
  gtk_window_get_mnemonic_modifier(self)
# proc get_mnemonic_modifier*(self: Window): Gdk3.SModifierType {.inline.} =

# gtk_window_get_mnemonics_visible
# flags: {isMethod} container: Window
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_window_get_mnemonics_visible(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_get_mnemonics_visible".}
proc get_mnemonics_visible*(self: Window): bool {.inline.} =
  gtk_window_get_mnemonics_visible(self)
# proc get_mnemonics_visible*(self: Window): bool {.inline.} =

# gtk_window_get_modal
# flags: {isMethod} container: Window
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_window_get_modal(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_get_modal".}
proc get_modal*(self: Window): bool {.inline.} =
  gtk_window_get_modal(self)
# proc get_modal*(self: Window): bool {.inline.} =

# gtk_window_get_opacity
# flags: {isMethod} container: Window (deprecated)
# gtk_window_get_position
# flags: {isMethod} container: Window
# need sugar: is method
# arg root_x: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg root_y: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_get_position(self: ptr TWindow, root_x: ptr int32, root_y: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_window_get_position".}
proc get_position*(self: Window, root_x: var int32, root_y: var int32) {.inline.} =
  gtk_window_get_position(self, addr(root_x), addr(root_y))
# tuple-return
# root_x: var int32
# root_y: var int32
# proc get_position*(self: Window) {.inline.} =

# gtk_window_get_resizable
# flags: {isMethod} container: Window
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_window_get_resizable(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_get_resizable".}
proc get_resizable*(self: Window): bool {.inline.} =
  gtk_window_get_resizable(self)
# proc get_resizable*(self: Window): bool {.inline.} =

# gtk_window_get_resize_grip_area
# flags: {isMethod} container: Window (deprecated)
# gtk_window_get_role
# flags: {isMethod} container: Window
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_window_get_role(self: ptr TWindow): ucstring {.cdecl, dynlib: lib, importc: "gtk_window_get_role".}
proc get_role*(self: Window): ucstring {.inline.} =
  gtk_window_get_role(self)
# proc get_role*(self: Window): ucstring {.inline.} =

# gtk_window_get_screen
# flags: {isMethod} container: Window
# need sugar: is method
# return: INTERFACE 'Gdk3.Screen' 'TransferNone[Gdk3.TScreen]' (diff., need sugar)
proc gtk_window_get_screen(self: ptr TWindow): TransferNone[Gdk3.TScreen] {.cdecl, dynlib: lib, importc: "gtk_window_get_screen".}
proc get_screen*(self: Window): Gdk3.Screen {.inline.} =
  wrap(gtk_window_get_screen(self))
# proc get_screen*(self: Window): Gdk3.Screen {.inline.} =

# gtk_window_get_size
# flags: {isMethod} container: Window
# need sugar: is method
# arg width: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# arg height: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_get_size(self: ptr TWindow, width: ptr int32, height: ptr int32) {.cdecl, dynlib: lib, importc: "gtk_window_get_size".}
proc get_size*(self: Window, width: var int32, height: var int32) {.inline.} =
  gtk_window_get_size(self, addr(width), addr(height))
# tuple-return
# width: var int32
# height: var int32
# proc get_size*(self: Window) {.inline.} =

# gtk_window_get_skip_pager_hint
# flags: {isMethod} container: Window
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_window_get_skip_pager_hint(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_get_skip_pager_hint".}
proc get_skip_pager_hint*(self: Window): bool {.inline.} =
  gtk_window_get_skip_pager_hint(self)
# proc get_skip_pager_hint*(self: Window): bool {.inline.} =

# gtk_window_get_skip_taskbar_hint
# flags: {isMethod} container: Window
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_window_get_skip_taskbar_hint(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_get_skip_taskbar_hint".}
proc get_skip_taskbar_hint*(self: Window): bool {.inline.} =
  gtk_window_get_skip_taskbar_hint(self)
# proc get_skip_taskbar_hint*(self: Window): bool {.inline.} =

# gtk_window_get_title
# flags: {isMethod} container: Window
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_window_get_title(self: ptr TWindow): ucstring {.cdecl, dynlib: lib, importc: "gtk_window_get_title".}
proc get_title*(self: Window): ucstring {.inline.} =
  gtk_window_get_title(self)
# proc get_title*(self: Window): ucstring {.inline.} =

# gtk_window_get_titlebar
# flags: {isMethod} container: Window
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_window_get_titlebar(self: ptr TWindow): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_window_get_titlebar".}
proc get_titlebar*(self: Window): Widget {.inline.} =
  wrap(gtk_window_get_titlebar(self))
# proc get_titlebar*(self: Window): Widget {.inline.} =

# gtk_window_get_transient_for
# flags: {isMethod} container: Window
# need sugar: is method
# return: INTERFACE 'Window' 'TransferNone[TWindow]' (diff., need sugar)
proc gtk_window_get_transient_for(self: ptr TWindow): TransferNone[TWindow] {.cdecl, dynlib: lib, importc: "gtk_window_get_transient_for".}
proc get_transient_for*(self: Window): Window {.inline.} =
  wrap(gtk_window_get_transient_for(self))
# proc get_transient_for*(self: Window): Window {.inline.} =

# gtk_window_get_type_hint
# flags: {isMethod} container: Window
# need sugar: is method
# return: INTERFACE 'Gdk3.WindowTypeHint' 'Gdk3.WindowTypeHint'
proc gtk_window_get_type_hint(self: ptr TWindow): Gdk3.WindowTypeHint {.cdecl, dynlib: lib, importc: "gtk_window_get_type_hint".}
proc get_type_hint*(self: Window): Gdk3.WindowTypeHint {.inline.} =
  gtk_window_get_type_hint(self)
# proc get_type_hint*(self: Window): Gdk3.WindowTypeHint {.inline.} =

# gtk_window_get_urgency_hint
# flags: {isMethod} container: Window
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_window_get_urgency_hint(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_get_urgency_hint".}
proc get_urgency_hint*(self: Window): bool {.inline.} =
  gtk_window_get_urgency_hint(self)
# proc get_urgency_hint*(self: Window): bool {.inline.} =

# gtk_window_get_window_type
# flags: {isMethod} container: Window
# need sugar: is method
# return: INTERFACE 'WindowType' 'WindowType'
proc gtk_window_get_window_type(self: ptr TWindow): WindowType {.cdecl, dynlib: lib, importc: "gtk_window_get_window_type".}
proc get_window_type*(self: Window): WindowType {.inline.} =
  gtk_window_get_window_type(self)
# proc get_window_type*(self: Window): WindowType {.inline.} =

# gtk_window_has_group
# flags: {isMethod} container: Window
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_window_has_group(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_has_group".}
proc has_group*(self: Window): bool {.inline.} =
  gtk_window_has_group(self)
# proc has_group*(self: Window): bool {.inline.} =

# gtk_window_has_toplevel_focus
# flags: {isMethod} container: Window
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_window_has_toplevel_focus(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_has_toplevel_focus".}
proc has_toplevel_focus*(self: Window): bool {.inline.} =
  gtk_window_has_toplevel_focus(self)
# proc has_toplevel_focus*(self: Window): bool {.inline.} =

# gtk_window_iconify
# flags: {isMethod} container: Window
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_iconify(self: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_window_iconify".}
proc iconify*(self: Window) {.inline.} =
  gtk_window_iconify(self)
# proc iconify*(self: Window) {.inline.} =

# gtk_window_is_active
# flags: {isMethod} container: Window
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_window_is_active(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_is_active".}
proc is_active*(self: Window): bool {.inline.} =
  gtk_window_is_active(self)
# proc is_active*(self: Window): bool {.inline.} =

# gtk_window_is_maximized
# flags: {isMethod} container: Window
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_window_is_maximized(self: ptr TWindow): bool {.cdecl, dynlib: lib, importc: "gtk_window_is_maximized".}
proc is_maximized*(self: Window): bool {.inline.} =
  gtk_window_is_maximized(self)
# proc is_maximized*(self: Window): bool {.inline.} =

# gtk_window_maximize
# flags: {isMethod} container: Window
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_maximize(self: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_window_maximize".}
proc maximize*(self: Window) {.inline.} =
  gtk_window_maximize(self)
# proc maximize*(self: Window) {.inline.} =

# gtk_window_mnemonic_activate
# flags: {isMethod} container: Window
# need sugar: is method
# arg keyval: UINT32 'uint32' 'uint32' IN
# arg modifier: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_window_mnemonic_activate(self: ptr TWindow, keyval: uint32, modifier: Gdk3.SModifierType): bool {.cdecl, dynlib: lib, importc: "gtk_window_mnemonic_activate".}
proc mnemonic_activate*(self: Window, keyval: uint32, modifier: Gdk3.SModifierType): bool {.inline.} =
  gtk_window_mnemonic_activate(self, keyval, modifier)
# proc mnemonic_activate*(self: Window, keyval: uint32, modifier: Gdk3.SModifierType): bool {.inline.} =

# gtk_window_move
# flags: {isMethod} container: Window
# need sugar: is method
# arg x: INT32 'int32' 'int32' IN
# arg y: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_move(self: ptr TWindow, x: int32, y: int32) {.cdecl, dynlib: lib, importc: "gtk_window_move".}
proc move*(self: Window, x: int32, y: int32) {.inline.} =
  gtk_window_move(self, x, y)
# proc move*(self: Window, x: int32, y: int32) {.inline.} =

# gtk_window_parse_geometry
# flags: {isMethod} container: Window
# need sugar: is method
# arg geometry: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_window_parse_geometry(self: ptr TWindow, geometry: ucstring): bool {.cdecl, dynlib: lib, importc: "gtk_window_parse_geometry".}
proc parse_geometry*(self: Window, geometry: ustring): bool {.inline.} =
  gtk_window_parse_geometry(self, ucstring(geometry))
# proc parse_geometry*(self: Window, geometry: ustring): bool {.inline.} =

# gtk_window_present
# flags: {isMethod} container: Window
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_present(self: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_window_present".}
proc present*(self: Window) {.inline.} =
  gtk_window_present(self)
# proc present*(self: Window) {.inline.} =

# gtk_window_present_with_time
# flags: {isMethod} container: Window
# need sugar: is method
# arg timestamp: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_present_with_time(self: ptr TWindow, timestamp: uint32) {.cdecl, dynlib: lib, importc: "gtk_window_present_with_time".}
proc present_with_time*(self: Window, timestamp: uint32) {.inline.} =
  gtk_window_present_with_time(self, timestamp)
# proc present_with_time*(self: Window, timestamp: uint32) {.inline.} =

# gtk_window_propagate_key_event
# flags: {isMethod} container: Window
# need sugar: is method
# arg event: INTERFACE (STRUCT) 'ptr Gdk3.TEventKey' 'ptr Gdk3.TEventKey' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_window_propagate_key_event(self: ptr TWindow, event: ptr Gdk3.TEventKey): bool {.cdecl, dynlib: lib, importc: "gtk_window_propagate_key_event".}
proc propagate_key_event*(self: Window, event: ptr Gdk3.TEventKey): bool {.inline.} =
  gtk_window_propagate_key_event(self, event)
# proc propagate_key_event*(self: Window, event: ptr Gdk3.TEventKey): bool {.inline.} =

# gtk_window_remove_accel_group
# flags: {isMethod} container: Window
# need sugar: is method
# arg accel_group: INTERFACE (OBJECT) 'AccelGroup' 'ptr TAccelGroup' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_remove_accel_group(self: ptr TWindow, accel_group: ptr TAccelGroup) {.cdecl, dynlib: lib, importc: "gtk_window_remove_accel_group".}
proc remove_accel_group*(self: Window, accel_group: AccelGroup) {.inline.} =
  gtk_window_remove_accel_group(self, accel_group.getPointer)
# proc remove_accel_group*(self: Window, accel_group: AccelGroup) {.inline.} =

# gtk_window_remove_mnemonic
# flags: {isMethod} container: Window
# need sugar: is method
# arg keyval: UINT32 'uint32' 'uint32' IN
# arg target: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_remove_mnemonic(self: ptr TWindow, keyval: uint32, target: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_window_remove_mnemonic".}
proc remove_mnemonic*(self: Window, keyval: uint32, target: Widget) {.inline.} =
  gtk_window_remove_mnemonic(self, keyval, target.getPointer)
# proc remove_mnemonic*(self: Window, keyval: uint32, target: Widget) {.inline.} =

# gtk_window_reshow_with_initial_size
# flags: {isMethod} container: Window (deprecated)
# gtk_window_resize
# flags: {isMethod} container: Window
# need sugar: is method
# arg width: INT32 'int32' 'int32' IN
# arg height: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_resize(self: ptr TWindow, width: int32, height: int32) {.cdecl, dynlib: lib, importc: "gtk_window_resize".}
proc resize*(self: Window, width: int32, height: int32) {.inline.} =
  gtk_window_resize(self, width, height)
# proc resize*(self: Window, width: int32, height: int32) {.inline.} =

# gtk_window_resize_grip_is_visible
# flags: {isMethod} container: Window (deprecated)
# gtk_window_resize_to_geometry
# flags: {isMethod} container: Window
# need sugar: is method
# arg width: INT32 'int32' 'int32' IN
# arg height: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_resize_to_geometry(self: ptr TWindow, width: int32, height: int32) {.cdecl, dynlib: lib, importc: "gtk_window_resize_to_geometry".}
proc resize_to_geometry*(self: Window, width: int32, height: int32) {.inline.} =
  gtk_window_resize_to_geometry(self, width, height)
# proc resize_to_geometry*(self: Window, width: int32, height: int32) {.inline.} =

# gtk_window_set_accept_focus
# flags: {isMethod} container: Window
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_accept_focus(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_accept_focus".}
proc set_accept_focus*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_accept_focus(self, setting)
# proc set_accept_focus*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_application
# flags: {isMethod} container: Window
# need sugar: is method
# arg application: INTERFACE (OBJECT) 'Application' 'ptr TApplication' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_application(self: ptr TWindow, application: ptr TApplication) {.cdecl, dynlib: lib, importc: "gtk_window_set_application".}
proc set_application*(self: Window, application: Application) {.inline.} =
  gtk_window_set_application(self, application.getPointer)
# proc set_application*(self: Window, application: Application) {.inline.} =

# gtk_window_set_attached_to
# flags: {isMethod} container: Window
# need sugar: is method
# arg attach_widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_attached_to(self: ptr TWindow, attach_widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_window_set_attached_to".}
proc set_attached_to*(self: Window, attach_widget: Widget) {.inline.} =
  gtk_window_set_attached_to(self, attach_widget.getPointer)
# proc set_attached_to*(self: Window, attach_widget: Widget) {.inline.} =

# gtk_window_set_decorated
# flags: {isMethod} container: Window
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_decorated(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_decorated".}
proc set_decorated*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_decorated(self, setting)
# proc set_decorated*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_default
# flags: {isMethod} container: Window
# need sugar: is method
# arg default_widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_default(self: ptr TWindow, default_widget: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_window_set_default".}
proc set_default*(self: Window, default_widget: Widget) {.inline.} =
  gtk_window_set_default(self, default_widget.getPointer)
# proc set_default*(self: Window, default_widget: Widget) {.inline.} =

# gtk_window_set_default_geometry
# flags: {isMethod} container: Window
# need sugar: is method
# arg width: INT32 'int32' 'int32' IN
# arg height: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_default_geometry(self: ptr TWindow, width: int32, height: int32) {.cdecl, dynlib: lib, importc: "gtk_window_set_default_geometry".}
proc set_default_geometry*(self: Window, width: int32, height: int32) {.inline.} =
  gtk_window_set_default_geometry(self, width, height)
# proc set_default_geometry*(self: Window, width: int32, height: int32) {.inline.} =

# gtk_window_set_default_size
# flags: {isMethod} container: Window
# need sugar: is method
# arg width: INT32 'int32' 'int32' IN
# arg height: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_default_size(self: ptr TWindow, width: int32, height: int32) {.cdecl, dynlib: lib, importc: "gtk_window_set_default_size".}
proc set_default_size*(self: Window, width: int32, height: int32) {.inline.} =
  gtk_window_set_default_size(self, width, height)
# proc set_default_size*(self: Window, width: int32, height: int32) {.inline.} =

# gtk_window_set_deletable
# flags: {isMethod} container: Window
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_deletable(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_deletable".}
proc set_deletable*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_deletable(self, setting)
# proc set_deletable*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_destroy_with_parent
# flags: {isMethod} container: Window
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_destroy_with_parent(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_destroy_with_parent".}
proc set_destroy_with_parent*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_destroy_with_parent(self, setting)
# proc set_destroy_with_parent*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_focus
# flags: {isMethod} container: Window
# need sugar: is method
# arg focus: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_focus(self: ptr TWindow, focus: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_window_set_focus".}
proc set_focus*(self: Window, focus: Widget) {.inline.} =
  gtk_window_set_focus(self, focus.getPointer)
# proc set_focus*(self: Window, focus: Widget) {.inline.} =

# gtk_window_set_focus_on_map
# flags: {isMethod} container: Window
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_focus_on_map(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_focus_on_map".}
proc set_focus_on_map*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_focus_on_map(self, setting)
# proc set_focus_on_map*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_focus_visible
# flags: {isMethod} container: Window
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_focus_visible(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_focus_visible".}
proc set_focus_visible*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_focus_visible(self, setting)
# proc set_focus_visible*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_geometry_hints
# flags: {isMethod} container: Window
# need sugar: is method
# arg geometry_widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# arg geometry: INTERFACE (STRUCT) 'ptr Gdk3.TGeometry' 'ptr Gdk3.TGeometry' IN
# arg geom_mask: INTERFACE (FLAGS) 'Gdk3.SWindowHints' 'Gdk3.SWindowHints' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_geometry_hints(self: ptr TWindow, geometry_widget: ptr TWidget, geometry: ptr Gdk3.TGeometry, geom_mask: Gdk3.SWindowHints) {.cdecl, dynlib: lib, importc: "gtk_window_set_geometry_hints".}
proc set_geometry_hints*(self: Window, geometry_widget: Widget, geometry: ptr Gdk3.TGeometry, geom_mask: Gdk3.SWindowHints) {.inline.} =
  gtk_window_set_geometry_hints(self, geometry_widget.getPointer, geometry, geom_mask)
# proc set_geometry_hints*(self: Window, geometry_widget: Widget, geometry: ptr Gdk3.TGeometry, geom_mask: Gdk3.SWindowHints) {.inline.} =

# gtk_window_set_gravity
# flags: {isMethod} container: Window
# need sugar: is method
# arg gravity: INTERFACE (ENUM) 'Gdk3.Gravity' 'Gdk3.Gravity' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_gravity(self: ptr TWindow, gravity: Gdk3.Gravity) {.cdecl, dynlib: lib, importc: "gtk_window_set_gravity".}
proc set_gravity*(self: Window, gravity: Gdk3.Gravity) {.inline.} =
  gtk_window_set_gravity(self, gravity)
# proc set_gravity*(self: Window, gravity: Gdk3.Gravity) {.inline.} =

# gtk_window_set_has_resize_grip
# flags: {isMethod} container: Window (deprecated)
# gtk_window_set_has_user_ref_count
# flags: {isMethod} container: Window
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_has_user_ref_count(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_has_user_ref_count".}
proc set_has_user_ref_count*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_has_user_ref_count(self, setting)
# proc set_has_user_ref_count*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_hide_titlebar_when_maximized
# flags: {isMethod} container: Window
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_hide_titlebar_when_maximized(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_hide_titlebar_when_maximized".}
proc set_hide_titlebar_when_maximized*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_hide_titlebar_when_maximized(self, setting)
# proc set_hide_titlebar_when_maximized*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_icon
# flags: {isMethod} container: Window
# need sugar: is method
# arg icon: INTERFACE (OBJECT) 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_icon(self: ptr TWindow, icon: ptr GdkPixbuf2.TPixbuf) {.cdecl, dynlib: lib, importc: "gtk_window_set_icon".}
proc set_icon*(self: Window, icon: GdkPixbuf2.Pixbuf) {.inline.} =
  gtk_window_set_icon(self, icon.getPointer)
# proc set_icon*(self: Window, icon: GdkPixbuf2.Pixbuf) {.inline.} =

# gtk_window_set_icon_from_file
# flags: {isMethod, throws} container: Window
# can throw
# need sugar: is method
# arg filename: FILENAME 'string' 'cstring' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_window_set_icon_from_file(self: ptr TWindow, filename: cstring, error: ptr PGError=nil): bool {.cdecl, dynlib: lib, importc: "gtk_window_set_icon_from_file".}
proc set_icon_from_file*(self: Window, filename: string): bool {.inline.} =
  gtk_window_set_icon_from_file(self, cstring(filename))
# proc set_icon_from_file*(self: Window, filename: string): bool {.inline.} =

# gtk_window_set_icon_list
# flags: {isMethod} container: Window
# need sugar: is method
# arg list: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_icon_list(self: ptr TWindow, list: ptr GLIST_TODO) {.cdecl, dynlib: lib, importc: "gtk_window_set_icon_list".}
proc set_icon_list*(self: Window, list: ptr GLIST_TODO) {.inline.} =
  gtk_window_set_icon_list(self, list)
# proc set_icon_list*(self: Window, list: ptr GLIST_TODO) {.inline.} =

# gtk_window_set_icon_name
# flags: {isMethod} container: Window
# need sugar: is method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_icon_name(self: ptr TWindow, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_window_set_icon_name".}
proc set_icon_name*(self: Window, name: ustring) {.inline.} =
  gtk_window_set_icon_name(self, ucstring(name))
# proc set_icon_name*(self: Window, name: ustring) {.inline.} =

# gtk_window_set_keep_above
# flags: {isMethod} container: Window
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_keep_above(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_keep_above".}
proc set_keep_above*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_keep_above(self, setting)
# proc set_keep_above*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_keep_below
# flags: {isMethod} container: Window
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_keep_below(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_keep_below".}
proc set_keep_below*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_keep_below(self, setting)
# proc set_keep_below*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_mnemonic_modifier
# flags: {isMethod} container: Window
# need sugar: is method
# arg modifier: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_mnemonic_modifier(self: ptr TWindow, modifier: Gdk3.SModifierType) {.cdecl, dynlib: lib, importc: "gtk_window_set_mnemonic_modifier".}
proc set_mnemonic_modifier*(self: Window, modifier: Gdk3.SModifierType) {.inline.} =
  gtk_window_set_mnemonic_modifier(self, modifier)
# proc set_mnemonic_modifier*(self: Window, modifier: Gdk3.SModifierType) {.inline.} =

# gtk_window_set_mnemonics_visible
# flags: {isMethod} container: Window
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_mnemonics_visible(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_mnemonics_visible".}
proc set_mnemonics_visible*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_mnemonics_visible(self, setting)
# proc set_mnemonics_visible*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_modal
# flags: {isMethod} container: Window
# need sugar: is method
# arg modal: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_modal(self: ptr TWindow, modal: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_modal".}
proc set_modal*(self: Window, modal: bool) {.inline.} =
  gtk_window_set_modal(self, modal)
# proc set_modal*(self: Window, modal: bool) {.inline.} =

# gtk_window_set_opacity
# flags: {isMethod} container: Window (deprecated)
# gtk_window_set_position
# flags: {isMethod} container: Window
# need sugar: is method
# arg position: INTERFACE (ENUM) 'WindowPosition' 'WindowPosition' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_position(self: ptr TWindow, position: WindowPosition) {.cdecl, dynlib: lib, importc: "gtk_window_set_position".}
proc set_position*(self: Window, position: WindowPosition) {.inline.} =
  gtk_window_set_position(self, position)
# proc set_position*(self: Window, position: WindowPosition) {.inline.} =

# gtk_window_set_resizable
# flags: {isMethod} container: Window
# need sugar: is method
# arg resizable: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_resizable(self: ptr TWindow, resizable: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_resizable".}
proc set_resizable*(self: Window, resizable: bool) {.inline.} =
  gtk_window_set_resizable(self, resizable)
# proc set_resizable*(self: Window, resizable: bool) {.inline.} =

# gtk_window_set_role
# flags: {isMethod} container: Window
# need sugar: is method
# arg role: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_role(self: ptr TWindow, role: ucstring) {.cdecl, dynlib: lib, importc: "gtk_window_set_role".}
proc set_role*(self: Window, role: ustring) {.inline.} =
  gtk_window_set_role(self, ucstring(role))
# proc set_role*(self: Window, role: ustring) {.inline.} =

# gtk_window_set_screen
# flags: {isMethod} container: Window
# need sugar: is method
# arg screen: INTERFACE (OBJECT) 'Gdk3.Screen' 'ptr Gdk3.TScreen' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_screen(self: ptr TWindow, screen: ptr Gdk3.TScreen) {.cdecl, dynlib: lib, importc: "gtk_window_set_screen".}
proc set_screen*(self: Window, screen: Gdk3.Screen) {.inline.} =
  gtk_window_set_screen(self, screen.getPointer)
# proc set_screen*(self: Window, screen: Gdk3.Screen) {.inline.} =

# gtk_window_set_skip_pager_hint
# flags: {isMethod} container: Window
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_skip_pager_hint(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_skip_pager_hint".}
proc set_skip_pager_hint*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_skip_pager_hint(self, setting)
# proc set_skip_pager_hint*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_skip_taskbar_hint
# flags: {isMethod} container: Window
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_skip_taskbar_hint(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_skip_taskbar_hint".}
proc set_skip_taskbar_hint*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_skip_taskbar_hint(self, setting)
# proc set_skip_taskbar_hint*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_startup_id
# flags: {isMethod} container: Window
# need sugar: is method
# arg startup_id: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_startup_id(self: ptr TWindow, startup_id: ucstring) {.cdecl, dynlib: lib, importc: "gtk_window_set_startup_id".}
proc set_startup_id*(self: Window, startup_id: ustring) {.inline.} =
  gtk_window_set_startup_id(self, ucstring(startup_id))
# proc set_startup_id*(self: Window, startup_id: ustring) {.inline.} =

# gtk_window_set_title
# flags: {isMethod} container: Window
# need sugar: is method
# arg title: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_title(self: ptr TWindow, title: ucstring) {.cdecl, dynlib: lib, importc: "gtk_window_set_title".}
proc set_title*(self: Window, title: ustring) {.inline.} =
  gtk_window_set_title(self, ucstring(title))
# proc set_title*(self: Window, title: ustring) {.inline.} =

# gtk_window_set_titlebar
# flags: {isMethod} container: Window
# need sugar: is method
# arg titlebar: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_titlebar(self: ptr TWindow, titlebar: ptr TWidget) {.cdecl, dynlib: lib, importc: "gtk_window_set_titlebar".}
proc set_titlebar*(self: Window, titlebar: Widget) {.inline.} =
  gtk_window_set_titlebar(self, titlebar.getPointer)
# proc set_titlebar*(self: Window, titlebar: Widget) {.inline.} =

# gtk_window_set_transient_for
# flags: {isMethod} container: Window
# need sugar: is method
# arg parent: INTERFACE (OBJECT) 'Window' 'ptr TWindow' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_transient_for(self: ptr TWindow, parent: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_window_set_transient_for".}
proc set_transient_for*(self: Window, parent: Window) {.inline.} =
  gtk_window_set_transient_for(self, parent.getPointer)
# proc set_transient_for*(self: Window, parent: Window) {.inline.} =

# gtk_window_set_type_hint
# flags: {isMethod} container: Window
# need sugar: is method
# arg hint: INTERFACE (ENUM) 'Gdk3.WindowTypeHint' 'Gdk3.WindowTypeHint' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_type_hint(self: ptr TWindow, hint: Gdk3.WindowTypeHint) {.cdecl, dynlib: lib, importc: "gtk_window_set_type_hint".}
proc set_type_hint*(self: Window, hint: Gdk3.WindowTypeHint) {.inline.} =
  gtk_window_set_type_hint(self, hint)
# proc set_type_hint*(self: Window, hint: Gdk3.WindowTypeHint) {.inline.} =

# gtk_window_set_urgency_hint
# flags: {isMethod} container: Window
# need sugar: is method
# arg setting: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_urgency_hint(self: ptr TWindow, setting: bool) {.cdecl, dynlib: lib, importc: "gtk_window_set_urgency_hint".}
proc set_urgency_hint*(self: Window, setting: bool) {.inline.} =
  gtk_window_set_urgency_hint(self, setting)
# proc set_urgency_hint*(self: Window, setting: bool) {.inline.} =

# gtk_window_set_wmclass
# flags: {isMethod} container: Window
# need sugar: is method
# arg wmclass_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg wmclass_class: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_set_wmclass(self: ptr TWindow, wmclass_name: ucstring, wmclass_class: ucstring) {.cdecl, dynlib: lib, importc: "gtk_window_set_wmclass".}
proc set_wmclass*(self: Window, wmclass_name: ustring, wmclass_class: ustring) {.inline.} =
  gtk_window_set_wmclass(self, ucstring(wmclass_name), ucstring(wmclass_class))
# proc set_wmclass*(self: Window, wmclass_name: ustring, wmclass_class: ustring) {.inline.} =

# gtk_window_stick
# flags: {isMethod} container: Window
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_stick(self: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_window_stick".}
proc stick*(self: Window) {.inline.} =
  gtk_window_stick(self)
# proc stick*(self: Window) {.inline.} =

# gtk_window_unfullscreen
# flags: {isMethod} container: Window
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_unfullscreen(self: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_window_unfullscreen".}
proc unfullscreen*(self: Window) {.inline.} =
  gtk_window_unfullscreen(self)
# proc unfullscreen*(self: Window) {.inline.} =

# gtk_window_unmaximize
# flags: {isMethod} container: Window
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_unmaximize(self: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_window_unmaximize".}
proc unmaximize*(self: Window) {.inline.} =
  gtk_window_unmaximize(self)
# proc unmaximize*(self: Window) {.inline.} =

# gtk_window_unstick
# flags: {isMethod} container: Window
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_unstick(self: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_window_unstick".}
proc unstick*(self: Window) {.inline.} =
  gtk_window_unstick(self)
# proc unstick*(self: Window) {.inline.} =

# initializer for WindowAccessible: gtk_window_accessible_get_type
proc gtk_window_accessible_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_window_accessible_get_type".}
template gtype*(klass_parameter: typedesc[WindowAccessible]): GType = gtk_window_accessible_get_type()
# initializer for WindowGroup: gtk_window_group_get_type
proc gtk_window_group_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_window_group_get_type".}
template gtype*(klass_parameter: typedesc[WindowGroup]): GType = gtk_window_group_get_type()
# gtk_window_group_new
# flags: {isConstructor} container: WindowGroup
# need sugar: is static method
# return: INTERFACE 'WindowGroup' 'TransferFull[TWindowGroup]' (diff., need sugar)
proc gtk_window_group_new(): TransferFull[TWindowGroup] {.cdecl, dynlib: lib, importc: "gtk_window_group_new".}
proc new_windowgroup*(): WindowGroup {.inline.} =
  wrap(gtk_window_group_new())
# proc new_windowgroup*(): WindowGroup {.inline.} =

# gtk_window_group_add_window
# flags: {isMethod} container: WindowGroup
# need sugar: is method
# arg window: INTERFACE (OBJECT) 'Window' 'ptr TWindow' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_group_add_window(self: ptr TWindowGroup, window: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_window_group_add_window".}
proc add_window*(self: WindowGroup, window: Window) {.inline.} =
  gtk_window_group_add_window(self, window.getPointer)
# proc add_window*(self: WindowGroup, window: Window) {.inline.} =

# gtk_window_group_get_current_device_grab
# flags: {isMethod} container: WindowGroup
# need sugar: is method
# arg device: INTERFACE (OBJECT) 'Gdk3.Device' 'ptr Gdk3.TDevice' IN (diff., need sugar)
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_window_group_get_current_device_grab(self: ptr TWindowGroup, device: ptr Gdk3.TDevice): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_window_group_get_current_device_grab".}
proc get_current_device_grab*(self: WindowGroup, device: Gdk3.Device): Widget {.inline.} =
  wrap(gtk_window_group_get_current_device_grab(self, device.getPointer))
# proc get_current_device_grab*(self: WindowGroup, device: Gdk3.Device): Widget {.inline.} =

# gtk_window_group_get_current_grab
# flags: {isMethod} container: WindowGroup
# need sugar: is method
# return: INTERFACE 'Widget' 'TransferNone[TWidget]' (diff., need sugar)
proc gtk_window_group_get_current_grab(self: ptr TWindowGroup): TransferNone[TWidget] {.cdecl, dynlib: lib, importc: "gtk_window_group_get_current_grab".}
proc get_current_grab*(self: WindowGroup): Widget {.inline.} =
  wrap(gtk_window_group_get_current_grab(self))
# proc get_current_grab*(self: WindowGroup): Widget {.inline.} =

# gtk_window_group_list_windows
# flags: {isMethod} container: WindowGroup
# need sugar: is method
# return: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO'
proc gtk_window_group_list_windows(self: ptr TWindowGroup): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_window_group_list_windows".}
proc list_windows*(self: WindowGroup): ptr GLIST_TODO {.inline.} =
  gtk_window_group_list_windows(self)
# proc list_windows*(self: WindowGroup): ptr GLIST_TODO {.inline.} =

# gtk_window_group_remove_window
# flags: {isMethod} container: WindowGroup
# need sugar: is method
# arg window: INTERFACE (OBJECT) 'Window' 'ptr TWindow' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_window_group_remove_window(self: ptr TWindowGroup, window: ptr TWindow) {.cdecl, dynlib: lib, importc: "gtk_window_group_remove_window".}
proc remove_window*(self: WindowGroup, window: Window) {.inline.} =
  gtk_window_group_remove_window(self, window.getPointer)
# proc remove_window*(self: WindowGroup, window: Window) {.inline.} =

# object signals
#------------------
# AboutDialog - activate-link - 
# uri: ustring (ucstring) IN
declareSignal(AboutDialog, TAboutDialog, activate_link, uri, ustring)
# AccelGroup - accel-activate - 
# acceleratable: GObject2.Object (ptr GObject2.TObject) IN
# keyval: uint32 (uint32) IN
# modifier: Gdk3.SModifierType (Gdk3.SModifierType) IN
# nargs == 3: not implemented
# AccelGroup - accel-changed - 
# keyval: uint32 (uint32) IN
# modifier: Gdk3.SModifierType (Gdk3.SModifierType) IN
# accel_closure: ptr GObject2.TClosure (ptr GObject2.TClosure) IN
# nargs == 3: not implemented
# AccelMap - changed - 
# accel_path: ustring (ucstring) IN
# accel_key: uint32 (uint32) IN
# accel_mods: Gdk3.SModifierType (Gdk3.SModifierType) IN
# nargs == 3: not implemented
# Action - activate - 
declareSignal(Action, TAction, activate)
# ActionGroup - connect-proxy - 
# action: Action (ptr TAction) IN
# proxy: Widget (ptr TWidget) IN
# nargs == 2: not implemented
# ActionGroup - disconnect-proxy - 
# action: Action (ptr TAction) IN
# proxy: Widget (ptr TWidget) IN
# nargs == 2: not implemented
# ActionGroup - post-activate - 
# action: Action (ptr TAction) IN
declareSignal(ActionGroup, TActionGroup, post_activate, action, Action)
# ActionGroup - pre-activate - 
# action: Action (ptr TAction) IN
declareSignal(ActionGroup, TActionGroup, pre_activate, action, Action)
# Adjustment - changed - 
declareSignal(Adjustment, TAdjustment, changed)
# Adjustment - value-changed - 
declareSignal(Adjustment, TAdjustment, value_changed)
# AppChooserButton - custom-item-activated - 
# item_name: ustring (ucstring) IN
declareSignal(AppChooserButton, TAppChooserButton, custom_item_activated, item_name, ustring)
# AppChooserWidget - application-activated - 
# application: ptr Gio2.TAppInfo (ptr Gio2.TAppInfo) IN
declareSignal(AppChooserWidget, TAppChooserWidget, application_activated, application, ptr Gio2.TAppInfo)
# AppChooserWidget - application-selected - 
# application: ptr Gio2.TAppInfo (ptr Gio2.TAppInfo) IN
declareSignal(AppChooserWidget, TAppChooserWidget, application_selected, application, ptr Gio2.TAppInfo)
# AppChooserWidget - populate-popup - 
# menu: Menu (ptr TMenu) IN
# application: ptr Gio2.TAppInfo (ptr Gio2.TAppInfo) IN
# nargs == 2: not implemented
# Application - window-added - 
# window: Window (ptr TWindow) IN
declareSignal(Application, TApplication, window_added, window, Window)
# Application - window-removed - 
# window: Window (ptr TWindow) IN
declareSignal(Application, TApplication, window_removed, window, Window)
# Assistant - apply - 
declareSignal(Assistant, TAssistant, apply)
# Assistant - cancel - 
declareSignal(Assistant, TAssistant, cancel)
# Assistant - close - 
declareSignal(Assistant, TAssistant, close)
# Assistant - escape - 
declareSignal(Assistant, TAssistant, escape)
# Assistant - prepare - 
# page: Widget (ptr TWidget) IN
declareSignal(Assistant, TAssistant, prepare, page, Widget)
# Button - activate - 
declareSignal(Button, TButton, activate)
# Button - clicked - 
declareSignal(Button, TButton, clicked)
# Button - enter - 
declareSignal(Button, TButton, enter)
# Button - leave - 
declareSignal(Button, TButton, leave)
# Button - pressed - 
declareSignal(Button, TButton, pressed)
# Button - released - 
declareSignal(Button, TButton, released)
# Calendar - day-selected - 
declareSignal(Calendar, TCalendar, day_selected)
# Calendar - day-selected-double-click - 
declareSignal(Calendar, TCalendar, day_selected_double_click)
# Calendar - month-changed - 
declareSignal(Calendar, TCalendar, month_changed)
# Calendar - next-month - 
declareSignal(Calendar, TCalendar, next_month)
# Calendar - next-year - 
declareSignal(Calendar, TCalendar, next_year)
# Calendar - prev-month - 
declareSignal(Calendar, TCalendar, prev_month)
# Calendar - prev-year - 
declareSignal(Calendar, TCalendar, prev_year)
# CellArea - add-editable - 
# renderer: CellRenderer (ptr TCellRenderer) IN
# editable: ptr TCellEditable (ptr TCellEditable) IN
# cell_area: ptr Gdk3.TRectangle (ptr Gdk3.TRectangle) IN
# path: ustring (ucstring) IN
# nargs == 4: not implemented
# CellArea - apply-attributes - 
# model: ptr TTreeModel (ptr TTreeModel) IN
# iter: ptr TTreeIter (ptr TTreeIter) IN
# is_expander: bool (bool) IN
# is_expanded: bool (bool) IN
# nargs == 4: not implemented
# CellArea - focus-changed - 
# renderer: CellRenderer (ptr TCellRenderer) IN
# path: ustring (ucstring) IN
# nargs == 2: not implemented
# CellArea - remove-editable - 
# renderer: CellRenderer (ptr TCellRenderer) IN
# editable: ptr TCellEditable (ptr TCellEditable) IN
# nargs == 2: not implemented
# CellRenderer - editing-canceled - 
declareSignal(CellRenderer, TCellRenderer, editing_canceled)
# CellRenderer - editing-started - 
# editable: ptr TCellEditable (ptr TCellEditable) IN
# path: ustring (ucstring) IN
# nargs == 2: not implemented
# CellRendererAccel - accel-cleared - 
# path_string: ustring (ucstring) IN
declareSignal(CellRendererAccel, TCellRendererAccel, accel_cleared, path_string, ustring)
# CellRendererAccel - accel-edited - 
# path_string: ustring (ucstring) IN
# accel_key: uint32 (uint32) IN
# accel_mods: Gdk3.SModifierType (Gdk3.SModifierType) IN
# hardware_keycode: uint32 (uint32) IN
# nargs == 4: not implemented
# CellRendererCombo - changed - 
# path_string: ustring (ucstring) IN
# new_iter: ptr TTreeIter (ptr TTreeIter) IN
# nargs == 2: not implemented
# CellRendererText - edited - 
# path: ustring (ucstring) IN
# new_text: ustring (ucstring) IN
# nargs == 2: not implemented
# CellRendererToggle - toggled - 
# path: ustring (ucstring) IN
declareSignal(CellRendererToggle, TCellRendererToggle, toggled, path, ustring)
# CheckMenuItem - toggled - 
declareSignal(CheckMenuItem, TCheckMenuItem, toggled)
# Clipboard - owner-change - 
# event: ptr Gdk3.TEventOwnerChange (ptr Gdk3.TEventOwnerChange) IN
declareSignal(Clipboard, TClipboard, owner_change, event, ptr Gdk3.TEventOwnerChange)
# ColorButton - color-set - 
declareSignal(ColorButton, TColorButton, color_set)
# ColorSelection - color-changed - 
declareSignal(ColorSelection, TColorSelection, color_changed)
# ComboBox - changed - 
declareSignal(ComboBox, TComboBox, changed)
# ComboBox - format-entry-text - 
# path: ustring (ucstring) IN
declareSignal(ComboBox, TComboBox, format_entry_text, path, ustring)
# ComboBox - move-active - 
# scroll_type: ScrollType (ScrollType) IN
declareSignal(ComboBox, TComboBox, move_active, scroll_type, ScrollType)
# ComboBox - popdown - 
declareSignal(ComboBox, TComboBox, popdown)
# ComboBox - popup - 
declareSignal(ComboBox, TComboBox, popup)
# Container - add - 
# object: Widget (ptr TWidget) IN
declareSignal(Container, TContainer, add, object_x, Widget)
# Container - check-resize - 
declareSignal(Container, TContainer, check_resize)
# Container - remove - 
# object: Widget (ptr TWidget) IN
declareSignal(Container, TContainer, remove, object_x, Widget)
# Container - set-focus-child - 
# object: Widget (ptr TWidget) IN
declareSignal(Container, TContainer, set_focus_child, object_x, Widget)
# CssProvider - parsing-error - 
# section: ptr TCssSection (ptr TCssSection) IN
# error: ptr ERROR_TODO (ptr ERROR_TODO) IN
# nargs == 2: not implemented
# Dialog - close - 
declareSignal(Dialog, TDialog, close)
# Dialog - response - 
# response_id: int32 (int32) IN
declareSignal(Dialog, TDialog, response, response_id, int32)
# Entry - activate - 
declareSignal(Entry, TEntry, activate)
# Entry - backspace - 
declareSignal(Entry, TEntry, backspace)
# Entry - copy-clipboard - 
declareSignal(Entry, TEntry, copy_clipboard)
# Entry - cut-clipboard - 
declareSignal(Entry, TEntry, cut_clipboard)
# Entry - delete-from-cursor - 
# type: DeleteType (DeleteType) IN
# count: int32 (int32) IN
# nargs == 2: not implemented
# Entry - icon-press - 
# icon_pos: EntryIconPosition (EntryIconPosition) IN
# event: ptr Gdk3.TEventButton (ptr Gdk3.TEventButton) IN
# nargs == 2: not implemented
# Entry - icon-release - 
# icon_pos: EntryIconPosition (EntryIconPosition) IN
# event: ptr Gdk3.TEventButton (ptr Gdk3.TEventButton) IN
# nargs == 2: not implemented
# Entry - insert-at-cursor - 
# string: ustring (ucstring) IN
declareSignal(Entry, TEntry, insert_at_cursor, string, ustring)
# Entry - move-cursor - 
# step: MovementStep (MovementStep) IN
# count: int32 (int32) IN
# extend_selection: bool (bool) IN
# nargs == 3: not implemented
# Entry - paste-clipboard - 
declareSignal(Entry, TEntry, paste_clipboard)
# Entry - populate-popup - 
# popup: Widget (ptr TWidget) IN
declareSignal(Entry, TEntry, populate_popup, popup, Widget)
# Entry - preedit-changed - 
# preedit: ustring (ucstring) IN
declareSignal(Entry, TEntry, preedit_changed, preedit, ustring)
# Entry - toggle-overwrite - 
declareSignal(Entry, TEntry, toggle_overwrite)
# EntryBuffer - deleted-text - 
# position: uint32 (uint32) IN
# n_chars: uint32 (uint32) IN
# nargs == 2: not implemented
# EntryBuffer - inserted-text - 
# position: uint32 (uint32) IN
# chars: ustring (ucstring) IN
# n_chars: uint32 (uint32) IN
# nargs == 3: not implemented
# EntryCompletion - action-activated - 
# index: int32 (int32) IN
declareSignal(EntryCompletion, TEntryCompletion, action_activated, index, int32)
# EntryCompletion - cursor-on-match - 
# model: ptr TTreeModel (ptr TTreeModel) IN
# iter: ptr TTreeIter (ptr TTreeIter) IN
# nargs == 2: not implemented
# EntryCompletion - insert-prefix - 
# prefix: ustring (ucstring) IN
declareSignal(EntryCompletion, TEntryCompletion, insert_prefix, prefix, ustring)
# EntryCompletion - match-selected - 
# model: ptr TTreeModel (ptr TTreeModel) IN
# iter: ptr TTreeIter (ptr TTreeIter) IN
# nargs == 2: not implemented
# EntryCompletion - no-matches - 
declareSignal(EntryCompletion, TEntryCompletion, no_matches)
# Expander - activate - 
declareSignal(Expander, TExpander, activate)
# FileChooserButton - file-set - 
declareSignal(FileChooserButton, TFileChooserButton, file_set)
# FileChooserWidget - desktop-folder - 
declareSignal(FileChooserWidget, TFileChooserWidget, desktop_folder)
# FileChooserWidget - down-folder - 
declareSignal(FileChooserWidget, TFileChooserWidget, down_folder)
# FileChooserWidget - home-folder - 
declareSignal(FileChooserWidget, TFileChooserWidget, home_folder)
# FileChooserWidget - location-popup - 
# path: ustring (ucstring) IN
declareSignal(FileChooserWidget, TFileChooserWidget, location_popup, path, ustring)
# FileChooserWidget - location-popup-on-paste - 
declareSignal(FileChooserWidget, TFileChooserWidget, location_popup_on_paste)
# FileChooserWidget - location-toggle-popup - 
declareSignal(FileChooserWidget, TFileChooserWidget, location_toggle_popup)
# FileChooserWidget - places-shortcut - 
declareSignal(FileChooserWidget, TFileChooserWidget, places_shortcut)
# FileChooserWidget - quick-bookmark - 
# bookmark_index: int32 (int32) IN
declareSignal(FileChooserWidget, TFileChooserWidget, quick_bookmark, bookmark_index, int32)
# FileChooserWidget - recent-shortcut - 
declareSignal(FileChooserWidget, TFileChooserWidget, recent_shortcut)
# FileChooserWidget - search-shortcut - 
declareSignal(FileChooserWidget, TFileChooserWidget, search_shortcut)
# FileChooserWidget - show-hidden - 
declareSignal(FileChooserWidget, TFileChooserWidget, show_hidden)
# FileChooserWidget - up-folder - 
declareSignal(FileChooserWidget, TFileChooserWidget, up_folder)
# FlowBox - activate-cursor-child - 
declareSignal(FlowBox, TFlowBox, activate_cursor_child)
# FlowBox - child-activated - 
# child: FlowBoxChild (ptr TFlowBoxChild) IN
declareSignal(FlowBox, TFlowBox, child_activated, child, FlowBoxChild)
# FlowBox - move-cursor - 
# step: MovementStep (MovementStep) IN
# count: int32 (int32) IN
# nargs == 2: not implemented
# FlowBox - select-all - 
declareSignal(FlowBox, TFlowBox, select_all)
# FlowBox - selected-children-changed - 
declareSignal(FlowBox, TFlowBox, selected_children_changed)
# FlowBox - toggle-cursor-child - 
declareSignal(FlowBox, TFlowBox, toggle_cursor_child)
# FlowBox - unselect-all - 
declareSignal(FlowBox, TFlowBox, unselect_all)
# FlowBoxChild - activate - 
declareSignal(FlowBoxChild, TFlowBoxChild, activate)
# FontButton - font-set - 
declareSignal(FontButton, TFontButton, font_set)
# GLArea - create-context - 
declareSignal(GLArea, TGLArea, create_context)
# GLArea - render - 
# context: Gdk3.GLContext (ptr Gdk3.TGLContext) IN
declareSignal(GLArea, TGLArea, render, context, Gdk3.GLContext)
# GLArea - resize - 
# width: int32 (int32) IN
# height: int32 (int32) IN
# nargs == 2: not implemented
# Gesture - begin - 
# sequence: ptr Gdk3.TEventSequence (ptr Gdk3.TEventSequence) IN
declareSignal(Gesture, TGesture, begin, sequence, ptr Gdk3.TEventSequence)
# Gesture - cancel - 
# sequence: ptr Gdk3.TEventSequence (ptr Gdk3.TEventSequence) IN
declareSignal(Gesture, TGesture, cancel, sequence, ptr Gdk3.TEventSequence)
# Gesture - end - 
# sequence: ptr Gdk3.TEventSequence (ptr Gdk3.TEventSequence) IN
declareSignal(Gesture, TGesture, end_x, sequence, ptr Gdk3.TEventSequence)
# Gesture - sequence-state-changed - 
# sequence: ptr Gdk3.TEventSequence (ptr Gdk3.TEventSequence) IN
# state: EventSequenceState (EventSequenceState) IN
# nargs == 2: not implemented
# Gesture - update - 
# sequence: ptr Gdk3.TEventSequence (ptr Gdk3.TEventSequence) IN
declareSignal(Gesture, TGesture, update, sequence, ptr Gdk3.TEventSequence)
# GestureDrag - drag-begin - 
# start_x: float64 (float64) IN
# start_y: float64 (float64) IN
# nargs == 2: not implemented
# GestureDrag - drag-end - 
# offset_x: float64 (float64) IN
# offset_y: float64 (float64) IN
# nargs == 2: not implemented
# GestureDrag - drag-update - 
# offset_x: float64 (float64) IN
# offset_y: float64 (float64) IN
# nargs == 2: not implemented
# GestureLongPress - cancelled - 
declareSignal(GestureLongPress, TGestureLongPress, cancelled)
# GestureLongPress - pressed - 
# x: float64 (float64) IN
# y: float64 (float64) IN
# nargs == 2: not implemented
# GestureMultiPress - pressed - 
# n_press: int32 (int32) IN
# x: float64 (float64) IN
# y: float64 (float64) IN
# nargs == 3: not implemented
# GestureMultiPress - released - 
# n_press: int32 (int32) IN
# x: float64 (float64) IN
# y: float64 (float64) IN
# nargs == 3: not implemented
# GestureMultiPress - stopped - 
declareSignal(GestureMultiPress, TGestureMultiPress, stopped)
# GesturePan - pan - 
# direction: PanDirection (PanDirection) IN
# offset: float64 (float64) IN
# nargs == 2: not implemented
# GestureRotate - angle-changed - 
# angle: float64 (float64) IN
# angle_delta: float64 (float64) IN
# nargs == 2: not implemented
# GestureSwipe - swipe - 
# velocity_x: float64 (float64) IN
# velocity_y: float64 (float64) IN
# nargs == 2: not implemented
# GestureZoom - scale-changed - 
# scale: float64 (float64) IN
declareSignal(GestureZoom, TGestureZoom, scale_changed, scale, float64)
# HSV - changed - 
declareSignal(HSV, THSV, changed)
# HSV - move - 
# object: DirectionType (DirectionType) IN
declareSignal(HSV, THSV, move, object_x, DirectionType)
# HandleBox - child-attached - 
# widget: Widget (ptr TWidget) IN
declareSignal(HandleBox, THandleBox, child_attached, widget, Widget)
# HandleBox - child-detached - 
# widget: Widget (ptr TWidget) IN
declareSignal(HandleBox, THandleBox, child_detached, widget, Widget)
# IMContext - commit - 
# str: ustring (ucstring) IN
declareSignal(IMContext, TIMContext, commit, str, ustring)
# IMContext - delete-surrounding - 
# offset: int32 (int32) IN
# n_chars: int32 (int32) IN
# nargs == 2: not implemented
# IMContext - preedit-changed - 
declareSignal(IMContext, TIMContext, preedit_changed)
# IMContext - preedit-end - 
declareSignal(IMContext, TIMContext, preedit_end)
# IMContext - preedit-start - 
declareSignal(IMContext, TIMContext, preedit_start)
# IMContext - retrieve-surrounding - 
declareSignal(IMContext, TIMContext, retrieve_surrounding)
# IconTheme - changed - 
declareSignal(IconTheme, TIconTheme, changed)
# IconView - activate-cursor-item - 
declareSignal(IconView, TIconView, activate_cursor_item)
# IconView - item-activated - 
# path: ptr TTreePath (ptr TTreePath) IN
declareSignal(IconView, TIconView, item_activated, path, ptr TTreePath)
# IconView - move-cursor - 
# step: MovementStep (MovementStep) IN
# count: int32 (int32) IN
# nargs == 2: not implemented
# IconView - select-all - 
declareSignal(IconView, TIconView, select_all)
# IconView - select-cursor-item - 
declareSignal(IconView, TIconView, select_cursor_item)
# IconView - selection-changed - 
declareSignal(IconView, TIconView, selection_changed)
# IconView - toggle-cursor-item - 
declareSignal(IconView, TIconView, toggle_cursor_item)
# IconView - unselect-all - 
declareSignal(IconView, TIconView, unselect_all)
# InfoBar - close - 
declareSignal(InfoBar, TInfoBar, close)
# InfoBar - response - 
# response_id: int32 (int32) IN
declareSignal(InfoBar, TInfoBar, response, response_id, int32)
# Label - activate-current-link - 
declareSignal(Label, TLabel, activate_current_link)
# Label - activate-link - 
# uri: ustring (ucstring) IN
declareSignal(Label, TLabel, activate_link, uri, ustring)
# Label - copy-clipboard - 
declareSignal(Label, TLabel, copy_clipboard)
# Label - move-cursor - 
# step: MovementStep (MovementStep) IN
# count: int32 (int32) IN
# extend_selection: bool (bool) IN
# nargs == 3: not implemented
# Label - populate-popup - 
# menu: Menu (ptr TMenu) IN
declareSignal(Label, TLabel, populate_popup, menu, Menu)
# LevelBar - offset-changed - 
# name: ustring (ucstring) IN
declareSignal(LevelBar, TLevelBar, offset_changed, name, ustring)
# LinkButton - activate-link - 
declareSignal(LinkButton, TLinkButton, activate_link)
# ListBox - activate-cursor-row - 
declareSignal(ListBox, TListBox, activate_cursor_row)
# ListBox - move-cursor - 
# object: MovementStep (MovementStep) IN
# p0: int32 (int32) IN
# nargs == 2: not implemented
# ListBox - row-activated - 
# row: ListBoxRow (ptr TListBoxRow) IN
declareSignal(ListBox, TListBox, row_activated, row, ListBoxRow)
# ListBox - row-selected - 
# row: ListBoxRow (ptr TListBoxRow) IN
declareSignal(ListBox, TListBox, row_selected, row, ListBoxRow)
# ListBox - select-all - 
declareSignal(ListBox, TListBox, select_all)
# ListBox - selected-rows-changed - 
declareSignal(ListBox, TListBox, selected_rows_changed)
# ListBox - toggle-cursor-row - 
declareSignal(ListBox, TListBox, toggle_cursor_row)
# ListBox - unselect-all - 
declareSignal(ListBox, TListBox, unselect_all)
# ListBoxRow - activate - 
declareSignal(ListBoxRow, TListBoxRow, activate)
# Menu - move-scroll - 
# scroll_type: ScrollType (ScrollType) IN
declareSignal(Menu, TMenu, move_scroll, scroll_type, ScrollType)
# MenuItem - activate - 
declareSignal(MenuItem, TMenuItem, activate)
# MenuItem - activate-item - 
declareSignal(MenuItem, TMenuItem, activate_item)
# MenuItem - deselect - 
declareSignal(MenuItem, TMenuItem, deselect)
# MenuItem - select - 
declareSignal(MenuItem, TMenuItem, select)
# MenuItem - toggle-size-allocate - 
# object: int32 (int32) IN
declareSignal(MenuItem, TMenuItem, toggle_size_allocate, object_x, int32)
# MenuItem - toggle-size-request - 
# object: pointer (pointer) IN
declareSignal(MenuItem, TMenuItem, toggle_size_request, object_x, pointer)
# MenuShell - activate-current - 
# force_hide: bool (bool) IN
declareSignal(MenuShell, TMenuShell, activate_current, force_hide, bool)
# MenuShell - cancel - 
declareSignal(MenuShell, TMenuShell, cancel)
# MenuShell - cycle-focus - 
# direction: DirectionType (DirectionType) IN
declareSignal(MenuShell, TMenuShell, cycle_focus, direction, DirectionType)
# MenuShell - deactivate - 
declareSignal(MenuShell, TMenuShell, deactivate)
# MenuShell - insert - 
# child: Widget (ptr TWidget) IN
# position: int32 (int32) IN
# nargs == 2: not implemented
# MenuShell - move-current - 
# direction: MenuDirectionType (MenuDirectionType) IN
declareSignal(MenuShell, TMenuShell, move_current, direction, MenuDirectionType)
# MenuShell - move-selected - 
# distance: int32 (int32) IN
declareSignal(MenuShell, TMenuShell, move_selected, distance, int32)
# MenuShell - selection-done - 
declareSignal(MenuShell, TMenuShell, selection_done)
# MenuToolButton - show-menu - 
declareSignal(MenuToolButton, TMenuToolButton, show_menu)
# Notebook - change-current-page - 
# object: int32 (int32) IN
declareSignal(Notebook, TNotebook, change_current_page, object_x, int32)
# Notebook - create-window - 
# page: Widget (ptr TWidget) IN
# x: int32 (int32) IN
# y: int32 (int32) IN
# nargs == 3: not implemented
# Notebook - focus-tab - 
# object: NotebookTab (NotebookTab) IN
declareSignal(Notebook, TNotebook, focus_tab, object_x, NotebookTab)
# Notebook - move-focus-out - 
# object: DirectionType (DirectionType) IN
declareSignal(Notebook, TNotebook, move_focus_out, object_x, DirectionType)
# Notebook - page-added - 
# child: Widget (ptr TWidget) IN
# page_num: uint32 (uint32) IN
# nargs == 2: not implemented
# Notebook - page-removed - 
# child: Widget (ptr TWidget) IN
# page_num: uint32 (uint32) IN
# nargs == 2: not implemented
# Notebook - page-reordered - 
# child: Widget (ptr TWidget) IN
# page_num: uint32 (uint32) IN
# nargs == 2: not implemented
# Notebook - reorder-tab - 
# object: DirectionType (DirectionType) IN
# p0: bool (bool) IN
# nargs == 2: not implemented
# Notebook - select-page - 
# object: bool (bool) IN
declareSignal(Notebook, TNotebook, select_page, object_x, bool)
# Notebook - switch-page - 
# page: Widget (ptr TWidget) IN
# page_num: uint32 (uint32) IN
# nargs == 2: not implemented
# Overlay - get-child-position - 
# widget: Widget (ptr TWidget) IN
# allocation: ptr Gdk3.TRectangle (ptr Gdk3.TRectangle) OUT
# nargs == 2: not implemented
# Paned - accept-position - 
declareSignal(Paned, TPaned, accept_position)
# Paned - cancel-position - 
declareSignal(Paned, TPaned, cancel_position)
# Paned - cycle-child-focus - 
# reversed: bool (bool) IN
declareSignal(Paned, TPaned, cycle_child_focus, reversed, bool)
# Paned - cycle-handle-focus - 
# reversed: bool (bool) IN
declareSignal(Paned, TPaned, cycle_handle_focus, reversed, bool)
# Paned - move-handle - 
# scroll_type: ScrollType (ScrollType) IN
declareSignal(Paned, TPaned, move_handle, scroll_type, ScrollType)
# Paned - toggle-handle-focus - 
declareSignal(Paned, TPaned, toggle_handle_focus)
# PlacesSidebar - drag-action-ask - 
# actions: int32 (int32) IN
declareSignal(PlacesSidebar, TPlacesSidebar, drag_action_ask, actions, int32)
# PlacesSidebar - drag-action-requested - 
# context: Gdk3.DragContext (ptr Gdk3.TDragContext) IN
# dest_file: ptr Gio2.TFile (ptr Gio2.TFile) IN
# source_file_list: ptr GLIST_TODO (ptr GLIST_TODO) IN
# nargs == 3: not implemented
# PlacesSidebar - drag-perform-drop - 
# dest_file: ptr Gio2.TFile (ptr Gio2.TFile) IN
# source_file_list: ptr GLIST_TODO (ptr GLIST_TODO) IN
# action: int32 (int32) IN
# nargs == 3: not implemented
# PlacesSidebar - open-location - 
# location: ptr Gio2.TFile (ptr Gio2.TFile) IN
# open_flags: SPlacesOpenFlags (SPlacesOpenFlags) IN
# nargs == 2: not implemented
# PlacesSidebar - populate-popup - 
# container: Widget (ptr TWidget) IN
# selected_item: ptr Gio2.TFile (ptr Gio2.TFile) IN
# selected_volume: ptr Gio2.TVolume (ptr Gio2.TVolume) IN
# nargs == 3: not implemented
# PlacesSidebar - show-connect-to-server - 
declareSignal(PlacesSidebar, TPlacesSidebar, show_connect_to_server)
# PlacesSidebar - show-enter-location - 
declareSignal(PlacesSidebar, TPlacesSidebar, show_enter_location)
# PlacesSidebar - show-error-message - 
# primary: ustring (ucstring) IN
# secondary: ustring (ucstring) IN
# nargs == 2: not implemented
# PlacesSidebar - show-other-locations - 
declareSignal(PlacesSidebar, TPlacesSidebar, show_other_locations)
# Popover - closed - 
declareSignal(Popover, TPopover, closed)
# PrintOperation - begin-print - 
# context: PrintContext (ptr TPrintContext) IN
declareSignal(PrintOperation, TPrintOperation, begin_print, context, PrintContext)
# PrintOperation - create-custom-widget - 
declareSignal(PrintOperation, TPrintOperation, create_custom_widget)
# PrintOperation - custom-widget-apply - 
# widget: Widget (ptr TWidget) IN
declareSignal(PrintOperation, TPrintOperation, custom_widget_apply, widget, Widget)
# PrintOperation - done - 
# result: PrintOperationResult (PrintOperationResult) IN
declareSignal(PrintOperation, TPrintOperation, done, result_x, PrintOperationResult)
# PrintOperation - draw-page - 
# context: PrintContext (ptr TPrintContext) IN
# page_nr: int32 (int32) IN
# nargs == 2: not implemented
# PrintOperation - end-print - 
# context: PrintContext (ptr TPrintContext) IN
declareSignal(PrintOperation, TPrintOperation, end_print, context, PrintContext)
# PrintOperation - paginate - 
# context: PrintContext (ptr TPrintContext) IN
declareSignal(PrintOperation, TPrintOperation, paginate, context, PrintContext)
# PrintOperation - preview - 
# preview: ptr TPrintOperationPreview (ptr TPrintOperationPreview) IN
# context: PrintContext (ptr TPrintContext) IN
# parent: Window (ptr TWindow) IN
# nargs == 3: not implemented
# PrintOperation - request-page-setup - 
# context: PrintContext (ptr TPrintContext) IN
# page_nr: int32 (int32) IN
# setup: PageSetup (ptr TPageSetup) IN
# nargs == 3: not implemented
# PrintOperation - status-changed - 
declareSignal(PrintOperation, TPrintOperation, status_changed)
# PrintOperation - update-custom-widget - 
# widget: Widget (ptr TWidget) IN
# setup: PageSetup (ptr TPageSetup) IN
# settings: PrintSettings (ptr TPrintSettings) IN
# nargs == 3: not implemented
# RadioAction - changed - 
# current: RadioAction (ptr TRadioAction) IN
declareSignal(RadioAction, TRadioAction, changed, current, RadioAction)
# RadioButton - group-changed - 
declareSignal(RadioButton, TRadioButton, group_changed)
# RadioMenuItem - group-changed - 
declareSignal(RadioMenuItem, TRadioMenuItem, group_changed)
# Range - adjust-bounds - 
# value: float64 (float64) IN
declareSignal(Range, TRange, adjust_bounds, value, float64)
# Range - change-value - 
# scroll: ScrollType (ScrollType) IN
# value: float64 (float64) IN
# nargs == 2: not implemented
# Range - move-slider - 
# step: ScrollType (ScrollType) IN
declareSignal(Range, TRange, move_slider, step, ScrollType)
# Range - value-changed - 
declareSignal(Range, TRange, value_changed)
# RecentManager - changed - 
declareSignal(RecentManager, TRecentManager, changed)
# Scale - format-value - 
# value: float64 (float64) IN
declareSignal(Scale, TScale, format_value, value, float64)
# ScaleButton - popdown - 
declareSignal(ScaleButton, TScaleButton, popdown)
# ScaleButton - popup - 
declareSignal(ScaleButton, TScaleButton, popup)
# ScaleButton - value-changed - 
# value: float64 (float64) IN
declareSignal(ScaleButton, TScaleButton, value_changed, value, float64)
# ScrolledWindow - edge-overshot - 
# pos: PositionType (PositionType) IN
declareSignal(ScrolledWindow, TScrolledWindow, edge_overshot, pos, PositionType)
# ScrolledWindow - edge-reached - 
# pos: PositionType (PositionType) IN
declareSignal(ScrolledWindow, TScrolledWindow, edge_reached, pos, PositionType)
# ScrolledWindow - move-focus-out - 
# direction_type: DirectionType (DirectionType) IN
declareSignal(ScrolledWindow, TScrolledWindow, move_focus_out, direction_type, DirectionType)
# ScrolledWindow - scroll-child - 
# scroll: ScrollType (ScrollType) IN
# horizontal: bool (bool) IN
# nargs == 2: not implemented
# SearchEntry - next-match - 
declareSignal(SearchEntry, TSearchEntry, next_match)
# SearchEntry - previous-match - 
declareSignal(SearchEntry, TSearchEntry, previous_match)
# SearchEntry - search-changed - 
declareSignal(SearchEntry, TSearchEntry, search_changed)
# SearchEntry - stop-search - 
declareSignal(SearchEntry, TSearchEntry, stop_search)
# SpinButton - change-value - 
# scroll: ScrollType (ScrollType) IN
declareSignal(SpinButton, TSpinButton, change_value, scroll, ScrollType)
# SpinButton - input - 
# new_value: var float64 (ptr float64) OUT
declareSignal(SpinButton, TSpinButton, input, new_value, var float64)
# SpinButton - output - 
declareSignal(SpinButton, TSpinButton, output)
# SpinButton - value-changed - 
declareSignal(SpinButton, TSpinButton, value_changed)
# SpinButton - wrapped - 
declareSignal(SpinButton, TSpinButton, wrapped)
# StatusIcon - activate - 
declareSignal(StatusIcon, TStatusIcon, activate)
# StatusIcon - button-press-event - 
# event: ptr Gdk3.TEventButton (ptr Gdk3.TEventButton) IN
declareSignal(StatusIcon, TStatusIcon, button_press_event, event, ptr Gdk3.TEventButton)
# StatusIcon - button-release-event - 
# event: ptr Gdk3.TEventButton (ptr Gdk3.TEventButton) IN
declareSignal(StatusIcon, TStatusIcon, button_release_event, event, ptr Gdk3.TEventButton)
# StatusIcon - popup-menu - 
# button: uint32 (uint32) IN
# activate_time: uint32 (uint32) IN
# nargs == 2: not implemented
# StatusIcon - query-tooltip - 
# x: int32 (int32) IN
# y: int32 (int32) IN
# keyboard_mode: bool (bool) IN
# tooltip: Tooltip (ptr TTooltip) IN
# nargs == 4: not implemented
# StatusIcon - scroll-event - 
# event: ptr Gdk3.TEventScroll (ptr Gdk3.TEventScroll) IN
declareSignal(StatusIcon, TStatusIcon, scroll_event, event, ptr Gdk3.TEventScroll)
# StatusIcon - size-changed - 
# size: int32 (int32) IN
declareSignal(StatusIcon, TStatusIcon, size_changed, size, int32)
# Statusbar - text-popped - 
# context_id: uint32 (uint32) IN
# text: ustring (ucstring) IN
# nargs == 2: not implemented
# Statusbar - text-pushed - 
# context_id: uint32 (uint32) IN
# text: ustring (ucstring) IN
# nargs == 2: not implemented
# Style - realize - 
declareSignal(Style, TStyle, realize)
# Style - unrealize - 
declareSignal(Style, TStyle, unrealize)
# StyleContext - changed - 
declareSignal(StyleContext, TStyleContext, changed)
# Switch - activate - 
declareSignal(Switch, TSwitch, activate)
# Switch - state-set - 
# state: bool (bool) IN
declareSignal(Switch, TSwitch, state_set, state, bool)
# TextBuffer - apply-tag - 
# tag: TextTag (ptr TTextTag) IN
# start: ptr TTextIter (ptr TTextIter) IN
# end: ptr TTextIter (ptr TTextIter) IN
# nargs == 3: not implemented
# TextBuffer - begin-user-action - 
declareSignal(TextBuffer, TTextBuffer, begin_user_action)
# TextBuffer - changed - 
declareSignal(TextBuffer, TTextBuffer, changed)
# TextBuffer - delete-range - 
# start: ptr TTextIter (ptr TTextIter) IN
# end: ptr TTextIter (ptr TTextIter) IN
# nargs == 2: not implemented
# TextBuffer - end-user-action - 
declareSignal(TextBuffer, TTextBuffer, end_user_action)
# TextBuffer - insert-child-anchor - 
# location: ptr TTextIter (ptr TTextIter) IN
# anchor: TextChildAnchor (ptr TTextChildAnchor) IN
# nargs == 2: not implemented
# TextBuffer - insert-pixbuf - 
# location: ptr TTextIter (ptr TTextIter) IN
# pixbuf: GdkPixbuf2.Pixbuf (ptr GdkPixbuf2.TPixbuf) IN
# nargs == 2: not implemented
# TextBuffer - insert-text - 
# location: ptr TTextIter (ptr TTextIter) IN
# text: ustring (ucstring) IN
# len: int32 (int32) IN
# nargs == 3: not implemented
# TextBuffer - mark-deleted - 
# mark: TextMark (ptr TTextMark) IN
declareSignal(TextBuffer, TTextBuffer, mark_deleted, mark, TextMark)
# TextBuffer - mark-set - 
# location: ptr TTextIter (ptr TTextIter) IN
# mark: TextMark (ptr TTextMark) IN
# nargs == 2: not implemented
# TextBuffer - modified-changed - 
declareSignal(TextBuffer, TTextBuffer, modified_changed)
# TextBuffer - paste-done - 
# clipboard: Clipboard (ptr TClipboard) IN
declareSignal(TextBuffer, TTextBuffer, paste_done, clipboard, Clipboard)
# TextBuffer - remove-tag - 
# tag: TextTag (ptr TTextTag) IN
# start: ptr TTextIter (ptr TTextIter) IN
# end: ptr TTextIter (ptr TTextIter) IN
# nargs == 3: not implemented
# TextTag - event - 
# object: GObject2.Object (ptr GObject2.TObject) IN
# event: ptr Gdk3.TEvent (ptr Gdk3.TEvent) IN
# iter: ptr TTextIter (ptr TTextIter) IN
# nargs == 3: not implemented
# TextTagTable - tag-added - 
# tag: TextTag (ptr TTextTag) IN
declareSignal(TextTagTable, TTextTagTable, tag_added, tag, TextTag)
# TextTagTable - tag-changed - 
# tag: TextTag (ptr TTextTag) IN
# size_changed: bool (bool) IN
# nargs == 2: not implemented
# TextTagTable - tag-removed - 
# tag: TextTag (ptr TTextTag) IN
declareSignal(TextTagTable, TTextTagTable, tag_removed, tag, TextTag)
# TextView - backspace - 
declareSignal(TextView, TTextView, backspace)
# TextView - copy-clipboard - 
declareSignal(TextView, TTextView, copy_clipboard)
# TextView - cut-clipboard - 
declareSignal(TextView, TTextView, cut_clipboard)
# TextView - delete-from-cursor - 
# type: DeleteType (DeleteType) IN
# count: int32 (int32) IN
# nargs == 2: not implemented
# TextView - extend-selection - 
# granularity: TextExtendSelection (TextExtendSelection) IN
# location: ptr TTextIter (ptr TTextIter) IN
# start: ptr TTextIter (ptr TTextIter) IN
# end: ptr TTextIter (ptr TTextIter) IN
# nargs == 4: not implemented
# TextView - insert-at-cursor - 
# string: ustring (ucstring) IN
declareSignal(TextView, TTextView, insert_at_cursor, string, ustring)
# TextView - move-cursor - 
# step: MovementStep (MovementStep) IN
# count: int32 (int32) IN
# extend_selection: bool (bool) IN
# nargs == 3: not implemented
# TextView - move-viewport - 
# step: ScrollStep (ScrollStep) IN
# count: int32 (int32) IN
# nargs == 2: not implemented
# TextView - paste-clipboard - 
declareSignal(TextView, TTextView, paste_clipboard)
# TextView - populate-popup - 
# popup: Widget (ptr TWidget) IN
declareSignal(TextView, TTextView, populate_popup, popup, Widget)
# TextView - preedit-changed - 
# preedit: ustring (ucstring) IN
declareSignal(TextView, TTextView, preedit_changed, preedit, ustring)
# TextView - select-all - 
# select: bool (bool) IN
declareSignal(TextView, TTextView, select_all, select, bool)
# TextView - set-anchor - 
declareSignal(TextView, TTextView, set_anchor)
# TextView - toggle-cursor-visible - 
declareSignal(TextView, TTextView, toggle_cursor_visible)
# TextView - toggle-overwrite - 
declareSignal(TextView, TTextView, toggle_overwrite)
# ToggleAction - toggled - 
declareSignal(ToggleAction, TToggleAction, toggled)
# ToggleButton - toggled - 
declareSignal(ToggleButton, TToggleButton, toggled)
# ToggleToolButton - toggled - 
declareSignal(ToggleToolButton, TToggleToolButton, toggled)
# ToolButton - clicked - 
declareSignal(ToolButton, TToolButton, clicked)
# ToolItem - create-menu-proxy - 
declareSignal(ToolItem, TToolItem, create_menu_proxy)
# ToolItem - toolbar-reconfigured - 
declareSignal(ToolItem, TToolItem, toolbar_reconfigured)
# Toolbar - focus-home-or-end - 
# focus_home: bool (bool) IN
declareSignal(Toolbar, TToolbar, focus_home_or_end, focus_home, bool)
# Toolbar - orientation-changed - 
# orientation: Orientation (Orientation) IN
declareSignal(Toolbar, TToolbar, orientation_changed, orientation, Orientation)
# Toolbar - popup-context-menu - 
# x: int32 (int32) IN
# y: int32 (int32) IN
# button: int32 (int32) IN
# nargs == 3: not implemented
# Toolbar - style-changed - 
# style: ToolbarStyle (ToolbarStyle) IN
declareSignal(Toolbar, TToolbar, style_changed, style, ToolbarStyle)
# TreeSelection - changed - 
declareSignal(TreeSelection, TTreeSelection, changed)
# TreeView - columns-changed - 
declareSignal(TreeView, TTreeView, columns_changed)
# TreeView - cursor-changed - 
declareSignal(TreeView, TTreeView, cursor_changed)
# TreeView - expand-collapse-cursor-row - 
# object: bool (bool) IN
# p0: bool (bool) IN
# p1: bool (bool) IN
# nargs == 3: not implemented
# TreeView - move-cursor - 
# step: MovementStep (MovementStep) IN
# direction: int32 (int32) IN
# nargs == 2: not implemented
# TreeView - row-activated - 
# path: ptr TTreePath (ptr TTreePath) IN
# column: TreeViewColumn (ptr TTreeViewColumn) IN
# nargs == 2: not implemented
# TreeView - row-collapsed - 
# iter: ptr TTreeIter (ptr TTreeIter) IN
# path: ptr TTreePath (ptr TTreePath) IN
# nargs == 2: not implemented
# TreeView - row-expanded - 
# iter: ptr TTreeIter (ptr TTreeIter) IN
# path: ptr TTreePath (ptr TTreePath) IN
# nargs == 2: not implemented
# TreeView - select-all - 
declareSignal(TreeView, TTreeView, select_all)
# TreeView - select-cursor-parent - 
declareSignal(TreeView, TTreeView, select_cursor_parent)
# TreeView - select-cursor-row - 
# object: bool (bool) IN
declareSignal(TreeView, TTreeView, select_cursor_row, object_x, bool)
# TreeView - start-interactive-search - 
declareSignal(TreeView, TTreeView, start_interactive_search)
# TreeView - test-collapse-row - 
# iter: ptr TTreeIter (ptr TTreeIter) IN
# path: ptr TTreePath (ptr TTreePath) IN
# nargs == 2: not implemented
# TreeView - test-expand-row - 
# iter: ptr TTreeIter (ptr TTreeIter) IN
# path: ptr TTreePath (ptr TTreePath) IN
# nargs == 2: not implemented
# TreeView - toggle-cursor-row - 
declareSignal(TreeView, TTreeView, toggle_cursor_row)
# TreeView - unselect-all - 
declareSignal(TreeView, TTreeView, unselect_all)
# TreeViewColumn - clicked - 
declareSignal(TreeViewColumn, TTreeViewColumn, clicked)
# UIManager - actions-changed - 
declareSignal(UIManager, TUIManager, actions_changed)
# UIManager - add-widget - 
# widget: Widget (ptr TWidget) IN
declareSignal(UIManager, TUIManager, add_widget, widget, Widget)
# UIManager - connect-proxy - 
# action: Action (ptr TAction) IN
# proxy: Widget (ptr TWidget) IN
# nargs == 2: not implemented
# UIManager - disconnect-proxy - 
# action: Action (ptr TAction) IN
# proxy: Widget (ptr TWidget) IN
# nargs == 2: not implemented
# UIManager - post-activate - 
# action: Action (ptr TAction) IN
declareSignal(UIManager, TUIManager, post_activate, action, Action)
# UIManager - pre-activate - 
# action: Action (ptr TAction) IN
declareSignal(UIManager, TUIManager, pre_activate, action, Action)
# Widget - accel-closures-changed - 
declareSignal(Widget, TWidget, accel_closures_changed)
# Widget - button-press-event - 
# event: ptr Gdk3.TEventButton (ptr Gdk3.TEventButton) IN
declareSignal(Widget, TWidget, button_press_event, event, ptr Gdk3.TEventButton)
# Widget - button-release-event - 
# event: ptr Gdk3.TEventButton (ptr Gdk3.TEventButton) IN
declareSignal(Widget, TWidget, button_release_event, event, ptr Gdk3.TEventButton)
# Widget - can-activate-accel - 
# signal_id: uint32 (uint32) IN
declareSignal(Widget, TWidget, can_activate_accel, signal_id, uint32)
# Widget - child-notify - 
# child_property: GObject2.ParamSpec (ptr GObject2.TParamSpec) IN
declareSignal(Widget, TWidget, child_notify, child_property, GObject2.ParamSpec)
# Widget - composited-changed - 
declareSignal(Widget, TWidget, composited_changed)
# Widget - configure-event - 
# event: ptr Gdk3.TEventConfigure (ptr Gdk3.TEventConfigure) IN
declareSignal(Widget, TWidget, configure_event, event, ptr Gdk3.TEventConfigure)
# Widget - damage-event - 
# event: ptr Gdk3.TEventExpose (ptr Gdk3.TEventExpose) IN
declareSignal(Widget, TWidget, damage_event, event, ptr Gdk3.TEventExpose)
# Widget - delete-event - 
# event: ptr Gdk3.TEvent (ptr Gdk3.TEvent) IN
declareSignal(Widget, TWidget, delete_event, event, ptr Gdk3.TEvent)
# Widget - destroy - 
declareSignal(Widget, TWidget, destroy)
# Widget - destroy-event - 
# event: ptr Gdk3.TEvent (ptr Gdk3.TEvent) IN
declareSignal(Widget, TWidget, destroy_event, event, ptr Gdk3.TEvent)
# Widget - direction-changed - 
# previous_direction: TextDirection (TextDirection) IN
declareSignal(Widget, TWidget, direction_changed, previous_direction, TextDirection)
# Widget - drag-begin - 
# context: Gdk3.DragContext (ptr Gdk3.TDragContext) IN
declareSignal(Widget, TWidget, drag_begin, context, Gdk3.DragContext)
# Widget - drag-data-delete - 
# context: Gdk3.DragContext (ptr Gdk3.TDragContext) IN
declareSignal(Widget, TWidget, drag_data_delete, context, Gdk3.DragContext)
# Widget - drag-data-get - 
# context: Gdk3.DragContext (ptr Gdk3.TDragContext) IN
# data: ptr TSelectionData (ptr TSelectionData) IN
# info: uint32 (uint32) IN
# time: uint32 (uint32) IN
# nargs == 4: not implemented
# Widget - drag-data-received - 
# context: Gdk3.DragContext (ptr Gdk3.TDragContext) IN
# x: int32 (int32) IN
# y: int32 (int32) IN
# data: ptr TSelectionData (ptr TSelectionData) IN
# info: uint32 (uint32) IN
# time: uint32 (uint32) IN
# nargs == 6: not implemented
# Widget - drag-drop - 
# context: Gdk3.DragContext (ptr Gdk3.TDragContext) IN
# x: int32 (int32) IN
# y: int32 (int32) IN
# time: uint32 (uint32) IN
# nargs == 4: not implemented
# Widget - drag-end - 
# context: Gdk3.DragContext (ptr Gdk3.TDragContext) IN
declareSignal(Widget, TWidget, drag_end, context, Gdk3.DragContext)
# Widget - drag-failed - 
# context: Gdk3.DragContext (ptr Gdk3.TDragContext) IN
# result: DragResult (DragResult) IN
# nargs == 2: not implemented
# Widget - drag-leave - 
# context: Gdk3.DragContext (ptr Gdk3.TDragContext) IN
# time: uint32 (uint32) IN
# nargs == 2: not implemented
# Widget - drag-motion - 
# context: Gdk3.DragContext (ptr Gdk3.TDragContext) IN
# x: int32 (int32) IN
# y: int32 (int32) IN
# time: uint32 (uint32) IN
# nargs == 4: not implemented
# Widget - draw - 
# cr: ptr cairo1.TContext (ptr cairo1.TContext) IN
declareSignal(Widget, TWidget, draw, cr, ptr cairo1.TContext)
# Widget - enter-notify-event - 
# event: ptr Gdk3.TEventCrossing (ptr Gdk3.TEventCrossing) IN
declareSignal(Widget, TWidget, enter_notify_event, event, ptr Gdk3.TEventCrossing)
# Widget - event - 
# event: ptr Gdk3.TEvent (ptr Gdk3.TEvent) IN
declareSignal(Widget, TWidget, event, event, ptr Gdk3.TEvent)
# Widget - event-after - 
# event: ptr Gdk3.TEvent (ptr Gdk3.TEvent) IN
declareSignal(Widget, TWidget, event_after, event, ptr Gdk3.TEvent)
# Widget - focus - 
# direction: DirectionType (DirectionType) IN
declareSignal(Widget, TWidget, focus, direction, DirectionType)
# Widget - focus-in-event - 
# event: ptr Gdk3.TEventFocus (ptr Gdk3.TEventFocus) IN
declareSignal(Widget, TWidget, focus_in_event, event, ptr Gdk3.TEventFocus)
# Widget - focus-out-event - 
# event: ptr Gdk3.TEventFocus (ptr Gdk3.TEventFocus) IN
declareSignal(Widget, TWidget, focus_out_event, event, ptr Gdk3.TEventFocus)
# Widget - grab-broken-event - 
# event: ptr Gdk3.TEventGrabBroken (ptr Gdk3.TEventGrabBroken) IN
declareSignal(Widget, TWidget, grab_broken_event, event, ptr Gdk3.TEventGrabBroken)
# Widget - grab-focus - 
declareSignal(Widget, TWidget, grab_focus)
# Widget - grab-notify - 
# was_grabbed: bool (bool) IN
declareSignal(Widget, TWidget, grab_notify, was_grabbed, bool)
# Widget - hide - 
declareSignal(Widget, TWidget, hide)
# Widget - hierarchy-changed - 
# previous_toplevel: Widget (ptr TWidget) IN
declareSignal(Widget, TWidget, hierarchy_changed, previous_toplevel, Widget)
# Widget - key-press-event - 
# event: ptr Gdk3.TEventKey (ptr Gdk3.TEventKey) IN
declareSignal(Widget, TWidget, key_press_event, event, ptr Gdk3.TEventKey)
# Widget - key-release-event - 
# event: ptr Gdk3.TEventKey (ptr Gdk3.TEventKey) IN
declareSignal(Widget, TWidget, key_release_event, event, ptr Gdk3.TEventKey)
# Widget - keynav-failed - 
# direction: DirectionType (DirectionType) IN
declareSignal(Widget, TWidget, keynav_failed, direction, DirectionType)
# Widget - leave-notify-event - 
# event: ptr Gdk3.TEventCrossing (ptr Gdk3.TEventCrossing) IN
declareSignal(Widget, TWidget, leave_notify_event, event, ptr Gdk3.TEventCrossing)
# Widget - map - 
declareSignal(Widget, TWidget, map)
# Widget - map-event - 
# event: ptr Gdk3.TEventAny (ptr Gdk3.TEventAny) IN
declareSignal(Widget, TWidget, map_event, event, ptr Gdk3.TEventAny)
# Widget - mnemonic-activate - 
# arg1: bool (bool) IN
declareSignal(Widget, TWidget, mnemonic_activate, arg1, bool)
# Widget - motion-notify-event - 
# event: ptr Gdk3.TEventMotion (ptr Gdk3.TEventMotion) IN
declareSignal(Widget, TWidget, motion_notify_event, event, ptr Gdk3.TEventMotion)
# Widget - move-focus - 
# direction: DirectionType (DirectionType) IN
declareSignal(Widget, TWidget, move_focus, direction, DirectionType)
# Widget - parent-set - 
# old_parent: Widget (ptr TWidget) IN
declareSignal(Widget, TWidget, parent_set, old_parent, Widget)
# Widget - popup-menu - 
declareSignal(Widget, TWidget, popup_menu)
# Widget - property-notify-event - 
# event: ptr Gdk3.TEventProperty (ptr Gdk3.TEventProperty) IN
declareSignal(Widget, TWidget, property_notify_event, event, ptr Gdk3.TEventProperty)
# Widget - proximity-in-event - 
# event: ptr Gdk3.TEventProximity (ptr Gdk3.TEventProximity) IN
declareSignal(Widget, TWidget, proximity_in_event, event, ptr Gdk3.TEventProximity)
# Widget - proximity-out-event - 
# event: ptr Gdk3.TEventProximity (ptr Gdk3.TEventProximity) IN
declareSignal(Widget, TWidget, proximity_out_event, event, ptr Gdk3.TEventProximity)
# Widget - query-tooltip - 
# x: int32 (int32) IN
# y: int32 (int32) IN
# keyboard_mode: bool (bool) IN
# tooltip: Tooltip (ptr TTooltip) IN
# nargs == 4: not implemented
# Widget - realize - 
declareSignal(Widget, TWidget, realize)
# Widget - screen-changed - 
# previous_screen: Gdk3.Screen (ptr Gdk3.TScreen) IN
declareSignal(Widget, TWidget, screen_changed, previous_screen, Gdk3.Screen)
# Widget - scroll-event - 
# event: ptr Gdk3.TEventScroll (ptr Gdk3.TEventScroll) IN
declareSignal(Widget, TWidget, scroll_event, event, ptr Gdk3.TEventScroll)
# Widget - selection-clear-event - 
# event: ptr Gdk3.TEventSelection (ptr Gdk3.TEventSelection) IN
declareSignal(Widget, TWidget, selection_clear_event, event, ptr Gdk3.TEventSelection)
# Widget - selection-get - 
# data: ptr TSelectionData (ptr TSelectionData) IN
# info: uint32 (uint32) IN
# time: uint32 (uint32) IN
# nargs == 3: not implemented
# Widget - selection-notify-event - 
# event: ptr Gdk3.TEventSelection (ptr Gdk3.TEventSelection) IN
declareSignal(Widget, TWidget, selection_notify_event, event, ptr Gdk3.TEventSelection)
# Widget - selection-received - 
# data: ptr TSelectionData (ptr TSelectionData) IN
# time: uint32 (uint32) IN
# nargs == 2: not implemented
# Widget - selection-request-event - 
# event: ptr Gdk3.TEventSelection (ptr Gdk3.TEventSelection) IN
declareSignal(Widget, TWidget, selection_request_event, event, ptr Gdk3.TEventSelection)
# Widget - show - 
declareSignal(Widget, TWidget, show)
# Widget - show-help - 
# help_type: WidgetHelpType (WidgetHelpType) IN
declareSignal(Widget, TWidget, show_help, help_type, WidgetHelpType)
# Widget - size-allocate - 
# allocation: ptr Gdk3.TRectangle (ptr Gdk3.TRectangle) IN
declareSignal(Widget, TWidget, size_allocate, allocation, ptr Gdk3.TRectangle)
# Widget - state-changed - 
# state: StateType (StateType) IN
declareSignal(Widget, TWidget, state_changed, state, StateType)
# Widget - state-flags-changed - 
# flags: SStateFlags (SStateFlags) IN
declareSignal(Widget, TWidget, state_flags_changed, flags, SStateFlags)
# Widget - style-set - 
# previous_style: Style (ptr TStyle) IN
declareSignal(Widget, TWidget, style_set, previous_style, Style)
# Widget - style-updated - 
declareSignal(Widget, TWidget, style_updated)
# Widget - touch-event - 
# object: ptr Gdk3.TEvent (ptr Gdk3.TEvent) IN
declareSignal(Widget, TWidget, touch_event, object_x, ptr Gdk3.TEvent)
# Widget - unmap - 
declareSignal(Widget, TWidget, unmap)
# Widget - unmap-event - 
# event: ptr Gdk3.TEventAny (ptr Gdk3.TEventAny) IN
declareSignal(Widget, TWidget, unmap_event, event, ptr Gdk3.TEventAny)
# Widget - unrealize - 
declareSignal(Widget, TWidget, unrealize)
# Widget - visibility-notify-event - 
# event: ptr Gdk3.TEventVisibility (ptr Gdk3.TEventVisibility) IN
declareSignal(Widget, TWidget, visibility_notify_event, event, ptr Gdk3.TEventVisibility)
# Widget - window-state-event - 
# event: ptr Gdk3.TEventWindowState (ptr Gdk3.TEventWindowState) IN
declareSignal(Widget, TWidget, window_state_event, event, ptr Gdk3.TEventWindowState)
# Window - activate-default - 
declareSignal(Window, TWindow, activate_default)
# Window - activate-focus - 
declareSignal(Window, TWindow, activate_focus)
# Window - enable-debugging - 
# toggle: bool (bool) IN
declareSignal(Window, TWindow, enable_debugging, toggle, bool)
# Window - keys-changed - 
declareSignal(Window, TWindow, keys_changed)
# Window - set-focus - 
# object: Widget (ptr TWidget) IN
declareSignal(Window, TWindow, set_focus, object_x, Widget)
  # struct methods
  #------------------
# struct AboutDialogClass
# struct AboutDialogPrivate
# struct AccelGroupClass
# struct AccelGroupEntry
# struct AccelGroupPrivate
# struct AccelKey
# struct AccelLabelClass
# struct AccelLabelPrivate
# struct AccelMapClass
# struct AccessibleClass
# struct AccessiblePrivate
# struct ActionBarClass
# struct ActionBarPrivate
# struct ActionClass
# struct ActionEntry
# struct ActionGroupClass
# struct ActionGroupPrivate
# struct ActionPrivate
# struct ActionableInterface
# struct ActivatableIface
# struct AdjustmentClass
# struct AdjustmentPrivate
# struct AlignmentClass
# struct AlignmentPrivate
# struct AppChooserButtonClass
# struct AppChooserButtonPrivate
# struct AppChooserDialogClass
# struct AppChooserDialogPrivate
# struct AppChooserWidgetClass
# struct AppChooserWidgetPrivate
# struct ApplicationClass
# struct ApplicationPrivate
# struct ApplicationWindowClass
# struct ApplicationWindowPrivate
# struct ArrowAccessibleClass
# struct ArrowAccessiblePrivate
# struct ArrowClass
# struct ArrowPrivate
# struct AspectFrameClass
# struct AspectFramePrivate
# struct AssistantClass
# struct AssistantPrivate
# struct BinClass
# struct BinPrivate
# struct BindingArg
# struct BindingEntry
# gtk_binding_entry_add_signal_from_string
# flags: {} container: BindingEntry
# need sugar: is static method
# arg binding_set: INTERFACE (STRUCT) 'ptr TBindingSet' 'ptr TBindingSet' IN
# arg signal_desc: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'GLib2.TokenType' 'GLib2.TokenType'
# warning, already written a prototype with the name of gtk_binding_entry_add_signal_from_string
# proc gtk_binding_entry_add_signal_from_string(binding_set: ptr TBindingSet, signal_desc: ucstring): GLib2.TokenType {.cdecl, dynlib: lib, importc: "gtk_binding_entry_add_signal_from_string".}
template add_signal_from_string*(klass_parameter: typedesc[TBindingEntry], binding_set: ptr TBindingSet, signal_desc: ustring): GLib2.TokenType =
  gtk_binding_entry_add_signal_from_string(binding_set, ucstring(signal_desc))
# template add_signal_from_string*(klass_parameter: typedesc[TBindingEntry], binding_set: ptr TBindingSet, signal_desc: ustring): GLib2.TokenType =

# gtk_binding_entry_add_signall
# flags: {} container: BindingEntry
# need sugar: is static method
# arg binding_set: INTERFACE (STRUCT) 'ptr TBindingSet' 'ptr TBindingSet' IN
# arg keyval: UINT32 'uint32' 'uint32' IN
# arg modifiers: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# arg signal_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg binding_args: GSLIST 'ptr GSLIST_TODO' 'ptr GSLIST_TODO' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
# warning, already written a prototype with the name of gtk_binding_entry_add_signall
# proc gtk_binding_entry_add_signall(binding_set: ptr TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType, signal_name: ucstring, binding_args: ptr GSLIST_TODO) {.cdecl, dynlib: lib, importc: "gtk_binding_entry_add_signall".}
template add_signall*(klass_parameter: typedesc[TBindingEntry], binding_set: ptr TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType, signal_name: ustring, binding_args: ptr GSLIST_TODO) =
  gtk_binding_entry_add_signall(binding_set, keyval, modifiers, ucstring(signal_name), binding_args)
# template add_signall*(klass_parameter: typedesc[TBindingEntry], binding_set: ptr TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType, signal_name: ustring, binding_args: ptr GSLIST_TODO) =

# gtk_binding_entry_remove
# flags: {} container: BindingEntry
# need sugar: is static method
# arg binding_set: INTERFACE (STRUCT) 'ptr TBindingSet' 'ptr TBindingSet' IN
# arg keyval: UINT32 'uint32' 'uint32' IN
# arg modifiers: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
# warning, already written a prototype with the name of gtk_binding_entry_remove
# proc gtk_binding_entry_remove(binding_set: ptr TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType) {.cdecl, dynlib: lib, importc: "gtk_binding_entry_remove".}
template remove*(klass_parameter: typedesc[TBindingEntry], binding_set: ptr TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType) =
  gtk_binding_entry_remove(binding_set, keyval, modifiers)
# template remove*(klass_parameter: typedesc[TBindingEntry], binding_set: ptr TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType) =

# gtk_binding_entry_skip
# flags: {} container: BindingEntry
# need sugar: is static method
# arg binding_set: INTERFACE (STRUCT) 'ptr TBindingSet' 'ptr TBindingSet' IN
# arg keyval: UINT32 'uint32' 'uint32' IN
# arg modifiers: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
# warning, already written a prototype with the name of gtk_binding_entry_skip
# proc gtk_binding_entry_skip(binding_set: ptr TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType) {.cdecl, dynlib: lib, importc: "gtk_binding_entry_skip".}
template skip*(klass_parameter: typedesc[TBindingEntry], binding_set: ptr TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType) =
  gtk_binding_entry_skip(binding_set, keyval, modifiers)
# template skip*(klass_parameter: typedesc[TBindingEntry], binding_set: ptr TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType) =

# struct BindingSet
# gtk_binding_set_activate
# flags: {isMethod} container: BindingSet
# need sugar: is method
# arg keyval: UINT32 'uint32' 'uint32' IN
# arg modifiers: INTERFACE (FLAGS) 'Gdk3.SModifierType' 'Gdk3.SModifierType' IN
# arg object: INTERFACE (OBJECT) 'GObject2.Object' 'ptr GObject2.TObject' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_binding_set_activate(self: ptr TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType, object_x: ptr GObject2.TObject): bool {.cdecl, dynlib: lib, importc: "gtk_binding_set_activate".}
proc activate*(self: ptr TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType, object_x: GObject2.Object): bool {.inline.} =
  gtk_binding_set_activate(self, keyval, modifiers, object_x.getPointer)
# proc activate*(self: ptr TBindingSet, keyval: uint32, modifiers: Gdk3.SModifierType, object_x: GObject2.Object): bool {.inline.} =

# gtk_binding_set_add_path
# flags: {isMethod} container: BindingSet (deprecated)
# gtk_binding_set_find
# flags: {} container: BindingSet
# need sugar: is static method
# arg set_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'ptr TBindingSet' 'ptr TBindingSet'
# warning, already written a prototype with the name of gtk_binding_set_find
# proc gtk_binding_set_find(set_name: ucstring): ptr TBindingSet {.cdecl, dynlib: lib, importc: "gtk_binding_set_find".}
template find*(klass_parameter: typedesc[TBindingSet], set_name: ustring): ptr TBindingSet =
  gtk_binding_set_find(ucstring(set_name))
# template find*(klass_parameter: typedesc[TBindingSet], set_name: ustring): ptr TBindingSet =

# struct BindingSignal
# struct BooleanCellAccessibleClass
# struct BooleanCellAccessiblePrivate
# struct Border
# gtk_border_new
# flags: {isConstructor} container: Border
# need sugar: is static method
# return: INTERFACE 'ptr TBorder' 'ptr TBorder'
proc gtk_border_new(): ptr TBorder {.cdecl, dynlib: lib, importc: "gtk_border_new".}
proc new_border*(): ptr TBorder {.inline.} =
  gtk_border_new()
# proc new_border*(): ptr TBorder {.inline.} =

# gtk_border_copy
# flags: {isMethod} container: Border
# need sugar: is method
# return: INTERFACE 'ptr TBorder' 'ptr TBorder'
proc gtk_border_copy(self: ptr TBorder): ptr TBorder {.cdecl, dynlib: lib, importc: "gtk_border_copy".}
proc copy*(self: ptr TBorder): ptr TBorder {.inline.} =
  gtk_border_copy(self)
# proc copy*(self: ptr TBorder): ptr TBorder {.inline.} =

# gtk_border_free
# flags: {isMethod} container: Border
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_border_free(self: ptr TBorder) {.cdecl, dynlib: lib, importc: "gtk_border_free".}
proc free*(self: ptr TBorder) {.inline.} =
  gtk_border_free(self)
# proc free*(self: ptr TBorder) {.inline.} =

# struct BoxClass
# struct BoxPrivate
# struct BuildableIface
# struct BuilderClass
# struct BuilderPrivate
# struct ButtonAccessibleClass
# struct ButtonAccessiblePrivate
# struct ButtonBoxClass
# struct ButtonBoxPrivate
# struct ButtonClass
# struct ButtonPrivate
# struct CalendarClass
# struct CalendarPrivate
# struct CellAccessibleClass
# struct CellAccessibleParentIface
# struct CellAccessiblePrivate
# struct CellAreaBoxClass
# struct CellAreaBoxPrivate
# struct CellAreaClass
# gtk_cell_area_class_find_cell_property
# flags: {isMethod} container: CellAreaClass
# need sugar: is method
# arg property_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'GObject2.ParamSpec' 'TransferNone[GObject2.TParamSpec]' (diff., need sugar)
proc gtk_cell_area_class_find_cell_property(self: ptr TCellAreaClass, property_name: ucstring): TransferNone[GObject2.TParamSpec] {.cdecl, dynlib: lib, importc: "gtk_cell_area_class_find_cell_property".}
proc find_cell_property*(self: ptr TCellAreaClass, property_name: ustring): GObject2.ParamSpec {.inline.} =
  wrap(gtk_cell_area_class_find_cell_property(self, ucstring(property_name)))
# proc find_cell_property*(self: ptr TCellAreaClass, property_name: ustring): GObject2.ParamSpec {.inline.} =

# gtk_cell_area_class_install_cell_property
# flags: {isMethod} container: CellAreaClass
# need sugar: is method
# arg property_id: UINT32 'uint32' 'uint32' IN
# arg pspec: INTERFACE (OBJECT) 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_area_class_install_cell_property(self: ptr TCellAreaClass, property_id: uint32, pspec: ptr GObject2.TParamSpec) {.cdecl, dynlib: lib, importc: "gtk_cell_area_class_install_cell_property".}
proc install_cell_property*(self: ptr TCellAreaClass, property_id: uint32, pspec: GObject2.ParamSpec) {.inline.} =
  gtk_cell_area_class_install_cell_property(self, property_id, pspec.getPointer)
# proc install_cell_property*(self: ptr TCellAreaClass, property_id: uint32, pspec: GObject2.ParamSpec) {.inline.} =

# gtk_cell_area_class_list_cell_properties
# flags: {isMethod} container: CellAreaClass
# need sugar: is method
# arg n_properties: UINT32 'var uint32' 'ptr uint32' OUT (diff., need sugar)
# return: ARRAY 'zeroTerminatedArray[ptr GObject2.TParamSpec]' 'zeroTerminatedArray[ptr GObject2.TParamSpec]'
proc gtk_cell_area_class_list_cell_properties(self: ptr TCellAreaClass, n_properties: ptr uint32): zeroTerminatedArray[ptr GObject2.TParamSpec] {.cdecl, dynlib: lib, importc: "gtk_cell_area_class_list_cell_properties".}
proc list_cell_properties*(self: ptr TCellAreaClass, n_properties: var uint32): zeroTerminatedArray[ptr GObject2.TParamSpec] {.inline.} =
  gtk_cell_area_class_list_cell_properties(self, addr(n_properties))
# tuple-return
# n_properties: var uint32
# proc list_cell_properties*(self: ptr TCellAreaClass): zeroTerminatedArray[ptr GObject2.TParamSpec] {.inline.} =

# struct CellAreaContextClass
# struct CellAreaContextPrivate
# struct CellAreaPrivate
# struct CellEditableIface
# struct CellLayoutIface
# struct CellRendererAccelClass
# struct CellRendererAccelPrivate
# struct CellRendererClass
# gtk_cell_renderer_class_set_accessible_type
# flags: {isMethod} container: CellRendererClass
# need sugar: is method
# arg type: GTYPE 'GType' 'GType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_cell_renderer_class_set_accessible_type(self: ptr TCellRendererClass, type_x: GType) {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_class_set_accessible_type".}
proc set_accessible_type*(self: ptr TCellRendererClass, type_x: GType) {.inline.} =
  gtk_cell_renderer_class_set_accessible_type(self, type_x)
# proc set_accessible_type*(self: ptr TCellRendererClass, type_x: GType) {.inline.} =

# struct CellRendererClassPrivate
# struct CellRendererComboClass
# struct CellRendererComboPrivate
# struct CellRendererPixbufClass
# struct CellRendererPixbufPrivate
# struct CellRendererPrivate
# struct CellRendererProgressClass
# struct CellRendererProgressPrivate
# struct CellRendererSpinClass
# struct CellRendererSpinPrivate
# struct CellRendererSpinnerClass
# struct CellRendererSpinnerPrivate
# struct CellRendererTextClass
# struct CellRendererTextPrivate
# struct CellRendererToggleClass
# struct CellRendererTogglePrivate
# struct CellViewClass
# struct CellViewPrivate
# struct CheckButtonClass
# struct CheckMenuItemAccessibleClass
# struct CheckMenuItemAccessiblePrivate
# struct CheckMenuItemClass
# struct CheckMenuItemPrivate
# struct ColorButtonClass
# struct ColorButtonPrivate
# struct ColorChooserDialogClass
# struct ColorChooserDialogPrivate
# struct ColorChooserInterface
# struct ColorChooserWidgetClass
# struct ColorChooserWidgetPrivate
# struct ColorSelectionClass
# struct ColorSelectionDialogClass
# struct ColorSelectionDialogPrivate
# struct ColorSelectionPrivate
# struct ComboBoxAccessibleClass
# struct ComboBoxAccessiblePrivate
# struct ComboBoxClass
# struct ComboBoxPrivate
# struct ComboBoxTextClass
# struct ComboBoxTextPrivate
# struct ContainerAccessibleClass
# struct ContainerAccessiblePrivate
# struct ContainerCellAccessibleClass
# struct ContainerCellAccessiblePrivate
# struct ContainerClass
# gtk_container_class_find_child_property
# flags: {isMethod} container: ContainerClass
# need sugar: is method
# arg property_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'GObject2.ParamSpec' 'TransferNone[GObject2.TParamSpec]' (diff., need sugar)
proc gtk_container_class_find_child_property(self: ptr TContainerClass, property_name: ucstring): TransferNone[GObject2.TParamSpec] {.cdecl, dynlib: lib, importc: "gtk_container_class_find_child_property".}
proc find_child_property*(self: ptr TContainerClass, property_name: ustring): GObject2.ParamSpec {.inline.} =
  wrap(gtk_container_class_find_child_property(self, ucstring(property_name)))
# proc find_child_property*(self: ptr TContainerClass, property_name: ustring): GObject2.ParamSpec {.inline.} =

# gtk_container_class_handle_border_width
# flags: {isMethod} container: ContainerClass
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_container_class_handle_border_width(self: ptr TContainerClass) {.cdecl, dynlib: lib, importc: "gtk_container_class_handle_border_width".}
proc handle_border_width*(self: ptr TContainerClass) {.inline.} =
  gtk_container_class_handle_border_width(self)
# proc handle_border_width*(self: ptr TContainerClass) {.inline.} =

# gtk_container_class_install_child_properties
# flags: {isMethod} container: ContainerClass
# need sugar: is method
# arg n_pspecs: UINT32 'uint32' 'uint32' IN
# arg pspecs: ARRAY 'var openarray[ptr GObject2.TParamSpec]' 'openarray[ptr GObject2.TParamSpec]' IN (diff., need sugar) array lengthArg: 0
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_container_class_install_child_properties(self: ptr TContainerClass, n_pspecs: uint32, pspecs: openarray[ptr GObject2.TParamSpec]) {.cdecl, dynlib: lib, importc: "gtk_container_class_install_child_properties".}
proc install_child_properties*(self: ptr TContainerClass, pspecs: var openarray[ptr GObject2.TParamSpec]) {.inline.} =
  gtk_container_class_install_child_properties(self, pspecs.len.uint32, pspecs)
# proc install_child_properties*(self: ptr TContainerClass, pspecs: var openarray[ptr GObject2.TParamSpec]) {.inline.} =

# gtk_container_class_install_child_property
# flags: {isMethod} container: ContainerClass
# need sugar: is method
# arg property_id: UINT32 'uint32' 'uint32' IN
# arg pspec: INTERFACE (OBJECT) 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_container_class_install_child_property(self: ptr TContainerClass, property_id: uint32, pspec: ptr GObject2.TParamSpec) {.cdecl, dynlib: lib, importc: "gtk_container_class_install_child_property".}
proc install_child_property*(self: ptr TContainerClass, property_id: uint32, pspec: GObject2.ParamSpec) {.inline.} =
  gtk_container_class_install_child_property(self, property_id, pspec.getPointer)
# proc install_child_property*(self: ptr TContainerClass, property_id: uint32, pspec: GObject2.ParamSpec) {.inline.} =

# gtk_container_class_list_child_properties
# flags: {isMethod} container: ContainerClass
# need sugar: is method
# arg n_properties: UINT32 'var uint32' 'ptr uint32' OUT (diff., need sugar)
# return: ARRAY 'zeroTerminatedArray[ptr GObject2.TParamSpec]' 'zeroTerminatedArray[ptr GObject2.TParamSpec]'
proc gtk_container_class_list_child_properties(self: ptr TContainerClass, n_properties: ptr uint32): zeroTerminatedArray[ptr GObject2.TParamSpec] {.cdecl, dynlib: lib, importc: "gtk_container_class_list_child_properties".}
proc list_child_properties*(self: ptr TContainerClass, n_properties: var uint32): zeroTerminatedArray[ptr GObject2.TParamSpec] {.inline.} =
  gtk_container_class_list_child_properties(self, addr(n_properties))
# tuple-return
# n_properties: var uint32
# proc list_child_properties*(self: ptr TContainerClass): zeroTerminatedArray[ptr GObject2.TParamSpec] {.inline.} =

# struct ContainerPrivate
# struct CssProviderClass
# struct CssProviderPrivate
# struct CssSection
# gtk_css_section_get_end_line
# flags: {isMethod} container: CssSection
# need sugar: is method
# return: UINT32 'uint32' 'uint32'
proc gtk_css_section_get_end_line(self: ptr TCssSection): uint32 {.cdecl, dynlib: lib, importc: "gtk_css_section_get_end_line".}
proc get_end_line*(self: ptr TCssSection): uint32 {.inline.} =
  gtk_css_section_get_end_line(self)
# proc get_end_line*(self: ptr TCssSection): uint32 {.inline.} =

# gtk_css_section_get_end_position
# flags: {isMethod} container: CssSection
# need sugar: is method
# return: UINT32 'uint32' 'uint32'
proc gtk_css_section_get_end_position(self: ptr TCssSection): uint32 {.cdecl, dynlib: lib, importc: "gtk_css_section_get_end_position".}
proc get_end_position*(self: ptr TCssSection): uint32 {.inline.} =
  gtk_css_section_get_end_position(self)
# proc get_end_position*(self: ptr TCssSection): uint32 {.inline.} =

# gtk_css_section_get_file
# flags: {isMethod} container: CssSection
# need sugar: is method
# return: INTERFACE 'ptr Gio2.TFile' 'TransferNone[Gio2.TFile]' (diff., need sugar)
proc gtk_css_section_get_file(self: ptr TCssSection): TransferNone[Gio2.TFile] {.cdecl, dynlib: lib, importc: "gtk_css_section_get_file".}
proc get_file*(self: ptr TCssSection): ptr Gio2.TFile {.inline.} =
  wrap(gtk_css_section_get_file(self))
# proc get_file*(self: ptr TCssSection): ptr Gio2.TFile {.inline.} =

# gtk_css_section_get_parent
# flags: {isMethod} container: CssSection
# need sugar: is method
# return: INTERFACE 'ptr TCssSection' 'ptr TCssSection'
proc gtk_css_section_get_parent(self: ptr TCssSection): ptr TCssSection {.cdecl, dynlib: lib, importc: "gtk_css_section_get_parent".}
proc get_parent*(self: ptr TCssSection): ptr TCssSection {.inline.} =
  gtk_css_section_get_parent(self)
# proc get_parent*(self: ptr TCssSection): ptr TCssSection {.inline.} =

# gtk_css_section_get_section_type
# flags: {isMethod} container: CssSection
# need sugar: is method
# return: INTERFACE 'CssSectionType' 'CssSectionType'
proc gtk_css_section_get_section_type(self: ptr TCssSection): CssSectionType {.cdecl, dynlib: lib, importc: "gtk_css_section_get_section_type".}
proc get_section_type*(self: ptr TCssSection): CssSectionType {.inline.} =
  gtk_css_section_get_section_type(self)
# proc get_section_type*(self: ptr TCssSection): CssSectionType {.inline.} =

# gtk_css_section_get_start_line
# flags: {isMethod} container: CssSection
# need sugar: is method
# return: UINT32 'uint32' 'uint32'
proc gtk_css_section_get_start_line(self: ptr TCssSection): uint32 {.cdecl, dynlib: lib, importc: "gtk_css_section_get_start_line".}
proc get_start_line*(self: ptr TCssSection): uint32 {.inline.} =
  gtk_css_section_get_start_line(self)
# proc get_start_line*(self: ptr TCssSection): uint32 {.inline.} =

# gtk_css_section_get_start_position
# flags: {isMethod} container: CssSection
# need sugar: is method
# return: UINT32 'uint32' 'uint32'
proc gtk_css_section_get_start_position(self: ptr TCssSection): uint32 {.cdecl, dynlib: lib, importc: "gtk_css_section_get_start_position".}
proc get_start_position*(self: ptr TCssSection): uint32 {.inline.} =
  gtk_css_section_get_start_position(self)
# proc get_start_position*(self: ptr TCssSection): uint32 {.inline.} =

# gtk_css_section_ref
# flags: {isMethod} container: CssSection
# need sugar: is method
# return: INTERFACE 'ptr TCssSection' 'ptr TCssSection'
proc gtk_css_section_ref(self: ptr TCssSection): ptr TCssSection {.cdecl, dynlib: lib, importc: "gtk_css_section_ref".}
proc ref_x*(self: ptr TCssSection): ptr TCssSection {.inline.} =
  gtk_css_section_ref(self)
# proc ref_x*(self: ptr TCssSection): ptr TCssSection {.inline.} =

# gtk_css_section_unref
# flags: {isMethod} container: CssSection
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_css_section_unref(self: ptr TCssSection) {.cdecl, dynlib: lib, importc: "gtk_css_section_unref".}
proc unref*(self: ptr TCssSection) {.inline.} =
  gtk_css_section_unref(self)
# proc unref*(self: ptr TCssSection) {.inline.} =

# struct DialogClass
# struct DialogPrivate
# struct DrawingAreaClass
# struct EditableInterface
# struct EntryAccessibleClass
# struct EntryAccessiblePrivate
# struct EntryBufferClass
# struct EntryBufferPrivate
# struct EntryClass
# struct EntryCompletionClass
# struct EntryCompletionPrivate
# struct EntryPrivate
# struct EventBoxClass
# struct EventBoxPrivate
# struct EventControllerClass
# struct ExpanderAccessibleClass
# struct ExpanderAccessiblePrivate
# struct ExpanderClass
# struct ExpanderPrivate
# struct FileChooserButtonClass
# struct FileChooserButtonPrivate
# struct FileChooserDialogClass
# struct FileChooserDialogPrivate
# struct FileChooserWidgetClass
# struct FileChooserWidgetPrivate
# struct FileFilterInfo
# struct FixedChild
# struct FixedClass
# struct FixedPrivate
# struct FlowBoxAccessibleClass
# struct FlowBoxAccessiblePrivate
# struct FlowBoxChildAccessibleClass
# struct FlowBoxChildClass
# struct FlowBoxClass
# struct FontButtonClass
# struct FontButtonPrivate
# struct FontChooserDialogClass
# struct FontChooserDialogPrivate
# struct FontChooserIface
# struct FontChooserWidgetClass
# struct FontChooserWidgetPrivate
# struct FontSelectionClass
# struct FontSelectionDialogClass
# struct FontSelectionDialogPrivate
# struct FontSelectionPrivate
# struct FrameAccessibleClass
# struct FrameAccessiblePrivate
# struct FrameClass
# struct FramePrivate
# struct GLAreaClass
# struct GestureClass
# struct GestureDragClass
# struct GestureLongPressClass
# struct GestureMultiPressClass
# struct GesturePanClass
# struct GestureRotateClass
# struct GestureSingleClass
# struct GestureSwipeClass
# struct GestureZoomClass
# struct Gradient
# gtk_gradient_new_linear
# flags: {isConstructor} container: Gradient (deprecated)
# gtk_gradient_new_radial
# flags: {isConstructor} container: Gradient (deprecated)
# gtk_gradient_add_color_stop
# flags: {isMethod} container: Gradient (deprecated)
# gtk_gradient_ref
# flags: {isMethod} container: Gradient (deprecated)
# gtk_gradient_resolve
# flags: {isMethod} container: Gradient (deprecated)
# gtk_gradient_resolve_for_context
# flags: {isMethod} container: Gradient
# need sugar: is method
# arg context: INTERFACE (OBJECT) 'StyleContext' 'ptr TStyleContext' IN (diff., need sugar)
# return: INTERFACE 'ptr cairo1.TPattern' 'ptr cairo1.TPattern'
proc gtk_gradient_resolve_for_context(self: ptr TGradient, context: ptr TStyleContext): ptr cairo1.TPattern {.cdecl, dynlib: lib, importc: "gtk_gradient_resolve_for_context".}
proc resolve_for_context*(self: ptr TGradient, context: StyleContext): ptr cairo1.TPattern {.inline.} =
  gtk_gradient_resolve_for_context(self, context.getPointer)
# proc resolve_for_context*(self: ptr TGradient, context: StyleContext): ptr cairo1.TPattern {.inline.} =

# gtk_gradient_to_string
# flags: {isMethod} container: Gradient (deprecated)
# gtk_gradient_unref
# flags: {isMethod} container: Gradient (deprecated)
# struct GridClass
# struct GridPrivate
# struct HBoxClass
# struct HButtonBoxClass
# struct HPanedClass
# struct HSVClass
# struct HSVPrivate
# struct HScaleClass
# struct HScrollbarClass
# struct HSeparatorClass
# struct HandleBoxClass
# struct HandleBoxPrivate
# struct HeaderBarClass
# struct HeaderBarPrivate
# struct IMContextClass
# struct IMContextInfo
# struct IMContextSimpleClass
# struct IMContextSimplePrivate
# struct IMMulticontextClass
# struct IMMulticontextPrivate
# struct IconFactoryClass
# struct IconFactoryPrivate
# struct IconInfoClass
# struct IconSet
# gtk_icon_set_new
# flags: {isConstructor} container: IconSet (deprecated)
# gtk_icon_set_new_from_pixbuf
# flags: {isConstructor} container: IconSet (deprecated)
# gtk_icon_set_add_source
# flags: {isMethod} container: IconSet (deprecated)
# gtk_icon_set_copy
# flags: {isMethod} container: IconSet (deprecated)
# gtk_icon_set_get_sizes
# flags: {isMethod} container: IconSet (deprecated)
# gtk_icon_set_ref
# flags: {isMethod} container: IconSet (deprecated)
# gtk_icon_set_render_icon
# flags: {isMethod} container: IconSet (deprecated)
# gtk_icon_set_render_icon_pixbuf
# flags: {isMethod} container: IconSet (deprecated)
# gtk_icon_set_render_icon_surface
# flags: {isMethod} container: IconSet (deprecated)
# gtk_icon_set_unref
# flags: {isMethod} container: IconSet (deprecated)
# struct IconSource
# gtk_icon_source_new
# flags: {isConstructor} container: IconSource (deprecated)
# gtk_icon_source_copy
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_free
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_get_direction
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_get_direction_wildcarded
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_get_filename
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_get_icon_name
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_get_pixbuf
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_get_size
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_get_size_wildcarded
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_get_state
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_get_state_wildcarded
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_set_direction
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_set_direction_wildcarded
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_set_filename
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_set_icon_name
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_set_pixbuf
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_set_size
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_set_size_wildcarded
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_set_state
# flags: {isMethod} container: IconSource (deprecated)
# gtk_icon_source_set_state_wildcarded
# flags: {isMethod} container: IconSource (deprecated)
# struct IconThemeClass
# struct IconThemePrivate
# struct IconViewAccessibleClass
# struct IconViewAccessiblePrivate
# struct IconViewClass
# struct IconViewPrivate
# struct ImageAccessibleClass
# struct ImageAccessiblePrivate
# struct ImageCellAccessibleClass
# struct ImageCellAccessiblePrivate
# struct ImageClass
# struct ImageMenuItemClass
# struct ImageMenuItemPrivate
# struct ImagePrivate
# struct InfoBarClass
# struct InfoBarPrivate
# struct InvisibleClass
# struct InvisiblePrivate
# struct LabelAccessibleClass
# struct LabelAccessiblePrivate
# struct LabelClass
# struct LabelPrivate
# struct LabelSelectionInfo
# struct LayoutClass
# struct LayoutPrivate
# struct LevelBarAccessibleClass
# struct LevelBarAccessiblePrivate
# struct LevelBarClass
# struct LevelBarPrivate
# struct LinkButtonAccessibleClass
# struct LinkButtonAccessiblePrivate
# struct LinkButtonClass
# struct LinkButtonPrivate
# struct ListBoxAccessibleClass
# struct ListBoxAccessiblePrivate
# struct ListBoxClass
# struct ListBoxRowAccessibleClass
# struct ListBoxRowClass
# struct ListStoreClass
# struct ListStorePrivate
# struct LockButtonAccessibleClass
# struct LockButtonAccessiblePrivate
# struct LockButtonClass
# struct LockButtonPrivate
# struct MenuAccessibleClass
# struct MenuAccessiblePrivate
# struct MenuBarClass
# struct MenuBarPrivate
# struct MenuButtonAccessibleClass
# struct MenuButtonAccessiblePrivate
# struct MenuButtonClass
# struct MenuButtonPrivate
# struct MenuClass
# struct MenuItemAccessibleClass
# struct MenuItemAccessiblePrivate
# struct MenuItemClass
# struct MenuItemPrivate
# struct MenuPrivate
# struct MenuShellAccessibleClass
# struct MenuShellAccessiblePrivate
# struct MenuShellClass
# struct MenuShellPrivate
# struct MenuToolButtonClass
# struct MenuToolButtonPrivate
# struct MessageDialogClass
# struct MessageDialogPrivate
# struct MiscClass
# struct MiscPrivate
# struct MountOperationClass
# struct MountOperationPrivate
# struct NotebookAccessibleClass
# struct NotebookAccessiblePrivate
# struct NotebookClass
# struct NotebookPageAccessibleClass
# struct NotebookPageAccessiblePrivate
# struct NotebookPrivate
# struct NumerableIconClass
# struct NumerableIconPrivate
# struct OffscreenWindowClass
# struct OrientableIface
# struct OverlayClass
# struct OverlayPrivate
# struct PageRange
# struct PanedAccessibleClass
# struct PanedAccessiblePrivate
# struct PanedClass
# struct PanedPrivate
# struct PaperSize
# gtk_paper_size_new
# flags: {isConstructor} container: PaperSize
# need sugar: is static method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'ptr TPaperSize' 'ptr TPaperSize'
proc gtk_paper_size_new(name: ucstring): ptr TPaperSize {.cdecl, dynlib: lib, importc: "gtk_paper_size_new".}
proc new_papersize*(name: ustring): ptr TPaperSize {.inline.} =
  gtk_paper_size_new(ucstring(name))
# proc new_papersize*(name: ustring): ptr TPaperSize {.inline.} =

# gtk_paper_size_new_custom
# flags: {isConstructor} container: PaperSize
# need sugar: is static method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg display_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg width: DOUBLE 'float64' 'float64' IN
# arg height: DOUBLE 'float64' 'float64' IN
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: INTERFACE 'ptr TPaperSize' 'ptr TPaperSize'
proc gtk_paper_size_new_custom(name: ucstring, display_name: ucstring, width: float64, height: float64, unit: Unit): ptr TPaperSize {.cdecl, dynlib: lib, importc: "gtk_paper_size_new_custom".}
proc new_papersize_custom*(name: ustring, display_name: ustring, width: float64, height: float64, unit: Unit): ptr TPaperSize {.inline.} =
  gtk_paper_size_new_custom(ucstring(name), ucstring(display_name), width, height, unit)
# proc new_papersize_custom*(name: ustring, display_name: ustring, width: float64, height: float64, unit: Unit): ptr TPaperSize {.inline.} =

# gtk_paper_size_new_from_ipp
# flags: {isConstructor} container: PaperSize
# need sugar: is static method
# arg ipp_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg width: DOUBLE 'float64' 'float64' IN
# arg height: DOUBLE 'float64' 'float64' IN
# return: INTERFACE 'ptr TPaperSize' 'ptr TPaperSize'
proc gtk_paper_size_new_from_ipp(ipp_name: ucstring, width: float64, height: float64): ptr TPaperSize {.cdecl, dynlib: lib, importc: "gtk_paper_size_new_from_ipp".}
proc new_papersize_from_ipp*(ipp_name: ustring, width: float64, height: float64): ptr TPaperSize {.inline.} =
  gtk_paper_size_new_from_ipp(ucstring(ipp_name), width, height)
# proc new_papersize_from_ipp*(ipp_name: ustring, width: float64, height: float64): ptr TPaperSize {.inline.} =

# gtk_paper_size_new_from_key_file
# flags: {isConstructor, throws} container: PaperSize
# can throw
# need sugar: is static method
# arg key_file: INTERFACE (STRUCT) 'ptr GLib2.TKeyFile' 'ptr GLib2.TKeyFile' IN
# arg group_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'ptr TPaperSize' 'ptr TPaperSize'
proc gtk_paper_size_new_from_key_file(key_file: ptr GLib2.TKeyFile, group_name: ucstring, error: ptr PGError=nil): ptr TPaperSize {.cdecl, dynlib: lib, importc: "gtk_paper_size_new_from_key_file".}
proc new_papersize_from_key_file*(key_file: ptr GLib2.TKeyFile, group_name: ustring): ptr TPaperSize {.inline.} =
  gtk_paper_size_new_from_key_file(key_file, ucstring(group_name))
# proc new_papersize_from_key_file*(key_file: ptr GLib2.TKeyFile, group_name: ustring): ptr TPaperSize {.inline.} =

# gtk_paper_size_new_from_ppd
# flags: {isConstructor} container: PaperSize
# need sugar: is static method
# arg ppd_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg ppd_display_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg width: DOUBLE 'float64' 'float64' IN
# arg height: DOUBLE 'float64' 'float64' IN
# return: INTERFACE 'ptr TPaperSize' 'ptr TPaperSize'
proc gtk_paper_size_new_from_ppd(ppd_name: ucstring, ppd_display_name: ucstring, width: float64, height: float64): ptr TPaperSize {.cdecl, dynlib: lib, importc: "gtk_paper_size_new_from_ppd".}
proc new_papersize_from_ppd*(ppd_name: ustring, ppd_display_name: ustring, width: float64, height: float64): ptr TPaperSize {.inline.} =
  gtk_paper_size_new_from_ppd(ucstring(ppd_name), ucstring(ppd_display_name), width, height)
# proc new_papersize_from_ppd*(ppd_name: ustring, ppd_display_name: ustring, width: float64, height: float64): ptr TPaperSize {.inline.} =

# gtk_paper_size_copy
# flags: {isMethod} container: PaperSize
# need sugar: is method
# return: INTERFACE 'ptr TPaperSize' 'ptr TPaperSize'
proc gtk_paper_size_copy(self: ptr TPaperSize): ptr TPaperSize {.cdecl, dynlib: lib, importc: "gtk_paper_size_copy".}
proc copy*(self: ptr TPaperSize): ptr TPaperSize {.inline.} =
  gtk_paper_size_copy(self)
# proc copy*(self: ptr TPaperSize): ptr TPaperSize {.inline.} =

# gtk_paper_size_free
# flags: {isMethod} container: PaperSize
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_paper_size_free(self: ptr TPaperSize) {.cdecl, dynlib: lib, importc: "gtk_paper_size_free".}
proc free*(self: ptr TPaperSize) {.inline.} =
  gtk_paper_size_free(self)
# proc free*(self: ptr TPaperSize) {.inline.} =

# gtk_paper_size_get_default_bottom_margin
# flags: {isMethod} container: PaperSize
# need sugar: is method
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: DOUBLE 'float64' 'float64'
proc gtk_paper_size_get_default_bottom_margin(self: ptr TPaperSize, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_paper_size_get_default_bottom_margin".}
proc get_default_bottom_margin*(self: ptr TPaperSize, unit: Unit): float64 {.inline.} =
  gtk_paper_size_get_default_bottom_margin(self, unit)
# proc get_default_bottom_margin*(self: ptr TPaperSize, unit: Unit): float64 {.inline.} =

# gtk_paper_size_get_default_left_margin
# flags: {isMethod} container: PaperSize
# need sugar: is method
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: DOUBLE 'float64' 'float64'
proc gtk_paper_size_get_default_left_margin(self: ptr TPaperSize, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_paper_size_get_default_left_margin".}
proc get_default_left_margin*(self: ptr TPaperSize, unit: Unit): float64 {.inline.} =
  gtk_paper_size_get_default_left_margin(self, unit)
# proc get_default_left_margin*(self: ptr TPaperSize, unit: Unit): float64 {.inline.} =

# gtk_paper_size_get_default_right_margin
# flags: {isMethod} container: PaperSize
# need sugar: is method
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: DOUBLE 'float64' 'float64'
proc gtk_paper_size_get_default_right_margin(self: ptr TPaperSize, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_paper_size_get_default_right_margin".}
proc get_default_right_margin*(self: ptr TPaperSize, unit: Unit): float64 {.inline.} =
  gtk_paper_size_get_default_right_margin(self, unit)
# proc get_default_right_margin*(self: ptr TPaperSize, unit: Unit): float64 {.inline.} =

# gtk_paper_size_get_default_top_margin
# flags: {isMethod} container: PaperSize
# need sugar: is method
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: DOUBLE 'float64' 'float64'
proc gtk_paper_size_get_default_top_margin(self: ptr TPaperSize, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_paper_size_get_default_top_margin".}
proc get_default_top_margin*(self: ptr TPaperSize, unit: Unit): float64 {.inline.} =
  gtk_paper_size_get_default_top_margin(self, unit)
# proc get_default_top_margin*(self: ptr TPaperSize, unit: Unit): float64 {.inline.} =

# gtk_paper_size_get_display_name
# flags: {isMethod} container: PaperSize
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_paper_size_get_display_name(self: ptr TPaperSize): ucstring {.cdecl, dynlib: lib, importc: "gtk_paper_size_get_display_name".}
proc get_display_name*(self: ptr TPaperSize): ucstring {.inline.} =
  gtk_paper_size_get_display_name(self)
# proc get_display_name*(self: ptr TPaperSize): ucstring {.inline.} =

# gtk_paper_size_get_height
# flags: {isMethod} container: PaperSize
# need sugar: is method
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: DOUBLE 'float64' 'float64'
proc gtk_paper_size_get_height(self: ptr TPaperSize, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_paper_size_get_height".}
proc get_height*(self: ptr TPaperSize, unit: Unit): float64 {.inline.} =
  gtk_paper_size_get_height(self, unit)
# proc get_height*(self: ptr TPaperSize, unit: Unit): float64 {.inline.} =

# gtk_paper_size_get_name
# flags: {isMethod} container: PaperSize
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_paper_size_get_name(self: ptr TPaperSize): ucstring {.cdecl, dynlib: lib, importc: "gtk_paper_size_get_name".}
proc get_name*(self: ptr TPaperSize): ucstring {.inline.} =
  gtk_paper_size_get_name(self)
# proc get_name*(self: ptr TPaperSize): ucstring {.inline.} =

# gtk_paper_size_get_ppd_name
# flags: {isMethod} container: PaperSize
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_paper_size_get_ppd_name(self: ptr TPaperSize): ucstring {.cdecl, dynlib: lib, importc: "gtk_paper_size_get_ppd_name".}
proc get_ppd_name*(self: ptr TPaperSize): ucstring {.inline.} =
  gtk_paper_size_get_ppd_name(self)
# proc get_ppd_name*(self: ptr TPaperSize): ucstring {.inline.} =

# gtk_paper_size_get_width
# flags: {isMethod} container: PaperSize
# need sugar: is method
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: DOUBLE 'float64' 'float64'
proc gtk_paper_size_get_width(self: ptr TPaperSize, unit: Unit): float64 {.cdecl, dynlib: lib, importc: "gtk_paper_size_get_width".}
proc get_width*(self: ptr TPaperSize, unit: Unit): float64 {.inline.} =
  gtk_paper_size_get_width(self, unit)
# proc get_width*(self: ptr TPaperSize, unit: Unit): float64 {.inline.} =

# gtk_paper_size_is_custom
# flags: {isMethod} container: PaperSize
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_paper_size_is_custom(self: ptr TPaperSize): bool {.cdecl, dynlib: lib, importc: "gtk_paper_size_is_custom".}
proc is_custom*(self: ptr TPaperSize): bool {.inline.} =
  gtk_paper_size_is_custom(self)
# proc is_custom*(self: ptr TPaperSize): bool {.inline.} =

# gtk_paper_size_is_equal
# flags: {isMethod} container: PaperSize
# need sugar: is method
# arg size2: INTERFACE (STRUCT) 'ptr TPaperSize' 'ptr TPaperSize' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_paper_size_is_equal(self: ptr TPaperSize, size2: ptr TPaperSize): bool {.cdecl, dynlib: lib, importc: "gtk_paper_size_is_equal".}
proc is_equal*(self: ptr TPaperSize, size2: ptr TPaperSize): bool {.inline.} =
  gtk_paper_size_is_equal(self, size2)
# proc is_equal*(self: ptr TPaperSize, size2: ptr TPaperSize): bool {.inline.} =

# gtk_paper_size_is_ipp
# flags: {isMethod} container: PaperSize
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_paper_size_is_ipp(self: ptr TPaperSize): bool {.cdecl, dynlib: lib, importc: "gtk_paper_size_is_ipp".}
proc is_ipp*(self: ptr TPaperSize): bool {.inline.} =
  gtk_paper_size_is_ipp(self)
# proc is_ipp*(self: ptr TPaperSize): bool {.inline.} =

# gtk_paper_size_set_size
# flags: {isMethod} container: PaperSize
# need sugar: is method
# arg width: DOUBLE 'float64' 'float64' IN
# arg height: DOUBLE 'float64' 'float64' IN
# arg unit: INTERFACE (ENUM) 'Unit' 'Unit' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_paper_size_set_size(self: ptr TPaperSize, width: float64, height: float64, unit: Unit) {.cdecl, dynlib: lib, importc: "gtk_paper_size_set_size".}
proc set_size*(self: ptr TPaperSize, width: float64, height: float64, unit: Unit) {.inline.} =
  gtk_paper_size_set_size(self, width, height, unit)
# proc set_size*(self: ptr TPaperSize, width: float64, height: float64, unit: Unit) {.inline.} =

# gtk_paper_size_to_key_file
# flags: {isMethod} container: PaperSize
# need sugar: is method
# arg key_file: INTERFACE (STRUCT) 'ptr GLib2.TKeyFile' 'ptr GLib2.TKeyFile' IN
# arg group_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_paper_size_to_key_file(self: ptr TPaperSize, key_file: ptr GLib2.TKeyFile, group_name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_paper_size_to_key_file".}
proc to_key_file*(self: ptr TPaperSize, key_file: ptr GLib2.TKeyFile, group_name: ustring) {.inline.} =
  gtk_paper_size_to_key_file(self, key_file, ucstring(group_name))
# proc to_key_file*(self: ptr TPaperSize, key_file: ptr GLib2.TKeyFile, group_name: ustring) {.inline.} =

# gtk_paper_size_get_default
# flags: {} container: PaperSize
# need sugar: is static method
# return: UTF8 'ucstring' 'ucstring'
# warning, already written a prototype with the name of gtk_paper_size_get_default
# proc gtk_paper_size_get_default(): ucstring {.cdecl, dynlib: lib, importc: "gtk_paper_size_get_default".}
template get_default*(klass_parameter: typedesc[TPaperSize]): ucstring =
  gtk_paper_size_get_default()
# template get_default*(klass_parameter: typedesc[TPaperSize]): ucstring =

# gtk_paper_size_get_paper_sizes
# flags: {} container: PaperSize
# need sugar: is static method
# arg include_custom: BOOLEAN 'bool' 'bool' IN
# return: GLIST 'ptr GLIST_TODO' 'ptr GLIST_TODO'
# warning, already written a prototype with the name of gtk_paper_size_get_paper_sizes
# proc gtk_paper_size_get_paper_sizes(include_custom: bool): ptr GLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_paper_size_get_paper_sizes".}
template get_paper_sizes*(klass_parameter: typedesc[TPaperSize], include_custom: bool): ptr GLIST_TODO =
  gtk_paper_size_get_paper_sizes(include_custom)
# template get_paper_sizes*(klass_parameter: typedesc[TPaperSize], include_custom: bool): ptr GLIST_TODO =

# struct PlacesSidebarClass
# struct PopoverAccessibleClass
# struct PopoverClass
# struct PopoverMenuClass
# struct PopoverPrivate
# struct PrintOperationClass
# struct PrintOperationPreviewIface
# struct PrintOperationPrivate
# struct ProgressBarAccessibleClass
# struct ProgressBarAccessiblePrivate
# struct ProgressBarClass
# struct ProgressBarPrivate
# struct RadioActionClass
# struct RadioActionEntry
# struct RadioActionPrivate
# struct RadioButtonAccessibleClass
# struct RadioButtonAccessiblePrivate
# struct RadioButtonClass
# struct RadioButtonPrivate
# struct RadioMenuItemAccessibleClass
# struct RadioMenuItemAccessiblePrivate
# struct RadioMenuItemClass
# struct RadioMenuItemPrivate
# struct RadioToolButtonClass
# struct RangeAccessibleClass
# struct RangeAccessiblePrivate
# struct RangeClass
# struct RangePrivate
# struct RcContext
# struct RcProperty
# gtk_rc_property_parse_border
# flags: {} container: RcProperty
# need sugar: is static method
# arg pspec: INTERFACE (OBJECT) 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# arg gstring: INTERFACE (STRUCT) 'ptr GLib2.TString' 'ptr GLib2.TString' IN
# arg property_value: INTERFACE (STRUCT) 'ptr GObject2.TValue' 'ptr GObject2.TValue' IN
# return: BOOLEAN 'bool' 'bool'
# warning, already written a prototype with the name of gtk_rc_property_parse_border
# proc gtk_rc_property_parse_border(pspec: ptr GObject2.TParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.cdecl, dynlib: lib, importc: "gtk_rc_property_parse_border".}
template parse_border*(klass_parameter: typedesc[TRcProperty], pspec: GObject2.ParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool =
  gtk_rc_property_parse_border(pspec.getPointer, gstring, property_value)
# template parse_border*(klass_parameter: typedesc[TRcProperty], pspec: GObject2.ParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool =

# gtk_rc_property_parse_color
# flags: {} container: RcProperty
# need sugar: is static method
# arg pspec: INTERFACE (OBJECT) 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# arg gstring: INTERFACE (STRUCT) 'ptr GLib2.TString' 'ptr GLib2.TString' IN
# arg property_value: INTERFACE (STRUCT) 'ptr GObject2.TValue' 'ptr GObject2.TValue' IN
# return: BOOLEAN 'bool' 'bool'
# warning, already written a prototype with the name of gtk_rc_property_parse_color
# proc gtk_rc_property_parse_color(pspec: ptr GObject2.TParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.cdecl, dynlib: lib, importc: "gtk_rc_property_parse_color".}
template parse_color*(klass_parameter: typedesc[TRcProperty], pspec: GObject2.ParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool =
  gtk_rc_property_parse_color(pspec.getPointer, gstring, property_value)
# template parse_color*(klass_parameter: typedesc[TRcProperty], pspec: GObject2.ParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool =

# gtk_rc_property_parse_enum
# flags: {} container: RcProperty
# need sugar: is static method
# arg pspec: INTERFACE (OBJECT) 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# arg gstring: INTERFACE (STRUCT) 'ptr GLib2.TString' 'ptr GLib2.TString' IN
# arg property_value: INTERFACE (STRUCT) 'ptr GObject2.TValue' 'ptr GObject2.TValue' IN
# return: BOOLEAN 'bool' 'bool'
# warning, already written a prototype with the name of gtk_rc_property_parse_enum
# proc gtk_rc_property_parse_enum(pspec: ptr GObject2.TParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.cdecl, dynlib: lib, importc: "gtk_rc_property_parse_enum".}
template parse_enum*(klass_parameter: typedesc[TRcProperty], pspec: GObject2.ParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool =
  gtk_rc_property_parse_enum(pspec.getPointer, gstring, property_value)
# template parse_enum*(klass_parameter: typedesc[TRcProperty], pspec: GObject2.ParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool =

# gtk_rc_property_parse_flags
# flags: {} container: RcProperty
# need sugar: is static method
# arg pspec: INTERFACE (OBJECT) 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# arg gstring: INTERFACE (STRUCT) 'ptr GLib2.TString' 'ptr GLib2.TString' IN
# arg property_value: INTERFACE (STRUCT) 'ptr GObject2.TValue' 'ptr GObject2.TValue' IN
# return: BOOLEAN 'bool' 'bool'
# warning, already written a prototype with the name of gtk_rc_property_parse_flags
# proc gtk_rc_property_parse_flags(pspec: ptr GObject2.TParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.cdecl, dynlib: lib, importc: "gtk_rc_property_parse_flags".}
template parse_flags*(klass_parameter: typedesc[TRcProperty], pspec: GObject2.ParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool =
  gtk_rc_property_parse_flags(pspec.getPointer, gstring, property_value)
# template parse_flags*(klass_parameter: typedesc[TRcProperty], pspec: GObject2.ParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool =

# gtk_rc_property_parse_requisition
# flags: {} container: RcProperty
# need sugar: is static method
# arg pspec: INTERFACE (OBJECT) 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# arg gstring: INTERFACE (STRUCT) 'ptr GLib2.TString' 'ptr GLib2.TString' IN
# arg property_value: INTERFACE (STRUCT) 'ptr GObject2.TValue' 'ptr GObject2.TValue' IN
# return: BOOLEAN 'bool' 'bool'
# warning, already written a prototype with the name of gtk_rc_property_parse_requisition
# proc gtk_rc_property_parse_requisition(pspec: ptr GObject2.TParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool {.cdecl, dynlib: lib, importc: "gtk_rc_property_parse_requisition".}
template parse_requisition*(klass_parameter: typedesc[TRcProperty], pspec: GObject2.ParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool =
  gtk_rc_property_parse_requisition(pspec.getPointer, gstring, property_value)
# template parse_requisition*(klass_parameter: typedesc[TRcProperty], pspec: GObject2.ParamSpec, gstring: ptr GLib2.TString, property_value: ptr GObject2.TValue): bool =

# struct RcStyleClass
# struct RecentActionClass
# struct RecentActionPrivate
# struct RecentChooserDialogClass
# struct RecentChooserDialogPrivate
# struct RecentChooserIface
# struct RecentChooserMenuClass
# struct RecentChooserMenuPrivate
# struct RecentChooserWidgetClass
# struct RecentChooserWidgetPrivate
# struct RecentData
# struct RecentFilterInfo
# struct RecentInfo
# gtk_recent_info_create_app_info
# flags: {isMethod, throws} container: RecentInfo
# can throw
# need sugar: is method
# arg app_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'ptr Gio2.TAppInfo' 'TransferFull[Gio2.TAppInfo]' (diff., need sugar)
proc gtk_recent_info_create_app_info(self: ptr TRecentInfo, app_name: ucstring, error: ptr PGError=nil): TransferFull[Gio2.TAppInfo] {.cdecl, dynlib: lib, importc: "gtk_recent_info_create_app_info".}
proc create_app_info*(self: ptr TRecentInfo, app_name: ustring): ptr Gio2.TAppInfo {.inline.} =
  wrap(gtk_recent_info_create_app_info(self, ucstring(app_name)))
# proc create_app_info*(self: ptr TRecentInfo, app_name: ustring): ptr Gio2.TAppInfo {.inline.} =

# gtk_recent_info_exists
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_recent_info_exists(self: ptr TRecentInfo): bool {.cdecl, dynlib: lib, importc: "gtk_recent_info_exists".}
proc exists*(self: ptr TRecentInfo): bool {.inline.} =
  gtk_recent_info_exists(self)
# proc exists*(self: ptr TRecentInfo): bool {.inline.} =

# gtk_recent_info_get_added
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_recent_info_get_added(self: ptr TRecentInfo): int32 {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_added".}
proc get_added*(self: ptr TRecentInfo): int32 {.inline.} =
  gtk_recent_info_get_added(self)
# proc get_added*(self: ptr TRecentInfo): int32 {.inline.} =

# gtk_recent_info_get_age
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_recent_info_get_age(self: ptr TRecentInfo): int32 {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_age".}
proc get_age*(self: ptr TRecentInfo): int32 {.inline.} =
  gtk_recent_info_get_age(self)
# proc get_age*(self: ptr TRecentInfo): int32 {.inline.} =

# gtk_recent_info_get_application_info
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# arg app_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg app_exec: UTF8 'var ucstring' 'ptr ucstring' OUT (diff., need sugar)
# arg count: UINT32 'var uint32' 'ptr uint32' OUT (diff., need sugar)
# arg time_: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_recent_info_get_application_info(self: ptr TRecentInfo, app_name: ucstring, app_exec: ptr ucstring, count: ptr uint32, time_x: ptr int32): bool {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_application_info".}
proc get_application_info*(self: ptr TRecentInfo, app_name: ustring, app_exec: var ucstring, count: var uint32, time_x: var int32): bool {.inline.} =
  gtk_recent_info_get_application_info(self, ucstring(app_name), addr(app_exec), addr(count), addr(time_x))
# tuple-return
# app_exec: var ucstring
# count: var uint32
# time_: var int32
# proc get_application_info*(self: ptr TRecentInfo, app_name: ustring): bool {.inline.} =

# gtk_recent_info_get_applications
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# arg length: UINT32 'var uint32' 'ptr uint32' OUT (diff., need sugar) optional
# return: ARRAY 'zeroTerminatedArray[ucstring]' 'zeroTerminatedArray[ucstring]'
proc gtk_recent_info_get_applications(self: ptr TRecentInfo, length: ptr uint32): zeroTerminatedArray[ucstring] {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_applications".}
proc get_applications*(self: ptr TRecentInfo, length: var uint32): zeroTerminatedArray[ucstring] {.inline.} =
  gtk_recent_info_get_applications(self, addr(length))
# tuple-return
# length: var uint32
# proc get_applications*(self: ptr TRecentInfo): zeroTerminatedArray[ucstring] {.inline.} =

# gtk_recent_info_get_description
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_recent_info_get_description(self: ptr TRecentInfo): ucstring {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_description".}
proc get_description*(self: ptr TRecentInfo): ucstring {.inline.} =
  gtk_recent_info_get_description(self)
# proc get_description*(self: ptr TRecentInfo): ucstring {.inline.} =

# gtk_recent_info_get_display_name
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_recent_info_get_display_name(self: ptr TRecentInfo): ucstring {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_display_name".}
proc get_display_name*(self: ptr TRecentInfo): ucstring {.inline.} =
  gtk_recent_info_get_display_name(self)
# proc get_display_name*(self: ptr TRecentInfo): ucstring {.inline.} =

# gtk_recent_info_get_gicon
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# return: INTERFACE 'ptr Gio2.TIcon' 'TransferFull[Gio2.TIcon]' (diff., need sugar)
proc gtk_recent_info_get_gicon(self: ptr TRecentInfo): TransferFull[Gio2.TIcon] {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_gicon".}
proc get_gicon*(self: ptr TRecentInfo): ptr Gio2.TIcon {.inline.} =
  wrap(gtk_recent_info_get_gicon(self))
# proc get_gicon*(self: ptr TRecentInfo): ptr Gio2.TIcon {.inline.} =

# gtk_recent_info_get_groups
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# arg length: UINT32 'var uint32' 'ptr uint32' OUT (diff., need sugar) optional
# return: ARRAY 'zeroTerminatedArray[ucstring]' 'zeroTerminatedArray[ucstring]'
proc gtk_recent_info_get_groups(self: ptr TRecentInfo, length: ptr uint32): zeroTerminatedArray[ucstring] {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_groups".}
proc get_groups*(self: ptr TRecentInfo, length: var uint32): zeroTerminatedArray[ucstring] {.inline.} =
  gtk_recent_info_get_groups(self, addr(length))
# tuple-return
# length: var uint32
# proc get_groups*(self: ptr TRecentInfo): zeroTerminatedArray[ucstring] {.inline.} =

# gtk_recent_info_get_icon
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# arg size: INT32 'int32' 'int32' IN
# return: INTERFACE 'GdkPixbuf2.Pixbuf' 'TransferFull[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_recent_info_get_icon(self: ptr TRecentInfo, size: int32): TransferFull[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_icon".}
proc get_icon*(self: ptr TRecentInfo, size: int32): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_recent_info_get_icon(self, size))
# proc get_icon*(self: ptr TRecentInfo, size: int32): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_recent_info_get_mime_type
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_recent_info_get_mime_type(self: ptr TRecentInfo): ucstring {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_mime_type".}
proc get_mime_type*(self: ptr TRecentInfo): ucstring {.inline.} =
  gtk_recent_info_get_mime_type(self)
# proc get_mime_type*(self: ptr TRecentInfo): ucstring {.inline.} =

# gtk_recent_info_get_modified
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_recent_info_get_modified(self: ptr TRecentInfo): int32 {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_modified".}
proc get_modified*(self: ptr TRecentInfo): int32 {.inline.} =
  gtk_recent_info_get_modified(self)
# proc get_modified*(self: ptr TRecentInfo): int32 {.inline.} =

# gtk_recent_info_get_private_hint
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_recent_info_get_private_hint(self: ptr TRecentInfo): bool {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_private_hint".}
proc get_private_hint*(self: ptr TRecentInfo): bool {.inline.} =
  gtk_recent_info_get_private_hint(self)
# proc get_private_hint*(self: ptr TRecentInfo): bool {.inline.} =

# gtk_recent_info_get_short_name
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_recent_info_get_short_name(self: ptr TRecentInfo): ucstring {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_short_name".}
proc get_short_name*(self: ptr TRecentInfo): ucstring {.inline.} =
  gtk_recent_info_get_short_name(self)
# proc get_short_name*(self: ptr TRecentInfo): ucstring {.inline.} =

# gtk_recent_info_get_uri
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_recent_info_get_uri(self: ptr TRecentInfo): ucstring {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_uri".}
proc get_uri*(self: ptr TRecentInfo): ucstring {.inline.} =
  gtk_recent_info_get_uri(self)
# proc get_uri*(self: ptr TRecentInfo): ucstring {.inline.} =

# gtk_recent_info_get_uri_display
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_recent_info_get_uri_display(self: ptr TRecentInfo): ucstring {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_uri_display".}
proc get_uri_display*(self: ptr TRecentInfo): ucstring {.inline.} =
  gtk_recent_info_get_uri_display(self)
# proc get_uri_display*(self: ptr TRecentInfo): ucstring {.inline.} =

# gtk_recent_info_get_visited
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_recent_info_get_visited(self: ptr TRecentInfo): int32 {.cdecl, dynlib: lib, importc: "gtk_recent_info_get_visited".}
proc get_visited*(self: ptr TRecentInfo): int32 {.inline.} =
  gtk_recent_info_get_visited(self)
# proc get_visited*(self: ptr TRecentInfo): int32 {.inline.} =

# gtk_recent_info_has_application
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# arg app_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_recent_info_has_application(self: ptr TRecentInfo, app_name: ucstring): bool {.cdecl, dynlib: lib, importc: "gtk_recent_info_has_application".}
proc has_application*(self: ptr TRecentInfo, app_name: ustring): bool {.inline.} =
  gtk_recent_info_has_application(self, ucstring(app_name))
# proc has_application*(self: ptr TRecentInfo, app_name: ustring): bool {.inline.} =

# gtk_recent_info_has_group
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# arg group_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_recent_info_has_group(self: ptr TRecentInfo, group_name: ucstring): bool {.cdecl, dynlib: lib, importc: "gtk_recent_info_has_group".}
proc has_group*(self: ptr TRecentInfo, group_name: ustring): bool {.inline.} =
  gtk_recent_info_has_group(self, ucstring(group_name))
# proc has_group*(self: ptr TRecentInfo, group_name: ustring): bool {.inline.} =

# gtk_recent_info_is_local
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_recent_info_is_local(self: ptr TRecentInfo): bool {.cdecl, dynlib: lib, importc: "gtk_recent_info_is_local".}
proc is_local*(self: ptr TRecentInfo): bool {.inline.} =
  gtk_recent_info_is_local(self)
# proc is_local*(self: ptr TRecentInfo): bool {.inline.} =

# gtk_recent_info_last_application
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_recent_info_last_application(self: ptr TRecentInfo): ucstring {.cdecl, dynlib: lib, importc: "gtk_recent_info_last_application".}
proc last_application*(self: ptr TRecentInfo): ucstring {.inline.} =
  gtk_recent_info_last_application(self)
# proc last_application*(self: ptr TRecentInfo): ucstring {.inline.} =

# gtk_recent_info_match
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# arg info_b: INTERFACE (STRUCT) 'ptr TRecentInfo' 'ptr TRecentInfo' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_recent_info_match(self: ptr TRecentInfo, info_b: ptr TRecentInfo): bool {.cdecl, dynlib: lib, importc: "gtk_recent_info_match".}
proc match*(self: ptr TRecentInfo, info_b: ptr TRecentInfo): bool {.inline.} =
  gtk_recent_info_match(self, info_b)
# proc match*(self: ptr TRecentInfo, info_b: ptr TRecentInfo): bool {.inline.} =

# gtk_recent_info_ref
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# return: INTERFACE 'ptr TRecentInfo' 'ptr TRecentInfo'
proc gtk_recent_info_ref(self: ptr TRecentInfo): ptr TRecentInfo {.cdecl, dynlib: lib, importc: "gtk_recent_info_ref".}
proc ref_x*(self: ptr TRecentInfo): ptr TRecentInfo {.inline.} =
  gtk_recent_info_ref(self)
# proc ref_x*(self: ptr TRecentInfo): ptr TRecentInfo {.inline.} =

# gtk_recent_info_unref
# flags: {isMethod} container: RecentInfo
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_recent_info_unref(self: ptr TRecentInfo) {.cdecl, dynlib: lib, importc: "gtk_recent_info_unref".}
proc unref*(self: ptr TRecentInfo) {.inline.} =
  gtk_recent_info_unref(self)
# proc unref*(self: ptr TRecentInfo) {.inline.} =

# struct RecentManagerClass
# struct RecentManagerPrivate
# struct RendererCellAccessibleClass
# struct RendererCellAccessiblePrivate
# struct RequestedSize
# struct Requisition
# gtk_requisition_new
# flags: {isConstructor} container: Requisition
# need sugar: is static method
# return: INTERFACE 'ptr TRequisition' 'ptr TRequisition'
proc gtk_requisition_new(): ptr TRequisition {.cdecl, dynlib: lib, importc: "gtk_requisition_new".}
proc new_requisition*(): ptr TRequisition {.inline.} =
  gtk_requisition_new()
# proc new_requisition*(): ptr TRequisition {.inline.} =

# gtk_requisition_copy
# flags: {isMethod} container: Requisition
# need sugar: is method
# return: INTERFACE 'ptr TRequisition' 'ptr TRequisition'
proc gtk_requisition_copy(self: ptr TRequisition): ptr TRequisition {.cdecl, dynlib: lib, importc: "gtk_requisition_copy".}
proc copy*(self: ptr TRequisition): ptr TRequisition {.inline.} =
  gtk_requisition_copy(self)
# proc copy*(self: ptr TRequisition): ptr TRequisition {.inline.} =

# gtk_requisition_free
# flags: {isMethod} container: Requisition
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_requisition_free(self: ptr TRequisition) {.cdecl, dynlib: lib, importc: "gtk_requisition_free".}
proc free*(self: ptr TRequisition) {.inline.} =
  gtk_requisition_free(self)
# proc free*(self: ptr TRequisition) {.inline.} =

# struct RevealerClass
# struct ScaleAccessibleClass
# struct ScaleAccessiblePrivate
# struct ScaleButtonAccessibleClass
# struct ScaleButtonAccessiblePrivate
# struct ScaleButtonClass
# struct ScaleButtonPrivate
# struct ScaleClass
# struct ScalePrivate
# struct ScrollableInterface
# struct ScrollbarClass
# struct ScrolledWindowAccessibleClass
# struct ScrolledWindowAccessiblePrivate
# struct ScrolledWindowClass
# struct ScrolledWindowPrivate
# struct SearchBarClass
# struct SearchEntryClass
# struct SelectionData
# gtk_selection_data_copy
# flags: {isMethod} container: SelectionData
# need sugar: is method
# return: INTERFACE 'ptr TSelectionData' 'ptr TSelectionData'
proc gtk_selection_data_copy(self: ptr TSelectionData): ptr TSelectionData {.cdecl, dynlib: lib, importc: "gtk_selection_data_copy".}
proc copy*(self: ptr TSelectionData): ptr TSelectionData {.inline.} =
  gtk_selection_data_copy(self)
# proc copy*(self: ptr TSelectionData): ptr TSelectionData {.inline.} =

# gtk_selection_data_free
# flags: {isMethod} container: SelectionData
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_selection_data_free(self: ptr TSelectionData) {.cdecl, dynlib: lib, importc: "gtk_selection_data_free".}
proc free*(self: ptr TSelectionData) {.inline.} =
  gtk_selection_data_free(self)
# proc free*(self: ptr TSelectionData) {.inline.} =

# gtk_selection_data_get_data_type
# flags: {isMethod} container: SelectionData
# need sugar: is method
# return: INTERFACE 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom'
proc gtk_selection_data_get_data_type(self: ptr TSelectionData): ptr Gdk3.TAtom {.cdecl, dynlib: lib, importc: "gtk_selection_data_get_data_type".}
proc get_data_type*(self: ptr TSelectionData): ptr Gdk3.TAtom {.inline.} =
  gtk_selection_data_get_data_type(self)
# proc get_data_type*(self: ptr TSelectionData): ptr Gdk3.TAtom {.inline.} =

# gtk_selection_data_get_data_with_length
# flags: {isMethod} container: SelectionData
# need sugar: is method
# arg length: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# return: ARRAY 'string' 'cstring' (diff., need sugar)
proc gtk_selection_data_get_data_with_length(self: ptr TSelectionData, length: ptr int32): cstring {.cdecl, dynlib: lib, importc: "gtk_selection_data_get_data_with_length".}
proc get_data*(self: ptr TSelectionData, length: var int32): string {.inline.} =
  $(gtk_selection_data_get_data_with_length(self, addr(length)))
# tuple-return
# length: var int32
# proc get_data*(self: ptr TSelectionData): string {.inline.} =

# gtk_selection_data_get_display
# flags: {isMethod} container: SelectionData
# need sugar: is method
# return: INTERFACE 'Gdk3.Display' 'TransferNone[Gdk3.TDisplay]' (diff., need sugar)
proc gtk_selection_data_get_display(self: ptr TSelectionData): TransferNone[Gdk3.TDisplay] {.cdecl, dynlib: lib, importc: "gtk_selection_data_get_display".}
proc get_display*(self: ptr TSelectionData): Gdk3.Display {.inline.} =
  wrap(gtk_selection_data_get_display(self))
# proc get_display*(self: ptr TSelectionData): Gdk3.Display {.inline.} =

# gtk_selection_data_get_format
# flags: {isMethod} container: SelectionData
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_selection_data_get_format(self: ptr TSelectionData): int32 {.cdecl, dynlib: lib, importc: "gtk_selection_data_get_format".}
proc get_format*(self: ptr TSelectionData): int32 {.inline.} =
  gtk_selection_data_get_format(self)
# proc get_format*(self: ptr TSelectionData): int32 {.inline.} =

# gtk_selection_data_get_length
# flags: {isMethod} container: SelectionData
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_selection_data_get_length(self: ptr TSelectionData): int32 {.cdecl, dynlib: lib, importc: "gtk_selection_data_get_length".}
proc get_length*(self: ptr TSelectionData): int32 {.inline.} =
  gtk_selection_data_get_length(self)
# proc get_length*(self: ptr TSelectionData): int32 {.inline.} =

# gtk_selection_data_get_pixbuf
# flags: {isMethod} container: SelectionData
# need sugar: is method
# return: INTERFACE 'GdkPixbuf2.Pixbuf' 'TransferFull[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_selection_data_get_pixbuf(self: ptr TSelectionData): TransferFull[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_selection_data_get_pixbuf".}
proc get_pixbuf*(self: ptr TSelectionData): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_selection_data_get_pixbuf(self))
# proc get_pixbuf*(self: ptr TSelectionData): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_selection_data_get_selection
# flags: {isMethod} container: SelectionData
# need sugar: is method
# return: INTERFACE 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom'
proc gtk_selection_data_get_selection(self: ptr TSelectionData): ptr Gdk3.TAtom {.cdecl, dynlib: lib, importc: "gtk_selection_data_get_selection".}
proc get_selection*(self: ptr TSelectionData): ptr Gdk3.TAtom {.inline.} =
  gtk_selection_data_get_selection(self)
# proc get_selection*(self: ptr TSelectionData): ptr Gdk3.TAtom {.inline.} =

# gtk_selection_data_get_target
# flags: {isMethod} container: SelectionData
# need sugar: is method
# return: INTERFACE 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom'
proc gtk_selection_data_get_target(self: ptr TSelectionData): ptr Gdk3.TAtom {.cdecl, dynlib: lib, importc: "gtk_selection_data_get_target".}
proc get_target*(self: ptr TSelectionData): ptr Gdk3.TAtom {.inline.} =
  gtk_selection_data_get_target(self)
# proc get_target*(self: ptr TSelectionData): ptr Gdk3.TAtom {.inline.} =

# gtk_selection_data_get_targets
# flags: {isMethod} container: SelectionData
# need sugar: is method
# arg targets: ARRAY 'var openarray[ptr Gdk3.TAtom]' 'openarray[ptr Gdk3.TAtom]' OUT (diff., need sugar) array lengthArg: 1
# arg n_atoms: INT32 'var int32' 'ptr int32' OUT (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_selection_data_get_targets(self: ptr TSelectionData, targets: openarray[ptr Gdk3.TAtom], n_atoms: ptr int32): bool {.cdecl, dynlib: lib, importc: "gtk_selection_data_get_targets".}
proc get_targets*(self: ptr TSelectionData, targets: var openarray[ptr Gdk3.TAtom], n_atoms: var int32): bool {.inline.} =
  gtk_selection_data_get_targets(self, targets, addr(n_atoms))
# tuple-return
# targets: var openarray[ptr Gdk3.TAtom]
# n_atoms: var int32
# proc get_targets*(self: ptr TSelectionData): bool {.inline.} =

# gtk_selection_data_get_text
# flags: {isMethod} container: SelectionData
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_selection_data_get_text(self: ptr TSelectionData): ucstring {.cdecl, dynlib: lib, importc: "gtk_selection_data_get_text".}
proc get_text*(self: ptr TSelectionData): ucstring {.inline.} =
  gtk_selection_data_get_text(self)
# proc get_text*(self: ptr TSelectionData): ucstring {.inline.} =

# gtk_selection_data_get_uris
# flags: {isMethod} container: SelectionData
# need sugar: is method
# return: ARRAY 'zeroTerminatedArray[ucstring]' 'zeroTerminatedArray[ucstring]'
proc gtk_selection_data_get_uris(self: ptr TSelectionData): zeroTerminatedArray[ucstring] {.cdecl, dynlib: lib, importc: "gtk_selection_data_get_uris".}
proc get_uris*(self: ptr TSelectionData): zeroTerminatedArray[ucstring] {.inline.} =
  gtk_selection_data_get_uris(self)
# proc get_uris*(self: ptr TSelectionData): zeroTerminatedArray[ucstring] {.inline.} =

# gtk_selection_data_set
# flags: {isMethod} container: SelectionData
# need sugar: is method
# arg type: INTERFACE (STRUCT) 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom' IN
# arg format: INT32 'int32' 'int32' IN
# arg data: ARRAY 'string' 'cstring' IN (diff., need sugar) array lengthArg: 3
# arg length: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_selection_data_set(self: ptr TSelectionData, type_x: ptr Gdk3.TAtom, format: int32, data: cstring, length: int32) {.cdecl, dynlib: lib, importc: "gtk_selection_data_set".}
proc set*(self: ptr TSelectionData, type_x: ptr Gdk3.TAtom, format: int32, data: string) {.inline.} =
  gtk_selection_data_set(self, type_x, format, cstring(data), data.len.int32)
# proc set*(self: ptr TSelectionData, type_x: ptr Gdk3.TAtom, format: int32, data: string) {.inline.} =

# gtk_selection_data_set_pixbuf
# flags: {isMethod} container: SelectionData
# need sugar: is method
# arg pixbuf: INTERFACE (OBJECT) 'GdkPixbuf2.Pixbuf' 'ptr GdkPixbuf2.TPixbuf' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_selection_data_set_pixbuf(self: ptr TSelectionData, pixbuf: ptr GdkPixbuf2.TPixbuf): bool {.cdecl, dynlib: lib, importc: "gtk_selection_data_set_pixbuf".}
proc set_pixbuf*(self: ptr TSelectionData, pixbuf: GdkPixbuf2.Pixbuf): bool {.inline.} =
  gtk_selection_data_set_pixbuf(self, pixbuf.getPointer)
# proc set_pixbuf*(self: ptr TSelectionData, pixbuf: GdkPixbuf2.Pixbuf): bool {.inline.} =

# gtk_selection_data_set_text
# flags: {isMethod} container: SelectionData
# need sugar: is method
# arg str: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg len: INT32 'int32' 'int32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_selection_data_set_text(self: ptr TSelectionData, str: ucstring, len: int32): bool {.cdecl, dynlib: lib, importc: "gtk_selection_data_set_text".}
proc set_text*(self: ptr TSelectionData, str: ustring, len: int32): bool {.inline.} =
  gtk_selection_data_set_text(self, ucstring(str), len)
# proc set_text*(self: ptr TSelectionData, str: ustring, len: int32): bool {.inline.} =

# gtk_selection_data_set_uris
# flags: {isMethod} container: SelectionData
# need sugar: is method
# arg uris: ARRAY 'uncheckedArray[ucstring]' 'uncheckedArray[ucstring]' IN array zero-terminated
# return: BOOLEAN 'bool' 'bool'
proc gtk_selection_data_set_uris(self: ptr TSelectionData, uris: uncheckedArray[ucstring]): bool {.cdecl, dynlib: lib, importc: "gtk_selection_data_set_uris".}
proc set_uris*(self: ptr TSelectionData, uris: uncheckedArray[ucstring]): bool {.inline.} =
  gtk_selection_data_set_uris(self, uris)
# proc set_uris*(self: ptr TSelectionData, uris: uncheckedArray[ucstring]): bool {.inline.} =

# gtk_selection_data_targets_include_image
# flags: {isMethod} container: SelectionData
# need sugar: is method
# arg writable: BOOLEAN 'bool' 'bool' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_selection_data_targets_include_image(self: ptr TSelectionData, writable: bool): bool {.cdecl, dynlib: lib, importc: "gtk_selection_data_targets_include_image".}
proc targets_include_image*(self: ptr TSelectionData, writable: bool): bool {.inline.} =
  gtk_selection_data_targets_include_image(self, writable)
# proc targets_include_image*(self: ptr TSelectionData, writable: bool): bool {.inline.} =

# gtk_selection_data_targets_include_rich_text
# flags: {isMethod} container: SelectionData
# need sugar: is method
# arg buffer: INTERFACE (OBJECT) 'TextBuffer' 'ptr TTextBuffer' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_selection_data_targets_include_rich_text(self: ptr TSelectionData, buffer: ptr TTextBuffer): bool {.cdecl, dynlib: lib, importc: "gtk_selection_data_targets_include_rich_text".}
proc targets_include_rich_text*(self: ptr TSelectionData, buffer: TextBuffer): bool {.inline.} =
  gtk_selection_data_targets_include_rich_text(self, buffer.getPointer)
# proc targets_include_rich_text*(self: ptr TSelectionData, buffer: TextBuffer): bool {.inline.} =

# gtk_selection_data_targets_include_text
# flags: {isMethod} container: SelectionData
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_selection_data_targets_include_text(self: ptr TSelectionData): bool {.cdecl, dynlib: lib, importc: "gtk_selection_data_targets_include_text".}
proc targets_include_text*(self: ptr TSelectionData): bool {.inline.} =
  gtk_selection_data_targets_include_text(self)
# proc targets_include_text*(self: ptr TSelectionData): bool {.inline.} =

# gtk_selection_data_targets_include_uri
# flags: {isMethod} container: SelectionData
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_selection_data_targets_include_uri(self: ptr TSelectionData): bool {.cdecl, dynlib: lib, importc: "gtk_selection_data_targets_include_uri".}
proc targets_include_uri*(self: ptr TSelectionData): bool {.inline.} =
  gtk_selection_data_targets_include_uri(self)
# proc targets_include_uri*(self: ptr TSelectionData): bool {.inline.} =

# struct SeparatorClass
# struct SeparatorMenuItemClass
# struct SeparatorPrivate
# struct SeparatorToolItemClass
# struct SeparatorToolItemPrivate
# struct SettingsClass
# struct SettingsPrivate
# struct SettingsValue
# struct SizeGroupClass
# struct SizeGroupPrivate
# struct SpinButtonAccessibleClass
# struct SpinButtonAccessiblePrivate
# struct SpinButtonClass
# struct SpinButtonPrivate
# struct SpinnerAccessibleClass
# struct SpinnerAccessiblePrivate
# struct SpinnerClass
# struct SpinnerPrivate
# struct StackClass
# struct StackSidebarClass
# struct StackSidebarPrivate
# struct StackSwitcherClass
# struct StatusIconClass
# struct StatusIconPrivate
# struct StatusbarAccessibleClass
# struct StatusbarAccessiblePrivate
# struct StatusbarClass
# struct StatusbarPrivate
# struct StockItem
# gtk_stock_item_free
# flags: {isMethod} container: StockItem (deprecated)
# struct StyleClass
# struct StyleContextClass
# struct StyleContextPrivate
# struct StylePropertiesClass
# struct StylePropertiesPrivate
# struct StyleProviderIface
# struct SwitchAccessibleClass
# struct SwitchAccessiblePrivate
# struct SwitchClass
# struct SwitchPrivate
# struct SymbolicColor
# gtk_symbolic_color_new_alpha
# flags: {isConstructor} container: SymbolicColor (deprecated)
# gtk_symbolic_color_new_literal
# flags: {isConstructor} container: SymbolicColor (deprecated)
# gtk_symbolic_color_new_mix
# flags: {isConstructor} container: SymbolicColor (deprecated)
# gtk_symbolic_color_new_name
# flags: {isConstructor} container: SymbolicColor (deprecated)
# gtk_symbolic_color_new_shade
# flags: {isConstructor} container: SymbolicColor (deprecated)
# gtk_symbolic_color_new_win32
# flags: {isConstructor} container: SymbolicColor (deprecated)
# gtk_symbolic_color_ref
# flags: {isMethod} container: SymbolicColor (deprecated)
# gtk_symbolic_color_resolve
# flags: {isMethod} container: SymbolicColor (deprecated)
# gtk_symbolic_color_to_string
# flags: {isMethod} container: SymbolicColor (deprecated)
# gtk_symbolic_color_unref
# flags: {isMethod} container: SymbolicColor (deprecated)
# struct TableChild
# struct TableClass
# struct TablePrivate
# struct TableRowCol
# struct TargetEntry
# gtk_target_entry_new
# flags: {isConstructor} container: TargetEntry
# need sugar: is static method
# arg target: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg flags: UINT32 'uint32' 'uint32' IN
# arg info: UINT32 'uint32' 'uint32' IN
# return: INTERFACE 'ptr TTargetEntry' 'ptr TTargetEntry'
proc gtk_target_entry_new(target: ucstring, flags: uint32, info: uint32): ptr TTargetEntry {.cdecl, dynlib: lib, importc: "gtk_target_entry_new".}
proc new_targetentry*(target: ustring, flags: uint32, info: uint32): ptr TTargetEntry {.inline.} =
  gtk_target_entry_new(ucstring(target), flags, info)
# proc new_targetentry*(target: ustring, flags: uint32, info: uint32): ptr TTargetEntry {.inline.} =

# gtk_target_entry_copy
# flags: {isMethod} container: TargetEntry
# need sugar: is method
# return: INTERFACE 'ptr TTargetEntry' 'ptr TTargetEntry'
proc gtk_target_entry_copy(self: ptr TTargetEntry): ptr TTargetEntry {.cdecl, dynlib: lib, importc: "gtk_target_entry_copy".}
proc copy*(self: ptr TTargetEntry): ptr TTargetEntry {.inline.} =
  gtk_target_entry_copy(self)
# proc copy*(self: ptr TTargetEntry): ptr TTargetEntry {.inline.} =

# gtk_target_entry_free
# flags: {isMethod} container: TargetEntry
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_target_entry_free(self: ptr TTargetEntry) {.cdecl, dynlib: lib, importc: "gtk_target_entry_free".}
proc free*(self: ptr TTargetEntry) {.inline.} =
  gtk_target_entry_free(self)
# proc free*(self: ptr TTargetEntry) {.inline.} =

# struct TargetList
# gtk_target_list_new
# flags: {isConstructor} container: TargetList
# need sugar: is static method
# arg targets: ARRAY 'var openarray[TTargetEntry]' 'openarray[TTargetEntry]' IN (diff., need sugar) array lengthArg: 1
# arg ntargets: UINT32 'uint32' 'uint32' IN
# return: INTERFACE 'ptr TTargetList' 'ptr TTargetList'
proc gtk_target_list_new(targets: openarray[TTargetEntry], ntargets: uint32): ptr TTargetList {.cdecl, dynlib: lib, importc: "gtk_target_list_new".}
proc new_targetlist*(targets: var openarray[TTargetEntry]): ptr TTargetList {.inline.} =
  gtk_target_list_new(targets, targets.len.uint32)
# proc new_targetlist*(targets: var openarray[TTargetEntry]): ptr TTargetList {.inline.} =

# gtk_target_list_add
# flags: {isMethod} container: TargetList
# need sugar: is method
# arg target: INTERFACE (STRUCT) 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom' IN
# arg flags: UINT32 'uint32' 'uint32' IN
# arg info: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_target_list_add(self: ptr TTargetList, target: ptr Gdk3.TAtom, flags: uint32, info: uint32) {.cdecl, dynlib: lib, importc: "gtk_target_list_add".}
proc add*(self: ptr TTargetList, target: ptr Gdk3.TAtom, flags: uint32, info: uint32) {.inline.} =
  gtk_target_list_add(self, target, flags, info)
# proc add*(self: ptr TTargetList, target: ptr Gdk3.TAtom, flags: uint32, info: uint32) {.inline.} =

# gtk_target_list_add_image_targets
# flags: {isMethod} container: TargetList
# need sugar: is method
# arg info: UINT32 'uint32' 'uint32' IN
# arg writable: BOOLEAN 'bool' 'bool' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_target_list_add_image_targets(self: ptr TTargetList, info: uint32, writable: bool) {.cdecl, dynlib: lib, importc: "gtk_target_list_add_image_targets".}
proc add_image_targets*(self: ptr TTargetList, info: uint32, writable: bool) {.inline.} =
  gtk_target_list_add_image_targets(self, info, writable)
# proc add_image_targets*(self: ptr TTargetList, info: uint32, writable: bool) {.inline.} =

# gtk_target_list_add_rich_text_targets
# flags: {isMethod} container: TargetList
# need sugar: is method
# arg info: UINT32 'uint32' 'uint32' IN
# arg deserializable: BOOLEAN 'bool' 'bool' IN
# arg buffer: INTERFACE (OBJECT) 'TextBuffer' 'ptr TTextBuffer' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_target_list_add_rich_text_targets(self: ptr TTargetList, info: uint32, deserializable: bool, buffer: ptr TTextBuffer) {.cdecl, dynlib: lib, importc: "gtk_target_list_add_rich_text_targets".}
proc add_rich_text_targets*(self: ptr TTargetList, info: uint32, deserializable: bool, buffer: TextBuffer) {.inline.} =
  gtk_target_list_add_rich_text_targets(self, info, deserializable, buffer.getPointer)
# proc add_rich_text_targets*(self: ptr TTargetList, info: uint32, deserializable: bool, buffer: TextBuffer) {.inline.} =

# gtk_target_list_add_table
# flags: {isMethod} container: TargetList
# need sugar: is method
# arg targets: ARRAY 'var openarray[TTargetEntry]' 'openarray[TTargetEntry]' IN (diff., need sugar) array lengthArg: 1
# arg ntargets: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_target_list_add_table(self: ptr TTargetList, targets: openarray[TTargetEntry], ntargets: uint32) {.cdecl, dynlib: lib, importc: "gtk_target_list_add_table".}
proc add_table*(self: ptr TTargetList, targets: var openarray[TTargetEntry]) {.inline.} =
  gtk_target_list_add_table(self, targets, targets.len.uint32)
# proc add_table*(self: ptr TTargetList, targets: var openarray[TTargetEntry]) {.inline.} =

# gtk_target_list_add_text_targets
# flags: {isMethod} container: TargetList
# need sugar: is method
# arg info: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_target_list_add_text_targets(self: ptr TTargetList, info: uint32) {.cdecl, dynlib: lib, importc: "gtk_target_list_add_text_targets".}
proc add_text_targets*(self: ptr TTargetList, info: uint32) {.inline.} =
  gtk_target_list_add_text_targets(self, info)
# proc add_text_targets*(self: ptr TTargetList, info: uint32) {.inline.} =

# gtk_target_list_add_uri_targets
# flags: {isMethod} container: TargetList
# need sugar: is method
# arg info: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_target_list_add_uri_targets(self: ptr TTargetList, info: uint32) {.cdecl, dynlib: lib, importc: "gtk_target_list_add_uri_targets".}
proc add_uri_targets*(self: ptr TTargetList, info: uint32) {.inline.} =
  gtk_target_list_add_uri_targets(self, info)
# proc add_uri_targets*(self: ptr TTargetList, info: uint32) {.inline.} =

# gtk_target_list_find
# flags: {isMethod} container: TargetList
# need sugar: is method
# arg target: INTERFACE (STRUCT) 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom' IN
# arg info: UINT32 'var uint32' 'ptr uint32' OUT (diff., need sugar) optional
# return: BOOLEAN 'bool' 'bool'
proc gtk_target_list_find(self: ptr TTargetList, target: ptr Gdk3.TAtom, info: ptr uint32): bool {.cdecl, dynlib: lib, importc: "gtk_target_list_find".}
proc find*(self: ptr TTargetList, target: ptr Gdk3.TAtom, info: var uint32): bool {.inline.} =
  gtk_target_list_find(self, target, addr(info))
# tuple-return
# info: var uint32
# proc find*(self: ptr TTargetList, target: ptr Gdk3.TAtom): bool {.inline.} =

# gtk_target_list_ref
# flags: {isMethod} container: TargetList
# need sugar: is method
# return: INTERFACE 'ptr TTargetList' 'ptr TTargetList'
proc gtk_target_list_ref(self: ptr TTargetList): ptr TTargetList {.cdecl, dynlib: lib, importc: "gtk_target_list_ref".}
proc ref_x*(self: ptr TTargetList): ptr TTargetList {.inline.} =
  gtk_target_list_ref(self)
# proc ref_x*(self: ptr TTargetList): ptr TTargetList {.inline.} =

# gtk_target_list_remove
# flags: {isMethod} container: TargetList
# need sugar: is method
# arg target: INTERFACE (STRUCT) 'ptr Gdk3.TAtom' 'ptr Gdk3.TAtom' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_target_list_remove(self: ptr TTargetList, target: ptr Gdk3.TAtom) {.cdecl, dynlib: lib, importc: "gtk_target_list_remove".}
proc remove*(self: ptr TTargetList, target: ptr Gdk3.TAtom) {.inline.} =
  gtk_target_list_remove(self, target)
# proc remove*(self: ptr TTargetList, target: ptr Gdk3.TAtom) {.inline.} =

# gtk_target_list_unref
# flags: {isMethod} container: TargetList
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_target_list_unref(self: ptr TTargetList) {.cdecl, dynlib: lib, importc: "gtk_target_list_unref".}
proc unref*(self: ptr TTargetList) {.inline.} =
  gtk_target_list_unref(self)
# proc unref*(self: ptr TTargetList) {.inline.} =

# struct TargetPair
# struct TearoffMenuItemClass
# struct TearoffMenuItemPrivate
# struct TextAppearance
# struct TextAttributes
# gtk_text_attributes_new
# flags: {isConstructor} container: TextAttributes
# need sugar: is static method
# return: INTERFACE 'ptr TTextAttributes' 'ptr TTextAttributes'
proc gtk_text_attributes_new(): ptr TTextAttributes {.cdecl, dynlib: lib, importc: "gtk_text_attributes_new".}
proc new_textattributes*(): ptr TTextAttributes {.inline.} =
  gtk_text_attributes_new()
# proc new_textattributes*(): ptr TTextAttributes {.inline.} =

# gtk_text_attributes_copy
# flags: {isMethod} container: TextAttributes
# need sugar: is method
# return: INTERFACE 'ptr TTextAttributes' 'ptr TTextAttributes'
proc gtk_text_attributes_copy(self: ptr TTextAttributes): ptr TTextAttributes {.cdecl, dynlib: lib, importc: "gtk_text_attributes_copy".}
proc copy*(self: ptr TTextAttributes): ptr TTextAttributes {.inline.} =
  gtk_text_attributes_copy(self)
# proc copy*(self: ptr TTextAttributes): ptr TTextAttributes {.inline.} =

# gtk_text_attributes_copy_values
# flags: {isMethod} container: TextAttributes
# need sugar: is method
# arg dest: INTERFACE (STRUCT) 'ptr TTextAttributes' 'ptr TTextAttributes' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_attributes_copy_values(self: ptr TTextAttributes, dest: ptr TTextAttributes) {.cdecl, dynlib: lib, importc: "gtk_text_attributes_copy_values".}
proc copy_values*(self: ptr TTextAttributes, dest: ptr TTextAttributes) {.inline.} =
  gtk_text_attributes_copy_values(self, dest)
# proc copy_values*(self: ptr TTextAttributes, dest: ptr TTextAttributes) {.inline.} =

# gtk_text_attributes_ref
# flags: {isMethod} container: TextAttributes
# need sugar: is method
# return: INTERFACE 'ptr TTextAttributes' 'ptr TTextAttributes'
proc gtk_text_attributes_ref(self: ptr TTextAttributes): ptr TTextAttributes {.cdecl, dynlib: lib, importc: "gtk_text_attributes_ref".}
proc ref_x*(self: ptr TTextAttributes): ptr TTextAttributes {.inline.} =
  gtk_text_attributes_ref(self)
# proc ref_x*(self: ptr TTextAttributes): ptr TTextAttributes {.inline.} =

# gtk_text_attributes_unref
# flags: {isMethod} container: TextAttributes
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_attributes_unref(self: ptr TTextAttributes) {.cdecl, dynlib: lib, importc: "gtk_text_attributes_unref".}
proc unref*(self: ptr TTextAttributes) {.inline.} =
  gtk_text_attributes_unref(self)
# proc unref*(self: ptr TTextAttributes) {.inline.} =

# struct TextBTree
# struct TextBufferClass
# struct TextBufferPrivate
# struct TextCellAccessibleClass
# struct TextCellAccessiblePrivate
# struct TextChildAnchorClass
# struct TextIter
# gtk_text_iter_assign
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg other: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_iter_assign(self: ptr TTextIter, other: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_iter_assign".}
proc assign*(self: ptr TTextIter, other: ptr TTextIter) {.inline.} =
  gtk_text_iter_assign(self, other)
# proc assign*(self: ptr TTextIter, other: ptr TTextIter) {.inline.} =

# gtk_text_iter_backward_char
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_backward_char(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_char".}
proc backward_char*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_backward_char(self)
# proc backward_char*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_backward_chars
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg count: INT32 'int32' 'int32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_backward_chars(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_chars".}
proc backward_chars*(self: ptr TTextIter, count: int32): bool {.inline.} =
  gtk_text_iter_backward_chars(self, count)
# proc backward_chars*(self: ptr TTextIter, count: int32): bool {.inline.} =

# gtk_text_iter_backward_cursor_position
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_backward_cursor_position(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_cursor_position".}
proc backward_cursor_position*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_backward_cursor_position(self)
# proc backward_cursor_position*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_backward_cursor_positions
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg count: INT32 'int32' 'int32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_backward_cursor_positions(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_cursor_positions".}
proc backward_cursor_positions*(self: ptr TTextIter, count: int32): bool {.inline.} =
  gtk_text_iter_backward_cursor_positions(self, count)
# proc backward_cursor_positions*(self: ptr TTextIter, count: int32): bool {.inline.} =

# gtk_text_iter_backward_find_char
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg pred: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg user_data: VOID 'pointer' 'pointer' IN
# arg limit: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_backward_find_char(self: ptr TTextIter, pred: pointer, user_data: pointer, limit: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_find_char".}
proc backward_find_char*(self: ptr TTextIter, pred: pointer, user_data: pointer, limit: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_backward_find_char(self, pred, user_data, limit)
# proc backward_find_char*(self: ptr TTextIter, pred: pointer, user_data: pointer, limit: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_backward_line
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_backward_line(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_line".}
proc backward_line*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_backward_line(self)
# proc backward_line*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_backward_lines
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg count: INT32 'int32' 'int32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_backward_lines(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_lines".}
proc backward_lines*(self: ptr TTextIter, count: int32): bool {.inline.} =
  gtk_text_iter_backward_lines(self, count)
# proc backward_lines*(self: ptr TTextIter, count: int32): bool {.inline.} =

# gtk_text_iter_backward_search
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg str: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg flags: INTERFACE (FLAGS) 'STextSearchFlags' 'STextSearchFlags' IN
# arg match_start: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' OUT caller-allocates optional
# arg match_end: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' OUT caller-allocates optional
# arg limit: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_backward_search(self: ptr TTextIter, str: ucstring, flags: STextSearchFlags, match_start: ptr TTextIter, match_end: ptr TTextIter, limit: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_search".}
proc backward_search*(self: ptr TTextIter, str: ustring, flags: STextSearchFlags, match_start: ptr TTextIter, match_end: ptr TTextIter, limit: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_backward_search(self, ucstring(str), flags, match_start, match_end, limit)
# tuple-return
# match_start: ptr TTextIter
# match_end: ptr TTextIter
# proc backward_search*(self: ptr TTextIter, str: ustring, flags: STextSearchFlags, limit: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_backward_sentence_start
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_backward_sentence_start(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_sentence_start".}
proc backward_sentence_start*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_backward_sentence_start(self)
# proc backward_sentence_start*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_backward_sentence_starts
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg count: INT32 'int32' 'int32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_backward_sentence_starts(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_sentence_starts".}
proc backward_sentence_starts*(self: ptr TTextIter, count: int32): bool {.inline.} =
  gtk_text_iter_backward_sentence_starts(self, count)
# proc backward_sentence_starts*(self: ptr TTextIter, count: int32): bool {.inline.} =

# gtk_text_iter_backward_to_tag_toggle
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg tag: INTERFACE (OBJECT) 'TextTag' 'ptr TTextTag' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_backward_to_tag_toggle(self: ptr TTextIter, tag: ptr TTextTag): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_to_tag_toggle".}
proc backward_to_tag_toggle*(self: ptr TTextIter, tag: TextTag): bool {.inline.} =
  gtk_text_iter_backward_to_tag_toggle(self, tag.getPointer)
# proc backward_to_tag_toggle*(self: ptr TTextIter, tag: TextTag): bool {.inline.} =

# gtk_text_iter_backward_visible_cursor_position
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_backward_visible_cursor_position(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_visible_cursor_position".}
proc backward_visible_cursor_position*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_backward_visible_cursor_position(self)
# proc backward_visible_cursor_position*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_backward_visible_cursor_positions
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg count: INT32 'int32' 'int32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_backward_visible_cursor_positions(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_visible_cursor_positions".}
proc backward_visible_cursor_positions*(self: ptr TTextIter, count: int32): bool {.inline.} =
  gtk_text_iter_backward_visible_cursor_positions(self, count)
# proc backward_visible_cursor_positions*(self: ptr TTextIter, count: int32): bool {.inline.} =

# gtk_text_iter_backward_visible_line
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_backward_visible_line(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_visible_line".}
proc backward_visible_line*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_backward_visible_line(self)
# proc backward_visible_line*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_backward_visible_lines
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg count: INT32 'int32' 'int32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_backward_visible_lines(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_visible_lines".}
proc backward_visible_lines*(self: ptr TTextIter, count: int32): bool {.inline.} =
  gtk_text_iter_backward_visible_lines(self, count)
# proc backward_visible_lines*(self: ptr TTextIter, count: int32): bool {.inline.} =

# gtk_text_iter_backward_visible_word_start
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_backward_visible_word_start(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_visible_word_start".}
proc backward_visible_word_start*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_backward_visible_word_start(self)
# proc backward_visible_word_start*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_backward_visible_word_starts
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg count: INT32 'int32' 'int32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_backward_visible_word_starts(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_visible_word_starts".}
proc backward_visible_word_starts*(self: ptr TTextIter, count: int32): bool {.inline.} =
  gtk_text_iter_backward_visible_word_starts(self, count)
# proc backward_visible_word_starts*(self: ptr TTextIter, count: int32): bool {.inline.} =

# gtk_text_iter_backward_word_start
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_backward_word_start(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_word_start".}
proc backward_word_start*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_backward_word_start(self)
# proc backward_word_start*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_backward_word_starts
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg count: INT32 'int32' 'int32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_backward_word_starts(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_backward_word_starts".}
proc backward_word_starts*(self: ptr TTextIter, count: int32): bool {.inline.} =
  gtk_text_iter_backward_word_starts(self, count)
# proc backward_word_starts*(self: ptr TTextIter, count: int32): bool {.inline.} =

# gtk_text_iter_begins_tag
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg tag: INTERFACE (OBJECT) 'TextTag' 'ptr TTextTag' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_begins_tag(self: ptr TTextIter, tag: ptr TTextTag): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_begins_tag".}
proc begins_tag*(self: ptr TTextIter, tag: TextTag): bool {.inline.} =
  gtk_text_iter_begins_tag(self, tag.getPointer)
# proc begins_tag*(self: ptr TTextIter, tag: TextTag): bool {.inline.} =

# gtk_text_iter_can_insert
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg default_editability: BOOLEAN 'bool' 'bool' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_can_insert(self: ptr TTextIter, default_editability: bool): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_can_insert".}
proc can_insert*(self: ptr TTextIter, default_editability: bool): bool {.inline.} =
  gtk_text_iter_can_insert(self, default_editability)
# proc can_insert*(self: ptr TTextIter, default_editability: bool): bool {.inline.} =

# gtk_text_iter_compare
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg rhs: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: INT32 'int32' 'int32'
proc gtk_text_iter_compare(self: ptr TTextIter, rhs: ptr TTextIter): int32 {.cdecl, dynlib: lib, importc: "gtk_text_iter_compare".}
proc compare*(self: ptr TTextIter, rhs: ptr TTextIter): int32 {.inline.} =
  gtk_text_iter_compare(self, rhs)
# proc compare*(self: ptr TTextIter, rhs: ptr TTextIter): int32 {.inline.} =

# gtk_text_iter_copy
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: INTERFACE 'ptr TTextIter' 'ptr TTextIter'
proc gtk_text_iter_copy(self: ptr TTextIter): ptr TTextIter {.cdecl, dynlib: lib, importc: "gtk_text_iter_copy".}
proc copy*(self: ptr TTextIter): ptr TTextIter {.inline.} =
  gtk_text_iter_copy(self)
# proc copy*(self: ptr TTextIter): ptr TTextIter {.inline.} =

# gtk_text_iter_editable
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg default_setting: BOOLEAN 'bool' 'bool' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_editable(self: ptr TTextIter, default_setting: bool): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_editable".}
proc editable*(self: ptr TTextIter, default_setting: bool): bool {.inline.} =
  gtk_text_iter_editable(self, default_setting)
# proc editable*(self: ptr TTextIter, default_setting: bool): bool {.inline.} =

# gtk_text_iter_ends_line
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_ends_line(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_ends_line".}
proc ends_line*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_ends_line(self)
# proc ends_line*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_ends_sentence
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_ends_sentence(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_ends_sentence".}
proc ends_sentence*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_ends_sentence(self)
# proc ends_sentence*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_ends_tag
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg tag: INTERFACE (OBJECT) 'TextTag' 'ptr TTextTag' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_ends_tag(self: ptr TTextIter, tag: ptr TTextTag): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_ends_tag".}
proc ends_tag*(self: ptr TTextIter, tag: TextTag): bool {.inline.} =
  gtk_text_iter_ends_tag(self, tag.getPointer)
# proc ends_tag*(self: ptr TTextIter, tag: TextTag): bool {.inline.} =

# gtk_text_iter_ends_word
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_ends_word(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_ends_word".}
proc ends_word*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_ends_word(self)
# proc ends_word*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_equal
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg rhs: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_equal(self: ptr TTextIter, rhs: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_equal".}
proc equal*(self: ptr TTextIter, rhs: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_equal(self, rhs)
# proc equal*(self: ptr TTextIter, rhs: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_forward_char
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_forward_char(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_char".}
proc forward_char*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_forward_char(self)
# proc forward_char*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_forward_chars
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg count: INT32 'int32' 'int32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_forward_chars(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_chars".}
proc forward_chars*(self: ptr TTextIter, count: int32): bool {.inline.} =
  gtk_text_iter_forward_chars(self, count)
# proc forward_chars*(self: ptr TTextIter, count: int32): bool {.inline.} =

# gtk_text_iter_forward_cursor_position
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_forward_cursor_position(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_cursor_position".}
proc forward_cursor_position*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_forward_cursor_position(self)
# proc forward_cursor_position*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_forward_cursor_positions
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg count: INT32 'int32' 'int32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_forward_cursor_positions(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_cursor_positions".}
proc forward_cursor_positions*(self: ptr TTextIter, count: int32): bool {.inline.} =
  gtk_text_iter_forward_cursor_positions(self, count)
# proc forward_cursor_positions*(self: ptr TTextIter, count: int32): bool {.inline.} =

# gtk_text_iter_forward_find_char
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg pred: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg user_data: VOID 'pointer' 'pointer' IN
# arg limit: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_forward_find_char(self: ptr TTextIter, pred: pointer, user_data: pointer, limit: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_find_char".}
proc forward_find_char*(self: ptr TTextIter, pred: pointer, user_data: pointer, limit: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_forward_find_char(self, pred, user_data, limit)
# proc forward_find_char*(self: ptr TTextIter, pred: pointer, user_data: pointer, limit: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_forward_line
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_forward_line(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_line".}
proc forward_line*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_forward_line(self)
# proc forward_line*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_forward_lines
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg count: INT32 'int32' 'int32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_forward_lines(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_lines".}
proc forward_lines*(self: ptr TTextIter, count: int32): bool {.inline.} =
  gtk_text_iter_forward_lines(self, count)
# proc forward_lines*(self: ptr TTextIter, count: int32): bool {.inline.} =

# gtk_text_iter_forward_search
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg str: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg flags: INTERFACE (FLAGS) 'STextSearchFlags' 'STextSearchFlags' IN
# arg match_start: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' OUT caller-allocates optional
# arg match_end: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' OUT caller-allocates optional
# arg limit: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_forward_search(self: ptr TTextIter, str: ucstring, flags: STextSearchFlags, match_start: ptr TTextIter, match_end: ptr TTextIter, limit: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_search".}
proc forward_search*(self: ptr TTextIter, str: ustring, flags: STextSearchFlags, match_start: ptr TTextIter, match_end: ptr TTextIter, limit: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_forward_search(self, ucstring(str), flags, match_start, match_end, limit)
# tuple-return
# match_start: ptr TTextIter
# match_end: ptr TTextIter
# proc forward_search*(self: ptr TTextIter, str: ustring, flags: STextSearchFlags, limit: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_forward_sentence_end
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_forward_sentence_end(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_sentence_end".}
proc forward_sentence_end*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_forward_sentence_end(self)
# proc forward_sentence_end*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_forward_sentence_ends
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg count: INT32 'int32' 'int32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_forward_sentence_ends(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_sentence_ends".}
proc forward_sentence_ends*(self: ptr TTextIter, count: int32): bool {.inline.} =
  gtk_text_iter_forward_sentence_ends(self, count)
# proc forward_sentence_ends*(self: ptr TTextIter, count: int32): bool {.inline.} =

# gtk_text_iter_forward_to_end
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_iter_forward_to_end(self: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_to_end".}
proc forward_to_end*(self: ptr TTextIter) {.inline.} =
  gtk_text_iter_forward_to_end(self)
# proc forward_to_end*(self: ptr TTextIter) {.inline.} =

# gtk_text_iter_forward_to_line_end
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_forward_to_line_end(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_to_line_end".}
proc forward_to_line_end*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_forward_to_line_end(self)
# proc forward_to_line_end*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_forward_to_tag_toggle
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg tag: INTERFACE (OBJECT) 'TextTag' 'ptr TTextTag' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_forward_to_tag_toggle(self: ptr TTextIter, tag: ptr TTextTag): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_to_tag_toggle".}
proc forward_to_tag_toggle*(self: ptr TTextIter, tag: TextTag): bool {.inline.} =
  gtk_text_iter_forward_to_tag_toggle(self, tag.getPointer)
# proc forward_to_tag_toggle*(self: ptr TTextIter, tag: TextTag): bool {.inline.} =

# gtk_text_iter_forward_visible_cursor_position
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_forward_visible_cursor_position(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_visible_cursor_position".}
proc forward_visible_cursor_position*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_forward_visible_cursor_position(self)
# proc forward_visible_cursor_position*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_forward_visible_cursor_positions
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg count: INT32 'int32' 'int32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_forward_visible_cursor_positions(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_visible_cursor_positions".}
proc forward_visible_cursor_positions*(self: ptr TTextIter, count: int32): bool {.inline.} =
  gtk_text_iter_forward_visible_cursor_positions(self, count)
# proc forward_visible_cursor_positions*(self: ptr TTextIter, count: int32): bool {.inline.} =

# gtk_text_iter_forward_visible_line
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_forward_visible_line(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_visible_line".}
proc forward_visible_line*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_forward_visible_line(self)
# proc forward_visible_line*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_forward_visible_lines
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg count: INT32 'int32' 'int32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_forward_visible_lines(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_visible_lines".}
proc forward_visible_lines*(self: ptr TTextIter, count: int32): bool {.inline.} =
  gtk_text_iter_forward_visible_lines(self, count)
# proc forward_visible_lines*(self: ptr TTextIter, count: int32): bool {.inline.} =

# gtk_text_iter_forward_visible_word_end
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_forward_visible_word_end(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_visible_word_end".}
proc forward_visible_word_end*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_forward_visible_word_end(self)
# proc forward_visible_word_end*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_forward_visible_word_ends
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg count: INT32 'int32' 'int32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_forward_visible_word_ends(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_visible_word_ends".}
proc forward_visible_word_ends*(self: ptr TTextIter, count: int32): bool {.inline.} =
  gtk_text_iter_forward_visible_word_ends(self, count)
# proc forward_visible_word_ends*(self: ptr TTextIter, count: int32): bool {.inline.} =

# gtk_text_iter_forward_word_end
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_forward_word_end(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_word_end".}
proc forward_word_end*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_forward_word_end(self)
# proc forward_word_end*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_forward_word_ends
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg count: INT32 'int32' 'int32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_forward_word_ends(self: ptr TTextIter, count: int32): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_forward_word_ends".}
proc forward_word_ends*(self: ptr TTextIter, count: int32): bool {.inline.} =
  gtk_text_iter_forward_word_ends(self, count)
# proc forward_word_ends*(self: ptr TTextIter, count: int32): bool {.inline.} =

# gtk_text_iter_free
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_iter_free(self: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_iter_free".}
proc free*(self: ptr TTextIter) {.inline.} =
  gtk_text_iter_free(self)
# proc free*(self: ptr TTextIter) {.inline.} =

# gtk_text_iter_get_attributes
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg values: INTERFACE (STRUCT) 'ptr TTextAttributes' 'ptr TTextAttributes' OUT caller-allocates
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_get_attributes(self: ptr TTextIter, values: ptr TTextAttributes): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_attributes".}
proc get_attributes*(self: ptr TTextIter, values: ptr TTextAttributes): bool {.inline.} =
  gtk_text_iter_get_attributes(self, values)
# tuple-return
# values: ptr TTextAttributes
# proc get_attributes*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_get_buffer
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: INTERFACE 'TextBuffer' 'TransferNone[TTextBuffer]' (diff., need sugar)
proc gtk_text_iter_get_buffer(self: ptr TTextIter): TransferNone[TTextBuffer] {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_buffer".}
proc get_buffer*(self: ptr TTextIter): TextBuffer {.inline.} =
  wrap(gtk_text_iter_get_buffer(self))
# proc get_buffer*(self: ptr TTextIter): TextBuffer {.inline.} =

# gtk_text_iter_get_bytes_in_line
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_text_iter_get_bytes_in_line(self: ptr TTextIter): int32 {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_bytes_in_line".}
proc get_bytes_in_line*(self: ptr TTextIter): int32 {.inline.} =
  gtk_text_iter_get_bytes_in_line(self)
# proc get_bytes_in_line*(self: ptr TTextIter): int32 {.inline.} =

# gtk_text_iter_get_char
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: UNICHAR 'unichar' 'unichar'
proc gtk_text_iter_get_char(self: ptr TTextIter): unichar {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_char".}
proc get_char*(self: ptr TTextIter): unichar {.inline.} =
  gtk_text_iter_get_char(self)
# proc get_char*(self: ptr TTextIter): unichar {.inline.} =

# gtk_text_iter_get_chars_in_line
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_text_iter_get_chars_in_line(self: ptr TTextIter): int32 {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_chars_in_line".}
proc get_chars_in_line*(self: ptr TTextIter): int32 {.inline.} =
  gtk_text_iter_get_chars_in_line(self)
# proc get_chars_in_line*(self: ptr TTextIter): int32 {.inline.} =

# gtk_text_iter_get_child_anchor
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: INTERFACE 'TextChildAnchor' 'TransferNone[TTextChildAnchor]' (diff., need sugar)
proc gtk_text_iter_get_child_anchor(self: ptr TTextIter): TransferNone[TTextChildAnchor] {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_child_anchor".}
proc get_child_anchor*(self: ptr TTextIter): TextChildAnchor {.inline.} =
  wrap(gtk_text_iter_get_child_anchor(self))
# proc get_child_anchor*(self: ptr TTextIter): TextChildAnchor {.inline.} =

# gtk_text_iter_get_language
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: INTERFACE 'ptr Pango1.TLanguage' 'ptr Pango1.TLanguage'
proc gtk_text_iter_get_language(self: ptr TTextIter): ptr Pango1.TLanguage {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_language".}
proc get_language*(self: ptr TTextIter): ptr Pango1.TLanguage {.inline.} =
  gtk_text_iter_get_language(self)
# proc get_language*(self: ptr TTextIter): ptr Pango1.TLanguage {.inline.} =

# gtk_text_iter_get_line
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_text_iter_get_line(self: ptr TTextIter): int32 {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_line".}
proc get_line*(self: ptr TTextIter): int32 {.inline.} =
  gtk_text_iter_get_line(self)
# proc get_line*(self: ptr TTextIter): int32 {.inline.} =

# gtk_text_iter_get_line_index
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_text_iter_get_line_index(self: ptr TTextIter): int32 {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_line_index".}
proc get_line_index*(self: ptr TTextIter): int32 {.inline.} =
  gtk_text_iter_get_line_index(self)
# proc get_line_index*(self: ptr TTextIter): int32 {.inline.} =

# gtk_text_iter_get_line_offset
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_text_iter_get_line_offset(self: ptr TTextIter): int32 {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_line_offset".}
proc get_line_offset*(self: ptr TTextIter): int32 {.inline.} =
  gtk_text_iter_get_line_offset(self)
# proc get_line_offset*(self: ptr TTextIter): int32 {.inline.} =

# gtk_text_iter_get_marks
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: GSLIST 'ptr GSLIST_TODO' 'ptr GSLIST_TODO'
proc gtk_text_iter_get_marks(self: ptr TTextIter): ptr GSLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_marks".}
proc get_marks*(self: ptr TTextIter): ptr GSLIST_TODO {.inline.} =
  gtk_text_iter_get_marks(self)
# proc get_marks*(self: ptr TTextIter): ptr GSLIST_TODO {.inline.} =

# gtk_text_iter_get_offset
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_text_iter_get_offset(self: ptr TTextIter): int32 {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_offset".}
proc get_offset*(self: ptr TTextIter): int32 {.inline.} =
  gtk_text_iter_get_offset(self)
# proc get_offset*(self: ptr TTextIter): int32 {.inline.} =

# gtk_text_iter_get_pixbuf
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: INTERFACE 'GdkPixbuf2.Pixbuf' 'TransferNone[GdkPixbuf2.TPixbuf]' (diff., need sugar)
proc gtk_text_iter_get_pixbuf(self: ptr TTextIter): TransferNone[GdkPixbuf2.TPixbuf] {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_pixbuf".}
proc get_pixbuf*(self: ptr TTextIter): GdkPixbuf2.Pixbuf {.inline.} =
  wrap(gtk_text_iter_get_pixbuf(self))
# proc get_pixbuf*(self: ptr TTextIter): GdkPixbuf2.Pixbuf {.inline.} =

# gtk_text_iter_get_slice
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg end: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: UTF8 'ucstring' 'ucstring'
proc gtk_text_iter_get_slice(self: ptr TTextIter, end_x: ptr TTextIter): ucstring {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_slice".}
proc get_slice*(self: ptr TTextIter, end_x: ptr TTextIter): ucstring {.inline.} =
  gtk_text_iter_get_slice(self, end_x)
# proc get_slice*(self: ptr TTextIter, end_x: ptr TTextIter): ucstring {.inline.} =

# gtk_text_iter_get_tags
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: GSLIST 'ptr GSLIST_TODO' 'ptr GSLIST_TODO'
proc gtk_text_iter_get_tags(self: ptr TTextIter): ptr GSLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_tags".}
proc get_tags*(self: ptr TTextIter): ptr GSLIST_TODO {.inline.} =
  gtk_text_iter_get_tags(self)
# proc get_tags*(self: ptr TTextIter): ptr GSLIST_TODO {.inline.} =

# gtk_text_iter_get_text
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg end: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: UTF8 'ucstring' 'ucstring'
proc gtk_text_iter_get_text(self: ptr TTextIter, end_x: ptr TTextIter): ucstring {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_text".}
proc get_text*(self: ptr TTextIter, end_x: ptr TTextIter): ucstring {.inline.} =
  gtk_text_iter_get_text(self, end_x)
# proc get_text*(self: ptr TTextIter, end_x: ptr TTextIter): ucstring {.inline.} =

# gtk_text_iter_get_toggled_tags
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg toggled_on: BOOLEAN 'bool' 'bool' IN
# return: GSLIST 'ptr GSLIST_TODO' 'ptr GSLIST_TODO'
proc gtk_text_iter_get_toggled_tags(self: ptr TTextIter, toggled_on: bool): ptr GSLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_toggled_tags".}
proc get_toggled_tags*(self: ptr TTextIter, toggled_on: bool): ptr GSLIST_TODO {.inline.} =
  gtk_text_iter_get_toggled_tags(self, toggled_on)
# proc get_toggled_tags*(self: ptr TTextIter, toggled_on: bool): ptr GSLIST_TODO {.inline.} =

# gtk_text_iter_get_visible_line_index
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_text_iter_get_visible_line_index(self: ptr TTextIter): int32 {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_visible_line_index".}
proc get_visible_line_index*(self: ptr TTextIter): int32 {.inline.} =
  gtk_text_iter_get_visible_line_index(self)
# proc get_visible_line_index*(self: ptr TTextIter): int32 {.inline.} =

# gtk_text_iter_get_visible_line_offset
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_text_iter_get_visible_line_offset(self: ptr TTextIter): int32 {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_visible_line_offset".}
proc get_visible_line_offset*(self: ptr TTextIter): int32 {.inline.} =
  gtk_text_iter_get_visible_line_offset(self)
# proc get_visible_line_offset*(self: ptr TTextIter): int32 {.inline.} =

# gtk_text_iter_get_visible_slice
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg end: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: UTF8 'ucstring' 'ucstring'
proc gtk_text_iter_get_visible_slice(self: ptr TTextIter, end_x: ptr TTextIter): ucstring {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_visible_slice".}
proc get_visible_slice*(self: ptr TTextIter, end_x: ptr TTextIter): ucstring {.inline.} =
  gtk_text_iter_get_visible_slice(self, end_x)
# proc get_visible_slice*(self: ptr TTextIter, end_x: ptr TTextIter): ucstring {.inline.} =

# gtk_text_iter_get_visible_text
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg end: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: UTF8 'ucstring' 'ucstring'
proc gtk_text_iter_get_visible_text(self: ptr TTextIter, end_x: ptr TTextIter): ucstring {.cdecl, dynlib: lib, importc: "gtk_text_iter_get_visible_text".}
proc get_visible_text*(self: ptr TTextIter, end_x: ptr TTextIter): ucstring {.inline.} =
  gtk_text_iter_get_visible_text(self, end_x)
# proc get_visible_text*(self: ptr TTextIter, end_x: ptr TTextIter): ucstring {.inline.} =

# gtk_text_iter_has_tag
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg tag: INTERFACE (OBJECT) 'TextTag' 'ptr TTextTag' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_has_tag(self: ptr TTextIter, tag: ptr TTextTag): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_has_tag".}
proc has_tag*(self: ptr TTextIter, tag: TextTag): bool {.inline.} =
  gtk_text_iter_has_tag(self, tag.getPointer)
# proc has_tag*(self: ptr TTextIter, tag: TextTag): bool {.inline.} =

# gtk_text_iter_in_range
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg start: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# arg end: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_in_range(self: ptr TTextIter, start: ptr TTextIter, end_x: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_in_range".}
proc in_range*(self: ptr TTextIter, start: ptr TTextIter, end_x: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_in_range(self, start, end_x)
# proc in_range*(self: ptr TTextIter, start: ptr TTextIter, end_x: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_inside_sentence
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_inside_sentence(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_inside_sentence".}
proc inside_sentence*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_inside_sentence(self)
# proc inside_sentence*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_inside_word
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_inside_word(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_inside_word".}
proc inside_word*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_inside_word(self)
# proc inside_word*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_is_cursor_position
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_is_cursor_position(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_is_cursor_position".}
proc is_cursor_position*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_is_cursor_position(self)
# proc is_cursor_position*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_is_end
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_is_end(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_is_end".}
proc is_end*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_is_end(self)
# proc is_end*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_is_start
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_is_start(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_is_start".}
proc is_start*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_is_start(self)
# proc is_start*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_order
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg second: INTERFACE (STRUCT) 'ptr TTextIter' 'ptr TTextIter' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_iter_order(self: ptr TTextIter, second: ptr TTextIter) {.cdecl, dynlib: lib, importc: "gtk_text_iter_order".}
proc order*(self: ptr TTextIter, second: ptr TTextIter) {.inline.} =
  gtk_text_iter_order(self, second)
# proc order*(self: ptr TTextIter, second: ptr TTextIter) {.inline.} =

# gtk_text_iter_set_line
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg line_number: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_iter_set_line(self: ptr TTextIter, line_number: int32) {.cdecl, dynlib: lib, importc: "gtk_text_iter_set_line".}
proc set_line*(self: ptr TTextIter, line_number: int32) {.inline.} =
  gtk_text_iter_set_line(self, line_number)
# proc set_line*(self: ptr TTextIter, line_number: int32) {.inline.} =

# gtk_text_iter_set_line_index
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg byte_on_line: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_iter_set_line_index(self: ptr TTextIter, byte_on_line: int32) {.cdecl, dynlib: lib, importc: "gtk_text_iter_set_line_index".}
proc set_line_index*(self: ptr TTextIter, byte_on_line: int32) {.inline.} =
  gtk_text_iter_set_line_index(self, byte_on_line)
# proc set_line_index*(self: ptr TTextIter, byte_on_line: int32) {.inline.} =

# gtk_text_iter_set_line_offset
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg char_on_line: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_iter_set_line_offset(self: ptr TTextIter, char_on_line: int32) {.cdecl, dynlib: lib, importc: "gtk_text_iter_set_line_offset".}
proc set_line_offset*(self: ptr TTextIter, char_on_line: int32) {.inline.} =
  gtk_text_iter_set_line_offset(self, char_on_line)
# proc set_line_offset*(self: ptr TTextIter, char_on_line: int32) {.inline.} =

# gtk_text_iter_set_offset
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg char_offset: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_iter_set_offset(self: ptr TTextIter, char_offset: int32) {.cdecl, dynlib: lib, importc: "gtk_text_iter_set_offset".}
proc set_offset*(self: ptr TTextIter, char_offset: int32) {.inline.} =
  gtk_text_iter_set_offset(self, char_offset)
# proc set_offset*(self: ptr TTextIter, char_offset: int32) {.inline.} =

# gtk_text_iter_set_visible_line_index
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg byte_on_line: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_iter_set_visible_line_index(self: ptr TTextIter, byte_on_line: int32) {.cdecl, dynlib: lib, importc: "gtk_text_iter_set_visible_line_index".}
proc set_visible_line_index*(self: ptr TTextIter, byte_on_line: int32) {.inline.} =
  gtk_text_iter_set_visible_line_index(self, byte_on_line)
# proc set_visible_line_index*(self: ptr TTextIter, byte_on_line: int32) {.inline.} =

# gtk_text_iter_set_visible_line_offset
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg char_on_line: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_text_iter_set_visible_line_offset(self: ptr TTextIter, char_on_line: int32) {.cdecl, dynlib: lib, importc: "gtk_text_iter_set_visible_line_offset".}
proc set_visible_line_offset*(self: ptr TTextIter, char_on_line: int32) {.inline.} =
  gtk_text_iter_set_visible_line_offset(self, char_on_line)
# proc set_visible_line_offset*(self: ptr TTextIter, char_on_line: int32) {.inline.} =

# gtk_text_iter_starts_line
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_starts_line(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_starts_line".}
proc starts_line*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_starts_line(self)
# proc starts_line*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_starts_sentence
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_starts_sentence(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_starts_sentence".}
proc starts_sentence*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_starts_sentence(self)
# proc starts_sentence*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_starts_word
# flags: {isMethod} container: TextIter
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_starts_word(self: ptr TTextIter): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_starts_word".}
proc starts_word*(self: ptr TTextIter): bool {.inline.} =
  gtk_text_iter_starts_word(self)
# proc starts_word*(self: ptr TTextIter): bool {.inline.} =

# gtk_text_iter_toggles_tag
# flags: {isMethod} container: TextIter
# need sugar: is method
# arg tag: INTERFACE (OBJECT) 'TextTag' 'ptr TTextTag' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_text_iter_toggles_tag(self: ptr TTextIter, tag: ptr TTextTag): bool {.cdecl, dynlib: lib, importc: "gtk_text_iter_toggles_tag".}
proc toggles_tag*(self: ptr TTextIter, tag: TextTag): bool {.inline.} =
  gtk_text_iter_toggles_tag(self, tag.getPointer)
# proc toggles_tag*(self: ptr TTextIter, tag: TextTag): bool {.inline.} =

# struct TextMarkClass
# struct TextTagClass
# struct TextTagPrivate
# struct TextTagTableClass
# struct TextTagTablePrivate
# struct TextViewAccessibleClass
# struct TextViewAccessiblePrivate
# struct TextViewClass
# struct TextViewPrivate
# struct ThemeEngine
# struct ThemingEngineClass
# struct ThemingEnginePrivate
# struct ToggleActionClass
# struct ToggleActionEntry
# struct ToggleActionPrivate
# struct ToggleButtonAccessibleClass
# struct ToggleButtonAccessiblePrivate
# struct ToggleButtonClass
# struct ToggleButtonPrivate
# struct ToggleToolButtonClass
# struct ToggleToolButtonPrivate
# struct ToolButtonClass
# struct ToolButtonPrivate
# struct ToolItemClass
# struct ToolItemGroupClass
# struct ToolItemGroupPrivate
# struct ToolItemPrivate
# struct ToolPaletteClass
# struct ToolPalettePrivate
# struct ToolShellIface
# struct ToolbarClass
# struct ToolbarPrivate
# struct ToplevelAccessibleClass
# struct ToplevelAccessiblePrivate
# struct TreeDragDestIface
# struct TreeDragSourceIface
# struct TreeIter
# gtk_tree_iter_copy
# flags: {isMethod} container: TreeIter
# need sugar: is method
# return: INTERFACE 'ptr TTreeIter' 'ptr TTreeIter'
proc gtk_tree_iter_copy(self: ptr TTreeIter): ptr TTreeIter {.cdecl, dynlib: lib, importc: "gtk_tree_iter_copy".}
proc copy*(self: ptr TTreeIter): ptr TTreeIter {.inline.} =
  gtk_tree_iter_copy(self)
# proc copy*(self: ptr TTreeIter): ptr TTreeIter {.inline.} =

# gtk_tree_iter_free
# flags: {isMethod} container: TreeIter
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_iter_free(self: ptr TTreeIter) {.cdecl, dynlib: lib, importc: "gtk_tree_iter_free".}
proc free*(self: ptr TTreeIter) {.inline.} =
  gtk_tree_iter_free(self)
# proc free*(self: ptr TTreeIter) {.inline.} =

# struct TreeModelFilterClass
# struct TreeModelFilterPrivate
# struct TreeModelIface
# struct TreeModelSortClass
# struct TreeModelSortPrivate
# struct TreePath
# gtk_tree_path_new
# flags: {isConstructor} container: TreePath
# need sugar: is static method
# return: INTERFACE 'ptr TTreePath' 'ptr TTreePath'
proc gtk_tree_path_new(): ptr TTreePath {.cdecl, dynlib: lib, importc: "gtk_tree_path_new".}
proc new_treepath*(): ptr TTreePath {.inline.} =
  gtk_tree_path_new()
# proc new_treepath*(): ptr TTreePath {.inline.} =

# gtk_tree_path_new_first
# flags: {isConstructor} container: TreePath
# need sugar: is static method
# return: INTERFACE 'ptr TTreePath' 'ptr TTreePath'
proc gtk_tree_path_new_first(): ptr TTreePath {.cdecl, dynlib: lib, importc: "gtk_tree_path_new_first".}
proc new_treepath_first*(): ptr TTreePath {.inline.} =
  gtk_tree_path_new_first()
# proc new_treepath_first*(): ptr TTreePath {.inline.} =

# gtk_tree_path_new_from_indicesv
# flags: {isConstructor} container: TreePath
# need sugar: is static method
# arg indices: ARRAY 'var openarray[int32]' 'openarray[int32]' IN (diff., need sugar) array lengthArg: 1
# arg length: UINT32 'uint32' 'uint32' IN
# return: INTERFACE 'ptr TTreePath' 'ptr TTreePath'
proc gtk_tree_path_new_from_indicesv(indices: openarray[int32], length: uint32): ptr TTreePath {.cdecl, dynlib: lib, importc: "gtk_tree_path_new_from_indicesv".}
proc new_treepath_from_indices*(indices: var openarray[int32]): ptr TTreePath {.inline.} =
  gtk_tree_path_new_from_indicesv(indices, indices.len.uint32)
# proc new_treepath_from_indices*(indices: var openarray[int32]): ptr TTreePath {.inline.} =

# gtk_tree_path_new_from_string
# flags: {isConstructor} container: TreePath
# need sugar: is static method
# arg path: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'ptr TTreePath' 'ptr TTreePath'
proc gtk_tree_path_new_from_string(path: ucstring): ptr TTreePath {.cdecl, dynlib: lib, importc: "gtk_tree_path_new_from_string".}
proc new_treepath_from_string*(path: ustring): ptr TTreePath {.inline.} =
  gtk_tree_path_new_from_string(ucstring(path))
# proc new_treepath_from_string*(path: ustring): ptr TTreePath {.inline.} =

# gtk_tree_path_append_index
# flags: {isMethod} container: TreePath
# need sugar: is method
# arg index_: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_path_append_index(self: ptr TTreePath, index_x: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_path_append_index".}
proc append_index*(self: ptr TTreePath, index_x: int32) {.inline.} =
  gtk_tree_path_append_index(self, index_x)
# proc append_index*(self: ptr TTreePath, index_x: int32) {.inline.} =

# gtk_tree_path_compare
# flags: {isMethod} container: TreePath
# need sugar: is method
# arg b: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: INT32 'int32' 'int32'
proc gtk_tree_path_compare(self: ptr TTreePath, b: ptr TTreePath): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_path_compare".}
proc compare*(self: ptr TTreePath, b: ptr TTreePath): int32 {.inline.} =
  gtk_tree_path_compare(self, b)
# proc compare*(self: ptr TTreePath, b: ptr TTreePath): int32 {.inline.} =

# gtk_tree_path_copy
# flags: {isMethod} container: TreePath
# need sugar: is method
# return: INTERFACE 'ptr TTreePath' 'ptr TTreePath'
proc gtk_tree_path_copy(self: ptr TTreePath): ptr TTreePath {.cdecl, dynlib: lib, importc: "gtk_tree_path_copy".}
proc copy*(self: ptr TTreePath): ptr TTreePath {.inline.} =
  gtk_tree_path_copy(self)
# proc copy*(self: ptr TTreePath): ptr TTreePath {.inline.} =

# gtk_tree_path_down
# flags: {isMethod} container: TreePath
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_path_down(self: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_tree_path_down".}
proc down*(self: ptr TTreePath) {.inline.} =
  gtk_tree_path_down(self)
# proc down*(self: ptr TTreePath) {.inline.} =

# gtk_tree_path_free
# flags: {isMethod} container: TreePath
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_path_free(self: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_tree_path_free".}
proc free*(self: ptr TTreePath) {.inline.} =
  gtk_tree_path_free(self)
# proc free*(self: ptr TTreePath) {.inline.} =

# gtk_tree_path_get_depth
# flags: {isMethod} container: TreePath
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_tree_path_get_depth(self: ptr TTreePath): int32 {.cdecl, dynlib: lib, importc: "gtk_tree_path_get_depth".}
proc get_depth*(self: ptr TTreePath): int32 {.inline.} =
  gtk_tree_path_get_depth(self)
# proc get_depth*(self: ptr TTreePath): int32 {.inline.} =

# gtk_tree_path_get_indices_with_depth
# flags: {isMethod} container: TreePath
# need sugar: is method
# arg depth: INT32 'var int32' 'ptr int32' OUT (diff., need sugar) optional
# return: ARRAY 'zeroTerminatedArray[int32]' 'zeroTerminatedArray[int32]'
proc gtk_tree_path_get_indices_with_depth(self: ptr TTreePath, depth: ptr int32): zeroTerminatedArray[int32] {.cdecl, dynlib: lib, importc: "gtk_tree_path_get_indices_with_depth".}
proc get_indices*(self: ptr TTreePath, depth: var int32): zeroTerminatedArray[int32] {.inline.} =
  gtk_tree_path_get_indices_with_depth(self, addr(depth))
# tuple-return
# depth: var int32
# proc get_indices*(self: ptr TTreePath): zeroTerminatedArray[int32] {.inline.} =

# gtk_tree_path_is_ancestor
# flags: {isMethod} container: TreePath
# need sugar: is method
# arg descendant: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_path_is_ancestor(self: ptr TTreePath, descendant: ptr TTreePath): bool {.cdecl, dynlib: lib, importc: "gtk_tree_path_is_ancestor".}
proc is_ancestor*(self: ptr TTreePath, descendant: ptr TTreePath): bool {.inline.} =
  gtk_tree_path_is_ancestor(self, descendant)
# proc is_ancestor*(self: ptr TTreePath, descendant: ptr TTreePath): bool {.inline.} =

# gtk_tree_path_is_descendant
# flags: {isMethod} container: TreePath
# need sugar: is method
# arg ancestor: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_path_is_descendant(self: ptr TTreePath, ancestor: ptr TTreePath): bool {.cdecl, dynlib: lib, importc: "gtk_tree_path_is_descendant".}
proc is_descendant*(self: ptr TTreePath, ancestor: ptr TTreePath): bool {.inline.} =
  gtk_tree_path_is_descendant(self, ancestor)
# proc is_descendant*(self: ptr TTreePath, ancestor: ptr TTreePath): bool {.inline.} =

# gtk_tree_path_next
# flags: {isMethod} container: TreePath
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_path_next(self: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_tree_path_next".}
proc next*(self: ptr TTreePath) {.inline.} =
  gtk_tree_path_next(self)
# proc next*(self: ptr TTreePath) {.inline.} =

# gtk_tree_path_prepend_index
# flags: {isMethod} container: TreePath
# need sugar: is method
# arg index_: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_path_prepend_index(self: ptr TTreePath, index_x: int32) {.cdecl, dynlib: lib, importc: "gtk_tree_path_prepend_index".}
proc prepend_index*(self: ptr TTreePath, index_x: int32) {.inline.} =
  gtk_tree_path_prepend_index(self, index_x)
# proc prepend_index*(self: ptr TTreePath, index_x: int32) {.inline.} =

# gtk_tree_path_prev
# flags: {isMethod} container: TreePath
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_path_prev(self: ptr TTreePath): bool {.cdecl, dynlib: lib, importc: "gtk_tree_path_prev".}
proc prev*(self: ptr TTreePath): bool {.inline.} =
  gtk_tree_path_prev(self)
# proc prev*(self: ptr TTreePath): bool {.inline.} =

# gtk_tree_path_to_string
# flags: {isMethod} container: TreePath
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_tree_path_to_string(self: ptr TTreePath): ucstring {.cdecl, dynlib: lib, importc: "gtk_tree_path_to_string".}
proc to_string*(self: ptr TTreePath): ucstring {.inline.} =
  gtk_tree_path_to_string(self)
# proc to_string*(self: ptr TTreePath): ucstring {.inline.} =

# gtk_tree_path_up
# flags: {isMethod} container: TreePath
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_path_up(self: ptr TTreePath): bool {.cdecl, dynlib: lib, importc: "gtk_tree_path_up".}
proc up*(self: ptr TTreePath): bool {.inline.} =
  gtk_tree_path_up(self)
# proc up*(self: ptr TTreePath): bool {.inline.} =

# struct TreeRowReference
# gtk_tree_row_reference_new
# flags: {isConstructor} container: TreeRowReference
# need sugar: is static method
# arg model: INTERFACE (INTERFACE) 'ptr TTreeModel' 'ptr TTreeModel' IN
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: INTERFACE 'ptr TTreeRowReference' 'ptr TTreeRowReference'
proc gtk_tree_row_reference_new(model: ptr TTreeModel, path: ptr TTreePath): ptr TTreeRowReference {.cdecl, dynlib: lib, importc: "gtk_tree_row_reference_new".}
proc new_treerowreference*(model: ptr TTreeModel, path: ptr TTreePath): ptr TTreeRowReference {.inline.} =
  gtk_tree_row_reference_new(model, path)
# proc new_treerowreference*(model: ptr TTreeModel, path: ptr TTreePath): ptr TTreeRowReference {.inline.} =

# gtk_tree_row_reference_new_proxy
# flags: {isConstructor} container: TreeRowReference
# need sugar: is static method
# arg proxy: INTERFACE (OBJECT) 'GObject2.Object' 'ptr GObject2.TObject' IN (diff., need sugar)
# arg model: INTERFACE (INTERFACE) 'ptr TTreeModel' 'ptr TTreeModel' IN
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: INTERFACE 'ptr TTreeRowReference' 'ptr TTreeRowReference'
proc gtk_tree_row_reference_new_proxy(proxy: ptr GObject2.TObject, model: ptr TTreeModel, path: ptr TTreePath): ptr TTreeRowReference {.cdecl, dynlib: lib, importc: "gtk_tree_row_reference_new_proxy".}
proc new_treerowreference_proxy*(proxy: GObject2.Object, model: ptr TTreeModel, path: ptr TTreePath): ptr TTreeRowReference {.inline.} =
  gtk_tree_row_reference_new_proxy(proxy.getPointer, model, path)
# proc new_treerowreference_proxy*(proxy: GObject2.Object, model: ptr TTreeModel, path: ptr TTreePath): ptr TTreeRowReference {.inline.} =

# gtk_tree_row_reference_copy
# flags: {isMethod} container: TreeRowReference
# need sugar: is method
# return: INTERFACE 'ptr TTreeRowReference' 'ptr TTreeRowReference'
proc gtk_tree_row_reference_copy(self: ptr TTreeRowReference): ptr TTreeRowReference {.cdecl, dynlib: lib, importc: "gtk_tree_row_reference_copy".}
proc copy*(self: ptr TTreeRowReference): ptr TTreeRowReference {.inline.} =
  gtk_tree_row_reference_copy(self)
# proc copy*(self: ptr TTreeRowReference): ptr TTreeRowReference {.inline.} =

# gtk_tree_row_reference_free
# flags: {isMethod} container: TreeRowReference
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_tree_row_reference_free(self: ptr TTreeRowReference) {.cdecl, dynlib: lib, importc: "gtk_tree_row_reference_free".}
proc free*(self: ptr TTreeRowReference) {.inline.} =
  gtk_tree_row_reference_free(self)
# proc free*(self: ptr TTreeRowReference) {.inline.} =

# gtk_tree_row_reference_get_model
# flags: {isMethod} container: TreeRowReference
# need sugar: is method
# return: INTERFACE 'ptr TTreeModel' 'TransferNone[TTreeModel]' (diff., need sugar)
proc gtk_tree_row_reference_get_model(self: ptr TTreeRowReference): TransferNone[TTreeModel] {.cdecl, dynlib: lib, importc: "gtk_tree_row_reference_get_model".}
proc get_model*(self: ptr TTreeRowReference): ptr TTreeModel {.inline.} =
  wrap(gtk_tree_row_reference_get_model(self))
# proc get_model*(self: ptr TTreeRowReference): ptr TTreeModel {.inline.} =

# gtk_tree_row_reference_get_path
# flags: {isMethod} container: TreeRowReference
# need sugar: is method
# return: INTERFACE 'ptr TTreePath' 'ptr TTreePath'
proc gtk_tree_row_reference_get_path(self: ptr TTreeRowReference): ptr TTreePath {.cdecl, dynlib: lib, importc: "gtk_tree_row_reference_get_path".}
proc get_path*(self: ptr TTreeRowReference): ptr TTreePath {.inline.} =
  gtk_tree_row_reference_get_path(self)
# proc get_path*(self: ptr TTreeRowReference): ptr TTreePath {.inline.} =

# gtk_tree_row_reference_valid
# flags: {isMethod} container: TreeRowReference
# need sugar: is method
# return: BOOLEAN 'bool' 'bool'
proc gtk_tree_row_reference_valid(self: ptr TTreeRowReference): bool {.cdecl, dynlib: lib, importc: "gtk_tree_row_reference_valid".}
proc valid*(self: ptr TTreeRowReference): bool {.inline.} =
  gtk_tree_row_reference_valid(self)
# proc valid*(self: ptr TTreeRowReference): bool {.inline.} =

# gtk_tree_row_reference_deleted
# flags: {} container: TreeRowReference
# need sugar: is static method
# arg proxy: INTERFACE (OBJECT) 'GObject2.Object' 'ptr GObject2.TObject' IN (diff., need sugar)
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
# warning, already written a prototype with the name of gtk_tree_row_reference_deleted
# proc gtk_tree_row_reference_deleted(proxy: ptr GObject2.TObject, path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_tree_row_reference_deleted".}
template deleted*(klass_parameter: typedesc[TTreeRowReference], proxy: GObject2.Object, path: ptr TTreePath) =
  gtk_tree_row_reference_deleted(proxy.getPointer, path)
# template deleted*(klass_parameter: typedesc[TTreeRowReference], proxy: GObject2.Object, path: ptr TTreePath) =

# gtk_tree_row_reference_inserted
# flags: {} container: TreeRowReference
# need sugar: is static method
# arg proxy: INTERFACE (OBJECT) 'GObject2.Object' 'ptr GObject2.TObject' IN (diff., need sugar)
# arg path: INTERFACE (STRUCT) 'ptr TTreePath' 'ptr TTreePath' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
# warning, already written a prototype with the name of gtk_tree_row_reference_inserted
# proc gtk_tree_row_reference_inserted(proxy: ptr GObject2.TObject, path: ptr TTreePath) {.cdecl, dynlib: lib, importc: "gtk_tree_row_reference_inserted".}
template inserted*(klass_parameter: typedesc[TTreeRowReference], proxy: GObject2.Object, path: ptr TTreePath) =
  gtk_tree_row_reference_inserted(proxy.getPointer, path)
# template inserted*(klass_parameter: typedesc[TTreeRowReference], proxy: GObject2.Object, path: ptr TTreePath) =

# struct TreeSelectionClass
# struct TreeSelectionPrivate
# struct TreeSortableIface
# struct TreeStoreClass
# struct TreeStorePrivate
# struct TreeViewAccessibleClass
# struct TreeViewAccessiblePrivate
# struct TreeViewClass
# struct TreeViewColumnClass
# struct TreeViewColumnPrivate
# struct TreeViewPrivate
# struct UIManagerClass
# struct UIManagerPrivate
# struct VBoxClass
# struct VButtonBoxClass
# struct VPanedClass
# struct VScaleClass
# struct VScrollbarClass
# struct VSeparatorClass
# struct ViewportClass
# struct ViewportPrivate
# struct VolumeButtonClass
# struct WidgetAccessibleClass
# struct WidgetAccessiblePrivate
# struct WidgetClass
# gtk_widget_class_bind_template_callback_full
# flags: {isMethod} container: WidgetClass
# need sugar: is method
# arg callback_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg callback_symbol: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_class_bind_template_callback_full(self: ptr TWidgetClass, callback_name: ucstring, callback_symbol: pointer) {.cdecl, dynlib: lib, importc: "gtk_widget_class_bind_template_callback_full".}
proc bind_template_callback_full*(self: ptr TWidgetClass, callback_name: ustring, callback_symbol: pointer) {.inline.} =
  gtk_widget_class_bind_template_callback_full(self, ucstring(callback_name), callback_symbol)
# proc bind_template_callback_full*(self: ptr TWidgetClass, callback_name: ustring, callback_symbol: pointer) {.inline.} =

# gtk_widget_class_bind_template_child_full
# flags: {isMethod} container: WidgetClass
# need sugar: is method
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# arg internal_child: BOOLEAN 'bool' 'bool' IN
# arg struct_offset: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_class_bind_template_child_full(self: ptr TWidgetClass, name: ucstring, internal_child: bool, struct_offset: int32) {.cdecl, dynlib: lib, importc: "gtk_widget_class_bind_template_child_full".}
proc bind_template_child_full*(self: ptr TWidgetClass, name: ustring, internal_child: bool, struct_offset: int32) {.inline.} =
  gtk_widget_class_bind_template_child_full(self, ucstring(name), internal_child, struct_offset)
# proc bind_template_child_full*(self: ptr TWidgetClass, name: ustring, internal_child: bool, struct_offset: int32) {.inline.} =

# gtk_widget_class_find_style_property
# flags: {isMethod} container: WidgetClass
# need sugar: is method
# arg property_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: INTERFACE 'GObject2.ParamSpec' 'TransferNone[GObject2.TParamSpec]' (diff., need sugar)
proc gtk_widget_class_find_style_property(self: ptr TWidgetClass, property_name: ucstring): TransferNone[GObject2.TParamSpec] {.cdecl, dynlib: lib, importc: "gtk_widget_class_find_style_property".}
proc find_style_property*(self: ptr TWidgetClass, property_name: ustring): GObject2.ParamSpec {.inline.} =
  wrap(gtk_widget_class_find_style_property(self, ucstring(property_name)))
# proc find_style_property*(self: ptr TWidgetClass, property_name: ustring): GObject2.ParamSpec {.inline.} =

# gtk_widget_class_install_style_property
# flags: {isMethod} container: WidgetClass
# need sugar: is method
# arg pspec: INTERFACE (OBJECT) 'GObject2.ParamSpec' 'ptr GObject2.TParamSpec' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_class_install_style_property(self: ptr TWidgetClass, pspec: ptr GObject2.TParamSpec) {.cdecl, dynlib: lib, importc: "gtk_widget_class_install_style_property".}
proc install_style_property*(self: ptr TWidgetClass, pspec: GObject2.ParamSpec) {.inline.} =
  gtk_widget_class_install_style_property(self, pspec.getPointer)
# proc install_style_property*(self: ptr TWidgetClass, pspec: GObject2.ParamSpec) {.inline.} =

# gtk_widget_class_list_style_properties
# flags: {isMethod} container: WidgetClass
# need sugar: is method
# arg n_properties: UINT32 'var uint32' 'ptr uint32' OUT (diff., need sugar)
# return: ARRAY 'zeroTerminatedArray[ptr GObject2.TParamSpec]' 'zeroTerminatedArray[ptr GObject2.TParamSpec]'
proc gtk_widget_class_list_style_properties(self: ptr TWidgetClass, n_properties: ptr uint32): zeroTerminatedArray[ptr GObject2.TParamSpec] {.cdecl, dynlib: lib, importc: "gtk_widget_class_list_style_properties".}
proc list_style_properties*(self: ptr TWidgetClass, n_properties: var uint32): zeroTerminatedArray[ptr GObject2.TParamSpec] {.inline.} =
  gtk_widget_class_list_style_properties(self, addr(n_properties))
# tuple-return
# n_properties: var uint32
# proc list_style_properties*(self: ptr TWidgetClass): zeroTerminatedArray[ptr GObject2.TParamSpec] {.inline.} =

# gtk_widget_class_set_accessible_role
# flags: {isMethod} container: WidgetClass
# need sugar: is method
# arg role: INTERFACE (ENUM) 'Atk1.Role' 'Atk1.Role' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_class_set_accessible_role(self: ptr TWidgetClass, role: Atk1.Role) {.cdecl, dynlib: lib, importc: "gtk_widget_class_set_accessible_role".}
proc set_accessible_role*(self: ptr TWidgetClass, role: Atk1.Role) {.inline.} =
  gtk_widget_class_set_accessible_role(self, role)
# proc set_accessible_role*(self: ptr TWidgetClass, role: Atk1.Role) {.inline.} =

# gtk_widget_class_set_accessible_type
# flags: {isMethod} container: WidgetClass
# need sugar: is method
# arg type: GTYPE 'GType' 'GType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_class_set_accessible_type(self: ptr TWidgetClass, type_x: GType) {.cdecl, dynlib: lib, importc: "gtk_widget_class_set_accessible_type".}
proc set_accessible_type*(self: ptr TWidgetClass, type_x: GType) {.inline.} =
  gtk_widget_class_set_accessible_type(self, type_x)
# proc set_accessible_type*(self: ptr TWidgetClass, type_x: GType) {.inline.} =

# gtk_widget_class_set_connect_func
# flags: {isMethod} container: WidgetClass
# need sugar: is method
# arg connect_func: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# arg connect_data: VOID 'pointer' 'pointer' IN
# arg connect_data_destroy: INTERFACE (CALLBACK) 'pointer' 'pointer' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_class_set_connect_func(self: ptr TWidgetClass, connect_func: pointer, connect_data: pointer, connect_data_destroy: pointer) {.cdecl, dynlib: lib, importc: "gtk_widget_class_set_connect_func".}
proc set_connect_func*(self: ptr TWidgetClass, connect_func: pointer, connect_data: pointer, connect_data_destroy: pointer) {.inline.} =
  gtk_widget_class_set_connect_func(self, connect_func, connect_data, connect_data_destroy)
# proc set_connect_func*(self: ptr TWidgetClass, connect_func: pointer, connect_data: pointer, connect_data_destroy: pointer) {.inline.} =

# gtk_widget_class_set_template
# flags: {isMethod} container: WidgetClass
# need sugar: is method
# arg template_bytes: INTERFACE (STRUCT) 'ptr GLib2.TBytes' 'ptr GLib2.TBytes' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_class_set_template(self: ptr TWidgetClass, template_bytes: ptr GLib2.TBytes) {.cdecl, dynlib: lib, importc: "gtk_widget_class_set_template".}
proc set_template*(self: ptr TWidgetClass, template_bytes: ptr GLib2.TBytes) {.inline.} =
  gtk_widget_class_set_template(self, template_bytes)
# proc set_template*(self: ptr TWidgetClass, template_bytes: ptr GLib2.TBytes) {.inline.} =

# gtk_widget_class_set_template_from_resource
# flags: {isMethod} container: WidgetClass
# need sugar: is method
# arg resource_name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_class_set_template_from_resource(self: ptr TWidgetClass, resource_name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_widget_class_set_template_from_resource".}
proc set_template_from_resource*(self: ptr TWidgetClass, resource_name: ustring) {.inline.} =
  gtk_widget_class_set_template_from_resource(self, ucstring(resource_name))
# proc set_template_from_resource*(self: ptr TWidgetClass, resource_name: ustring) {.inline.} =

# struct WidgetClassPrivate
# struct WidgetPath
# gtk_widget_path_new
# flags: {isConstructor} container: WidgetPath
# need sugar: is static method
# return: INTERFACE 'ptr TWidgetPath' 'ptr TWidgetPath'
proc gtk_widget_path_new(): ptr TWidgetPath {.cdecl, dynlib: lib, importc: "gtk_widget_path_new".}
proc new_widgetpath*(): ptr TWidgetPath {.inline.} =
  gtk_widget_path_new()
# proc new_widgetpath*(): ptr TWidgetPath {.inline.} =

# gtk_widget_path_append_for_widget
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# arg widget: INTERFACE (OBJECT) 'Widget' 'ptr TWidget' IN (diff., need sugar)
# return: INT32 'int32' 'int32'
proc gtk_widget_path_append_for_widget(self: ptr TWidgetPath, widget: ptr TWidget): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_path_append_for_widget".}
proc append_for_widget*(self: ptr TWidgetPath, widget: Widget): int32 {.inline.} =
  gtk_widget_path_append_for_widget(self, widget.getPointer)
# proc append_for_widget*(self: ptr TWidgetPath, widget: Widget): int32 {.inline.} =

# gtk_widget_path_append_type
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# arg type: GTYPE 'GType' 'GType' IN
# return: INT32 'int32' 'int32'
proc gtk_widget_path_append_type(self: ptr TWidgetPath, type_x: GType): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_path_append_type".}
proc append_type*(self: ptr TWidgetPath, type_x: GType): int32 {.inline.} =
  gtk_widget_path_append_type(self, type_x)
# proc append_type*(self: ptr TWidgetPath, type_x: GType): int32 {.inline.} =

# gtk_widget_path_append_with_siblings
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# arg siblings: INTERFACE (STRUCT) 'ptr TWidgetPath' 'ptr TWidgetPath' IN
# arg sibling_index: UINT32 'uint32' 'uint32' IN
# return: INT32 'int32' 'int32'
proc gtk_widget_path_append_with_siblings(self: ptr TWidgetPath, siblings: ptr TWidgetPath, sibling_index: uint32): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_path_append_with_siblings".}
proc append_with_siblings*(self: ptr TWidgetPath, siblings: ptr TWidgetPath, sibling_index: uint32): int32 {.inline.} =
  gtk_widget_path_append_with_siblings(self, siblings, sibling_index)
# proc append_with_siblings*(self: ptr TWidgetPath, siblings: ptr TWidgetPath, sibling_index: uint32): int32 {.inline.} =

# gtk_widget_path_copy
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# return: INTERFACE 'ptr TWidgetPath' 'ptr TWidgetPath'
proc gtk_widget_path_copy(self: ptr TWidgetPath): ptr TWidgetPath {.cdecl, dynlib: lib, importc: "gtk_widget_path_copy".}
proc copy*(self: ptr TWidgetPath): ptr TWidgetPath {.inline.} =
  gtk_widget_path_copy(self)
# proc copy*(self: ptr TWidgetPath): ptr TWidgetPath {.inline.} =

# gtk_widget_path_free
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_path_free(self: ptr TWidgetPath) {.cdecl, dynlib: lib, importc: "gtk_widget_path_free".}
proc free*(self: ptr TWidgetPath) {.inline.} =
  gtk_widget_path_free(self)
# proc free*(self: ptr TWidgetPath) {.inline.} =

# gtk_widget_path_get_object_type
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# return: GTYPE 'GType' 'GType'
proc gtk_widget_path_get_object_type(self: ptr TWidgetPath): GType {.cdecl, dynlib: lib, importc: "gtk_widget_path_get_object_type".}
proc get_object_type*(self: ptr TWidgetPath): GType {.inline.} =
  gtk_widget_path_get_object_type(self)
# proc get_object_type*(self: ptr TWidgetPath): GType {.inline.} =

# gtk_widget_path_has_parent
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# arg type: GTYPE 'GType' 'GType' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_path_has_parent(self: ptr TWidgetPath, type_x: GType): bool {.cdecl, dynlib: lib, importc: "gtk_widget_path_has_parent".}
proc has_parent*(self: ptr TWidgetPath, type_x: GType): bool {.inline.} =
  gtk_widget_path_has_parent(self, type_x)
# proc has_parent*(self: ptr TWidgetPath, type_x: GType): bool {.inline.} =

# gtk_widget_path_is_type
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# arg type: GTYPE 'GType' 'GType' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_path_is_type(self: ptr TWidgetPath, type_x: GType): bool {.cdecl, dynlib: lib, importc: "gtk_widget_path_is_type".}
proc is_type*(self: ptr TWidgetPath, type_x: GType): bool {.inline.} =
  gtk_widget_path_is_type(self, type_x)
# proc is_type*(self: ptr TWidgetPath, type_x: GType): bool {.inline.} =

# gtk_widget_path_iter_add_class
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# arg pos: INT32 'int32' 'int32' IN
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_path_iter_add_class(self: ptr TWidgetPath, pos: int32, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_add_class".}
proc iter_add_class*(self: ptr TWidgetPath, pos: int32, name: ustring) {.inline.} =
  gtk_widget_path_iter_add_class(self, pos, ucstring(name))
# proc iter_add_class*(self: ptr TWidgetPath, pos: int32, name: ustring) {.inline.} =

# gtk_widget_path_iter_add_qclass
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# arg pos: INT32 'int32' 'int32' IN
# arg qname: UINT32 'uint32' 'uint32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_path_iter_add_qclass(self: ptr TWidgetPath, pos: int32, qname: uint32) {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_add_qclass".}
proc iter_add_qclass*(self: ptr TWidgetPath, pos: int32, qname: uint32) {.inline.} =
  gtk_widget_path_iter_add_qclass(self, pos, qname)
# proc iter_add_qclass*(self: ptr TWidgetPath, pos: int32, qname: uint32) {.inline.} =

# gtk_widget_path_iter_add_region
# flags: {isMethod} container: WidgetPath (deprecated)
# gtk_widget_path_iter_clear_classes
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# arg pos: INT32 'int32' 'int32' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_path_iter_clear_classes(self: ptr TWidgetPath, pos: int32) {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_clear_classes".}
proc iter_clear_classes*(self: ptr TWidgetPath, pos: int32) {.inline.} =
  gtk_widget_path_iter_clear_classes(self, pos)
# proc iter_clear_classes*(self: ptr TWidgetPath, pos: int32) {.inline.} =

# gtk_widget_path_iter_clear_regions
# flags: {isMethod} container: WidgetPath (deprecated)
# gtk_widget_path_iter_get_name
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# arg pos: INT32 'int32' 'int32' IN
# return: UTF8 'ucstring' 'ucstring'
proc gtk_widget_path_iter_get_name(self: ptr TWidgetPath, pos: int32): ucstring {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_get_name".}
proc iter_get_name*(self: ptr TWidgetPath, pos: int32): ucstring {.inline.} =
  gtk_widget_path_iter_get_name(self, pos)
# proc iter_get_name*(self: ptr TWidgetPath, pos: int32): ucstring {.inline.} =

# gtk_widget_path_iter_get_object_type
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# arg pos: INT32 'int32' 'int32' IN
# return: GTYPE 'GType' 'GType'
proc gtk_widget_path_iter_get_object_type(self: ptr TWidgetPath, pos: int32): GType {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_get_object_type".}
proc iter_get_object_type*(self: ptr TWidgetPath, pos: int32): GType {.inline.} =
  gtk_widget_path_iter_get_object_type(self, pos)
# proc iter_get_object_type*(self: ptr TWidgetPath, pos: int32): GType {.inline.} =

# gtk_widget_path_iter_get_sibling_index
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# arg pos: INT32 'int32' 'int32' IN
# return: UINT32 'uint32' 'uint32'
proc gtk_widget_path_iter_get_sibling_index(self: ptr TWidgetPath, pos: int32): uint32 {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_get_sibling_index".}
proc iter_get_sibling_index*(self: ptr TWidgetPath, pos: int32): uint32 {.inline.} =
  gtk_widget_path_iter_get_sibling_index(self, pos)
# proc iter_get_sibling_index*(self: ptr TWidgetPath, pos: int32): uint32 {.inline.} =

# gtk_widget_path_iter_get_siblings
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# arg pos: INT32 'int32' 'int32' IN
# return: INTERFACE 'ptr TWidgetPath' 'ptr TWidgetPath'
proc gtk_widget_path_iter_get_siblings(self: ptr TWidgetPath, pos: int32): ptr TWidgetPath {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_get_siblings".}
proc iter_get_siblings*(self: ptr TWidgetPath, pos: int32): ptr TWidgetPath {.inline.} =
  gtk_widget_path_iter_get_siblings(self, pos)
# proc iter_get_siblings*(self: ptr TWidgetPath, pos: int32): ptr TWidgetPath {.inline.} =

# gtk_widget_path_iter_get_state
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# arg pos: INT32 'int32' 'int32' IN
# return: INTERFACE 'SStateFlags' 'SStateFlags'
proc gtk_widget_path_iter_get_state(self: ptr TWidgetPath, pos: int32): SStateFlags {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_get_state".}
proc iter_get_state*(self: ptr TWidgetPath, pos: int32): SStateFlags {.inline.} =
  gtk_widget_path_iter_get_state(self, pos)
# proc iter_get_state*(self: ptr TWidgetPath, pos: int32): SStateFlags {.inline.} =

# gtk_widget_path_iter_has_class
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# arg pos: INT32 'int32' 'int32' IN
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_path_iter_has_class(self: ptr TWidgetPath, pos: int32, name: ucstring): bool {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_has_class".}
proc iter_has_class*(self: ptr TWidgetPath, pos: int32, name: ustring): bool {.inline.} =
  gtk_widget_path_iter_has_class(self, pos, ucstring(name))
# proc iter_has_class*(self: ptr TWidgetPath, pos: int32, name: ustring): bool {.inline.} =

# gtk_widget_path_iter_has_name
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# arg pos: INT32 'int32' 'int32' IN
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_path_iter_has_name(self: ptr TWidgetPath, pos: int32, name: ucstring): bool {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_has_name".}
proc iter_has_name*(self: ptr TWidgetPath, pos: int32, name: ustring): bool {.inline.} =
  gtk_widget_path_iter_has_name(self, pos, ucstring(name))
# proc iter_has_name*(self: ptr TWidgetPath, pos: int32, name: ustring): bool {.inline.} =

# gtk_widget_path_iter_has_qclass
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# arg pos: INT32 'int32' 'int32' IN
# arg qname: UINT32 'uint32' 'uint32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_path_iter_has_qclass(self: ptr TWidgetPath, pos: int32, qname: uint32): bool {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_has_qclass".}
proc iter_has_qclass*(self: ptr TWidgetPath, pos: int32, qname: uint32): bool {.inline.} =
  gtk_widget_path_iter_has_qclass(self, pos, qname)
# proc iter_has_qclass*(self: ptr TWidgetPath, pos: int32, qname: uint32): bool {.inline.} =

# gtk_widget_path_iter_has_qname
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# arg pos: INT32 'int32' 'int32' IN
# arg qname: UINT32 'uint32' 'uint32' IN
# return: BOOLEAN 'bool' 'bool'
proc gtk_widget_path_iter_has_qname(self: ptr TWidgetPath, pos: int32, qname: uint32): bool {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_has_qname".}
proc iter_has_qname*(self: ptr TWidgetPath, pos: int32, qname: uint32): bool {.inline.} =
  gtk_widget_path_iter_has_qname(self, pos, qname)
# proc iter_has_qname*(self: ptr TWidgetPath, pos: int32, qname: uint32): bool {.inline.} =

# gtk_widget_path_iter_has_qregion
# flags: {isMethod} container: WidgetPath (deprecated)
# gtk_widget_path_iter_has_region
# flags: {isMethod} container: WidgetPath (deprecated)
# gtk_widget_path_iter_list_classes
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# arg pos: INT32 'int32' 'int32' IN
# return: GSLIST 'ptr GSLIST_TODO' 'ptr GSLIST_TODO'
proc gtk_widget_path_iter_list_classes(self: ptr TWidgetPath, pos: int32): ptr GSLIST_TODO {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_list_classes".}
proc iter_list_classes*(self: ptr TWidgetPath, pos: int32): ptr GSLIST_TODO {.inline.} =
  gtk_widget_path_iter_list_classes(self, pos)
# proc iter_list_classes*(self: ptr TWidgetPath, pos: int32): ptr GSLIST_TODO {.inline.} =

# gtk_widget_path_iter_list_regions
# flags: {isMethod} container: WidgetPath (deprecated)
# gtk_widget_path_iter_remove_class
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# arg pos: INT32 'int32' 'int32' IN
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_path_iter_remove_class(self: ptr TWidgetPath, pos: int32, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_remove_class".}
proc iter_remove_class*(self: ptr TWidgetPath, pos: int32, name: ustring) {.inline.} =
  gtk_widget_path_iter_remove_class(self, pos, ucstring(name))
# proc iter_remove_class*(self: ptr TWidgetPath, pos: int32, name: ustring) {.inline.} =

# gtk_widget_path_iter_remove_region
# flags: {isMethod} container: WidgetPath (deprecated)
# gtk_widget_path_iter_set_name
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# arg pos: INT32 'int32' 'int32' IN
# arg name: UTF8 'ustring' 'ucstring' IN (diff., need sugar)
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_path_iter_set_name(self: ptr TWidgetPath, pos: int32, name: ucstring) {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_set_name".}
proc iter_set_name*(self: ptr TWidgetPath, pos: int32, name: ustring) {.inline.} =
  gtk_widget_path_iter_set_name(self, pos, ucstring(name))
# proc iter_set_name*(self: ptr TWidgetPath, pos: int32, name: ustring) {.inline.} =

# gtk_widget_path_iter_set_object_type
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# arg pos: INT32 'int32' 'int32' IN
# arg type: GTYPE 'GType' 'GType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_path_iter_set_object_type(self: ptr TWidgetPath, pos: int32, type_x: GType) {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_set_object_type".}
proc iter_set_object_type*(self: ptr TWidgetPath, pos: int32, type_x: GType) {.inline.} =
  gtk_widget_path_iter_set_object_type(self, pos, type_x)
# proc iter_set_object_type*(self: ptr TWidgetPath, pos: int32, type_x: GType) {.inline.} =

# gtk_widget_path_iter_set_state
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# arg pos: INT32 'int32' 'int32' IN
# arg state: INTERFACE (FLAGS) 'SStateFlags' 'SStateFlags' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_path_iter_set_state(self: ptr TWidgetPath, pos: int32, state: SStateFlags) {.cdecl, dynlib: lib, importc: "gtk_widget_path_iter_set_state".}
proc iter_set_state*(self: ptr TWidgetPath, pos: int32, state: SStateFlags) {.inline.} =
  gtk_widget_path_iter_set_state(self, pos, state)
# proc iter_set_state*(self: ptr TWidgetPath, pos: int32, state: SStateFlags) {.inline.} =

# gtk_widget_path_length
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# return: INT32 'int32' 'int32'
proc gtk_widget_path_length(self: ptr TWidgetPath): int32 {.cdecl, dynlib: lib, importc: "gtk_widget_path_length".}
proc length*(self: ptr TWidgetPath): int32 {.inline.} =
  gtk_widget_path_length(self)
# proc length*(self: ptr TWidgetPath): int32 {.inline.} =

# gtk_widget_path_prepend_type
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# arg type: GTYPE 'GType' 'GType' IN
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_path_prepend_type(self: ptr TWidgetPath, type_x: GType) {.cdecl, dynlib: lib, importc: "gtk_widget_path_prepend_type".}
proc prepend_type*(self: ptr TWidgetPath, type_x: GType) {.inline.} =
  gtk_widget_path_prepend_type(self, type_x)
# proc prepend_type*(self: ptr TWidgetPath, type_x: GType) {.inline.} =

# gtk_widget_path_ref
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# return: INTERFACE 'ptr TWidgetPath' 'ptr TWidgetPath'
proc gtk_widget_path_ref(self: ptr TWidgetPath): ptr TWidgetPath {.cdecl, dynlib: lib, importc: "gtk_widget_path_ref".}
proc ref_x*(self: ptr TWidgetPath): ptr TWidgetPath {.inline.} =
  gtk_widget_path_ref(self)
# proc ref_x*(self: ptr TWidgetPath): ptr TWidgetPath {.inline.} =

# gtk_widget_path_to_string
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# return: UTF8 'ucstring' 'ucstring'
proc gtk_widget_path_to_string(self: ptr TWidgetPath): ucstring {.cdecl, dynlib: lib, importc: "gtk_widget_path_to_string".}
proc to_string*(self: ptr TWidgetPath): ucstring {.inline.} =
  gtk_widget_path_to_string(self)
# proc to_string*(self: ptr TWidgetPath): ucstring {.inline.} =

# gtk_widget_path_unref
# flags: {isMethod} container: WidgetPath
# need sugar: is method
# return: VOID 'VOID_TODO' 'VOID_TODO'
proc gtk_widget_path_unref(self: ptr TWidgetPath) {.cdecl, dynlib: lib, importc: "gtk_widget_path_unref".}
proc unref*(self: ptr TWidgetPath) {.inline.} =
  gtk_widget_path_unref(self)
# proc unref*(self: ptr TWidgetPath) {.inline.} =

# struct WidgetPrivate
# struct WindowAccessibleClass
# struct WindowAccessiblePrivate
# struct WindowClass
# struct WindowGeometryInfo
# struct WindowGroupClass
# struct WindowGroupPrivate
# struct WindowPrivate
  # flag type methods
  #------------------
# initializer for AccelFlags: gtk_accel_flags_get_type
proc gtk_accel_flags_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_accel_flags_get_type".}
template gtype*(klass_parameter: typedesc[AccelFlags]): GType = gtk_accel_flags_get_type()
# initializer for ApplicationInhibitFlags: gtk_application_inhibit_flags_get_type
proc gtk_application_inhibit_flags_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_application_inhibit_flags_get_type".}
template gtype*(klass_parameter: typedesc[ApplicationInhibitFlags]): GType = gtk_application_inhibit_flags_get_type()
# initializer for AttachOptions: gtk_attach_options_get_type
proc gtk_attach_options_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_attach_options_get_type".}
template gtype*(klass_parameter: typedesc[AttachOptions]): GType = gtk_attach_options_get_type()
# initializer for CalendarDisplayOptions: gtk_calendar_display_options_get_type
proc gtk_calendar_display_options_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_calendar_display_options_get_type".}
template gtype*(klass_parameter: typedesc[CalendarDisplayOptions]): GType = gtk_calendar_display_options_get_type()
# initializer for CellRendererState: gtk_cell_renderer_state_get_type
proc gtk_cell_renderer_state_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_cell_renderer_state_get_type".}
template gtype*(klass_parameter: typedesc[CellRendererState]): GType = gtk_cell_renderer_state_get_type()
# initializer for DebugFlag: gtk_debug_flag_get_type
proc gtk_debug_flag_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_debug_flag_get_type".}
template gtype*(klass_parameter: typedesc[DebugFlag]): GType = gtk_debug_flag_get_type()
# initializer for DestDefaults: gtk_dest_defaults_get_type
proc gtk_dest_defaults_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_dest_defaults_get_type".}
template gtype*(klass_parameter: typedesc[DestDefaults]): GType = gtk_dest_defaults_get_type()
# initializer for DialogFlags: gtk_dialog_flags_get_type
proc gtk_dialog_flags_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_dialog_flags_get_type".}
template gtype*(klass_parameter: typedesc[DialogFlags]): GType = gtk_dialog_flags_get_type()
# initializer for FileFilterFlags: gtk_file_filter_flags_get_type
proc gtk_file_filter_flags_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_file_filter_flags_get_type".}
template gtype*(klass_parameter: typedesc[FileFilterFlags]): GType = gtk_file_filter_flags_get_type()
# initializer for IconLookupFlags: gtk_icon_lookup_flags_get_type
proc gtk_icon_lookup_flags_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_icon_lookup_flags_get_type".}
template gtype*(klass_parameter: typedesc[IconLookupFlags]): GType = gtk_icon_lookup_flags_get_type()
# initializer for InputHints: gtk_input_hints_get_type
proc gtk_input_hints_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_input_hints_get_type".}
template gtype*(klass_parameter: typedesc[InputHints]): GType = gtk_input_hints_get_type()
# initializer for JunctionSides: gtk_junction_sides_get_type
proc gtk_junction_sides_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_junction_sides_get_type".}
template gtype*(klass_parameter: typedesc[JunctionSides]): GType = gtk_junction_sides_get_type()
# initializer for PlacesOpenFlags: gtk_places_open_flags_get_type
proc gtk_places_open_flags_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_places_open_flags_get_type".}
template gtype*(klass_parameter: typedesc[PlacesOpenFlags]): GType = gtk_places_open_flags_get_type()
# initializer for RcFlags: gtk_rc_flags_get_type
proc gtk_rc_flags_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_rc_flags_get_type".}
template gtype*(klass_parameter: typedesc[RcFlags]): GType = gtk_rc_flags_get_type()
# initializer for RecentFilterFlags: gtk_recent_filter_flags_get_type
proc gtk_recent_filter_flags_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_recent_filter_flags_get_type".}
template gtype*(klass_parameter: typedesc[RecentFilterFlags]): GType = gtk_recent_filter_flags_get_type()
# initializer for RegionFlags: gtk_region_flags_get_type
proc gtk_region_flags_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_region_flags_get_type".}
template gtype*(klass_parameter: typedesc[RegionFlags]): GType = gtk_region_flags_get_type()
# initializer for StateFlags: gtk_state_flags_get_type
proc gtk_state_flags_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_state_flags_get_type".}
template gtype*(klass_parameter: typedesc[StateFlags]): GType = gtk_state_flags_get_type()
# initializer for TargetFlags: gtk_target_flags_get_type
proc gtk_target_flags_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_target_flags_get_type".}
template gtype*(klass_parameter: typedesc[TargetFlags]): GType = gtk_target_flags_get_type()
# initializer for TextSearchFlags: gtk_text_search_flags_get_type
proc gtk_text_search_flags_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_text_search_flags_get_type".}
template gtype*(klass_parameter: typedesc[TextSearchFlags]): GType = gtk_text_search_flags_get_type()
# initializer for ToolPaletteDragTargets: gtk_tool_palette_drag_targets_get_type
proc gtk_tool_palette_drag_targets_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_tool_palette_drag_targets_get_type".}
template gtype*(klass_parameter: typedesc[ToolPaletteDragTargets]): GType = gtk_tool_palette_drag_targets_get_type()
# initializer for TreeModelFlags: gtk_tree_model_flags_get_type
proc gtk_tree_model_flags_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_tree_model_flags_get_type".}
template gtype*(klass_parameter: typedesc[TreeModelFlags]): GType = gtk_tree_model_flags_get_type()
# initializer for UIManagerItemType: gtk_ui_manager_item_type_get_type
proc gtk_ui_manager_item_type_get_type(): GType {.cdecl, dynlib: lib, importc: "gtk_ui_manager_item_type_get_type".}
template gtype*(klass_parameter: typedesc[UIManagerItemType]): GType = gtk_ui_manager_item_type_get_type()
